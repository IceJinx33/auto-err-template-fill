{
    "02567fd428a675ca91a0c6786f47f3e35881bcbd-0": {
        "doctext": "document: deep label distribution learning with label ambiguity convolutional neural networks (convnets) have achieved excellent recognition performance in various visual recognition tasks. a large labeled training set is one of the most important factors for its success. however, it is difficult to collect sufficient training images with precise labels in some domains such as apparent age estimation, head pose estimation, multi-label classification and semantic segmentation. fortunately, there is ambiguous information among labels, which makes these tasks different from traditional classification. based on this observation, we convert the label of each image into a discrete label distribution, and learn the label distribution by minimizing a kullback-leibler divergence between the predicted and ground-truth label distributions using deep convnets. the proposed dldl (deep label distribution learning) method effectively utilizes the label ambiguity in both feature learning and classifier learning, which help prevent the network from over-fitting even when the training set is small. experimental results show that the proposed approach produces significantly better results than state-of-the-art methods for age estimation and head pose estimation. at the same time, it also improves recognition performance for multi-label classification and semantic segmentation tasks. label distribution, deep learning, age estimation, head pose estimation, semantic segmentation. section: introduction convolutional neural networks (convnets) have achieved state-of-the-art performance on various visual recognition tasks such as image classification, object detection and semantic segmentation. the availability of a huge set of training images is one of the most important factors for their success. however, it is difficult to collect sufficient training images with unambiguous labels in domains such as age estimation, head pose estimation, multi-label classification and semantic segmentation. therefore, exploiting deep learning methods with limited samples and ambiguous labels has become an attractive yet challenging topic. why is it difficult to collect a large and accurately labeled training set? firstly, it is difficult (even for domain experts) to provide exact labels to some tasks. for example, the pixels close to object boundaries are very difficult to label for annotators in semantic segmentation. in addition, pixel labeling is a time-consuming task that may limit the amount of training samples. another example is that people's apparent age and head pose is difficult to describe with an accurate number. secondly, it is very hard to gather complete and sufficient data. for example, it is difficult to build an age dataset covering people from 1 to 85 years old, and ensure that every age in this range has enough associated images. similar difficulties arise in head pose estimation, where head poses are usually collected at a small set of angles with a 10 or 15 increment. thus, the publicly available age, head pose and semantic segmentation datasets are small scale compared to those in image classification tasks. these aforementioned small datasets have a common characteristic, i.e., label ambiguity, which refers to the uncertainty among the ground-truth labels. on one hand, label ambiguity is unavoidable in some applications. we usually predict another person's age in a way like\" around 25\", which indicates using not only 25, but also neighboring ages to describe the face. and, different people may have different guesses towards the same face. similar situations also hold for other types of tasks. the labels of pixels at object boundaries are difficult to annotate because of the inherent ambiguity of these pixels in semantic segmentation. on the other hand, label ambiguity can also happen if we are not confident in the labels we provide for an image. in the multi-label classification task, some objects are clearly visible but difficult to recognize. this type of objects are annotated as difficult in the pascal visual object classes (voc) classification challenge, e.g., the chair in the third image of the first row in fig. [reference]. [age estimation] [head pose estimation] [multi-label classification] [semantic segmentation] there are two main types of labeling methods: single-label recognition (slr) and multi-label recognition (mlr). slr assumes one image or pixel has one label and mlr assumes that one image or pixel may be assigned multiple labels. both slr and mlr aim to answer the question of which labels can be used to describe an image or pixel, but they can not describe the label ambiguity associated with it. label ambiguity will help improve recognition performance if it can be reasonably exploited. in order to utilize label correlation (which may be considered as a consequence of label ambiguity in some applications), geng et al. proposed a label distribution learning (ldl) approach for age estimation and head pose estimation. recently, some improvements of ldl have been proposed. xing et al. proposed two algorithms named ldlogitboost and aoso-ldlogitboost to learn general models to relax the maximum entropy model in traditional ldl methods. furthermore, he et al. generated age label distributions through weighted linear combination of the input image's label and its context-neighboring samples. however, these methods are suboptimal because they only utilize the correlation of neighboring labels in classifier learning, but not in learning the visual representations. deep convnets have natural advantages in feature learning. existing convnet frameworks can be viewed as classification and regression models based on different optimization objective functions. in many cases, the softmax loss and loss are used in deep convnet models for classification and regression problems, respectively. the softmax loss maximizes the estimated probability of the ground-truth class without considering other classes, and the loss minimizes the squared difference between the estimated values of the network and the ground-truth. these methods have achieved satisfactory performance in some domains such as image classification, human pose estimation and object detection. however, existing deep learning methods can not utilize the label ambiguity information. moreover, a well-known fact is that learning a good convnet requires a lot of images. in order to solve the issues mentioned above, we convert both traditional slr and mlr problems to label distribution learning problems. every instance is assigned a discrete label distribution according to its ground-truth. the label distribution can naturally describe the ambiguous information among all possible labels. through deep label distribution learning, the training instances associated with each class label is significantly increased without actually increase the number of the total training examples. fig. [reference] intuitively shows four examples of label distribution for different recognition tasks. then, we utilize a deep convnet to learn the label distribution in both feature learning and classifier learning. since we learn label distribution with deep convnets, we call our method dldl: deep label distribution learning. the benefits of dldl are summarized as follows: dldl is an end-to-end learning framework which utilizes the label ambiguity in both feature learning and classifier learning; dldl not only achieves more robust performance than existing classification and regression methods, but also effectively relaxes the requirement for large amount of training images, e.g., a training face image with ground-truth label 25 is also useful for predicting faces at age 24 or 26; dldl (only single model without ensemble) achieves better performance than the state-of-the-art methods on age and head pose estimation tasks. dldl also improves the performance for multi-label classification and semantic segmentation. the rest of this paper is organized as follows. we first review the related work in section [reference]. then, section [reference] proposes the dldl framework, including the dldl problem definition, dldl theory, label distribution construction and training details. after that, the experiments are reported in section [reference]. finally, section [reference] presents discussions and the conclusion is given in section [reference]. section: related work in the past two decades, many efforts have been devoted to visual recognition, including at least image classification, object detection, semantic segmentation, and facial attribute (apparent age and head pose) estimation. these works can be divided into two streams. earlier research was mainly based on hand-crafted features, while more recent ones are usually deep learning methods. in this section, we briefly review these related approaches. methods based on hand-crafted features usually include two stages. the first stage is feature extraction. the second stage learns models for recognition, detection or estimation using these features. svm, random forest and neural networks have commonly been used during the learning stage. in addition, geng et al. proposed the label distribution learning approach to utilize the correlation among adjacent labels, which further improved performance on age estimation and head pose estimation. although important progresses have been made with these features, the hand-crafted features render them suboptimal for particular tasks such as age or head pose estimation. more recently, learning feature representation has shown great advantages. for example, lu et al. tried to learn cost-sensitive local binary features for age estimation. deep learning has substantially improved upon the state-of-the-art in image classification, object detection, semantic segmentation and many other vision tasks. in many cases, the softmax loss is used in deep models for classification. besides classification, deep convnets have also been trained for regression tasks such as head pose estimation and facial landmark detection. in regression problems, the training procedure usually optimizes a squared loss function. satisfactory performance has also been obtained by using tukey's biweight function in human pose estimation. in terms of model architecture, deep convnet models which use deeper architecture and smaller convolution filters (e.g., vgg-nets and vgg-face) are very powerful. nevertheless, these deep learning methods do not make use of the presence of label ambiguity in the training set, and usually require a large amount of training data. a latest approach, in inception-v3, is based on label smoothing (ls). instead of only using the ground-truth label, they utilize a mixture of the ground-truth label and a uniform distribution to regularize the classifier. however, ls is limited to the uniform distribution among labels rather than mining labels' ambiguous information. we believe that label ambiguity is too important to ignore. if we make good use of the ambiguity, we expect the required number of training images for some tasks could be effectively reduced. in this paper, we focus on how to exploit the label ambiguity in deep convnets. age and head pose estimation from still face images are suitable applications of the proposed research. in addition, we also extend our works to multi-label classification and semantic segmentation. section: the proposed dldl approach in this section, we firstly give the definition of the dldl problem. then, we present the dldl theory. next, we propose the construction methods of label distribution for different recognition tasks. finally, we briefly introduce the dldl architecture and training details. subsection: the deep label distribution learning problem given an input image, we are interested in estimating a category output (e.g., age or head pose angles). for two input images and with ground-truth labels and, and are supposed to be similar to each other if the correlation of and is strong, and vice versa. for example, the correlation between faces aged 32 and 33 should be stronger than that between faces aged 32 and 64, in terms of facial details that reflect the age (e.g., skin smoothness). in other words, we expect high correlation among input images with similar outputs. the label distribution learning approach exploited such correlations in the machine learning phase, but used features that are extracted ignoring these correlations. the proposed dldl approach, however, is an end-to-end deep learning method which utilizes such correlation information in both feature learning and classifier learning. we will also extend dldl to handle other types of label ambiguity beyond correlation. to fulfill this goal, instead of outputting a single value for an input, dldl quantizes the range of possible values into several labels. for example, in age estimation, it is reasonable to assume that, and it is a common practice to estimate integer values for ages. thus, we can define the set as the ordered label set for age estimation. the task of dldl is then to predict a label distribution, where is the estimated probability that should be predicted to be years old. by estimating an entire label distribution, the deep learning machine is forced to take care of the ambiguity among labels. specifically, the input space of our framework is, where, and are the height, width, and number of channels of the input image, respectively. dldl predicts a label distribution vector, where is the label set defined for a specific task (e.g., the above). we assume is complete, i.e., any possible value has a corresponding member in. a training data set with instances is then denoted as. we use boldface lowercase letters like to denote vectors, and the-th element of is denoted as. the goal of dldl is to directly learn a conditional probability mass function from, where is the parameters in the framework. subsection: deep label distribution learning given an instance with label distribution, we assume that is the activation of the last fully connected layer in a deep convnet. we use a softmax function to turn these activations into a probability distribution, that is, given a training data set, the goal of dldl is to find to generate a distribution that is similar to. there are different criteria to measure the similarity or distance between two distributions. for example, if the kullback-leibler (kl) divergence is used as the measurement of the similarity between the ground-truth and predicted label distribution, then the best parameter is determined by thus, we can define the loss function as: stochastic gradient descent is used to minimize the objective function eq. [reference]. for any and, and the derivative of softmax (eq. [reference]) is well known, as where is 1 if, and 0 otherwise. according to the chain rule, for any fixed, we have thus, the derivative of with respect to is once is learned, the label distribution of any new instance can be generated by a forward run of the network. if the expected class label is a single one, dldl outputs, where prediction with multiple labels is also allowed, which could be a set where is a predefined threshold. if the expected output is a real number, dldl predicts the expectation of, as where. this indicates that dldl is suitable for both classification and regression tasks. subsection: label distribution construction the ground-truth label distribution is not available in most existing datasets, which must be generated under proper assumptions. a desirable label distribution must satisfy some basic principles: (1) should be a probability distribution. thus, we have and. (2) the probability values should have difference among all possible labels associated with an image. in other words, a less ambiguous category must be assigned high probability and those more ambiguous labels must have low probabilities. in this section, we propose the way to construct label distributions for age estimation, head pose estimation, multi-label classification and semantic segmentation. for age estimation, we assume that the probabilities should concentrate around the ground-truth age. thus, we quantize to get using a normal distribution. for example, the apparent age of a face is labeled by hundreds of users. the ground-truth (including a mean and a standard deviation) is calculated from all the votes. for this problem, we find the range of the target (e.g.,), quantize it into a complete and ordered label set, where is the label set size and are all possible predictions for. a label distribution is then, where is the probability that (i.e., for). since we use equal step size in quantizing, the normal p.d.f. (probability density function) is a natural choice to generate the ground-truth from and: where. fig. [reference] shows a face and its corresponding label distribution. for problems where is unknown, we will show that a reasonably chosen also works well in dldl. for head pose estimation, we need to jointly estimate pitch and yaw angles. thus, learning joint distribution is also necessary in dldl. suppose the label set is, where is a pair of values. that is, we want to learn the joint distribution of two variables. then, the label distribution can be represented by an matrix, whose-th element is. for example, when we use two angles (pitch and yaw) to describe a head pose, is a pair of pitch and yaw angles. given an instance with ground-truth mean and covariance matrix, we calculate its label distribution as where. in the above, we assume, that is, the covariance matrix is diagonal. fig. [reference] shows a joint label distribution with head pose and. for multi-label classification, a multi-label image always contains at least one object of the class of interest. there are usually multiple labels for an image. these labels are grouped into three different levels, including positive, negative and difficult in the pascal voc dataset. a label is positive means an image contains objects from that category, and negative otherwise. difficult indicates that an object is clearly visible but difficult to recognize. existing multi-label methods often view difficult as negative, which leads to the loss of useful information. it is not reasonable either if we simply treat difficult as positive. therefore, a nature choice is to use label ambiguity. we define different probabilities for different types of labels, as for positive, difficult and negative labels, respectively. furthermore, an normalization is applied to ensure: where equals, or if the label is positive, difficult or negative, respectively. the label distribution is shown for a multi-label image in fig. [reference]. for semantic segmentation, we need to label a pixel as belonging to one class if it is a pixel inside an object of that class, or as the background otherwise. let denote the annotation of the-th pixel, where (assuming there are categories and 0 for background). fully convolutional networks (fcn) have been an effective solution to this task. in fcn, a ground-truth label means that and for all. however, it is very difficult to specify ground-truth labels for pixels close to object boundaries, because labels of these pixels are inherently ambiguous. we propose a mechanism to describe the label ambiguity in the boundaries. considering a gaussian kernel matrix, we replace the original label distribution with, as where,, is the kernel size, and are padding and stride sizes. in our experiment, we set, and, and the generated label distribution is fig. [reference] gives the semantic label distribution for a bird image which shows that the ambiguity is encoded in the label distributions. subsection: the dldl architecture and training details we use a deep convnet and a training set to learn a as the estimation of. the structure of our network is based on popular deep models such as zf-net and vgg-nets. the zf-net consists five convolution layers, followed by three fully connected layers. the vgg-nets architecture includes 16 or 19 layers. we modify the last fully connected layer's output based on the task and replace the original softmax loss function with the kl loss function. in addition, we use the parameter relu for zf-net. in our network, the input is an order three tensor and the output may be a vector (age estimation and multi-label classification), a matrix (head pose estimation) or a tensor (semantic segmentation). in this paper, we train the deep models in two ways: training from scratch. for zf-net, the initialization is performed randomly, based on a gaussian distribution with zero mean and 0.01 standard deviation, and biases are initialized to zero. the coefficient of the parameter relu is initialized to 0.25. the dropout is applied to the last two fully connected layers with rate 0.5. the coefficient of weight decay is set to. optimization is done by stochastic gradient descent (sgd) using mini-batches of 128 and the momentum coefficient is 0.9. the initial learning rate is set to 0.01. the total number of epochs is about 20. fine-tuning. three pre-trained models including vgg-nets (16-layers and 19-layers) and vgg-face (16-layers) are used to fine-tune for different tasks. we remove these pre-trained models' classification layer and loss layer, and put in our label distribution layer which is initialized by the gaussian distribution and the kl loss layer. the learning rates of the convolutional layers, the first two fully-connected layers and the label distribution layer are initialized as 0.001, 0.001 and 0.01, respectively. we fine-tune all layers by back propagation through the whole net using mini-batches of 32. the total number of epochs is about 10 for age estimation and 20 for multi-label classification. section: experiments we evaluate dldl on four tasks, i.e., age estimation, head pose estimation, multi-label classification and semantic segmentation. our implementation is based on matconvnet. all our experiments are carried out on a nvidia k40 gpu with 12 gb of onboard memory. subsection: age estimation datasets. two age estimation datasets are used in our experiments. the first is morph, which is one of the largest publicly available age datasets. there are 55, 134 face images from more than 13, 000 subjects. ages range from 16 to 77. since no train/ test split is provided, 10-fold cross-validation is used for morph. the second dataset is from the apparent age estimation competition, the first competition track of the iccv chalearn lap 2015 workshop. compared with morph, this dataset (chalearn) consists of images collected in the wild, without any position, illumination or quality restriction. the only condition is that each image contains only one face. the dataset has 4, 699 images, and is split into 2, 476 training (train), 1, 136 validation (val) and 1, 087 testing (test) images. the apparent age (i.e., how old does this person look like) of each image is labeled by multiple individuals. the age of face images range from 3 to 85. for each image, its mean age and the corresponding standard deviation are given. since the ground-truth for test images are not published, we train on the train split and evaluate on the val split of chalearn images. baselines. to demonstrate the effectiveness of dldl, we firstly consider two related methods as baselines: convnet+ ls (kl) and convnet+ ld (- div). the former uses label smoothing (ls) as ground-truth and kl divergence as loss function. the latter uses label distribution (ld) as ground-truth and divergence as loss function, which is in addition, we also compare dldl with the following baseline methods: bfgs-ldl geng et al. proposed the label distribution learning approach (iis-lld) for age and head pose estimation. they used traditional image features. to further improve iis-lld, geng et al. proposed a bfgs-ldl algorithm by using the effective quasi-newton optimization method bfgs. c-convnet classification convnets have obtained very competitive performance in various computer vision tasks. zf-net and vgg-net are popular models which use the softmax loss. we replace the imagenet-specific 1000-way classification in these modes with the label set. r-convnet convnets are also successively trained for regression tasks. in r-convnet, the ground-truth label (age and pose angle) is projected into the range by the mapping, where and are the maximum and minimum values in the training label set. during prediction, the r-convnet regression result is reverse mapped to get. to speed up convergence, the last fully connected layer is followed a hyperbolic tangent activation function, which maps to. the squared, and-ins loss functions are used in r-convnet. implementation details. we use the same preprocessing pipeline for all compared methods, including face detection, facial key points detection and face alignment, as shown in fig [reference]. we employ the dpm model to detect the main facial region. then, the detected face is fed into cascaded convolution networks to get the five facial key points, including the left/ right eye centers, nose tip and left/ right mouth corners. finally, based on these facial points, we align the face to the upright pose. data augmentation are only applied to the training images for chalearn. for one color input training image, we generate its gray-scale version, and left-right flip both color and gray-scale versions. thus, every training image turns into 4 images. [input] [detection] [facial points] [alignment] we define for both datasets. the label distribution of each image is generated using eq. [reference]. the mean is provided in both morph and chalearn. the standard deviation, however, is provided in chalearn but not in morph. we simply set in morph. experiments for different methods are conducted under the same data splits. 1 used 80% of morph images for training and 20% for evaluation; 2 used additional external face images (i.e., imdb-wiki); 3 used pre-trained model (i.e., vgg-nets or vgg-face). evaluation criteria. mean absolute error (mae) and cumulative score (cs) are used to evaluate the performance of age estimation. mae is the average difference between the predicted and the real age: where and are the estimated and ground-truth age of the-th testing image, respectively. cs is defined as the accuracy rate of correct estimation: where is the number of correct estimation, i.e., testing images that satisfy. in our experiment,. in addition, a special measurement (named-error) is defined by the chalearn competition, computed as results. table [reference] lists results on both datasets. the upper part shows results in the literature. the middle part shows the baseline results. the lower part shows the results of the proposed approach. the first term in the parenthesis behind each method is the loss function corresponding to the method. max or exp represent predicting according to eq. [reference] or [reference], respectively. since cross-validation is used in morph, we also provide its standard deviations. [chalearn] [morph] [aflw] [subfigure] labelformat= empty [40] [19] [62] [23] [38] [24] [26] [66] [52] [22] [red39.69] [red19.29] [red61.61] [red22.94] [red37.87] [red24.27] [red25.40] [blue60.17] [blue35.06] [blue28.55] from table [reference], we can see that dldl consistently outperforms baselines and other published methods. the difference between dldl (kl, max) and its competitor c-convnet (softmax, max) is 0.51 on morph. this gap is more than 6 times the sum of their standard deviations (0.03+ 0.05), showing statistically significant differences. the advantage of dldl over r-convnet, c-convnet and convnet+ ls suggests that learning label distribution is advantageous in deep end-to-end models. dldl has much better results than bfgs-ldl, which shows that the learned deep features are more powerful than manually designed ones. compared to convnet+ ld (- div), dldl (kl) achieves lower mae on both datasets. it indicates that kl-divergence is better than-divergence for measuring the similarity of two distributions in this context. we find that c-convnet and r-convnet are not stable. the r-convnet () method, although being the second best method for chalearn, is inferior to c-convnet (softmax, exp) for morph. in addition, we also find that eq. [reference] is better than eq. [reference] in many cases, which suggests that eq. [reference] is more suitable than eq. [reference] for age estimation. fine-tuning dldl. instead of training dldl from scratch, we also fine-tune the network of vgg-face. on the small scale chalearn dataset, the mae of dldl is reduced from 5.34 to 3.51, yielding a significant improvement. the-error of dldl is reduced from 0.44 to 0.31, which is close to the best competition result 0.28 on the validation set. in, external training images (260, 282 additional external training images with real age annotation) were used. dldl only uses the chalearn dataset's 2, 476 training images and is the best among chalearn teams that do not use external data. in the competition, the best external-data-free-error is 0.48, which is worse than dldl's. however, the idea in to use external data is useful for further reducing dldl's estimation error. fig. [reference] and fig. [reference] show the cs curves on chalearn and morph datasets. at every error level, our dldl fine-tuned vgg-face always achieves the best accuracy among all methods. it is noteworthy that the cs curves of dldl (kl, max) and convnet (- div, max) are very close to that of the dldl+ vgg-face (kl, max) on morph even without lots of external data and very deep model. this observation supports the idea that using dldl can achieve competitive performance even with limited training samples. in fig. [reference], we show some examples of face images from the chalearn validation set and predicted label distributions by dldl (kl, exp). in many cases, our solution is able to accurately predict the apparent age of faces. failures may come from two causes. the first is the failure to detect or align the face. the second is some extreme conditions of face images such as occlusion, low resolution, heavy makeup and old photos. subsection: head pose estimation datasets. we use three datasets in head pose estimation: pointing'04, bjut-3d and annotated facial landmarks in the wild (aflw). in them, head pose is determined by two angles: pitch and yaw. pointing'04 discretizes the pitch into 9 angles and the yaw into 13 angles. when the pitch angel is or, the yaw angle is always set to. thus, there are 93 poses in total. the head images are taken from 15 different human subjects in two different time periods, resulting in images. bjut-3d contains 500 3d faces (250 male and 250 female people), acquired by a cyberware laser scanner in an engineered environment. 9 pitch angles and 13 yaw angles are used. there are in total 93 poses in this dataset, similar to that in pointing'04. therefore, face images are obtained. unlike pointing'04 and bjut-3d, the aflw is a real-world face database. head pose is coarsely obtained by fitting a mean 3d face with the posit algorithm. the dataset contains about 24k faces in real-world images. we select 23, 409 faces to ensure pitch and yaw angles within. implementation details. the head region is provided by bounding box annotations in pointing'04 and aflw. the bjut-3d does not contain background regions. therefore, we will not perform any preprocessing. in dldl, we set in pointing'04 and in bjut-3d for constructing label distributions. for aflw, ground-truth of head pose angles are given as real numbers. ground-truth (pitch and yaw) angles are divided from to in steps of, so we get (pitch, yaw) pair category labels. we set for aflw. since the discrete jeffrey's divergence is used in ldl, we implement bfgs-ldl with the kullback-leibler divergence. all experiments are performed under the same setting, including data splits, input size and network architecture. to validate the effectiveness of dldl for head pose estimation, we use the same baselines as age estimation. our experiments show that eq. [reference] has lower accuracy than eq. [reference]. hence, we use eq. [reference] in this section. evaluation criteria. three types of prediction values are evaluated: pitch, yaw, and pitch+ yaw, where pitch+ yaw jointly estimates the pitch and yaw angles. two different measurements are used, which is mae (eq. [reference]) and classification accuracy (acc). when we treat different poses as different classes, acc measures the pose class classification accuracy. in particular, the mae of pitch+ yaw is calculated as the euclidean distance between the predicted (pitch, yaw) pair and the ground-truth pair; the acc of pitch+ yaw is calculated by regarding each (pitch, yaw) pair as a class. for r-convnet, we only report its mae but not acc, because its predicted value are continuous real numbers. all methods are tested with 5-fold cross validation for pointing'04 and bjut-3d following. for aflw, 15, 561 face images are randomly chosen for training, and the remaining 7, 848 for evaluation. the setup is similar to the recent literature (14, 000 images for training and the rest 7, 041 images for testing). [subfigure] labelformat= empty [(+ 77,-4)] [(- 16,-1)] [(- 1,-30)] [(+ 30,+ 8)] [(+ 4,-4)] [(- 36,+ 13)] [(- 87,-3)] [(- 61,-58)] [(+ 63,+ 12)] [(+ 80,-27)] [red (+ 75,-3)] [red (- 15, 0)] [red (- 3,-27)] [red (+ 27,+ 6)] [red (+ 6,-3] [red (- 39,+ 15] [red (- 87, 0)] [blue (- 3,-12)] [blue (+ 21,+ 18] [blue (+ 45,-15)] results. tables [reference], [reference] and [reference] show results on pointing'04, bjut-3d and aflw, respectively. pointing'04 is small scale with only 2, 790 images. we observe that bfgs-ldl (with hand-crafted features) has much lower mae and much higher accuracy than deep learning methods c-convnet, r-convnet and convnet+ ls. one reasonable conjecture is that c-convnet, r-convnet and convnet+ ls are not well-learned with only small number of training images. dldl, however, successfully learns the head pose. for example, its accuracy for pitch+ yaw is 73.15 (and c-convnet is only 42.97). that is, dldl is able to perform deep learning with few training images, while c-convnet r-convnet and convnet+ ls have failed for this task. on bjut-3d and aflw which have enough training data, we observe that many deep learning methods show higher performance than bfgs-ldl. dldl achieves the best performance: it has much lower mae and higher accuracy than other methods. another observation is also worth mentioning. although r-convnet is better than c-convnet when label is dense such as age estimation and head pose estimation on aflw, it is obviously worse than c-convnet on bjut-3d and pointing'04 for head pose estimation which have sparse labels. in other words, the performance of c-convnet and r-convnet are not very robust, while the proposed method consistently achieves excellent performance. fig. [reference] shows the pitch+ yaw cs curves on the aflw dataset. there is an obvious gap between dldl and baseline methods at every error level. fig. [reference] shows the predicted label distributions for different head poses on the aflw testing set using the dldl model. our approach can estimate head pose with low errors but may fail under some extreme conditions. it is noteworthy that dldl may produce more incorrect estimations when both yaw and pitch are large (e.g.,). the reason might be that there are much fewer training examples for large angles than for other angles. subsection: multi-label classification datasets. we evaluate our approach for multi-label classification on the pascal voc dataset: pascal voc2007 and voc2012. there are 9, 963 and 22, 531 images in them, respectively. each image is annotated with one or several labels, corresponding to 20 object categories. these images are divided into three subsets including train, val and test sets. we train on the trainval set and evaluate on the test set. the evaluation metric is average precision (ap) and mean average precision (map), complying with the pascal challenge protocols. we denote our methods as images-fine-tuning-dldl (if-dldl) and proposals-fine-tuning-dldl (pf-dldl) when convnets are fine-tuned by images and proposals of images, respectively. details of these two variants are explained later in this section. we compare the proposed approaches with the following methods: vgg+ svm []. this method densely extracted 4, 096 dimensional convnet features at the penultimate layer of vgg-nets pre-trained on imagenet. these features from different scales (smallest image side) were aggregated by average pooling. then, these averaged features from two networks (\" net-d\" containing 16 layers and\" net-e\" containing 19 layers) were further fused by stacking. finally, normalized the resulting image features and used these features to train a linear svm classifier for multi-label classification. hcp []. hcp proposed to solve the multi-label object recognition task by extracting object proposals from the images. the method used image label and square loss to fine-tune a pre-trained convnet. then, bing or edgeboxes was used to extract object proposals, which were used to fine-tune the convnet again. finally, scores of these proposals were max-pooled to obtain the prediction. fev+ lv []. this approach transformed the multi-label object recognition problem into a multi-class multi-instance learning problem. two views (label view and feature view) were extracted for each proposal of images. then, these two views were encoded by a fisher vector for each image. if-vgg -\u21132 and if-vgg-kl. we fine-tune the vgg-nets with square loss and multi-label cross-entropy loss and use them as our if-dldl's baselines. they are trained using the same setting. implementation details. according to the ground-truth labels, we set different probabilities for all possible labels on pascal voc dataset. in our experiments,,,. finally, similar to label smoothing, a uniform distribution is added to, where. if-dldl. following, each training image is individually rescaled by randomly sampling in the range [256, 512]. we randomly crop patches from these resized images. we also adjust the pooling kernel in the pool5 layer from to. max-pooling and avg-pooling are used at pool5 to train two convnets. we obtain four convnet models thought fine-tuning\" net-d\" and\" net-e\". at the prediction stage, the smaller side of each image is scaled to a fixed length. each scaled image is fed to the fine-tuned convnets to obtain the 20-dim probability outputs. these probability outputs from different scales and different models are averaged to form the final prediction. pf-dldl. following, we further fine-tune if-dldl models with proposals of images to boost performance. for each training image, we employ edgeboxes to produce a set of proposal bounding boxes which are grouped into clusters by the normalized cut algorithm. for each cluster, the top proposals with higher predictive scores generated by edgeboxes are resized into square shapes (i.e.,). as a result, we can obtain proposals for an image. finally, these resized proposals are fed into a fine-tuned if-dldl model to obtain prediction scores and these scores are fused by max-pooling to form the prediction distribution of the image. this process can be learned by using an end-to-end way. in our implementation, we set and at the training and the prediction stage, respectively. similar to if-dldl, we also average fuse prediction scores of different models to generate the final prediction. results. in table [reference], we compare single model results (average ap of all classes) on voc2007. our pf-dldl defeats all the other methods. compared with fev+ lv, 1.7% improvement can be achieved by pf-dldl even without using the bounding box annotation. compared with hcp-vgg, our pf-dldl can achieve 92.3% map, which is significantly higher than their 90.9%. this further indicates that it is very important to learn a label distribution. table [reference] and [reference] report details of all experimental results on voc2007 and voc2012, respectively. it can be seen that if-dldl outperforms if-vgg-by 1.1% for voc2007 and 1.3% for voc2012, which indicates that the kl loss function is more suitable than loss for measuring the similarity of two label distributions. furthermore, if-dldl improves if-vgg-kl for about 0.2-0.3 points in map, which suggests that learning a label distribution is beneficial. more importantly, pf-dldl can achieve 93.4% for voc2007 and 92.4% for voc2012 in map when we average fuse output scores of four pf-dldl models. our framework shows good performance especially for scene categories such as\" chair\", 'table\" and\" sofa\". although pf-dldl significantly outperforms if-dldl in map, pf-dldl has higher computational cost than if-dldl on both training and testing stages. since if-dldl does not need region proposals or bounding box information, it may be effectively and efficiently implemented for practical multi-label application such as multi-label image retrieval. it is also possible that by adopting new techniques (such as the region proposal method using gated unit in, which has higher accuracy that ours on voc tasks), the accuracy of our dldl methods can be further improved. [chalearn] [morph] [pointing'04] [aflw pitch] [aflw yaw] bfgs-ldl dldl subsection: semantic segmentation datasets. we employ the pascal voc2011 segmentation dataset and the semantic boundaries dataset (sbd) for training the proposed dldl. there are 2, 224 images (1, 112 for training and 1, 112 for testing) with pixel labels for 20 semantic categories in voc2011. sbd contains 11, 355 annotated images (8, 984 for training and 2, 371 for testing) from hariharan et al.. following fcn, we train dldl using the union set (8, 825 images) of sbd and voc2011 training images. we evaluate the proposed approach on voc2011 (1, 112) and voc2012 (1, 456) test images. evaluation criteria. the performance is measured in terms of mean iu (intersection over union), which is the most widely used metric in semantic segmentation. we keep the same settings as fcn including training images and model structure. the main change is that we employ kl divergence as the loss function based on label distribution (eq. [reference]). note that although we transform the ground-truth to label distribution in the training process, our evaluation rely only on ground-truth label. recently, conditional random field (crf) has been broadly used in many state-of-the-art semantic segmentation systems. we optionally employ a fully connected crf to refine the predicted category score maps using the default parameters of. results. table [reference] gives the performance of dldl-8s and dldl-8s-crf on the test images of voc2011 and voc2012 and compares it to the well-known fcn-8s. dldl-8s improves the mean iu of fcn-8s form 62.7% to 64.9% on voc2011. on voc2012, dldl-8s leads to an improvement of 2.3 points in mean iu. dldl achieves better results than fcn, which suggests it is important to improve the segmentation performance using label ambiguity. in addition, the crf further improve performance of dldl-8s, offering a 2.6% absolute increase in mean iu both on voc2011 and voc2012. fig. [reference] shows four semantic segmentation examples from the voc2011 validation images using fcn-8s, dldl-8s and dldl-8s-crf. we can see that dldl-8s can successfully segment some small objects (e.g., car and bicycle) and particularly improve the segmentation of object boundaries (e.g., horse's leg and plant's leaves), but fcn-8s does not. dldl-8s may fail, e.g., it sees a flowerpot as a potted plant in the fourth row in fig. [reference]. furthermore, compared to dldl-8s, dldl-8s-crf is able to refine coarse pixel-level label predictions to produce sharp boundaries and fine-grained segmentations (e.g., plant's leaves). [subfloat] labelformat= empty position= top [image] [fcn-8s] [dldl-8s] [dldl-8s+ crf] [ground-truth] [chalearn] [morph] [bjut-3d] [aflw] section: discussions in this section, we try to understand the generalization performance of dldl through feature visualization, and to analyze why dldl can achieve high accuracy with limited training data. in addition, a study of the hyper-parameter is also provided. feature visualization. we visualize the model features in a low-dimensional space. early layers learn low-level features (e.g., edge and corner) and latter layers learn high level features (e.g., shapes and objects) in a deep convnet. hence, we extract the penultimate layer features (4, 096-dimensional) on morph, chalearn, pointing'04 and aflw validation sets. to obtain the 2-dimensional embeddings of the extracted high dimensional features, we employ a popular dimension reduction algorithm t-sne. the low-dimensional embeddings of validation images from the above four datasets are shown in fig. [reference]. the first row shows the 2-dim embeddings of hand-crafted features (bif for morph and chalearn, hog for pointing'04 and aflw) and the second row shows that of the dldl features. these figures are colored by their semantic category. it can be observed that clear semantic clusterings (old or young for age datasets, left or right, up or down for head pose datasets) appear in deep features but do not in hand-crafted features. reduce over-fitting. dldl can effectively reduce over-fitting when the training set is small. this effect can be explained by the label ambiguity. considering an input sample with one single label. in traditional deep convnet, and for all. in dldl, the label distribution contains many non zeros elements. the diversity of labels helps reduce over-fitting. moreover, the objective function (eq. [reference]) of dldl can be rewritten as in eq. [reference], the first term is the tradition convnet loss function. the second term maximize the log-likelihood of the ambiguous labels. unlike existing data augmentation techniques such as random cropping on the images, dldl augments data on the label side. in fig. [reference], mae is shown as a function of the number of epochs on two age datasets (chalearn and morph) and two head pose datasets (bjut-3d and aflw). on chalearn and aflw, c-convenet (softmax) achieves the lowest training mae, but produces the highest validation mae. in particular, the validation mae increases after the 8th epoch on chalearn. similar phenomenon is observed on aflw. this fact shows that over-fitting happens in c-convnet when the number of training images is small. although there are 15, 561 training images in aflw, each category contains on averagely 4 training images since there are 3, 721 categories. accelerate convergence. we further analyze the convergence performance of dldl, c-convnet and r-convnet. we can observe that the training mae is reduced very slowly at the beginning of training using c-convnet and r-convenet in many cases as shown in fig. [reference]. on the contrary, the mae of dldl reduces quickly. robust performance. one notable observation is that c-convnet and r-convenet is unstable. fig. [reference] shows the mae for pitch+ yaw, a complicated estimation of the joint distribution. this is a very sparse label set because the interval of adjacent class (pitch or yaw) is. r-convnet has difficulty in estimating this output, yielding errors that are roughly 20 times higher than dldl and c-convnet. on the other hand, c-convnet easily fall into over-fitting when there are not enough training data (e.g, fig. [reference] and fig. [reference]). the proposed dldl is more amenable to small datasets or sparse labels than c-convnet and r-convnet. analyze the hyper-parameter. dldl's performance may be affected by the label distribution. here, we take age estimation (morph) and head pose estimation (pointing'04) for examples. is a common hyper-parameter in these tasks if it is not provided in the ground-truth. we have empirically set in morph, and in pointing'04 in our experiments. in order to study the impact of, we test dldl with different values, changing from 0 to 3 with 0.5 interval. fig. [reference] shows the mae performance on morph and pointing'04 with different. we can see that a proper is important for low mae. but generally speaking, a value that is close to the interval between neighboring labels is a good choice. because the shape of all curves are v-shape like, it is also very convenient to find an optimal value using the cross-validation strategy. section: conclusion we observe that current deep convnets can not successfully learn good models when there are not enough training data and/ or the labels are ambiguous. we propose dldl, a deep label distribution learning framework to solve this issue by exploiting label ambiguity. in dldl, each image is labeled by a label distribution, which can utilize label ambiguity in both feature learning and classifier learning. dldl consistently improves the network training process in our experiments, by preventing it from over-fitting when the training set is small. we empirically showed that dldl produces robust and competitive performances than traditional classification or regression deep models on several popular visual recognition tasks. however, constructing a reasonable label distribution is still challenging due to the diversity of label space for different recognition tasks. it is an interesting direction to extend dldl to more recognition problems by constructing different label distributions. bibliography: references [] bin-bin gao received the b.s. and m.s. degrees in applied mathematics in 2010 and 2013, respectively. he is currently pursuing the ph.d. degree in the department of computer science and technology, nanjing university, china. his research interests include computer vision and machine learning. {ieeebiography} [] chao xing received the b.s. degree in software engineering from southeast university, china, in 2014. he is currently a postgraduate student in the school of computer science and engineering at southeast university, china. his research interests include pattern recognition, machine learning, and data mining. {ieeebiography} [] chen-wei xie received his b.s. degree from southeast university, china, in 2015. he is currently a postgraduate student in the department of computer science and technology, nanjing university, china. his research interests include computer vision and machine learning. {ieeebiography} [] jianxin wu (m'09) received the b.s. and m.s. degrees in computer science from nanjing university, and the ph.d. degree in computer science from the georgia institute of technology. he was an assistant professor with the nanyang technological university, singapore. he is currently a professor with the department of computer science and technology, nanjing university, china, and is associated with the national key laboratory for novel software technology, china. his current research interests include computer vision and machine learning. he has served as an area chair for cvpr 2017 and iccv 2015, a senior pc member for aaai 2017 and aaai 2016, and an associate editor of pattern recognition journal. {ieeebiography} [] xin geng (m'13) received the b.s. and m.s. degrees in computer science from nanjing university, china, in 2001 and 2004, respectively, and the ph. d degree from deakin university, australia in 2008. he joined the school of computer science and engineering at southeast university, china, in 2008, and is currently a professor and vice dean of the school. he has authored over 50 refereed papers, and he holds five patents in these areas. his research interests include pattern recognition, machine learning, and computer vision.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "pascal voc dataset"
                    ],
                    [
                        "chalearn validation set"
                    ],
                    [
                        "annotated facial landmarks in the wild"
                    ],
                    [
                        "aflw validation sets"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "mean absolute error"
                    ],
                    [
                        "mae"
                    ],
                    [
                        "mae"
                    ],
                    [
                        "average precision"
                    ],
                    [
                        "ap"
                    ]
                ],
                "Task": [
                    [
                        "apparent age estimation"
                    ],
                    [
                        "head pose estimation"
                    ],
                    [
                        "multi label classification"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "chalearn lap 2015",
                        "chalearn"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "optimization objective functions",
                        "mean absolute error",
                        "mae"
                    ]
                ],
                "Task": [
                    [
                        "age estimation",
                        "age"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "morph"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "optimization objective functions",
                        "mean absolute error",
                        "mae"
                    ]
                ],
                "Task": [
                    [
                        "age estimation",
                        "age"
                    ]
                ]
            }
        ]
    },
    "02b3d1d162080d9aefd3fc30a0bcc9a843073b5d-1": {
        "doctext": "in this work we explore recent advances in recurrent neural networks for large scale language modeling, a task central to language understanding. we extend current models to deal with two key challenges present in this task: corpora and vocabulary sizes, and complex, long term structure of language. we perform an exhaustive study on techniques such as character convolutional neural networks or long-short term memory, on the one billion word benchmark. our best single model significantly improves state-of-the-art perplexity from 51.3 down to 30.0 (whilst reducing the number of parameters by a factor of 20), while an ensemble of models sets a new record by improving perplexity from 41.0 down to 23.7. we also release these models for the nlp and ml community to study and improve upon. section: introduction language modeling (lm) is a task central to natural language processing (nlp) and language understanding. models which can accurately place distributions over sentences not only encode complexities of language such as grammatical structure, but also distill a fair amount of information about the knowledge that a corpora may contain. indeed, models that are able to assign a low probability to sentences that are grammatically correct but unlikely may help other tasks in fundamental language understanding like question answering, machine translation, or text summarization. lms have played a key role in traditional nlp tasks such as speech recognition, machine translation, or text summarization. often (although not always), training better language models improves the underlying metrics of the downstream task (such as word error rate for speech recognition, or bleu score for translation), which makes the task of training better lms valuable by itself. further, when trained on vast amounts of data, language models compactly extract knowledge encoded in the training data. for example, when trained on movie subtitles, these language models are able to generate basic answers to questions about object colors, facts about people, etc. lastly, recently proposed sequence-to-sequence models employ conditional language models as their key component to solve diverse tasks like machine translation or video generation. deep learning and recurrent neural networks (rnns) have fueled language modeling research in the past years as it allowed researchers to explore many tasks for which the strong conditional independence assumptions are unrealistic. despite the fact that simpler models, such as n-grams, only use a short history of previous words to predict the next word, they are still a key component to high quality, low perplexity lms. indeed, most recent work on large scale lm has shown that rnns are great in combination with n-grams, as they may have different strengths that complement n-gram models, but worse when considered in isolation. we believe that, despite much work being devoted to small data sets like the penn tree bank (ptb), research on larger tasks is very relevant as overfitting is not the main limitation in current language modeling, but is the main characteristic of the ptb task. results on larger corpora usually show better what matters as many ideas work well on small data sets but fail to improve on larger data sets. further, given current hardware trends and vast amounts of text available on the web, it is much more straightforward to tackle large scale modeling than it used to be. thus, we hope that our work will help and motivate researchers to work on traditional lm beyond ptb- for this purpose, we will open-source our models and training recipes. we focused on a well known, large scale lm benchmark: the one billion word benchmark data set. this data set is much larger than ptb (one thousand fold, 800k word vocabulary and 1b words training data) and far more challenging. similar to imagenet, which helped advance computer vision, we believe that releasing and working on large data sets and models with clear benchmarks will help advance language modeling. the contributions of our work are as follows: we explored, extended and tried to unify some of the current research on large scale lm. specifically, we designed a softmax loss which is based on character level cnns, is efficient to train, and is as precise as a full softmax which has orders of magnitude more parameters. our study yielded significant improvements to the state-of-the-art on a well known, large scale lm task: from 51.3 down to 30.0 perplexity for single models whilst reducing the number of parameters by a factor of 20. we show that an ensemble of a number of different models can bring down perplexity on this task to 23.7, a large improvement compared to current state-of-art. we share the model and recipes in order to help and motivate further research in this area. in section [reference] we review important concepts and previous work on language modeling. section [reference] presents our contributions to the field of neural language modeling, emphasizing large scale recurrent neural network training. sections [reference] and [reference] aim at exhaustively describing our experience and understanding throughout the project, as well as emplacing our work relative to other known approaches. section: related work in this section we describe previous work relevant to the approaches discussed in this paper. a more detailed discussion on language modeling research is provided in. subsection: language models language modeling (lm) has been a central task in nlp. the goal of lm is to learn a probability distribution over sequences of symbols pertaining to a language. much work has been done on both parametric (e.g., log-linear models) and non-parametric approaches (e.g., count-based lms). count-based approaches (based on statistics of n-grams) typically add smoothing which account for unseen (yet possible) sequences, and have been quite successful. to this extent, kneser-ney smoothed 5-gram models are a fairly strong baseline which, for large amounts of training data, have challenged other parametric approaches based on neural networks. most of our work is based on recurrent neural networks (rnn) models which retain long term dependencies. to this extent, we used the long-short term memory model which uses a gating mechanism to ensure proper propagation of information through many time steps. much work has been done on small and large scale rnn-based lms. the architectures that we considered in this paper are represented in figure [reference]. in our work, we train models on the popular one billion word benchmark, which can be considered to be a medium-sized data set for count-based lms but a very large data set for nn-based lms. this regime is most interesting to us as we believe learning a very good model of human language is a complex task which will require large models, and thus large amounts of data. further advances in data availability and computational resources helped our study. we argue this leap in scale enabled tremendous advances in deep learning. a clear example found in computer vision is imagenet, which enabled learning complex vision models from large amounts of data. a crucial aspect which we discuss in detail in later sections is the size of our models. despite the large number of parameters, we try to minimize computation as much as possible by adopting a strategy proposed in of projecting a relatively big recurrent state space down so that the matrices involved remain relatively small, yet the model has large memory capacity. subsection: convolutional embedding models there is an increased interest in incorporating character-level inputs to build word embeddings for various nlp problems, including part-of-speech tagging, parsing and language modeling. the additional character information has been shown useful on relatively small benchmark data sets. the approach proposed in builds word embeddings using bidirectional lstms over the characters. the recurrent networks process sequences of characters from both sides and their final state vectors are concatenated. the resulting representation is then fed to a neural network. this model achieved very good results on a part-of-speech tagging task. in, the words characters are processed by a 1-d cnn with max-pooling across the sequence for each convolutional feature. the resulting features are fed to a 2-layer highway network, which allows the embedding to learn semantic representations. the model was evaluated on small-scale language modeling experiments for various languages and matched the best results on the ptb data set despite having 60% fewer parameters. subsection: softmax over large vocabularies assigning probability distributions over large vocabularies is computationally challenging. for modeling language, maximizing log-likelihood of a given word sequence leads to optimizing cross-entropy between the target probability distribution (e.g., the target word we should be predicting), and our model predictions. generally, predictions come from a linear layer followed by a softmax non-linearity: where is the logit corresponding to a word. the logit is generally computed as an inner product where is a context vector and is a\" word embedding\" for. the main challenge when is very large (in the order of one million in this paper) is the fact that computing all inner products between and all embeddings becomes prohibitively slow during training (even when exploiting matrix-matrix multiplications and modern gpus). several approaches have been proposed to cope with the scaling issue: importance sampling, noise contrastive estimation (nce), self normalizing partition functions or hierarchical softmax- they all offer good solutions to this problem. we found importance sampling to be quite effective on this task, and explain the connection between it and nce in the following section, as they are closely related. section: language modeling improvements recurrent neural networks based lms employ the chain rule to model joint probabilities over word sequences: where the context of all previous words is encoded with an lstm, and the probability over words uses a softmax (see figure [reference] (a)). subsection: relationship between noise contrastive estimation and importance sampling as discussed in section [reference], a large scale softmax is necessary for training good lms because of the vocabulary size. a hierarchical softmax employs a tree in which the probability distribution over words is decomposed into a product of two probabilities for each word, greatly reducing training and inference time as only the path specified by the hierarchy needs to be computed and updated. choosing a good hierarchy is important for obtaining good results and we did not explore this approach further for this paper as sampling methods worked well for our setup. sampling approaches are only useful during training, as they propose an approximation to the loss which is cheap to compute (also in a distributed setting)- however, at inference time one still has to compute the normalization term over all words. noise contrastive estimation (nce) proposes to consider a surrogate binary classification task in which a classifier is trained to discriminate between true data, or samples coming from some arbitrary distribution. if both the noise and data distributions were known, the optimal classifier would be: where is the binary random variable indicating whether comes from the true data distribution, is the number of negative samples per positive word, and and are the data and noise distribution respectively (we dropped any dependency on previous words for notational simplicity). it is easy to show that if we train a logistic classifier where is the logistic function, then, is a good approximation of (is a logit which e.g. an lstm lm computes). the other technique, which is based on importance sampling (is), proposes to directly approximate the partition function (which comprises a sum over all words) with an estimate of it through importance sampling. though the methods look superficially similar, we will derive a similar surrogate classification task akin to nce which arrives at is, showing a strong connection between the two. suppose that, instead of having a binary task to decide if a word comes from the data or from the noise distribution, we want to identify the words coming from the true data distribution in a set, comprised of noise samples and one data distribution sample. thus, we can train a multiclass loss over a multinomial random variable which maximizes, assuming w.l.o.g. that is always the word coming from true data. by bayes rule, and ignoring terms that are constant with respect to, we can write: and, following a similar argument than for nce, if we define then is a good approximation of. note that the only difference between nce and is is that, in nce, we define a binary classification task between true or noise words with a logistic loss, whereas in is we define a multiclass classification problem with a softmax and cross entropy loss. we hope that our derivation helps clarify the similarities and differences between the two. in particular, we observe that is, as it optimizes a multiclass classification task (in contrast to solving a binary task), may be a better choice. indeed, the updates to the logits with is are tied whereas in nce they are independent. subsection: cnn softmax the character-level features allow for a smoother and compact parametrization of the word embeddings. recent efforts on small scale language modeling have used cnn character embeddings for the input embeddings. although not as straightforward, we propose an extension to this idea to also reduce the number of parameters of the softmax layer. recall from section [reference] that the softmax computes a logit as where is a context vector and the word embedding. instead of building a matrix of (whose rows correspond to), we produce with a cnn over the characters of as- we call this a cnn softmax. we used the same network architecture to dynamically generate the softmax word embeddings without sharing the parameters with the input word-embedding sub-network. for inference, the vectors can be precomputed, so there is no computational complexity increase w.r.t. the regular softmax. we note that, when using an importance sampling loss such as the one described in section [reference], only a few logits have non-zero gradient (those corresponding to the true and sampled words). with a softmax where are independently learned word embeddings, this is not a problem. but we observed that, when using a cnn, all the logits become tied as the function mapping from to is quite smooth. as a result, a much smaller learning rate had to be used. even with this, the model lacks capacity to differentiate between words that have very different meanings but that are spelled similarly. thus, a reasonable compromise was to add a small correction factor which is learned per word, such that: where is a matrix projecting a low-dimensional embedding vector back up to the dimensionality of the projected lstm hidden state of. this amounts to adding a bottleneck linear layer, and brings the cnn softmax much closer to our best result, as can be seen in table [reference], where adding a 128-dim correction halves the gap between regular and the cnn softmax. aside from a big reduction in the number of parameters and incorporating morphological knowledge from words, the other benefit of this approach is that out-of-vocabulary (oov) words can easily be scored. this may be useful for other problems such as machine translation where handling out-of-vocabulary words is very important. this approach also allows parallel training over various data sets since the model is no longer explicitly parametrized by the vocabulary size- or the language. this has shown to help when using byte-level input embeddings for named entity recognition, and we hope it will enable similar gains when used to map onto words. subsection: char lstm predictions the cnn softmax layer can handle arbitrary words and is much more efficient in terms of number of parameters than the full softmax matrix. it is, though, still considerably slow, as to evaluate perplexities we need to compute the partition function. a class of models that solve this problem more efficiently are character-level lstms. they make predictions one character at a time, thus allowing to compute probabilities over a much smaller vocabulary. on the other hand, these models are more difficult to train and seem to perform worse even in small tasks like ptb. most likely this is due to the sequences becoming much longer on average as the lstm reads the input character by character instead of word by word. thus, we combine the word and character-level models by feeding a word-level lstm hidden state into a small lstm that predicts the target word one character at a time (see figure [reference] (c)). in order to make the whole process reasonably efficient, we train the standard lstm model until convergence, freeze its weights, and replace the standard word-level softmax layer with the aforementioned character-level lstm. the resulting model scales independently of vocabulary size- both for training and inference. however, it does seem to be worse than regular and cnn softmax- we are hopeful that further research will enable these models to replace fixed vocabulary models whilst being computationally attractive. section: experiments all experiments were run using the tensorflow system, with the exception of some older models which were used in the ensemble. subsection: data set the experiments are performed on the 1b word benchmark data set introduced by, which is a publicly available benchmark for measuring progress of statistical language modeling. the data set contains about 0.8b words with a vocabulary of 793471 words, including sentence boundary markers. all the sentences are shuffled and the duplicates are removed. the words that are out of vocabulary (oov) are marked with a special unk token (there are approximately 0.3% such words). subsection: model setup the typical measure used for reporting progress in language modeling is perplexity, which is the average per-word log-probability on the holdout data set:. we follow the standard procedure and sum over all the words (including the end of sentence symbol). we used the 1b word benchmark data set without any pre-processing. given the shuffled sentences, they are input to the network as a batch of independent streams of words. whenever a sentence ends, a new one starts without any padding (thus maximizing the occupancy per batch). for the models that consume characters as inputs or as targets, each word is fed to the model as a sequence of character ids of preespecified length (see figure [reference] (b)). the words were processed to include special begin and end of word tokens and were padded to reach the expected length. i.e. if the maximum word length was 10, the word\" cat\" would be transformed to\"$ cat^\" due to the cnn model. in our experiments we found that limiting the maximum word length in training to 50 was sufficient to reach very good results while 32 was clearly insufficient. we used 256 characters in our vocabulary and the non-ascii symbols were represented as a sequence of bytes. subsection: model architecture we evaluated many variations of rnn lm architectures. these include the dimensionalities of the embedding layers, the state, projection sizes, and number of lstm layers to use. exhaustively trying all combinations would be extremely time consuming for such a large data set, but our findings suggest that lstms with a projection layer (i.e., a bottleneck between hidden states as in) trained with truncated bptt for 20 steps performed well. following we use dropout before and after every lstm layer. the biases of lstm forget gate were initialized to 1.0. the size of the models will be described in more detail in the following sections, and the choices of hyper-parameters will be released as open source upon publication. for any model using character embedding cnns, we closely follow the architecture from. the only important difference is that we use a larger number of convolutional features of 4096 to give enough capacity to the model. the resulting embedding is then linearly transformed to match the lstm projection sizes. this allows it to match the performance of regular word embeddings but only uses a small fraction of parameters. subsection: training procedure the models were trained until convergence with an adagrad optimizer using a learning rate of 0.2. in all the experiments the rnns were unrolled for 20 steps without ever resetting the lstm states. we used a batch size of 128. we clip the gradients of the lstm weights such that their norm is bounded by 1.0. using these hyper-parameters we found large lstms to be relatively easy to train. the same learning rate was used in almost all of the experiments. in a few cases we had to reduce it by an order of magnitude. unless otherwise stated, the experiments were performed with 32 gpu workers and asynchronous gradient updates. further details will be fully specified with the code upon publication. training a model for such large target vocabulary (793471 words) required to be careful with some details about the approximation to full softmax using importance sampling. we used a large number of negative (or noise) samples: 8192 such samples were drawn per step, but were shared across all the target words in the batch (2560 total, i.e. 128 times 20 unrolled steps). this results in multiplying (2560 x 1024) times (1024 x (8192+ 1)) (instead of (2560 x 1024) times (1024 x 793471)), i.e. about 100-fold less computation. section: results and analysis in this section we summarize the results of our experiments and do an in-depth analysis. table [reference] contains all results for our models compared to previously published work. table [reference] shows previous and our own work on ensembles of models. we hope that our encouraging results, which improved the best perplexity of a single model from 51.3 to 30.0 (whilst reducing the model size considerably), and set a new record with ensembles at 23.7, will enable rapid research and progress to advance language modeling. for this purpose, we will release the model weights and recipes upon publication. subsection: size matters unsurprisingly, size matters: when training on a very large and complex data set, fitting the training data with an lstm is fairly challenging. thus, the size of the lstm layer is a very important factor that influences the results, as seen in table [reference]. the best models are the largest we were able to fit into a gpu memory. our largest model was a 2-layer lstm with 8192+ 1024 dimensional recurrent state in each of the layers. increasing the embedding and projection size also helps but causes a large increase in the number of parameters, which is less desirable. lastly, training an rnn instead of an lstm yields poorer results (about 5 perplexity worse) for a comparable model size. subsection: regularization importance as shown in table [reference], using dropout improves the results. to our surprise, even relatively small models (e.g., single layer lstm with 2048 units projected to 512 dimensional outputs) can over-fit the training set if trained long enough, eventually yielding holdout set degradation. using dropout on non-recurrent connections largely mitigates these issues. while over-fitting still occurs, there is no more need for early stopping. for models that had 4096 or less units in the lstm layer, we used 10% dropout probability. for larger models, 25% was significantly better. even with such regularization, perplexities on the training set can be as much as 6 points below test. in one experiment we tried to use a smaller vocabulary comprising of the 100, 000 most frequent words and found the difference between train and test to be smaller- which suggests that too much capacity is given to rare words. this is less of an issue with character cnn embedding models as the embeddings are shared across all words. subsection: importance sampling is data efficient table [reference] shows the test perplexities of nce vs is loss after a few epochs of 2048 unit lstm with 512 projection. the is objective significantly improves the speed and the overall performance of the model when compared to nce. subsection: word embeddings vs character cnn replacing the embedding layer with a parametrized neural network that process characters of a given word allows the model to consume arbitrary words and is not restricted to a fixed vocabulary. this property is useful for data sets with conversational or informal text as well as for morphologically rich languages. our experiments show that using character-level embeddings is feasible and does not degrade performance- in fact, our best single model uses a character cnn embedding. an additional advantage is that the number of parameters of the input layer is reduced by a factor of 11 (though training speed is slightly worse). for inference, the embeddings can be precomputed so there is no speed penalty. overall, the embedding of the best model is parametrized by 72 m weights (down from 820 m weights). table [reference] shows a few examples of nearest neighbor embeddings for some out-of-vocabulary words when character cnns are used. subsection: smaller models with cnn softmax even with character-level embeddings, the model is still fairly large (though much smaller than the best competing models from previous work). most of the parameters are in the linear layer before the softmax: 820 m versus a total of 1.04b parameters. in one of the experiments we froze the word-lstm after convergence and replaced the softmax layer with the cnn softmax sub-network. without any fine-tuning that model was able to reach 39.8 perplexity with only 293 m weights (as seen in table [reference]). as described in section [reference], adding a\" correction\" word embedding term alleviates the gap between regular and cnn softmax. indeed, we can trade-off model size versus perplexity. for instance, by adding 100 m weights (through a 128 dimensional bottleneck embedding) we achieve 35.8 perplexity (see table [reference]). to contrast with the cnn softmax, we also evaluated a model that replaces the softmax layer with a smaller lstm that predicts one character at a time (see section [reference]). such a model does not have to learn long dependencies because the base lstm still operates at the word-level (see figure [reference] (c)). with a single-layer lstm of 1024 units we reached 49.0 test perplexity, far below the best model. in order to make the comparisons more fair, we performed a very expensive marginalization over the words in the vocabulary (to rule out words not in the dictionary which the character lstm would assign some probability). when doing this marginalization, the perplexity improved a bit down to 47.9. subsection: training speed we used 32 tesla k40 gpus to train our models. the smaller version of the lstm model with 2048 units and 512 projections needs less than 10 hours to reach below 45 perplexity and after only 2 hours of training the model beats previous state-of-the art on this data set. the best model needs about 5 days to get to 35 perplexity and 10 days to 32.5. the best results were achieved after 3 weeks of training. see table [reference] for more details. subsection: ensembles we averaged several of our best models and we were able to reach 23.7 test perplexity (more details and results can be seen in table [reference]), which is more than 40% improvement over previous work. interestingly, including the best n-gram model reduces the perplexity by 1.2 point even though the model is rather weak on its own (67.6 perplexity). most previous work had to either ensemble with the best n-gram model (as their rnn only used a limited output vocabulary of a few thousand words), or use n-gram features as additional input to the rnn. our results, on the contrary, suggest that n-grams are of limited benefit, and suggest that a carefully trained lstm lm is the most competitive model. subsection: lstms are best on the tail words figure [reference] shows the difference in log probabilities between our best model (at 30.0 perplexity) and the kn-5. as can be seen from the plot, the lstm is better across all the buckets and significantly outperforms kn-5 on the rare words. this is encouraging as it seems to suggest that lstm lms may fare even better for languages or data sets where the number of rare words is larger than traditional n-gram models. subsection: samples from the model to qualitatively evaluate the model, we sampled many sentences. we discarded short and politically incorrect ones, but the sample shown below is otherwise\" raw\" (i.e., not hand picked). the samples are of high quality- which is not a surprise, given the perplexities attained- but there are still some occasional mistakes. sentences generated by the ensemble (about 26 perplexity): with even more new technologies coming onto the market quickly during the past three years, an increasing number of companies now must tackle the ever-changing and ever-changing environmental challenges online.< s> check back for updates on this breaking news story.< s> about 800 people gathered at hever castle on long beach from noon to 2 pm, three to four times that of the funeral cort\u00e8ge.< s> we are aware of written instructions from the copyright holder not to, in any way, mention rosenberg's negative comments if they are relevant as indicated in the documents,\" ebay said in a statement.< s> it is now known that coffee and cacao products can do no harm on the body.< s> yuri zhirkov was in attendance at the stamford bridge at the start of the second half but neither drogba nor malouda was able to push on through the barcelona defence. section: discussion and conclusions in this paper we have shown that rnn lms can be trained on large amounts of data, and outperform competing models including carefully tuned n-grams. the reduction in perplexity from 51.3 to 30.0 is due to several key components which we studied in this paper. thus, a large, regularized lstm lm, with projection layers and trained with an approximation to the true softmax with importance sampling performs much better than n-grams. unlike previous work, we do not require to interpolate both the rnn lm and the n-gram, and the gains of doing so are rather marginal. by exploring recent advances in model architectures (e.g. lstms), exploiting small character cnns, and by sharing our findings in this paper and accompanying code and models (to be released upon publication), we hope to inspire research on large scale language modeling, a problem we consider crucial towards language understanding. we hope for future research to focus on reasonably sized datasets taking inspiration from recent advances seen in the computer vision community thanks to efforts such as imagenet. section: acknowledgements we thank ciprian chelba, ilya sutskever, and the google brain team for their help and discussions. we also thank koray kavukcuoglu for his help with the manuscript. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "one billion word benchmark data set"
                    ],
                    [
                        "one billion word benchmark"
                    ],
                    [
                        "ptb data set"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "perplexity"
                    ],
                    [
                        "perplexity"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "one billion word benchmark",
                        "1b words training data",
                        "1b word benchmark data set"
                    ]
                ],
                "Method": [
                    [
                        "lstm",
                        "lstm lm",
                        "lstm predictions",
                        "word-level lstm hidden state",
                        "lstm model",
                        "character-level lstm",
                        "lstms",
                        "lstm layer",
                        "lstm forget gate",
                        "2-layer lstm",
                        "single layer lstm",
                        "2048 unit lstm",
                        "word-lstm",
                        "single-layer lstm of 1024 units",
                        "character lstm",
                        "lstm lms",
                        "regularized lstm lm"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "language modeling",
                        "lm",
                        "lms",
                        "language models",
                        "large scale lm",
                        "modeling language"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "one billion word benchmark",
                        "1b words training data",
                        "1b word benchmark data set"
                    ]
                ],
                "Method": [
                    [
                        "lstm lm",
                        "lstm",
                        "lstm predictions",
                        "word-level lstm hidden state",
                        "lstm model",
                        "character-level lstm",
                        "lstms",
                        "lstm layer",
                        "lstm forget gate",
                        "2-layer lstm",
                        "single layer lstm",
                        "2048 unit lstm",
                        "word-lstm",
                        "single-layer lstm of 1024 units",
                        "character lstm",
                        "lstm lms",
                        "regularized lstm lm"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "language modeling",
                        "lm",
                        "lms",
                        "language models",
                        "large scale lm",
                        "modeling language"
                    ]
                ]
            }
        ]
    },
    "0398552184f80db111e9c28bf533b395f233ac00-2": {
        "doctext": "bridging saliency detection to weakly supervised object detection based on self-paced curriculum learning section: abstract weakly-supervised object detection (wod) is a challenging problems in computer vision. the key problem is to simultaneously infer the exact object locations in the training images and train the object detectors, given only the training images with weak image-level labels. intuitively, by simulating the selective attention mechanism of human visual system, saliency detection technique can select attractive objects in scenes and thus is a potential way to provide useful priors for wod. however, the way to adopt saliency detection in wod is not trivial since the detected saliency region might be possibly highly ambiguous in complex cases. to this end, this paper first comprehensively analyzes the challenges in applying saliency detection to wod. then, we make one of the earliest efforts to bridge saliency detection to wod via the self-paced curriculum learning, which can guide the learning procedure to gradually achieve faithful knowledge of multi-class objects from easy to hard. the experimental results demonstrate that the proposed approach can successfully bridge saliency detection and wod tasks and achieve the state-of-the-art object detection results under the weak supervision. section: introduction 1 object detection is one of the most fundamental yetchallenging problems in computer vision community. the most recent breakthrough was achieved by girshick et al., who trained the convolutional neural network (cnn) by using large amount of human labelled bounding boxes to learn the powerful feature representations and object classifiers. despite their success, the problem of object detection is still under-addressed in practice due to the heavy burden of labeling the training samples. essentially, in this big data era, humans more desire intelligent machines which are capable of automatically discovering the intrinsic patterns from the cheaply and massively collected weakly* the corresponding author labeled images. thus weakly supervised object detection (wod) systems have been gaining more interests recently. the key problem in wod is how to extract the exact object localizations and train the corresponding object detectors from the weakly labelled training images. in such chicken-egg problem, most methods (including the proposed one) usually use the alternative learning strategy that first provides some coarse estimation to initialize the potential object locations and then gradually train the object detectors and update object locations jointly. in this paper, we leverage saliency detection to initialize the potential object locations due to the following reasons: 1) saliency detection; [reference][reference] aims at simulating the selective attention mechanism of human visual system to automatically select sub-regions (usually the regions containing objects of interest) in image scenes. thus, it can be readily utilized to provide useful priors to estimate the potential object localizations and fit well to the investigated task. 2) some recent saliency detection methods such as [reference] and [reference] can process much faster than the priors, e.g., intra-class similarity [reference], inter-class variance [reference], and distance mapping relation [reference], adopted in the existing wod systems. 3) several existing works, e.g.,, have attempted to apply saliency detection techniques to wod. however they still have not sufficiently explore the intrinsic bridge between these two tasks, which motivates us to clarify the insightful relationship between these two tasks and further develop powerful learning regime to bridge them. essentially, although it sounds reasonable to apply saliency detection to wod, the way to bridge these two tasks is not trivial. the main problem is that saliency detection is formulated as category-free models which only distinguish attractive regions from the image background while irrelevant to the concrete object category. thus, as shown in fig. 1, in the images only containing one category of objects (considered as\" easy\" images), the objects can be captured by saliency detection methods easily and associated with the corresponding image label properly. whereas in the images weakly labelled as containing multiple categories of objects (considered as\" hard\" images), objects in all of categories will have the probabilities to attract the human attention and their corresponding locations are also hard for saliency models to identify, which largely increases the ambiguity when considering to apply the obtained salient detection results to initializing the training samples for wod. thus, it is unreliable to directly apply saliency detection to wod. to alleviate this problem, we propose to bridge saliency detection to wod via a self-paced curriculum learning (spcl) regime. spcl was proposed in as a general learning framework including both the curriculum learning (cl) and self-paced learning (spl) components. to the best of our knowledge, both of these two learning components are critical in successfully bridging saliency detection to wod, whereas none of the existing literature has explored them before. specifically, cl was proposed by [reference], which is usually learned based on the learning priorities derived by predetermined heuristics for particular problems. spl was proposed by [reference], where the learning pace is dynamically generated by the learner itself, according to which the learner has already learned from the data. thus, the cl and spl components in spcl can be correspondingly used to solve the training sample initialization and object detector updating problems in the proposed saliency-guided wod. to implement spcl for our task, we first design a task-specific curriculum to assign the\" easy\" images with larger priority than the\" hard\" images during the learning procedure, which indicates that only the salient object hypotheses in the\" easy\" images are selected as the initial training samples, while the object hypotheses in the\" hard\" images will be gradually involved in the subsequent learning iterations. to guide the learner to gradually learn faithful knowledge of multi-class objects from the\" easy\" (high-confidence) images to the\" hard\" (high-ambiguity) ones, a novel self-paced learning regularizer is proposed to enforce the learner to select confident and diverse training hypotheses in each iteration and learn the object detectors of multiple categories simultaneously. finally, the proposed spcl regime can fit well to solve the problems in this paper. compared with the spcl model in, the learning regime proposed in this paper mainly has three differences: 1) we design a task-specific learning curriculum for bridging saliency detection and wod effectively. 2) we introduce an additional term, the sample diversity term, in the self-paced regularizer to prevent the selected training hypotheses from drifting to a small collection of training images. 3) considering the latent relationship among the multiple categories of co-occurring objects, we further generalize the spl regime into multi-class formulation, which facilitates the learning system to penalize indiscriminative object hypotheses predicted as belonging to multiple object categories at the same time. to sum up, there are three-fold contributions in this paper:\uf0b7 we comprehensively analyze the prospect and challenges in the idea of bridging saliency detection to wod and propose an effective way to alleviate the problem, which achieves the state-of-the-art detection performance under the weak supervision.\uf0b7 we establish a novel spcl regime containing both the task-specific learning curriculum and the data-driven self-learning pace. the regime is well formulated as a concise optimization model.\uf0b7 we incorporate spcl with a sample diversity term and further generalize it to work in multi-class scenario. section: related works saliency detection: most saliency detection methods highlight the attractive image regions by exploring some bottom-up cues. as one frequently explored cue, local contrast [reference][reference] is usually used in the saliency detection models to highlight the image regions appearing differently with their spatially neighbor regions. another widely used bottom-up cue is the global contrast. being different from local contrast, global contrast [reference][reference] is used to discover image regions which are unique in the entire image context. more recently, background prior becomes another important cue for saliency detection. this kind of methods, e.g.,, assume that regions near image boundaries are probably backgrounds and detect salient regions as figure 1: this figure illustrates the main idea of this paper. as can be seen, in the training images with weak labels, some of them (in blue frame) are labelled only containing one object category, which are considered as\" easy\" images for the saliency detection methods. while others (in pink frame) labelled as containing multiple object categories are considered as\" hard\" images. due to the category free property of saliency detection, the objects in\" easy\" images have larger confidence to be extracted correctly by the saliency detection methods, whereas the objects in\" hard\" images can not be extracted successfully. to this end, we develop a novel self-paced curriculum learning paradigm to guide the learner to gradually achieve the faithful knowledge of the multiple object categories from easy (confident) to hard (ambiguous). calculating the contrast to these image boundary regions. as can be seen, the bottom-up cues explored by saliency detection models are highly potential to provide helpful priors to the object localizations in each image. weakly-supervised object detection: two key issues in wod are 1) predict the potential object localizations and 2) learn the object detectors. some early wod methods [reference] held the view that a better initial estimation of the object localizations is critical to this task as they can largely impact the subsequent learning process. thus, they explored different ways, e.g. intra-class similarity [reference], inter-class variance [reference], and distance mapping relation [reference], to initialize the training object hypotheses. later on, some recent wod methods started to pay more attention to the optimization procedure designed for better training object detectors under the weak supervision. for example, [reference][reference] proposed to smooth the object formulation to better obtain the optimal solutions. [reference] proposed to incorporate convex clustering in the learning procedure, which enforces the local similarity of the selected hypotheses during optimization. essentially, both of the above mentioned problems are critical in wod task. to this end, this paper proposes a novel spcl model which explicitly encode both the former problem (with the designed curriculum) and the later (with the self-paced regularizer) into a unified formulation and handle both problems in a theoretically sound manner. section: self-paced (curriculum) learning: inspired by the learning process of humans/ animals, the theory of self-paced (or curriculum) learning [reference][reference] is proposed lately. the idea is to learn the model iteratively from easy to complex samples in a self-paced fashion. by virtue of its generality, the spl theory has been widely applied to various tasks, such as multi-view clustering [reference], multi-label propagation [reference], multimedia event detection, and co-saliency detection. more recently, introduced the pre-defined learning curriculum to the conventional self-paced learning regime which can take into account both the helpful prior knowledge known before training and the self-learning progress during training. inspired by this work, we design a task-specific learning curriculum and construct a unified spcl model specifically for both the saliency detection and wod tasks, through which both can be naturally related. section: the proposed approach section: algorithm overview given k training images with weak labels consisting of c categories, we first extract the bounding box object hypotheses and their corresponding feature representations from each image. denote the features of each hypothesis in the k th image as {, where, ()\u2208 [0, 1], indicating the labels and the real-valued importance weights of each hypothesis, respectively, which are unknown at the beginning and will be optimized during the proposed learning regime. the aim of the proposed approach is to learn the object detectors {w, b}, where= {},= {}, of c object categories from the weakly-labeled training images, and then use them to detect objects in the test images. specifically, we first design a simple yet effective curriculum to select the salient hypotheses in\" easy\" images as initialization. then, the object detectors are trained and updated gradually under the guidance of the proposed self-paced learning strategy. finally, the obtained object detectors are used to detect the corresponding objects in the test images. the overall algorithm is shown in algorithm 1. section: problem formulation given object hypotheses from the training images, we propose a simple yet effective curriculum to initialize the learning procedure. specifically, we first obtain the\" easy\" images based on the number of weak labels of each image, i.e., images weakly labelled as only containing one object category are considered as\" easy\". then, for each\" easy\" image, we adopt an unsupervised saliency detection method, i.e., rc [reference] in this paper due to its efficiency, to generate the corresponding saliency estimation. finally, the important weights v are initialized as the intersection-over-union (iou) score between each hypothesis and the salient region. the hypotheses with weights larger than 0 are selected as the initial training hypotheses and their labels in y are set according to the label of the images containing them. afterwards, in order to gradually adapt the learner from the\" easy\" domain to the\" hard\" domain and finally capture the faithful knowledge of the objects of interest, a novel self-paced learning regularizer is proposed as follows:+ 1\u2264 2, enforces that each hypothesis should belong to only one object category, or no class, i.e., the background category. this constraint inherently penalizes the indiscriminative object hypotheses, i.e. the hypotheses predicted to belong to multiple object categories, when calculating their importance weight in (2). the third one, i.e.\u2211,* ()+ 1\u2265 2, means that for all object hypotheses located in the k th image, at least one should belong to the class which the image has been weakly annotated. this will make the learned result finely comply with the prior knowledge. in the proposed spcl regime, the self-paced capability is followed by the involvement of the spl regularizer ();, with the following form: where, are the class-specific parameters imposed on the easiness term and the diversity term, respectively. the negative l 1-norm term is inherited from the conventional spl [reference], which favors selecting easy over complex hypotheses. if we omit the diversity term, i.e. let= 0, the regularizer degenerates to the traditional hard spl function proposed in [reference], which conducts either 1 or 0 (i.e. selected in training or not) for the weight, () imposed on hypothesis (), by judging whether its loss value is smaller than the pace parameter or not. that is, a sample with smaller loss is taken as an easy sample and thus should be learned preferentially and vice versa. another regularization term favors selecting diverse hypotheses residing in more images. this can be easily understood by seeing that its negative leads to the group-wise sparse representation of v. contrariwise, this diversity term should have a counter-effect to group-wise sparsity. that is, minimizing this diversity term tends to disperse non-zero elements of v over more images, and thus favors selecting more diverse hypotheses. consequently, this anti-group-sparsity representation is expected to realize the desired diversity. different from the commonly utilized l 2, 1 norm, our utilized group-sparsity term is concave, leading to the convexity of its negative. this on one side simplifies the designation of the solving strategy, and on the other hand well fits the previous axiomatic definition for the spl regularizer. section: optimization method the solution of (1) can be approximately attained by alternatively optimizing the involved parameters {w, b}, y and v as described in algorithm 1. the optimization mainly contains following steps: object detectors updating: optimize object detector parameters {w, b} via one-vs-all svm under fixed y and v. in this case, (1) degenerates to the following form:;,, which can be equivalently reformulated as solving the following sub-optimization problems for each c=1, 2,\u2026, c:,. this is a standard one-vs-all (weighted) svm model [reference]. section: hypotheses labelling: optimize under fixed {w, b} and v: the goal of this step is to learn the pseudo-labels of training hypotheses from the current object detectors. the model in this case can be reformulated as: this problem can be equivalently decomposed into sub-problems with respect to each= 1,\u22ef,, i.e. for each image, where c* is the weak labels of the k th image: [reference] indicates the labels of the hypotheses in the k th image. its global optimum can be attained by algorithm 2, which can be derived from the theorem in. hypotheses re-weighting: optimize v under fixed {w, b} and y: after updating the pseudo-labels, we aim to renew the weights on all hypotheses to reflect their different importance to learning of the current decision surface. in this case, (1) degenerates to the following form: which is equivalent to independently solving the following sub-optimization problem for each= 1,\u22ef, and= 1,\u22ef, via: we can easily simplify the above optimization problem as: this model is convex and according to, we can apdopt an effective algorithm, i.e., the algorithm 3, for extracting the global optimum to it. section: experimental results section: experimental settings we evaluate our method on the pascal voc 2007 dataset [reference] which is widely used by the previous works. in our experiments, we follow the previous works [reference][reference][reference][reference] to discard any images that only contain object instances marked as\" difficult\" or\" truncated\" during the training phase, while all the images in the voc07-test are used during the test phase. for fair comparison, we follow the standard voc procedure [reference] and report average precision (ap) on the pascal voc 2007 test split. being consistent with the recently proposed wod methods [reference][reference][reference], we apply selective search [reference] to generate around 1500 bounding box object hypotheses in each image and adopt the cnn features [reference] pre-trained on the imagenet 2012 to represent each of the extracted object hypotheses. before training, and in (2) need to be set in advance. as suggested in, we set according to the number of the selected training hypotheses which is set to be 2% of the total bounding box windows extracted from the images weakly labelled as containing the c th object category. then, is set to be equal to empirically. section: comparison to the state-of-the-arts in this section, we evaluate the object detection performance of our framework by comparing it with 6 state-of-the-art wod approaches which are pr [reference], cc [reference], mdd [reference], llo [reference], vpc [reference], and mfmil [reference]. for quantitative comparison, we report the evaluation results in terms of the ap score in fig. 2. as can be seen, the proposed approach obtains the highest score of 29.96 on average. according to our analysis, the proposed approach can obtain significantly better results than mdd and mfmil mainly due to the better feature representation, stronger saliency prior, and more powerful learning scheme. compared with pr, cc, llo, and vpc, the performance gain of the proposed approach mainly comes from the core insight of this paper, i.e., developing property way to bridge saliency detection to wod, as we used the same feature representation with these methods. more specifically, compared with pr and cc, the performance gain of the proposed approach comes mainly from the idea to bridge saliency detection to wod because they only adopted weak priors in their initialization. compared with llo and vpc, the performance gain of the proposed approach mainly comes from the proposed spcl regime as these two methods also explored strong prior information for initializing the training hypotheses in their frameworks. some examples of the detection results are also shown in fig. 2, which includes some successful cases, i.e., the examples in the bus and cat categories, as well as some failure cases, i.e., examples in the plant and chair categories. the successful cases subjectively demonstrate the effectiveness of the proposed approach. for the failure cases, the main problem is that very limited number of images only contains the objects like plant and chair, leading to the insufficient training hypotheses in the initialization stage. this problem can be solved by designing more proper learning curriculum for wod in future works. section: model analysis to further analyze the proposed framework in this paper, we make more comprehensive evaluations in this section by comparing with five baseline models as described in table 1. the experimental results are shown in fig. 3, from which we can see: 1) the performance gap between sal+ svm and ours demonstrates the importance to develop proper ways to bridge saliency detection and wod. 2) the experimental results of sal+ spl, sal+ spcl, and ours demonstrate the better performance of the proposed learning regime as compared with some existing self-paced (curriculum) learning regimes. 3) the performance gap between ours and llo+ spcl* demonstrates the saliency prior can provide more helpful information than the prior designed in llo. 4) the performance gap between llo+ spcl* and llo indicates the better capability of the proposed learning regime as compared with the learning model in one state-of-the-art wod framework. according to the above analysis, the key insight of this paper, i.e., developing powerful learning regime, i.e., the proposed spcl, can better bridge saliency detection to wod and help the learner to capture the faithful knowledge of the object categories under weak supervision, has been demonstrated comprehensively. section: conclusion in this paper, in order to address the challenging wod problem, we proposed an effective framework to bridge saliency detection to the investigated task based on a novel spcl regime. the insight of this paper is that by developing powerful learning regime which contains both the task-specific learning curriculum and the data-driven self-learning pace, saliency detection technique can be better leveraged to provide beneficial information for helping the learner to capture the faithful knowledge of the object categories under weak supervision. experiments including comparisons to other state-of-the-arts and comprehensive analysis of the proposed framework on the benchmark dataset have demonstrated the effectiveness of our approach. for the future work, inspired by [reference], we plane to enable the proposed method to transfer the knowledge that has be captured to new concepts via novel regularizers.. llo baseline wod framework [reference]. llo+ spcl* replace the learning model, i.e., slsvm, in llo with the proposed spcl regime. section: section: acknowledgments: this work was supported in part by the national science foundation of china under grants 61522207 and 61473231, the doctorate foundation, and the excellent doctorate foundation of northwestern polytechnical university. section:",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "bridging"
                    ]
                ],
                "Metric": [
                    [
                        "average precision"
                    ],
                    [
                        "ap"
                    ]
                ],
                "Task": [
                    [
                        "saliency detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "weakly supervised object detection"
                    ],
                    [
                        "object detection"
                    ],
                    [
                        "detection"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "pascal voc 2007 dataset",
                        "pascal voc 2007 test split"
                    ]
                ],
                "Method": [
                    [
                        "self-paced curriculum learning",
                        "spcl",
                        "spcl regime",
                        "spcl model",
                        "curriculum",
                        "self-paced (curriculum) learning",
                        "self-paced (or curriculum) learning",
                        "unified spcl model",
                        "rc",
                        "self-paced (curriculum) learning regimes"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "weakly supervised object detection",
                        "weakly-supervised object detection",
                        "wod",
                        "wod tasks",
                        "object detection",
                        "wod systems",
                        "saliency-guided wod",
                        "wod task",
                        "detection",
                        "wod problem"
                    ]
                ]
            }
        ]
    },
    "05d2700846c0323f79c1344aca5333994c7c03a5-3": {
        "doctext": "document: the ibm 2016 english conversational telephone speech recognition system we describe a collection of acoustic and language modeling techniques that lowered the word error rate of our english conversational telephone lvcsr system to a record 6.6% on the switchboard subset of the hub5 2000 evaluation testset. on the acoustic side, we use a score fusion of three strong models: recurrent nets with maxout activations, very deep convolutional nets with 3x3 kernels, and bidirectional long short-term memory nets which operate on fmllr and i-vector features. on the language modeling side, we use an updated model\" m\" and hierarchical neural network lms. georgesaon, tomsercu, stevenrennieandhong-kwangj.kuo, yorktownheights, ny, 10598 gsaon@us.ibm.com\u00a9 ieee2004, pleasedonotredistribute index terms: recurrent neural networks, convolutional neural networks, conversational speech recognition section: introduction the landscape of neural network acoustic modeling is rapidly evolving. spurred by the success of deep feed-forward neural nets for lvcsr in and inspired by other research areas like image classification and natural language processing, many speech groups have looked at more sophisticated architectures such as deep convolutional nets, deep recurrent nets, time-delay neural nets, and long-short term memory nets. the trend is to remove a lot of the complexity and human knowledge that was necessary in the past to build good asr systems (e.g. speaker adaptation, phonetic context modeling, discriminative feature processing, etc.) and to replace them with a powerful neural network architecture that can be trained agnostically on a lot of data. with the advent of numerous neural network toolkits which can implement these sophisticated models out-of-the-box and powerful hardware based on gpus, the barrier of entry for building high performing asr systems has been lowered considerably. first case in point: front-end processing has been simplified considerably with the use of cnns which treat the log-mel spectral representation as an image and do n't require extra processing steps such as plp cepstra, lda, fmllr, fmpe transforms, etc. second case in point: end-to-end asr systems such as bypass the need of having phonetic context decision trees and hmms altogether and directly map the sequence of acoustic features to a sequence of characters or context independent phones. third case in point: training algorithms such as connectionist temporal classification do n't require an initial alignment of the training data which is typically done with a gmm-based baseline model. the above points beg the question whether, in this age of readily available nn toolkits, speech recognition expertise is still necessary or whether one can simply point a neural net to the audio and transcripts, let it train, and obtain a good acoustic model. while it is true that, as the amount of training data increases, the need for human asr expertise is lessened, at the moment the performance of end-to-end systems ultimately remains inferior to that of more traditional, i.e. hmm and decision tree-based, approaches. since the goal of this work is to obtain the lowest possible wer on the switchboard dataset regardless of other practical considerations such as speed and/ or simplicity, we have focused on the latter approaches. the paper is organized as follows: in section [reference] we discuss acoustic and language modeling improvements and in section [reference] we summarize our findings. section: system improvements in this section we describe three different acoustic models that were trained on 2000 hours of english conversational telephone speech: recurrent nets with maxout activations and annealed dropout, very deep convolutional nets with 3 3 kernels, and bidirectional long short-term memory nets operating on fmllr and i-vector features. all models are used in a hybrid hmm decoding scenario by subtracting the logarithm of the hmm state priors from the log of the softmax output scores. the training and test data, frontend processing, speaker adaptation are identical to and their description will be omitted. at the end of the section, we also provide an update on our vocabulary and language modeling experiments. subsection: recurrent nets with maxout activations we remind the reader that maxout nets generalize relu units by employing non-linearities of the form where the subsets of neurons are typically disjoint. in we have shown that maxout dnns and cnns trained with annealed dropout outperform their sigmoid-based counterparts on both 300 hours and 2000 hours training regimes. what was missing there was a comparison between maxout and sigmoid for unfolded rnns. the architecture of the maxout rnns comprises one recurrent layer with 2828 units projected to 1414 units via non-overlapping maxout operations. this layer is followed by 4 non-recurrent layers with 2828 units (also projected to 1414) followed by a bottleneck with 1024 512 units and an output layer with 32000 neurons corresponding to as many context-dependent hmm states. the number of neurons for the maxout layers have been chosen such that the weight matrices have roughly the same number of parameters as the baseline sigmoid network which has 2048 units per hidden layer. the recurrent layer is unfolded backwards in time for 6 time steps and has 340-dimensional inputs consisting of 6 spliced right context 40-dimensional fmllr frames () to which we append a 100-dimensional speaker-based ivector. the unfolded maxout rnn architecture is depicted in figure [reference]. the network is trained one hidden layer at a time with discriminative pretraining followed by 12 epochs of sgd ce training on randomized minibatches of 250 samples. the model is refined with hessian-free sequence discriminative training using the state-based mbr criterion for 10 iterations. in table [reference] we report the error rates for sigmoid and maxout rnns on the switchboard and callhome subsets of hub5'00. the decodings are done with a small vocabulary of 30 k words and a small 4-gram language model with 4 m n-grams. note that the sigmoid rnns have better error rates than what was reported in because they have been retrained after the data has been realigned with the best joint rnn/ cnn model. we observe that the maxout rnns are consistently better and that, by themselves, they achieve a similar wer as our previous best model which was the joint rnn/ cnn with sigmoid activations. subsection: very deep convolutional networks very deep cnns with small kernels have recently been shown to achieve very strong performance as acoustic models in hybrid nn-hmm speech recognition systems. results were provided after cross-entropy training on the 300 hours switchboard-1 dataset in, and results from sequence training on both switchboard-1 and the 2000 hours switchboard+ fisher dataset are in. the very deep convolutional networks are inspired by the\" vgg net\" architecture introduced in for the 2014 imagenet classification challenge, with the central idea to replace large convolutional kernels by small kernels. by stacking many of these convolutional layers with relu nonlinearities before pooling layers, the same receptive field is created with less parameters and more nonlinearity. figure [reference] shows the design of the networks. note that as we go deeper in the network, the time and frequency resolution is reduced through pooling only, while the convolutions are zero-padded as to not reduce the size of the feature maps. we increase the number of feature maps gradually from 64 to 512 (indicated by the different colors). we pool right before the layer that increases the number of feature maps. note that the indication of feature map size on the right only applies to the rightmost 2 designs. in contrast, the classical cnn architecture has only two layers, goes to 512 feature maps directly, and uses a large kernel on the first layer. our 10-layer cnn has about the same number of parameters as the classical cnn, converges in 5 times fewer epochs, but is computationally more expensive. results for 3 variations of the 10-layer cnn are in table [reference]. for model combination, we use the version with pooling, which is the exact same model without modifications from the original paper. our implementation was done in torch. we adopt the balanced sampling from, by sampling from context dependent state with probability. we keep throughout the experiments during cross-entropy training. during ce training, we optimize with simple sgd or nag, during st we found nag to be superior to sgd. we regularize the stochastic sequence training by adding the gradient of cross-entropy loss, as proposed in. subsection: bidirectional lstms given the recent popularity of lstms for acoustic modeling, we have experimented with such models on the switchboard task using the torch toolkit. we have looked at the effect of the input features on lstm performance, the number of layers and whether start states for the recurrent layers should be reset or carried over. we use bidirectional lstms that are trained on non-overlapping subsequences of 20 frames. the subsequences coming from the same utterance are contiguous so that the left-to-right final states for the current subsequence can be copied to the left-to-right start states for the next subsequence (i.e. carried over). for processing speed and in order to get good gradient estimates, we group subsequences from multiple utterances into minibatches of size 256. regardless of the number of lstm layers, all models use a linear bottleneck of size 256 before the softmax output layer (of size 32000). in one experiment, we compare the effect of input features on model performance. the baseline models are trained on 40-dimensional fmllr+ 100-dimensional ivector frames and have 1024 (or 512) lstm units per layer and per direction (left-to-right and right-to-left). the forward and backward activations from the previous lstm layer are concatenated and fed into the next lstm layer. the contrast model is a single layer bidirectional lstm trained on 128-dim features obtained by performing pca on 512-dimensional bottleneck features. the features are obtained from a 6-layer dnn cross entropy trained on blocks of 11 consecutive fmllr frames and 100-dimensional i-vectors. in table [reference], we report recognition results on hub5'00 for these four models trained with 15 passes of cross-entropy sgd on the 300 hour (swb-1) subset. due to a bug that affected our earlier multi-layer lstm results, we decided to go ahead with single layer bidirectional lstms on bottleneck features on the full 2000 hour training set. we also experimented with how to deal with the start states at the beginning of the left-to-right pass. one option is to carry them over from the previous subsequence and the other one is to reset the start states at the beginning of each subsequence. in figure [reference] we compare the cross-entropy loss on held-out data between these two models. as can be seen, the lstm model with carried over start states is much better at predicting the correct hmm state. however, when comparing word error rates in table [reference], the lstm with start states that are reset has a better performance. we surmise that this is because the increased memory of the lstm with carried over start states is in conflict with the state sequence constraints imposed by the hmm topology and the language model. additionally, we show the wers of the dnn used for the bottleneck features and of a 4-layer 512 unit lstm. we observe that the 4 layer lstm is significantly better than the dnn and the two single layer lstms trained on bottleneck features. subsection: model combination in table [reference] we report the performance of the individual models (rnn, vgg and 4-layer lstm) described in the previous subsections as well as the results after frame-level score fusion. all decodings are done with a 30 k word vocabulary and a small 4-gram language model with 4 m n-grams. we note that rnns and vgg nets exhibit similar performance and have a strong complementarity which improves the wer by 0.6% and 0.9% on swb and ch, respectively. subsection: language modeling experiments our language modeling strategy largely parallels that described in. for completeness, we will repeat some of the details here. the main difference is an increase in the vocabulary size from 30 k words to 85 k words. when comparing acoustic models in previous sections, we used a relatively small legacy language model used in previous publications: a 4 m n-gram (n=4) language model with a vocabulary of 30.5 k words. we wanted to increase the language model coverage in a manner that others can replicate. to this end, we increased the vocabulary size from 30.5 k words to 85 k words by adding the vocabulary of the publicly available broadcast news task. we also added to the lm publicly available text data from ldc, including switchboard, fisher, gigaword, and broadcast news and conversations. the most relevant data are the transcripts of the 1975 hour audio data used to train the acoustic model, consisting of about 24 m words. for each corpus we trained a 4-gram model with modified kneser-ney smoothing. the component lms are linearly interpolated with weights chosen to optimize perplexity on a held-out set. entropy pruning was applied, resulting in a single 4-gram lm consisting of 36 m n-grams. this new n-gram lm was used together with our best acoustic model to decode and generate word lattices for lm rescoring experiments. the first two lines of table [reference] show the improvement using this larger n-gram lm with larger vocabulary trained on more data. the wer improved by 1.0% for swb. part of this improvement (0.1-0.2%) was due to also using a larger beam for decoding and a change in vocabulary tokenization. we used two types of lms for lm rescoring: model m, a class-based exponential model and feed-forward neural network lm (nnlm). we built a model m lm on each corpus and interpolated the models, together with the 36 m n-gram lm. as shown in table [reference], using model m results in an improvement of 0.6% on swb. we built two nnlms for interpolation. one was trained on just the most relevant data: the 24 m word corpus (switchboard/ fisher/ callhome acoustic transcripts). another was trained on a 560 m word subset of the lm training data: in order to speed up training for this larger set, we employed a hierarchical nnlm approximation. table [reference] shows that the nnlms provided an additional 0.4% improvement over the model m result on swb. compared with the n-gram lm baseline, lm rescoring yielded a total improvement of 1.0% on swb (7.6% to 6.6%) and 1.5% on ch (13.7% to 12.2%). section: conclusion in our previous switchboard system paper we have observed a good complementarity between recurrent nets and convolutional nets and their combination led to significant accuracy gains. in this paper we have presented an improved unfolded rnn (with maxout instead of sigmoid activations) and a stronger cnn obtained by adding more convolutional layers with smaller kernels and relu nonlinearities. these improved models still have good complementarity and their frame-level score combination in conjunction with a multi-layer lstm leads to a 0.4%-0.7% decrease in wer over the lstm. multi-layer lstms were the strongest performing model followed closely by the rnn and vgg nets. we also believe that lstms have more potential for direct sequence-to-sequence modeling and we are actively exploring this area of research. on the language modeling side, we have increased our vocabulary from 30 k to 85 k words and updated our component lms. at the moment, we are less than 3% away from achieving human performance on the switchboard data (estimated to be around 4%). unfortunately, it looks like future improvements on this task will be considerably harder to get and will probably require a breakthrough in direct sequence-to-sequence modeling and a significant increase in training data. section: acknowledgment the authors wish to thank e. marcheret, j. cui and m. nussbaum-thom for useful suggestions about lstms. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "ibm 2016"
                    ],
                    [
                        "english conversational telephone speech recognition system"
                    ],
                    [
                        "switchboard"
                    ],
                    [
                        "switchboard subset"
                    ],
                    [
                        "switchboard subset of the hub5"
                    ],
                    [
                        "hub5"
                    ],
                    [
                        "switchboard dataset"
                    ],
                    [
                        "switchboard-1 dataset"
                    ],
                    [
                        "switchboard+ fisher dataset"
                    ],
                    [
                        "swb-1 subset"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "word error rates"
                    ],
                    [
                        "frame level score"
                    ]
                ],
                "Task": [
                    [
                        "speech recognition system"
                    ],
                    [
                        "language modeling side"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "switchboard subset",
                        "switchboard dataset",
                        "switchboard",
                        "hub5'00",
                        "switchboard task",
                        "switchboard data"
                    ]
                ],
                "Method": [
                    [
                        "m n-gram lm"
                    ]
                ],
                "Metric": [
                    [
                        "word error rate",
                        "error rates",
                        "word error rates"
                    ]
                ],
                "Task": [
                    [
                        "ibm 2016 english conversational telephone speech recognition system",
                        "conversational speech recognition",
                        "speech recognition expertise",
                        "hybrid nn-hmm speech recognition systems",
                        "recognition",
                        "ch"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "swb"
                    ]
                ],
                "Method": [
                    [
                        "m n-gram lm"
                    ]
                ],
                "Metric": [
                    [
                        "word error rate",
                        "error rates",
                        "word error rates"
                    ]
                ],
                "Task": [
                    [
                        "ibm 2016 english conversational telephone speech recognition system",
                        "conversational speech recognition",
                        "speech recognition expertise",
                        "hybrid nn-hmm speech recognition systems",
                        "recognition",
                        "ch"
                    ]
                ]
            }
        ]
    },
    "0626908dd710b91aece1a81f4ca0635f23fc47f3-4": {
        "doctext": "document: rethinking the inception architecture for computer vision convolutional networks are at the core of most state-of-the-art computer vision solutions for a wide variety of tasks. since 2014 very deep convolutional networks started to become mainstream, yielding substantial gains in various benchmarks. although increased model size and computational cost tend to translate to immediate quality gains for most tasks (as long as enough labeled data is provided for training), computational efficiency and low parameter count are still enabling factors for various use cases such as mobile vision and big-data scenarios. here we are exploring ways to scale up networks in ways that aim at utilizing the added computation as efficiently as possible by suitably factorized convolutions and aggressive regularization. we benchmark our methods on the ilsvrc 2012 classification challenge validation set demonstrate substantial gains over the state of the art: top-and top-error for single frame evaluation using a network with a computational cost of billion multiply-adds per inference and with using less than 25 million parameters. with an ensemble of models and multi-crop evaluation, we report top-error and top-error. section: introduction since the 2012 imagenet competition winning entry by krizhevsky et al, their network\" alexnet\" has been successfully applied to a larger variety of computer vision tasks, for example to object-detection, segmentation, human pose estimation, video classification, object tracking, and superresolution. these successes spurred a new line of research that focused on finding higher performing convolutional neural networks. starting in 2014, the quality of network architectures significantly improved by utilizing deeper and wider networks. vggnet and googlenet yielded similarly high performance in the 2014 ilsvrc classification challenge. one interesting observation was that gains in the classification performance tend to transfer to significant quality gains in a wide variety of application domains. this means that architectural improvements in deep convolutional architecture can be utilized for improving performance for most other computer vision tasks that are increasingly reliant on high quality, learned visual features. also, improvements in the network quality resulted in new application domains for convolutional networks in cases where alexnet features could not compete with hand engineered, crafted solutions, e.g. proposal generation in detection. although vggnet has the compelling feature of architectural simplicity, this comes at a high cost: evaluating the network requires a lot of computation. on the other hand, the inception architecture of googlenet was also designed to perform well even under strict constraints on memory and computational budget. for example, googlenet employed only 5 million parameters, which represented a reduction with respect to its predecessor alexnet, which used million parameters. furthermore, vggnet employed about 3x more parameters than alexnet. the computational cost of inception is also much lower than vggnet or its higher performing successors. this has made it feasible to utilize inception networks in big-data scenarios,, where huge amount of data needed to be processed at reasonable cost or scenarios where memory or computational capacity is inherently limited, for example in mobile vision settings. it is certainly possible to mitigate parts of these issues by applying specialized solutions to target memory use, or by optimizing the execution of certain operations via computational tricks. however, these methods add extra complexity. furthermore, these methods could be applied to optimize the inception architecture as well, widening the efficiency gap again. still, the complexity of the inception architecture makes it more difficult to make changes to the network. if the architecture is scaled up naively, large parts of the computational gains can be immediately lost. also, does not provide a clear description about the contributing factors that lead to the various design decisions of the googlenet architecture. this makes it much harder to adapt it to new use-cases while maintaining its efficiency. for example, if it is deemed necessary to increase the capacity of some inception-style model, the simple transformation of just doubling the number of all filter bank sizes will lead to a 4x increase in both computational cost and number of parameters. this might prove prohibitive or unreasonable in a lot of practical scenarios, especially if the associated gains are modest. in this paper, we start with describing a few general principles and optimization ideas that that proved to be useful for scaling up convolution networks in efficient ways. although our principles are not limited to inception-type networks, they are easier to observe in that context as the generic structure of the inception style building blocks is flexible enough to incorporate those constraints naturally. this is enabled by the generous use of dimensional reduction and parallel structures of the inception modules which allows for mitigating the impact of structural changes on nearby components. still, one needs to be cautious about doing so, as some guiding principles should be observed to maintain high quality of the models. section: general design principles here we will describe a few design principles based on large-scale experimentation with various architectural choices with convolutional networks. at this point, the utility of the principles below are speculative and additional future experimental evidence will be necessary to assess their accuracy and domain of validity. still, grave deviations from these principles tended to result in deterioration in the quality of the networks and fixing situations where those deviations were detected resulted in improved architectures in general. avoid representational bottlenecks, especially early in the network. feed-forward networks can be represented by an acyclic graph from the input layer (s) to the classifier or regressor. this defines a clear direction for the information flow. for any cut separating the inputs from the outputs, one can access the amount of information passing though the cut. one should avoid bottlenecks with extreme compression. in general the representation size should gently decrease from the inputs to the outputs before reaching the final representation used for the task at hand. theoretically, information content can not be assessed merely by the dimensionality of the representation as it discards important factors like correlation structure; the dimensionality merely provides a rough estimate of information content. higher dimensional representations are easier to process locally within a network. increasing the activations per tile in a convolutional network allows for more disentangled features. the resulting networks will train faster. spatial aggregation can be done over lower dimensional embeddings without much or any loss in representational power. for example, before performing a more spread out (e.g.) convolution, one can reduce the dimension of the input representation before the spatial aggregation without expecting serious adverse effects. we hypothesize that the reason for that is the strong correlation between adjacent unit results in much less loss of information during dimension reduction, if the outputs are used in a spatial aggregation context. given that these signals should be easily compressible, the dimension reduction even promotes faster learning. balance the width and depth of the network. optimal performance of the network can be reached by balancing the number of filters per stage and the depth of the network. increasing both the width and the depth of the network can contribute to higher quality networks. however, the optimal improvement for a constant amount of computation can be reached if both are increased in parallel. the computational budget should therefore be distributed in a balanced way between the depth and width of the network. although these principles might make sense, it is not straightforward to use them to improve the quality of networks out of box. the idea is to use them judiciously in ambiguous situations only. section: factorizing convolutions with large filter size much of the original gains of the googlenet network arise from a very generous use of dimension reduction. this can be viewed as a special case of factorizing convolutions in a computationally efficient manner. consider for example the case of a convolutional layer followed by a convolutional layer. in a vision network, it is expected that the outputs of near-by activations are highly correlated. therefore, we can expect that their activations can be reduced before aggregation and that this should result in similarly expressive local representations. here we explore other ways of factorizing convolutions in various settings, especially in order to increase the computational efficiency of the solution. since inception networks are fully convolutional, each weight corresponds to one multiplication per activation. therefore, any reduction in computational cost results in reduced number of parameters. this means that with suitable factorization, we can end up with more disentangled parameters and therefore with faster training. also, we can use the computational and memory savings to increase the filter-bank sizes of our network while maintaining our ability to train each model replica on a single computer. subsection: factorization into smaller convolutions convolutions with larger spatial filters (e.g. or) tend to be disproportionally expensive in terms of computation. for example, a convolution with filters over a grid with filters is 25/ 9= 2.78 times more computationally expensive than a convolution with the same number of filters. of course, a filter can capture dependencies between signals between activations of units further away in the earlier layers, so a reduction of the geometric size of the filters comes at a large cost of expressiveness. however, we can ask whether a convolution could be replaced by a multi-layer network with less parameters with the same input size and output depth. if we zoom into the computation graph of the convolution, we see that each output looks like a small fully-connected network sliding over tiles over its input (see figure [reference]). since we are constructing a vision network, it seems natural to exploit translation invariance again and replace the fully connected component by a two layer convolutional architecture: the first layer is a convolution, the second is a fully connected layer on top of the output grid of the first layer (see figure [reference]). sliding this small network over the input activation grid boils down to replacing the convolution with two layers of convolution (compare figure [reference] with [reference]). this setup clearly reduces the parameter count by sharing the weights between adjacent tiles. to analyze the expected computational cost savings, we will make a few simplifying assumptions that apply for the typical situations: we can assume that, that is that we want to change the number of activations/ unit by a constant alpha factor. since the convolution is aggregating, is typically slightly larger than one (around 1.5 in the case of googlenet). having a two layer replacement for the layer, it seems reasonable to reach this expansion in two steps: increasing the number of filters by in both steps. in order to simplify our estimate by choosing (no expansion), if we would naivly slide a network without reusing the computation between neighboring grid tiles, we would increase the computational cost. sliding this network can be represented by two convolutional layers which reuses the activations between adjacent tiles. this way, we end up with a net reduction of computation, resulting in a relative gain of by this factorization. the exact same saving holds for the parameter count as each parameter is used exactly once in the computation of the activation of each unit. still, this setup raises two general questions: does this replacement result in any loss of expressiveness? if our main goal is to factorize the linear part of the computation, would it not suggest to keep linear activations in the first layer? we have ran several control experiments (for example see figure [reference]) and using linear activation was always inferior to using rectified linear units in all stages of the factorization. we attribute this gain to the enhanced space of variations that the network can learn especially if we batch-normalize the output activations. one can see similar effects when using linear activations for the dimension reduction components. subsection: spatial factorization into asymmetric convolutions the above results suggest that convolutions with filters larger a might not be generally useful as they can always be reduced into a sequence of convolutional layers. still we can ask the question whether one should factorize them into smaller, for example convolutions. however, it turns out that one can do even better than by using asymmetric convolutions, e.g.. for example using a convolution followed by a convolution is equivalent to sliding a two layer network with the same receptive field as in a convolution (see figure [reference]). still the two-layer solution is cheaper for the same number of output filters, if the number of input and output filters is equal. by comparison, factorizing a convolution into a two convolution represents only a saving of computation.. in theory, we could go even further and argue that one can replace any convolution by a convolution followed by a convolution and the computational cost saving increases dramatically as grows (see figure 6). in practice, we have found that employing this factorization does not work well on early layers, but it gives very good results on medium grid-sizes (on feature maps, where ranges between and). on that level, very good results can be achieved by using convolutions followed by convolutions. section: utility of auxiliary classifiers has introduced the notion of auxiliary classifiers to improve the convergence of very deep networks. the original motivation was to push useful gradients to the lower layers to make them immediately useful and improve the convergence during training by combating the vanishing gradient problem in very deep networks. also lee et al argues that auxiliary classifiers promote more stable learning and better convergence. interestingly, we found that auxiliary classifiers did not result in improved convergence early in the training: the training progression of network with and without side head looks virtually identical before both models reach high accuracy. near the end of training, the network with the auxiliary branches starts to overtake the accuracy of the network without any auxiliary branch and reaches a slightly higher plateau. also used two side-heads at different stages in the network. the removal of the lower auxiliary branch did not have any adverse effect on the final quality of the network. together with the earlier observation in the previous paragraph, this means that original the hypothesis of that these branches help evolving the low-level features is most likely misplaced. instead, we argue that the auxiliary classifiers act as regularizer. this is supported by the fact that the main classifier of the network performs better if the side branch is batch-normalized or has a dropout layer. this also gives a weak supporting evidence for the conjecture that batch normalization acts as a regularizer. section: efficient grid size reduction traditionally, convolutional networks used some pooling operation to decrease the grid size of the feature maps. in order to avoid a representational bottleneck, before applying maximum or average pooling the activation dimension of the network filters is expanded. for example, starting a grid with filters, if we would like to arrive at a grid with filters, we first need to compute a stride-1 convolution with filters and then apply an additional pooling step. this means that the overall computational cost is dominated by the expensive convolution on the larger grid using operations. one possibility would be to switch to pooling with convolution and therefore resulting in reducing the computational cost by a quarter. however, this creates a representational bottlenecks as the overall dimensionality of the representation drops to resulting in less expressive networks (see figure [reference]). instead of doing so, we suggest another variant the reduces the computational cost even further while removing the representational bottleneck. (see figure [reference]). we can use two parallel stride 2 blocks: and. is a pooling layer (either average or maximum pooling) the activation, both of them are stride the filter banks of which are concatenated as in figure [reference]. section: inception-v2 here we are connecting the dots from above and propose a new architecture with improved performance on the ilsvrc 2012 classification benchmark. the layout of our network is given in table [reference]. note that we have factorized the traditional convolution into three convolutions based on the same ideas as described in section [reference]. for the inception part of the network, we have traditional inception modules at the with filters each. this is reduced to a grid with filters using the grid reduction technique described in section [reference]. this is is followed by instances of the factorized inception modules as depicted in figure [reference]. this is reduced to a grid with the grid reduction technique depicted in figure [reference]. at the coarsest level, we have two inception modules as depicted in figure [reference], with a concatenated output filter bank size of 2048 for each tile. the detailed structure of the network, including the sizes of filter banks inside the inception modules, is given in the supplementary material, given in the model.txt that is in the tar-file of this submission. however, we have observed that the quality of the network is relatively stable to variations as long as the principles from section [reference] are observed. although our network is layers deep, our computation cost is only about higher than that of googlenet and it is still much more efficient than vggnet. section: model regularization via label smoothing here we propose a mechanism to regularize the classifier layer by estimating the marginalized effect of label-dropout during training. for each training example, our model computes the probability of each label:. here, are the logits or unnormalized log-probabilities. consider the ground-truth distribution over labels for this training example, normalized so that. for brevity, let us omit the dependence of and on example. we define the loss for the example as the cross entropy:. minimizing this is equivalent to maximizing the expected log-likelihood of a label, where the label is selected according to its ground-truth distribution. cross-entropy loss is differentiable with respect to the logits and thus can be used for gradient training of deep models. the gradient has a rather simple form:, which is bounded between and. consider the case of a single ground-truth label, so that and for all. in this case, minimizing the cross entropy is equivalent to maximizing the log-likelihood of the correct label. for a particular example with label, the log-likelihood is maximized for, where is dirac delta, which equals for and otherwise. this maximum is not achievable for finite but is approached if for all- that is, if the logit corresponding to the ground-truth label is much great than all other logits. this, however, can cause two problems. first, it may result in over-fitting: if the model learns to assign full probability to the ground-truth label for each training example, it is not guaranteed to generalize. second, it encourages the differences between the largest logit and all others to become large, and this, combined with the bounded gradient, reduces the ability of the model to adapt. intuitively, this happens because the model becomes too confident about its predictions. we propose a mechanism for encouraging the model to be less confident. while this may not be desired if the goal is to maximize the log-likelihood of training labels, it does regularize the model and makes it more adaptable. the method is very simple. consider a distribution over labels, independent of the training example x, and a smoothing parameter. for a training example with ground-truth label, we replace the label distribution with which is a mixture of the original ground-truth distribution and the fixed distribution, with weights and, respectively. this can be seen as the distribution of the label obtained as follows: first, set it to the ground-truth label; then, with probability, replace with a sample drawn from the distribution. we propose to use the prior distribution over labels as. in our experiments, we used the uniform distribution, so that we refer to this change in ground-truth label distribution as label-smoothing regularization, or lsr. note that lsr achieves the desired goal of preventing the largest logit from becoming much larger than all others. indeed, if this were to happen, then a single would approach while all others would approach. this would result in a large cross-entropy with because, unlike, all have a positive lower bound. another interpretation of lsr can be obtained by considering the cross entropy: thus, lsr is equivalent to replacing a single cross-entropy loss with a pair of such losses and. the second loss penalizes the deviation of predicted label distribution from the prior, with the relative weight. note that this deviation could be equivalently captured by the kl divergence, since and is fixed. when is the uniform distribution, is a measure of how dissimilar the predicted distribution is to uniform, which could also be measured (but not equivalently) by negative entropy; we have not experimented with this approach. in our imagenet experiments with classes, we used and. for ilsvrc 2012, we have found a consistent improvement of about absolute both for top-error and the top-error (cf. table [reference]). section: training methodology we have trained our networks with stochastic gradient utilizing the tensorflow distributed machine learning system using replicas running each on a nvidia kepler gpu with batch size for epochs. our earlier experiments used momentum with a decay of, while our best models were achieved using rmsprop with decay of and. we used a learning rate of, decayed every two epoch using an exponential rate of. in addition, gradient clipping with threshold was found to be useful to stabilize the training. model evaluations are performed using a running average of the parameters computed over time. section: performance on lower resolution input a typical use-case of vision networks is for the the post-classification of detection, for example in the multibox context. this includes the analysis of a relative small patch of the image containing a single object with some context. the tasks is to decide whether the center part of the patch corresponds to some object and determine the class of the object if it does. the challenge is that objects tend to be relatively small and low-resolution. this raises the question of how to properly deal with lower resolution input. the common wisdom is that models employing higher resolution receptive fields tend to result in significantly improved recognition performance. however it is important to distinguish between the effect of the increased resolution of the first layer receptive field and the effects of larger model capacitance and computation. if we just change the resolution of the input without further adjustment to the model, then we end up using computationally much cheaper models to solve more difficult tasks. of course, it is natural, that these solutions loose out already because of the reduced computational effort. in order to make an accurate assessment, the model needs to analyze vague hints in order to be able to\" hallucinate\" the fine details. this is computationally costly. the question remains therefore: how much does higher input resolution helps if the computational effort is kept constant. one simple way to ensure constant effort is to reduce the strides of the first two layer in the case of lower resolution input, or by simply removing the first pooling layer of the network. for this purpose we have performed the following three experiments: receptive field with stride and maximum pooling after the first layer. receptive field with stride and maximum pooling after the first layer. receptive field with stride and without pooling after the first layer. all three networks have almost identical computational cost. although the third network is slightly cheaper, the cost of the pooling layer is marginal and (within of the total cost of the) network. in each case, the networks were trained until convergence and their quality was measured on the validation set of the imagenet ilsvrc 2012 classification benchmark. the results can be seen in table [reference]. although the lower-resolution networks take longer to train, the quality of the final result is quite close to that of their higher resolution counterparts. however, if one would just naively reduce the network size according to the input resolution, then network would perform much more poorly. however this would an unfair comparison as we would are comparing a 16 times cheaper model on a more difficult task. also these results of table [reference] suggest, one might consider using dedicated high-cost low resolution networks for smaller objects in the r-cnn context. section: experimental results and comparisons inception-v2 rmsprop inception-v2 label smoothing inception-v2 factorized table [reference] shows the experimental results about the recognition performance of our proposed architecture (inception-v2) as described in section [reference]. each inception-v2 line shows the result of the cumulative changes including the highlighted new modification plus all the earlier ones. label smoothing refers to method described in section [reference]. factorized includes a change that factorizes the first convolutional layer into a sequence of convolutional layers. bn-auxiliary refers to the version in which the fully connected layer of the auxiliary classifier is also batch-normalized, not just the convolutions. we are referring to the model in last row of table [reference] as inception-v3 and evaluate its performance in the multi-crop and ensemble settings. all our evaluations are done on the 48238 non-blacklisted examples on the ilsvrc-2012 validation set, as suggested by. we have evaluated all the 50000 examples as well and the results were roughly 0.1% worse in top-5 error and around 0.2% in top-1 error. in the upcoming version of this paper, we will verify our ensemble result on the test set, but at the time of our last evaluation of bn-inception in spring indicates that the test and validation set error tends to correlate very well. section: conclusions we have provided several design principles to scale up convolutional networks and studied them in the context of the inception architecture. this guidance can lead to high performance vision networks that have a relatively modest computation cost compared to simpler, more monolithic architectures. our highest quality version of inception-v3 reaches, top-and top-5 error for single crop evaluation on the ilsvr 2012 classification, setting a new state of the art. this is achieved with relatively modest () increase in computational cost compared to the network described in ioffe et al. still our solution uses much less computation than the best published results based on denser networks: our model outperforms the results of he et al- cutting the top-(top -) error by () relative, respectively- while being six times cheaper computationally and using at least five times less parameters (estimated). our ensemble of four inception-v3 models reaches with multi-crop evaluation reaches top-error which represents an over reduction to the best published results and is almost half of the error of ilsvrc 2014 winining googlenet ensemble. we have also demonstrated that high quality results can be reached with receptive field resolution as low as. this might prove to be helpful in systems for detecting relatively small objects. we have studied how factorizing convolutions and aggressive dimension reductions inside neural network can result in networks with relatively low computational cost while maintaining high quality. the combination of lower parameter count and additional regularization with batch-normalized auxiliary classifiers and label-smoothing allows for training high quality networks on relatively modest sized training sets. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "validation set"
                    ],
                    [
                        "ilsvrc-2012 validation set"
                    ]
                ],
                "Method": [
                    [
                        "alexnet"
                    ]
                ],
                "Metric": [
                    [
                        "error"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "ilsvrc 2012 classification challenge validation set",
                        "2012 imagenet",
                        "imagenet",
                        "ilsvrc 2012",
                        "imagenet ilsvrc 2012 classification benchmark",
                        "ilsvrc-2012 validation set",
                        "ilsvr 2012 classification"
                    ]
                ],
                "Method": [
                    [
                        "inception architecture",
                        "inception",
                        "inception networks",
                        "inception-style model",
                        "inception-type networks",
                        "inception style building blocks",
                        "inception modules",
                        "factorized inception modules",
                        "rmsprop inception",
                        "smoothing inception",
                        "inception-v3",
                        "ensemble of four inception-v3 models"
                    ]
                ],
                "Metric": [
                    [
                        "top",
                        "top-error",
                        "accuracy",
                        "top-1 error"
                    ]
                ],
                "Task": [
                    [
                        "ilsvrc classification challenge",
                        "post-classification of detection"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "ilsvrc 2012 classification challenge validation set",
                        "2012 imagenet",
                        "imagenet",
                        "ilsvrc 2012",
                        "imagenet ilsvrc 2012 classification benchmark",
                        "ilsvrc-2012 validation set",
                        "ilsvr 2012 classification"
                    ]
                ],
                "Method": [
                    [
                        "inception architecture",
                        "inception",
                        "inception networks",
                        "inception-style model",
                        "inception-type networks",
                        "inception style building blocks",
                        "inception modules",
                        "factorized inception modules",
                        "rmsprop inception",
                        "smoothing inception",
                        "inception-v3",
                        "ensemble of four inception-v3 models"
                    ]
                ],
                "Metric": [
                    [
                        "top",
                        "top-error",
                        "accuracy",
                        "top-5 error"
                    ]
                ],
                "Task": [
                    [
                        "ilsvrc classification challenge",
                        "post-classification of detection"
                    ]
                ]
            }
        ]
    },
    "0678a8abea82793993cd89383319da75f6dc4be3-5": {
        "doctext": "document: pronet: learning to propose object-specific boxes for cascaded neural networks this paper aims to classify and locate objects accurately and efficiently, without using bounding box annotations. it is challenging as objects in the wild could appear at arbitrary locations and in different scales. in this paper, we propose a novel classification architecture pronet based on convolutional neural networks. it uses computationally efficient neural networks to propose image regions that are likely to contain objects, and applies more powerful but slower networks on the proposed regions. the basic building block is a multi-scale fully-convolutional network which assigns object confidence scores to boxes at different locations and scales. we show that such networks can be trained effectively using image-level annotations, and can be connected into cascades or trees for efficient object classification. pronet outperforms previous state-of-the-art significantly on pascal voc 2012 and ms coco datasets for object classification and point-based localization. section: introduction we address the problem of object classification and localization in natural images. as objects could be small and appear at arbitrary locations, several frameworks rely on bounding boxes to train object-centric classifiers, and apply the classifiers by searching over different locations of the images. however, the annotation process for object bounding boxes is usually resource intensive and difficult to scale up. in light of this, we aim to simultaneously classify and locate objects given only image-level annotations for training. to cope with the lack of object-level annotations, several methods extract feature activations from convolutional neural networks (cnn) by scanning over different image regions. they then aggregate the extracted features into image-level representations for classification purpose. under this scheme, regions that belong to the background are considered as important as regions that contain objects. such global approaches tend to be sensitive to background, and can not be used directly for localization. we choose to use the fully-convolutional network (fcn) architecture for simultaneous object classification and localization. it replaces the fully-connected layers of a standard cnn (e.g. alexnet) with convolutional layers. this enables an fcn to take images of arbitrary sizes, and generate classification score maps efficiently. each element in a score map corresponds to a rectangular box (receptive field) in the original image. the score maps can then be used for classification and localization. the sampling strides and box sizes are determined by the fcn's network architecture. as box sizes are fixed, fcn might face difficulty dealing with objects of different scales. we address this problem by using a multi-stream multi-scale architecture. all streams share the same parameters, but take input images of different scales. to train the multi-scale fcn without object-level annotations, we generate image-level scores by pooling the score maps over multiple-scales, and compute the losses with image-level labels for back-propagation. once a multi-scale fcn is trained, it can be used for classification and localization directly. from another perspective, it also proposes a set of promising boxes that are likely to contain objects. we can then build a cascade architecture by zooming onto those promising boxes, and train new classifiers to verify them. the cascade allows the system to balance accuracy and speed: each stage filters out parts of image regions that are unlikely to contain objects. we name this propose and zoom pipeline as pronet. figure [reference] provides the high-level intuition behind pronet: three boxes are proposed for bird, potted plant and cat categories. the boxes are cropped out and verified further, until a certain decision is made. to train the later classifiers in pronet, we sample hard negatives based on image-level labels. for positives, as no object-level annotations are available, it is impossible to tell objects from background. to avoid over-fitting, we randomly sample positive boxes above a relative low threshold. different positive boxes from the same image can be sampled at different iterations of the stochastic gradient descent training process. at test time, only a small subset of boxes (10 to 20 per image) with highest object confidence scores are fed to the later classifiers. this allows us to utilize cnns that have stronger representation power with little computational overhead. pronet is highly configurable: for example, one could set a list of important object categories, and only verify the proposed boxes for those categories. moreover, apart from a traditional chain-structured cascade, we show that it is also possible to build tree-structured cascades, where each branch handles categories from a particular domain (set of vehicles or animals). in summary, our paper makes the following contributions: we propose pronet, a cascaded neural network framework that zooms onto promising object-specific boxes for efficient object classification and localization. we introduce strategies to train pronet with image-level annotations effectively; and demonstrate the implementations of chain-and tree-structured cascades. we show that pronet outperforms previous state-of-the-art significantly on the object classification and point-based localization tasks of the pascal voc 2012 dataset and the recently released ms coco dataset. section: related work object classification is a fundamental problem in computer vision. earlier work focused on classification from object-centric images. they usually extract hand-crafted low-level features and aggregate the features into image-level feature vectors. more challenging datasets have since been collected. they are of larger scale, and contain smaller objects which could be partially occluded. recently, deep convolutional neural networks (cnn) have achieved state-of-the-art performance on a wide range of visual recognition tasks, including object classification and detection. although cnns require large amount of data for training, it has been shown that they are able to learn representations that generalize to other tasks. such representations can be adapted to image classification by fine-tuning, or extracted as holistic features for classification with linear svms. when used as generic feature extractors, feature aggregation techniques designed for hand-crafted features can also work with cnn embeddings and achieve competitive performance. an alternative approach for object classification is via detection. among those utilizing bounding box annotations, rcnn achieves competitive performance by directly representing image boxes with cnn features and learning classifiers on top of the features. object proposal techniques are used to sample the image patches for classification. a recent framework, fast rcnn, uses fully-convolutional networks (fcn) to generate box-level features in batch, and is thus more computational efficient. object localization with image-level annotations is a weakly-supervised problem. it can be formulated as a multiple instance learning problem, and has been addressed to learn concept detectors from internet data. it has also been studied for object detection and segmentation. for object classification, wei et al. treat images as bags of patches, where the patches are selected using objectness criteria. they then use max pooling to fine-tune cnns based on image-level annotations. oquab et al. follow a similar approach, but make the training process end-to-end by converting cnns into fcns. the proposal generation network in pronet is also based on fcn, but uses a multi-stream architecture and cross-scale lse pooling to achieve scale-awareness. cascaded classifiers are a well-studied technique in computer vision. cascades with cnns have been explored for facial point detection, face detection and pose estimation. however, such methods require fully annotated training examples. pronet adopts the cascade philosophy to balance speed and accuracy, but does not require object bounding boxes for training. since pronet is a general object classifier, it can also be extended to have tree structure, where each leaf is a domain expert. section: pronet framework pronet has two basic components: an object-specific box proposal unit, and a verification unit. for each image, for each object category, the box proposal unit generates a list of confidence scores of the presence of the object instances, and the coordinates indicating the locations of the objects. pronet then zooms onto image boxes with higher scores to further verify if they are positive or hard negatives. the verification units can either take all boxes, which forms a chain structure; or a subset of boxes corresponding to certain domains (animal), which forms a tree structure. we implement these two units with convolutional neural networks. figure [reference] illustrates the overall pronet framework. subsection: proposal generation the first stage in our framework is to generate object-specific box proposals with cnns. for an input image and object category, we want to learn a proposal scoring function where corresponds to the location of a rectangular image region denoted by its top left and bottom right corners. a typical cnn architecture for image classification task (e.g. alexnet) involves a hierarchy of convolutional layers and fully connected layers. the convolutional layers operate on local image patches to extract feature representations. for a color image with 3 channels, the convolutional layers generate a feature map of elements, where is the output feature dimension. and correspond to the width and height of the feature map, they are controlled by input image size, as well as the kernel size, sampling step and padding size of the convolutional layers. the fully connected layers serve as classifiers which take fixed-size inputs, thus require the width and height of input images to be fixed. therefore, one possible way to compute is to enumerate locations and scales in a sliding window fashion or with bounding box proposals, and feed such image regions to cnns. we take an alternative approach based on fully convolutional networks (e.g. overfeat). fully convolutional networks (fcn) do not contain fully-connected layers. rather, they use only the convolutional layers, which allows them to process images of arbitrary sizes. the outputs of fcns are in the form of feature maps, where is the number of categories. each element in a feature map corresponds to the activation response for a particular category over a certain region. such regions are called receptive fields for the activations. compared with region sampling with sliding windows or bounding box proposals, fcns offer a seamless solution for end-to-end training under the cnn framework, and also naturally allow the sharing of intermediate features over overlapping image regions. scale adaptation with multi-stream fcns. one issue in use of fcns is that the sizes of receptive fields are typically fixed, while the object scales may vary a lot. we address this problem by using a multi-stream architecture. assume an fcn has been trained with inputs where objects have been resized to the same scale. we expand the network into streams, where every stream shares the same parameters as the pre-trained one. given an image, we scale it to different sizes and feed to the-stream fcn. the output feature map of each stream corresponds to a different scale in the original image. training with image-level annotations. when object bounding boxes are available, training fcns is straight-forward: one could either crop images with the bounding boxes, or use a loss function which operates directly on feature maps and takes the object locations into account. as such supervision is absent, we need to aggregate local responses into global ones so that image-level labels can be used for training. we use the log-sum-exp (lse) pooling function applied by for semantic segmentation: where is the category, corresponds to the-th stream of fcn, correspond to location in the feature map, is the total number of such elements and is a hyper parameter. the function's output is close to average when is small and maximum when is large. setting larger makes the aggregation focus on a smaller subset of image boxes, and has the potential to handle smaller objects better. lse pooling function can be implemented as a layer in a neural network. as illustrated in figure [reference], it is connected to the final layers of all-stream fcns and produces a dimensional vector for each image. we then compute the loss for each category and back-propagate the error gradients to the earlier layers. computing proposal scores. once the fcns have been trained, we compute proposal scores from the feature maps. specifically, for every neuron in the final layer of single-stream fcn, we compute its receptive field and use it as the location; the corresponding activation of the neuron is used as proposal score. although the exact receptive field may vary due to different padding strategies, we use a simple estimation which has been reported to work well in practice. denote the sampling stride of a spatial convolutional layer as and the kernel size of a max pooling layer as, the overall sampling stride is given by where is the collection of all convolutional layers and is the collection of all max pooling layers. implementation. our-stream fcns are implemented with torch. for each stream, we use the cnn-m 2048 architecture proposed in. it has 5 convolutional layers and 3 fully-connected layers. it achieves higher accuracy on imagenet than alexnet, while being faster and less memory consuming than very deep cnns. we use the model parameters released by the authors, which were pre-trained from imagenet dataset with 1, 000 categories. we convert the model into an fcn by replacing the three fully-connected layers with convolutional layers. the first convolutional layer has 512 input planes, 4096 output planes and kernel size of 6. the second has 4096 input planes, 2048 output planes and kernel size of 1. since the final layer is task-specific, it is initialized from scratch with 2048 input planes, output planes and kernel size of 1. to adapt the model parameters for object classification on different datasets, we only fine-tune the final two layers and freeze the model parameters from previous layers. the sampling stride of feature maps is 32 pixels, and the window size is 223 pixels. we set the number of streams to be 3. during training, all three streams share the same set of parameters. to facilitate training with mini-batches, every image is rescaled to, and pixels. as the aspect ratios of images could be different, we rescale the longer edge to 300, 500 and 700 respectively, and fill the empty pixels by mirroring the images. traditional cross entropy loss for multi-class classification introduces competition between different classes, thus it is not suitable for images with multiple labels. we compute the loss with binary cross entropy criteria for each class separately, and sum up the error gradients from losses of all classes for back-propagation. subsection: cascade-style proposal verification by setting thresholds on proposal scores, a small subset of image boxes which might contain objects are selected. similar to object detection frameworks, we run cnn classifiers on the selected boxes. the proposal step also serves as a filter whose goal is to preserve the object boxes with high recall rate, while removing the easy negatives. the verification classifiers then address a more focused problem on a smaller set of instances. connecting the two steps is essentially the same as training a cascade of classifiers. verification network architecture. as a later classifier in the cascade, accuracy is more important than speed. we choose the vgg-16 network architecture. compared with alexnet variants, it offers better accuracy for most visual recognition tasks, but is also slower and more memory demanding. we use the vgg-16 model parameters released by the authors, which was trained on 1, 000 imagenet categories. we use the same binary cross entropy criterion to compute losses. to make the training process faster, we only fine-tune the final two fully-connected layers and freeze all previous layers. inputinput outputoutput training images with proposal scores, batch size, threshold stopping criteria not met randomly select images from; initialize mini-batch; has proposal with score randomly sample a proposal where; set the sample's active class to; add proposed region to; resize and add full image to; set all classes as active; forward pass with; compute loss for the active class of each sample; update model parameters. mini-batch sampling algorithm for training cascade classifier with stochastic gradient descent. training strategy for the cascade. ideally, we want the verification network to handle hard examples from both positive and negative data. when a proposed region from an image not containing a given label has a high score of that class, we know it is a hard negative. however, it is impossible to tell a hard positive from background without using bounding box annotations. we attempt to avoid using background by selecting only the top scoring image region for each positive class. this results in significant over-fitting and poor generalizability for the trained verification net. the main problem with the above sampling strategy is that for positive instances, only easy examples which have been learned well are preserved. to fix this, we use a random sampling strategy as described in algorithm [reference]. for each image, we randomly select an image box whose proposal score is higher than threshold for class. in practice, the threshold is set to a relative low value (). if is labeled as positive for the image, we treat the box as a positive instance (though it might belong to background), and otherwise negative. note that the sampled box could be easy negatives for classes beyond. to avoid oversampling the easy negatives, we set as the active class during back-propagation and only compute the loss for the active class. inference with cascade. during inference, an image is passed to the proposal generation fcn to compute proposal scores. a small subset of proposed boxes with high scores are then passed to the verification network. for each class, we select the top scoring proposals if the scores are higher than threshold. we then use the following equation to combine the outputs from both networks: where is the set of selected proposals for class, is the score of class from the proposal network after lse pooling, and is the verification network's output for class on region. when no proposal is selected, we preserve scores from the proposal network without calibration as they are typically low. discussion. decomposing classification into cascade of proposal and verification networks allows the system to achieve high accuracy while maintaining a reasonable computational cost. it is also a flexible framework for different design choices. for example, one could decide to verify a subset of object classes which require higher accuracy. with the cascade training algorithm, we can build tree-structured cascaded neural networks, where each branch focuses on a subset of categories. we can also extend the cascade to have more stages, and train the new stages with newly annotated training data. figure [reference] illustrates these structures. section: experiments experimental setup. we work with the pascal voc 2012 dataset and the ms coco dataset. voc 2012 has 5, 000 images for training, 5, 000 for validation and 10, 000 for testing. there are 20 object classes in total. coco has 80, 000 images for training and 40, 000 images for validation. it has 80 object classes in 12 super-categories. we evaluated pronet on object classification and point-based object localization tasks. for object classification, we use the average precision metric. we used voc's result server to compute average precisions on the voc 2012 dataset. for point-based object localization, we use the criteria introduced in. for every image and every class, we output a location with maximum response for that class. the location is deemed correct if it falls into any bounding box associated with that class, with a tolerance of 18 pixels as used in. this information is then used to compute average precision. although object extent is not evaluated, the metric remains challenging as shown by. to generate localization coordinates for evaluation, we kept track of the image boxes which give highest responses at each stage, and used the center point of the selected boxes. we tried different values of hyper-parameter for lse pooling, and found that generally gave good performance. we fixed in all the following experiments. we used the stochastic gradient descent algorithm for training. to train proposal network, the learning rate was set to 0.01; to train verification network, the learning rate was set to 0.001. we set the filtering threshold for cascade to 0.1. which pooling method is better? we compare maximum pooling, average pooling and lse pooling methods to train proposal network with image-level supervision. table [reference] lists the classification and localization performance of the three different pooling methods. we can see that lse achieves the best classification map. average pooling is 3.7% worse than lse, which we believe is because it assigns equal importance to foreground and background. max pooling is 1.4% worse; compared with lse pooling, it only uses a single patch to generate image-level score, thus is more sensitive to noise and model initialization during training. we also generated visualizations to study the impact of pooling method on trained models. figure [reference] shows heat maps of the class train when different models are applied to the same image. we can see that the model trained by average pooling has high activations not only on the train but also on part of the background. for max pooling, only the wheel of the train has high response, presumably because it is the most discriminative for the train. model trained by lse pooling has high response on the train, but not on the background. does cascade help? we study the impact of adding cascaded classifiers on classification and localization performance. we first use a single level of cascade with one multi-scale fcn and one verification network. for each image and each class, we selected the top 3 regions per scale if their scores are higher than 0.1. the average number of regions to be verified is 24 per image. in table [reference], we can see that on pascal voc 2012, using a cascade helps improve classification map by 3.3% and localization map by 2.9%. is a longer cascade better? we are interested in observing how the performance changes with more levels of cascade. for this purpose, we first trained another set of proposal and verification networks using pascal voc data alone, but found that the network overfitted easily. since the training set of voc 2012 has only 5, 000 images, we found that the first set of proposal and verification networks\" perfectly solved\" this training set, leaving little room to improve its generalizability. in light of this, we used the 80, 000 images from coco training set as complementary data source. it covers the 20 categories used in voc but also has 60 other categories. rather than re-training all the networks by combining voc and coco data, we take that the previous cnns in the cascade have already been trained and fixed, and only train new cnns with the extra data. note that our cascade architecture offers a natural way to select the challenging instances from such incoming images. the final row in table [reference] shows the maps after adding a new set of cascades trained from coco images. we can see that it offers another 1% improvement over the previous cascade, which indicates that it is desirable to train a longer cascade when more training data becomes available. expanding cascades into trees. we also investigated the effect of building tree-structured cascades. coco dataset is used for evaluation as it has 3 times more categories than voc. we trained 12 verification networks corresponding to the 12 super-categories of coco. each network focuses on a single super-category, and processes the sampled boxes whose active classes belong to that super-category. at test time, each proposed box only goes through a single root to leaf path in the tree. the final row of table [reference] shows its classification and localization performance. we can see that compared with the chain structured cascade, tree-structured cascade achieves better performance, probably because it trains the neural networks to be focused on a small subset of similar categories. comparison with detection based approaches. we compare our proposed framework with two recent state-of-the-art object detection methods: rcnn and fast rcnn. unlike our framework, they require bounding box annotations for training. both methods use selective search to generate object proposals and cnns for classification. rcnn uses alexnet pre-trained from imagenet, while fast rcnn uses vgg-16 pre-trained from imagenet. to generate classification and localization results, for each class we select the detection output with maximum confidence score, and use the center of the detected bounding box for localization evaluation. we first fix the number of window proposals to 1000 for rcnn and fast rcnn. table [reference] shows the performance comparison. we can see that for classification, our proposed framework outperforms both rcnn and fast rcnn. for localization, our proposed framework outperforms rcnn, but is 4% worse than fast rcnn. we also study the impact of number of proposed boxes on our system's performance. for this purpose, we let the proposal network select top regions per scale for each class, and compute the average number of proposed boxes per image. for comparison, we ask fast rcnn to use up to 10, 50, 500 and 1000 selective search proposals per image. table [reference] shows the classification and localization performances respectively. we can see that pronet is quite robust to the number of proposed boxes, and achieves reasonably good performance with only 9 boxes on average. this confirms that pronet offers better accuracy with relatively small computational overhead. meanwhile, fast rcnn requires many more proposals to reach peak performance, presumably because the selective search proposals are for general objectness and not optimized for object classification in cascade fashion. comparison with other weakly-supervised methods. we compare pronet with several state-of-the-art object classification frameworks. classification and localization performance on pascal voc 2012 are shown in table [reference] and table [reference] respectively. table [reference] and figure [reference] show results and localization examples on coco dataset. among the compared systems, oquab et al. and nus-hcp use cnns pre-trained on the expanded imagenet data with more than 1500 categories, which has been shown to be useful for classification. since pronet uses cascades or trees of cnns, it can apply a more powerful cnn model vgg-16 with small computational overhead. this helps our system outperform most of the previous state-of-the-art systems significantly on both datasets. pronet is also slightly better than simonyan et al. which extracts vgg-16 features at three different scales over full images. their system is 3x to 6x slower than our cascade at test time. limitation. we evaluate pronet using the standard iou metric, which considers object extent as well as location. since the boxes generated by our proposal cnn have fixed aspect ratios, we follow to aggregate the heat maps over 1000 bounding box proposals generated by selective search per image. no bounding box regression is conducted. cascade cnn is then used to verify the high-scoring proposals. on pascal voc 2012 validation set, our proposal cnn has an map of 13.0% when overlap threshold is 0.5. the cascade cnn improves the map to 15.5%. although both results are higher than 11.7% as reported by, there is still a huge gap between the state-of-the-art object detection pipelines. our proposal network tends to select the most discriminative/ confusing parts of objects, which is good for cascade classification but bad for getting full object extents. separating and counting multiple objects are also challenging issues. section: conclusion we proposed pronet, a cascaded neural network for object classification and localization. pronet learns to propose object-specific boxes by multi-scale fcns trained from image-level annotations. it then sends a small subset of promising boxes to latter cnns for verification. detailed experimental evaluations have shown the effectiveness of pronet on the challenging pascal voc 2012 dataset and ms coco dataset. acknowledgement: we would like to thank sergey zagoruyko for help with fast rcnn experiments; pedro o. pinheiro, bolei zhou, maxime oquab, jo\u00ebl legrand, yuandong tian, l\u00e9on bottou and florent perronnin for valuable discussions. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "ms coco datasets"
                    ],
                    [
                        "pascal voc 2012 dataset"
                    ],
                    [
                        "voc 2012 dataset"
                    ],
                    [
                        "pascal voc 2012 validation set"
                    ]
                ],
                "Method": [
                    [
                        "pronet"
                    ]
                ],
                "Metric": [
                    [
                        "average precision"
                    ]
                ],
                "Task": [
                    [
                        "classify and locate objects"
                    ],
                    [
                        "object classification"
                    ],
                    [
                        "multi class classification"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "ms coco datasets",
                        "ms coco dataset",
                        "coco",
                        "coco training set",
                        "coco data",
                        "coco images",
                        "coco dataset"
                    ]
                ],
                "Method": [
                    [
                        "pronet",
                        "learning to propose object-specific boxes for cascaded neural networks",
                        "classification architecture pronet",
                        "pronet framework"
                    ]
                ],
                "Metric": [
                    [
                        "map"
                    ]
                ],
                "Task": [
                    [
                        "detection",
                        "weakly-supervised problem",
                        "object detection",
                        "supervision"
                    ]
                ]
            }
        ]
    },
    "081531984770a74e87dbd68907061b4b0f3631bf-6": {
        "doctext": "document: real-time video super-resolution with spatio-temporal networks and motion compensation convolutional neural networks have enabled accurate image super-resolution in real-time. however, recent attempts to benefit from temporal correlations in video super-resolution have been limited to naive or inefficient architectures. in this paper, we introduce spatio-temporal sub-pixel convolution networks that effectively exploit temporal redundancies and improve reconstruction accuracy while maintaining real-time speed. specifically, we discuss the use of early fusion, slow fusion and 3d convolutions for the joint processing of multiple consecutive video frames. we also propose a novel joint motion compensation and video super-resolution algorithm that is orders of magnitude more efficient than competing methods, relying on a fast multi-resolution spatial transformer module that is end-to-end trainable. these contributions provide both higher accuracy and temporally more consistent videos, which we confirm qualitatively and quantitatively. relative to single-frame models, spatio-temporal networks can either reduce the computational cost by 30% whilst maintaining the same quality or provide a 0.2db gain for a similar computational cost. results on publicly available datasets demonstrate that the proposed algorithms surpass current state-of-the-art performance in both accuracy and efficiency. srsrsuper-resolution lrlrlow-resolution hrhrhigh-resolution tvtvtotalvariation hdhdhighdefinition msemsemeansquarederror psnrpsnrpeaksignal-to-noiseratio section: introduction image and video sr are long-standing challenges of signal processing. sr aims at recovering a hr image or video from its lr version, and finds direct applications ranging from medical imaging to satellite imaging, as well as facilitating tasks such as face recognition. the reconstruction of hr data from a lr input is however a highly ill-posed problem that requires additional constraints to be solved. while those constraints are often application-dependent, they usually rely on data redundancy. in single image sr, where only one lr image is provided, methods exploit inherent image redundancy in the form of local correlations to recover lost high-frequency details by imposing sparsity constraints or assuming other types of image statistics such as multi-scale patch recurrence. in multi-image sr it is assumed that different observations of the same scene are available, hence the shared explicit redundancy can be used to constrain the problem and attempt to invert the downscaling process directly. transitioning from images to videos implies an additional data dimension (time) with a high degree of correlation that can also be exploited to improve performance in terms of accuracy as well as efficiency. subsection: related work video sr methods have mainly emerged as adaptations of image sr techniques. kernel regression methods have been shown to be applicable to videos using 3d kernels instead of 2d ones. dictionary learning approaches, which define lr images as a sparse linear combination of dictionary atoms coupled to a hr dictionary, have also been adapted from images to videos. another approach is example-based patch recurrence, which assumes patches in a single image or video obey multi-scale relationships, and therefore missing high-frequency content at a given scale can be inferred from coarser scale patches. this was successfully presented by glasner et al. for image sr and has later been extended to videos. when adapting a method from images to videos it is usually beneficial to incorporate the prior knowledge that frames of the same scene of a video can be approximated by a single image and a motion pattern. estimating and compensating motion is a powerful mechanism to further constrain the problem and expose temporal correlations. it is therefore very common to find video sr methods that explicitly model motion through frames. a natural choice has been to preprocess input frames by compensating inter-frame motion using displacement fields obtained from off-the-shelf optical flow algorithms. this nevertheless requires frame preprocessing and is usually expensive. alternatively, motion compensation can also be performed jointly with the sr task, as done in the bayesian approach of liu et al. by iteratively estimating motion as part of its wider modeling of the downscaling process. the advent of neural network techniques that can be trained from data to approximate complex nonlinear functions has set new performance standards in many applications including sr. dong et al. proposed to use a cnn architecture for single image sr that was later extended by kappeler et al. in a video sr network (vsrnet) which jointly processes multiple input frames. additionally, compensating the motion of input images with a tv-based optical flow algorithm showed an improved accuracy. joint motion compensation for sr with neural networks has also been studied through recurrent bidirectional networks. the common paradigm for cnn based approaches has been to upscale the lr image with bicubic interpolation before attempting to solve the sr problem. however, increasing input image size through interpolation considerably impacts the computational burden for cnn processing. a solution was proposed by shi et al. with an efficient sub-pixel convolution network (espcn), where an upscaling operation directly mapping from lr to hr space is learnt by the network. this technique reduces runtime by an order of magnitude and enables real-time video sr by independently processing frames with a single frame model. similar solutions to improve efficiency have also been proposed based on transposed convolutions. subsection: motivation and contributions [b] 0.32 [b] 0.32 [b] 0.32 existing solutions for hd video sr have not been able to effectively exploit temporal correlations while performing in real-time. on the one hand, espcn leverages sub-pixel convolution for a very efficient operation, but its naive extension to videos treating frames independently fails to exploit inter-frame redundancies and does not enforce a temporally consistent result. vsrnet, on the other hand, can improve reconstruction quality by jointly processing multiple input frames. however, the preprocessing of lr images with bicubic upscaling and the use of an inefficient motion compensation mechanism slows runtime to about frames per second even on videos smaller than standard definition resolution. spatial transformer networks provide a means to infer parameters for a spatial mapping between two images. these are differentiable networks that can be seamlessly combined and jointly trained with networks targeting other objectives to enhance their performance. for instance, spatial transformer networks were initially shown to facilitate image classification by transforming images onto the same frame of reference. recently, it has been shown how spatial transformers can encode optical flow features with unsupervised training, but they have nevertheless not yet been investigated for video motion compensation. related approaches have emerged for view synthesis assuming rigid transformations. in this paper, we combine the efficiency of sub-pixel convolution with the performance of spatio-temporal networks and motion compensation to obtain a fast and accurate video sr algorithm. we study different treatments of the temporal dimension with early fusion, slow fusion and 3d convolutions, which have been previously suggested to extend classification from images to videos. additionally, we build a motion compensation scheme based on spatial transformers, which is combined with spatio-temporal models to lead to a very efficient solution for video sr with motion compensation that is end-to-end trainable. a high-level diagram of the proposed approach is show in fig: network. the main contributions of this paper are: presenting a real-time approach for video sr based on sub-pixel convolution and spatio-temporal networks that improves accuracy and temporal consistency. comparing early fusion, slow fusion and 3d convolutions as alternative architectures for discovering spatio-temporal correlations. proposing an efficient method for dense inter-frame motion compensation based on a multi-scale spatial transformer network. combining the proposed motion compensation technique with spatio-temporal models to provide an efficient, end-to-end trainable motion compensated video sr algorithm. section: methods our starting point is the real-time image sr method espcn. we restrict our analysis to standard architectural choices and do not further investigate potentially beneficial extensions such as recurrence, residual connections or training networks based on perceptual loss functions. throughout the paper we assume all image processing is performed on the y-channel in colour space, and thus we represent all images as 2d matrices. subsection: sub-pixel convolution sr for a given lr image which is assumed to be the result of low-pass filtering and downscaling by a factor the hr image, the cnn super-resolved solution can be expressed as here, are model parameters and represents the mapping function from lr to hr. a convolutional network models this function as a concatenation of layers defined by sets of weights and biases, each followed by non-linearities, with. formally, the output of each layer is written as with. we assume the shape of filtering weights to be, where and represent the number and size of filters in layer, with the single frame input meaning. model parameters are optimised minimising a loss given a set of lr and hr example image pairs, commonly mse: methods preprocessing with bicubic upsampling before mapping from lr to hr impose that the output number of filters is. using sub-pixel convolution allows to process directly in the lr space and then use output filters to obtain an hr output tensor with shape that can be reordered to obtain. this implies that if there exists an upscaling operation that is better suited for the problem than bicubic upsampling, the network can learn it. moreover, and most importantly, all convolutional processing is performed in lr space, making this approach very efficient. subsection: spatio-temporal networks spatio-temporal networks assume input data to be a block of spatio-temporal information, such that instead of a single input frame, a sequence of consecutive frames is considered. this can be represented in the network by introducing an additional dimension for temporal depth, with the input depth representing an odd number of consecutive input frames. if we denote the temporal radius of a spatio-temporal block to be, we define the group of input frames centered at time as, and the problem in eq: image-sr becomes the shape of weighting filters is also extended by their temporal size, and their tensor shape becomes. we note that it is possible to consider solutions that aim to jointly reconstruct more than a single output frame, which could have advantages at least in terms of computational efficiency. however, in this work we focus on the reconstruction of only a single output frame. subsubsection: early fusion one of the most straightforward approaches for a cnn to process videos is to match the temporal depth of the input layer to the number of frames. this will collapse all temporal information in the first layer and the remaining operations are identical to those in a single image sr network, meaning. an illustration of early fusion is shown in fig: early-fusion for, where the temporal dimension has been colour coded and the output mapping to 2d space is omitted. this design has been studied for video classification and action recognition, and was also one of the architectures proposed in vsrnet. however, vsrnet requires bicubic upsampling as opposed to sub-pixel convolution, making the framework computationally much less efficient in comparison. subsubsection: slow fusion another option is to partially merge temporal information in a hierarchical structure, so it is slowly fused as information progresses through the network. in this case, the temporal depth of network layers is configured to be, and therefore some layers also have a temporal extent until all information has been merged and the depth of the network reduces to. this architecture, termed slow fusion, has shown better performance than early fusion for video classification. in fig: slow-fusion we show a slow fusion network where and the rate of fusion is defined by for or otherwise, meaning that at each layer only two consecutive frames or filter activations are merged until the network's temporal depth shrinks to. note that early fusion is an special case of slow fusion. subsubsection: 3d convolutions another variation of slow fusion is to force layer weights to be shared across the temporal dimension, which has computational advantages. assuming an online processing of frames, when a new frame becomes available the result of some layers for the previous frame can be reused. for instance, refering to the diagram in fig: slow-fusion and assuming the bottom frame to be the latest frame received, all activations above the dashed line are readily available because they were required for processing the previous frame. this architecture is equivalent to using 3d convolutions, initially proposed as an effective tool to learn spatio-temporal features that can help for video action recognition. an illustration of this design from a 3d convolution perspective is shown in fig:3dconv, where the arrangement of the temporal and filter features is swapped relative to fig: slow-fusion. subsection: spatial transformer motion compensation we propose the use of an efficient spatial transformer network to compensate the motion between frames fed to the sr network. it has been shown how spatial transformers can effectively encode optical flow to describe motion, and are therefore suitable for motion compensation. we will compensate blocks of three consecutive frames to combine the compensation module with the sr network as shown in fig: network, but for simplicity we first introduce motion compensation between two frames. notice that the data used contains inherent motion blur and (dis) occlusions, and even though an explicit modelling for these effects is not used it could potentially improve results. the task is to find the best optical flow representation relating a new frame with a reference current frame. the flow is assumed pixel-wise dense, allowing to displace each pixel to a new position, and the resulting pixel arrangement requires interpolation back onto a regular grid. we use bilinear interpolation as it is much more efficient than the thin-plate spline interpolation originally proposed in. optical flow is a function of parameters and is represented with two feature maps corresponding to displacements for the and dimensions, thus a compensated image can be expressed as, or more concisely we adopt a multi-scale design to represent the flow, which has been shown to be effective in classical methods and also in more recently proposed spatial transformer techniques. a schematic of the design is shown in fig: transformer and flow estimation modules are detailed in tab: transformer. first, a coarse estimate of the flow is obtained by early fusing the two input frames and downscaling spatial dimensions with strided convolutions. the estimated flow is upscaled with sub-pixel convolution and the result is applied to warp the target frame producing. the warped image is then processed together with the coarse flow and the original images through a fine flow estimation module. this uses a single strided convolution with stride and a final upscaling stage to obtain a finer flow map. the final motion compensated frame is obtained by warping the target frame with the total flow. output activations use tanh to represent pixel displacement in normalised space, such that a displacement of means maximum displacement from the center to the border of the image. to train the spatial transformer to perform motion compensation we optimise its parameters to minimise the mse between the transformed frame and the reference frame. similary to classical optical flow methods, we found that it is generally helpful to constrain the flow to behave smoothly in space, and so we penalise the huber loss of the flow map gradients, namely in practice we approximate the huber loss with, where. this function has a smooth behaviour near the origin and is sparsity promoting far from it. the spatial transformer module is advantageous relative to other motion compensation mechanisms as it is straightforward to combine with a sr network to perform joint motion compensation and video sr. referring to fig: network, the same parameters can be used to model motion of the outer two frames relative to the central frame. the spatial transformer and sr modules are both differentiable and therefore end-to-end trainable. as a result, they can be jointly optimised to minimise a composite loss combining the accuracy of the reconstruction in eq: image-sr-objective with the fidelity of motion compensation in eq: motion-compensation-objective, namely section: experiments and results in this section, we first analyse spatio-temporal networks for video sr in isolation and later evaluate the benefits of introducing motion compensation. we restrict our experiments to tackle and upscaling of full hd video resolution (), and no compression is applied. to ensure a fair comparison of methods, the number of network parameters need to be comparable so that gains in performance can be attributed to specific choices of network resource allocation and not to a trivial increase in capacity. for a layer, the number of floating-point operations to reconstruct a frame is approximated by in measuring the complexity of slow fusion networks with weight sharing we look at steady-state operation where the output of some layers is reused from one frame to the following. we note that the analysis of vsrnet variants in does not take into account model complexity. subsection: experimental setup subsubsection: data we use the cdvl database, which contains uncompressed full hd videos excluding repeated videos, and choose a subset of videos for training. the videos are downscaled and random samples are extracted from each hr-lr video pair to obtain training samples, of which are used for validation. depending on the network architecture, we refer to a sample as a single input-output frame pair for single frame networks, or as a block of consecutive lr input frames and the corresponding central hr frame for spatio-temporal networks. the remaining videos are used for testing. although the total number of training frames is large, we foresee that the methods presented could benefit from a richer, more diverse set of videos. additionally, we present a benchmark against various sr methods on publicly available videos that are recurrently used in the literature and we refer to as vid4. subsubsection: network training and parameters all sr models are trained following the same protocol and share similar hyperparameters. filter sizes are set to, and all non-linearities are rectified linear units except for the output layer, which uses a linear activation. biases are initialised to and weights use orthogonal initialisation with gain following recommendations in. all hidden layers are set to have the same number of features. video samples are broken into non-overlapping sub-samples of spatial dimensions, which are randomly grouped in batches for stochastic optimisation. we employ adam with a learning rate and an initial batch size. every epochs the batch size is doubled until it reaches a maximum size of. we choose for layers where the network temporal depth is (layers in gray in fig: early-fusion, fig: slow-fusion, fig:3dconv), and to maintain comparable network sizes we choose. this ensures that the number of features per hidden layer in early and slow fusion networks is always the same. for instance, the network shown in fig: slow-fusion, for which and for, the number of features in a layer network for sr would be 6, 8, 12, 24, 24,. subsection: spatio-temporal video sr subsubsection: single vs multi frame early fusion first, we investigate the impact of the number of input frames on complexity and accuracy without motion compensation. we compare single frame models (sf) against early fusion spatio-temporal models using 3, 5 and 7 input frames (e3, e5 and e7). psnr results on the cdvl dataset for networks of 6 to 11 layers are plotted in fig: single-vs-multi-frame. exploiting spatio-temporal correlations provides a more accurate result relative to an independent processing of frames. the increase in complexity from early fusion is marginal because only the first layer contributes to an increase of operations. although the accuracy of spatio-temporal models is relatively similar, we find that e7 slightly underperforms. it is likely that temporal dependencies beyond 5 frames become too complex for networks to learn useful information and act as noise degrading their performance. notice also that, whereas the performance increase from network depth is minimal after 8 layers for single frame networks, this increase is more consistent for spatio-temporal models. subsubsection: early vs slow fusion here we compare the different treatments of the temporal dimension discussed in ssec: st-networks. we assume networks with an input of frames and slow fusion models with filter temporal depths as in fig: st-networks. using sf, e5, s5, and s5-sw to refer to single frame networks and 5 frame input networks using early fusion, slow fusion, and slow fusion with shared weights, we show in tab: early-vs-slow-fusion results for 7 and 9 layer networks. as seen previously, early fusion networks attain a higher accuracy at a marginal 3% increase in operations relative to the single frame models, and as expected, slow fusion architectures provide efficiency advantages. slow fusion is faster than early fusion because it uses fewer features in the initial layers. referring to eq: operations, slow fusion uses in the first layers and, which results in fewer operations than, as used in early fusion. while the 7 layer network sees a considerable decrease in accuracy using slow fusion relative to early fusion, the 9 layer network can benefit from the same accuracy while reducing its complexity with slow fusion by about 30%. this suggests that in shallow networks the best use of network resources is to utilise the full network capacity to jointly process all temporal information as done by early fusion, but that in deeper networks slowly fusing the temporal dimension is beneficial, which is in line with the results presented by for video classification. additionally, weight sharing decreases accuracy because of the reduction in network parameters, but the reusability of network features means fewer operations are needed per frame. for instance, the 7 layer s5-sw network shows a reduction of almost 30% of operations with a minimal decrease in accuracy relative to sf. using 7 layers with e5 nevertheless shows better performance and faster operation than s5-sw with 9 layers, and in all cases we found that early or slow fusion consistently outperformed slow fusion with shared weights in this performance and efficiency trade-off. convolutions in spatio-temporal domain were shown in to work well for video action recognition, but with larger capacity and many more frames processed jointly. we speculate this could be the reason why the conclusions drawn from this high-level vision task do not extrapolate to the sr problem. subsection: motion compensated video sr [b] 0.32 [b] 0.32 [b] 0.32 in this section, the proposed frame motion compensation is combined with an early fusion network of temporal depth. first, the motion compensation module is trained independently using eq: video-sr-memc, where the first term is ignored and,. this results in a network that will compensate the motion of three consecutive frames by estimating the flow maps of outer frames relative to the middle frame. an example of a flow map obtained for one frame is shown in fig: memc, where we also show the effect the motion compensation module has on three consecutive frames. the early fusion motion compensated sr network (e3-mc) is initialised with a compensation and a sr network pretrained separately, and the full model is then jointly optimised with eq: video-sr-memc (,). results for sr on cdvl are compared in tab: motion-compensated-video-sr against a single frame (sf) model and early fusion without motion compensation (e3). e3-mc results in a psnr that is sometimes almost twice the improvement of e3 relative to sf, which we attribute to the fact that the network adapts the sr input to maximise temporal redundancy. in fig: mcsr-x3 we show how this improvement is reflected in better structure preservation. subsection: comparison to state-of-the-art we show in tab: set4 the performance on vid4 for srcnn, espcn, vsrnet and the proposed method, which we refer to as video espcn (vespcn). to demonstrate its benefits in efficiency and quality we evaluate two early fusion models: a 5 layer 3 frame network (5l-e3) and a 9 layer 3 frame network with motion compensation (9l-e3-mc). the metrics compared are psnr, ssim and movie indices. the movie index was designed as a metric measuring video quality that correlates with human perception and incorporates a notion of temporal consistency. we also directly compare the number of operations per frame of all cnn-based approaches for upscaling a generic p frame. reconstructions for srcnn, espcn and vsrnet use models provided by the authors. srcnn, espcn and vespcn were tested on theano and lasagne, and for vsrnet we used available caffe matlab code. we crop spatial borders as well as initial and final frames on all reconstructions for fair comparison against vsrnet. subsubsection: quality comparison an example of visual differences is shown in fig: set4-visualisation against the motion compensated network. from the close-up images, we see how the structural detail of the original video is better recovered by the proposed vespcn method. this is reflected in tab: set4, where it surpasses any other method in psnr and ssim by a large margin. fig: set4-visualisation also shows temporal profiles on the row highlighted by a dashed line through 25 consecutive frames, demonstrating a better temporal coherence of the reconstruction proposed. the great temporal coherence of vespcn also explains the significant reduction in the movie index. subsubsection: efficiency comparison the complexity of methods in tab: set4 is determined by network and input image sizes. srcnn and vsrnet upsample lr images before attempting to super-resolve them, which considerably increases the required number of operations. vsrnet is particularly expensive because it processes input frames in and feature layers, whereas sub-pixel convolution greatly reduces the number of operations required in espcn and vespcn. as a reference, espcn runs at ms per frame on a k2 gpu. the enhanced capabilities of spatio-temporal networks allow to reduce the network operations of vespcn relative to espcn while still matching its accuracy. as an example we show vespcn with 5l-e3, which reduces the number of operations by about 20% relative to espcn while maintaining a similar performance in all evaluated quality metrics. the operations for motion compensation in vespcn with 9l-e3-mc, included in tab: set4 results, amount to and gops for and upscaling, applied twice for each input frame requiring motion compensation. this makes the proposed motion compensated video sr very efficient relative to other approaches. for example, motion compensation in vsrnet is said to require 55 seconds per frame and is the computational bottleneck. this is not accounted for in tab: set4 but is slower than vespcn with 9l-e3-mc, which can run in the order of seconds. the optical flow method in vsrnet was originally shown to run at ms on gpu for each frame of dimensions, but this is still considerably slower than the proposed solution considering motion compensation is required for more than a single frame of hd dimensions. section: conclusion in this paper we combine the efficiency advantages of sub-pixel convolutions with temporal fusion strategies to present real-time spatio-temporal models for video sr. the spatio-temporal models used are shown to facilitate an improvement in reconstruction accuracy and temporal consistency or reduce computational complexity relative to independent single frame processing. the models investigated are extended with a motion compensation mechanism based on spatial transformer networks that is efficient and jointly trainable for video sr. results obtained with approaches that incorporate explicit motion compensation are demonstrated to be superior in terms of psnr and temporal consistency compared to spatio-temporal models alone, and outperform the current state of the art in video sr. bibliography: references",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "spatio temporal sub pixel convolution networks"
                    ],
                    [
                        "vsrnet"
                    ],
                    [
                        "real time image sr method"
                    ],
                    [
                        "vsrnet"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "real time video super resolution"
                    ],
                    [
                        "video super resolution"
                    ],
                    [
                        "super resolution"
                    ],
                    [
                        "resolution"
                    ],
                    [
                        "real time video sr"
                    ],
                    [
                        "motion compensated video sr"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "vid4"
                    ]
                ],
                "Method": [
                    [
                        "video espcn",
                        "vespcn",
                        "vespcn method"
                    ]
                ],
                "Metric": [
                    [
                        "movie",
                        "movie index"
                    ]
                ],
                "Task": [
                    [
                        "real-time video super-resolution",
                        "video super-resolution",
                        "video",
                        "sr",
                        "real-time video sr",
                        "hd video sr",
                        "spatio-temporal video sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "vid4"
                    ]
                ],
                "Method": [
                    [
                        "bicubic interpolation",
                        "bicubic upsampling"
                    ]
                ],
                "Metric": [
                    [
                        "movie",
                        "movie index"
                    ]
                ],
                "Task": [
                    [
                        "real-time video super-resolution",
                        "video super-resolution",
                        "video",
                        "sr",
                        "real-time video sr",
                        "hd video sr",
                        "spatio-temporal video sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "vid4"
                    ]
                ],
                "Method": [
                    [
                        "video espcn",
                        "vespcn",
                        "vespcn method"
                    ]
                ],
                "Metric": [
                    [
                        "psnr"
                    ]
                ],
                "Task": [
                    [
                        "real-time video super-resolution",
                        "video super-resolution",
                        "video",
                        "sr",
                        "real-time video sr",
                        "hd video sr",
                        "spatio-temporal video sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "vid4"
                    ]
                ],
                "Method": [
                    [
                        "bicubic interpolation",
                        "bicubic upsampling"
                    ]
                ],
                "Metric": [
                    [
                        "psnr"
                    ]
                ],
                "Task": [
                    [
                        "real-time video super-resolution",
                        "video super-resolution",
                        "video",
                        "sr",
                        "real-time video sr",
                        "hd video sr",
                        "spatio-temporal video sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "vid4"
                    ]
                ],
                "Method": [
                    [
                        "video espcn",
                        "vespcn",
                        "vespcn method"
                    ]
                ],
                "Metric": [
                    [
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "real-time video super-resolution",
                        "video super-resolution",
                        "video",
                        "sr",
                        "real-time video sr",
                        "hd video sr",
                        "spatio-temporal video sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "vid4"
                    ]
                ],
                "Method": [
                    [
                        "bicubic interpolation",
                        "bicubic upsampling"
                    ]
                ],
                "Metric": [
                    [
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "real-time video super-resolution",
                        "video super-resolution",
                        "video",
                        "sr",
                        "real-time video sr",
                        "hd video sr",
                        "spatio-temporal video sr"
                    ]
                ]
            }
        ]
    },
    "0834e74304b547c9354b6d7da6fa78ef47a48fa8-7": {
        "doctext": "document: line: large-scale information network embedding this paper studies the problem of embedding very large information networks into low-dimensional vector spaces, which is useful in many tasks such as visualization, node classification, and link prediction. most existing graph embedding methods do not scale for real world information networks which usually contain millions of nodes. in this paper, we propose a novel network embedding method called the\" line,\" which is suitable for arbitrary types of information networks: undirected, directed, and/ or weighted. the method optimizes a carefully designed objective function that preserves both the local and global network structures. an edge-sampling algorithm is proposed that addresses the limitation of the classical stochastic gradient descent and improves both the effectiveness and the efficiency of the inference. empirical experiments prove the effectiveness of the line on a variety of real-world information networks, including language networks, social networks, and citation networks. the algorithm is very efficient, which is able to learn the embedding of a network with millions of vertices and billions of edges in a few hours on a typical single machine. the source code of the line is available online. (iw3c2). www2015, may18-22, 2015, florence, italy. acm 978-1-4503-3469-3/ 15/ 05. http:// dx.doi.org/ 10.1145/ 2736277.2741093 i.2.6artificial intelligencelearning algorithms, experimentation section: introduction information networks are ubiquitous in the real world with examples such as airline networks, publication networks, social and communication networks, and the world wide web. the size of these information networks ranges from hundreds of nodes to millions and billions of nodes. analyzing large information networks has been attracting increasing attention in both academia and industry. this paper studies the problem of embedding information networks into low-dimensional spaces, in which every vertex is represented as a low-dimensional vector. such a low-dimensional embedding is very useful in a variety of applications such as visualization, node classification, link prediction, and recommendation. various methods of graph embedding have been proposed in the machine learning literature (e.g.,). they generally perform well on smaller networks. the problem becomes much more challenging when a real world information network is concerned, which typically contains millions of nodes and billions of edges. for example, the twitter followee-follower network contains 175 million active users and around twenty billion edges in 2012. most existing graph embedding algorithms do not scale for networks of this size. for example, the time complexity of classical graph embedding algorithms such as mds, isomap, laplacian eigenmap are at least quadratic to the number of vertices, which is too expensive for networks with millions of nodes. although a few very recent studies approach the embedding of large-scale networks, these methods either use an indirect approach that is not designed for networks (e.g.,) or lack a clear objective function tailored for network embedding (e.g.,). we anticipate that a new model with a carefully designed objective function that preserves properties of the graph and an efficient optimization technique should effectively find the embedding of millions of nodes. in this paper, we propose such a network embedding model called the\" line,\" which is able to scale to very large, arbitrary types of networks: undirected, directed and/ or weighted. the model optimizes an objective which preserves both the local and global network structures. naturally, the local structures are represented by the observed links in the networks, which capture the first-order proximity between the vertices. most existing graph embedding algorithms are designed to preserve this first-order proximity, e.g., isomap and laplacian eigenmap, even if they do not scale. we observe that in a real-world network many (if not the majority of) legitimate links are actually not observed. in other words, the observed first-order proximity in the real world data is not sufficient for preserving the global network structures. as a complement, we explore the second-order proximity between the vertices, which is not determined through the observed tie strength but through the shared neighborhood structures of the vertices. the general notion of the second-order proximity can be interpreted as nodes with shared neighbors being likely to be similar. such an intuition can be found in the theories of sociology and linguistics. for example,\" the degree of overlap of two people's friendship networks correlates with the strength of ties between them,\" in a social network; and\" you shall know a word by the company it keeps\" (firth, j. r. 1957:11) in text corpora. indeed, people who share many common friends are likely to share the same interest and become friends, and words that are used together with many similar words are likely to have similar meanings. fig. [reference] presents an illustrative example. as the weight of the edge between vertex 6 and 7 is large, i.e., 6 and 7 have a high first-order proximity, they should be represented closely to each other in the embedded space. on the other hand, though there is no link between vertex 5 and 6, they share many common neighbors, i.e., they have a high second-order proximity and therefore should also be represented closely to each other. we expect that the consideration of the second-order proximity effectively complements the sparsity of the first-order proximity and better preserves the global structure of the network. in this paper, we will present carefully designed objectives that preserve the first-order and the second-order proximities. even if a sound objective is found, optimizing it for a very large network is challenging. one approach that attracts attention in recent years is using the stochastic gradient descent for the optimization. however, we show that directly deploying the stochastic gradient descent is problematic for real world information networks. this is because in many networks, edges are weighted and the weights usually present a high variance. consider a word co-occurrence network, in which the weights (co-occurrences) of word pairs may range from one to hundreds of thousands. these weights of the edges will be multiplied into the gradients, resulting in the explosion of the gradients and thus compromise the performance. to address this, we propose a novel edge-sampling method, which improves both the effectiveness and efficiency of the inference. we sample the edges with the probabilities proportional to their weights, and then treat the sampled edges as binary edges for model updating. with this sampling process, the objective function remains the same and the weights of the edges no longer affect the gradients. the line is very general, which works well for directed or undirected, weighted or unweighted graphs. we evaluate the performance of the line with various real-world information networks, including language networks, social networks, and citation networks. the effectiveness of the learned embeddings is evaluated within multiple data mining tasks, including word analogy, text classification, and node classification. the results suggest that the line model outperforms other competitive baselines in terms of both effectiveness and efficiency. it is able to learn the embedding of a network with millions of nodes and billions of edges in a few hours on a single machine. to summarize, we make the following contributions: we propose a novel network embedding model called the\" line,\" which suits arbitrary types of information networks and easily scales to millions of nodes. it has a carefully designed objective function that preserves both the first-order and second-order proximities. we propose an edge-sampling algorithm for optimizing the objective. the algorithm tackles the limitation of the classical stochastic gradient decent and improves the effectiveness and efficiency of the inference. we conduct extensive experiments on real-world information networks. experimental results prove the effectiveness and efficiency of the proposed line model. organization. the rest of this paper is organized as follows. section [reference] summarizes the related work. section [reference] formally defines the problem of large-scale information network embedding. section [reference] introduces the line model in details. section [reference] presents the experimental results. finally we conclude in section [reference]. section: related work our work is related to classical methods of graph embedding or dimension reduction in general, such as multidimensional scaling (mds), isomap, lle and laplacian eigenmap. these approaches typically first construct the affinity graph using the feature vectors of the data points, e.g., the k-nearest neighbor graph of data, and then embed the affinity graph into a low dimensional space. however, these algorithms usually rely on solving the leading eigenvectors of the affinity matrices, the complexity of which is at least quadratic to the number of nodes, making them inefficient to handle large-scale networks. among the most recent literature is a technique called graph factorization. it finds the low-dimensional embedding of a large graph through matrix factorization, which is optimized using stochastic gradient descent. this is possible because a graph can be represented as an affinity matrix. however, the objective of matrix factorization is not designed for networks, therefore does not necessarily preserve the global network structure. intuitively, graph factorization expects nodes with higher first-order proximity are represented closely. instead, the line model uses an objective that is particularly designed for networks, which preserves both the first-order and the second-order proximities. practically, the graph factorization method only applies to undirected graphs while the proposed model is applicable for both undirected and directed graphs. the most recent work related with ours is deepwalk, which deploys a truncated random walk for social network embedding. although empirically effective, the deepwalk does not provide a clear objective that articulates what network properties are preserved. intuitively, deepwalk expects nodes with higher second-order proximity yield similar low-dimensional representations, while the line preserves both first-order and second-order proximities. deepwalk uses random walks to expand the neighborhood of a vertex, which is analogical to a depth-first search. we use a breadth-first search strategy, which is a more reasonable approach to the second-order proximity. practically, deepwalk only applies to unweighted networks, while our model is applicable for networks with both weighted and unweighted edges. in section [reference], we empirically compare the proposed model with these methods using various real world networks. section: problem definition we formally define the problem of large-scale information network embedding using first-order and second-order proximities. we first define an information network as follows: theorem: (information network) an information network is defined as= g (v, e), where v is the set of vertices, each representing a data object and e is the set of edges between the vertices, each representing a relationship between two data objects. each edge\u2208ee is an ordered pair= e (u, v) and is associated with a weight> w\u2062uv0, which indicates the strength of the relation. if g is undirected, we have\u2261 (u, v)(v, u) and\u2261w\u2062uvw\u2062vu; if g is directed, we have\u2262 (u, v)(v, u) and\u2262w\u2062uvw\u2062vu. in practice, information networks can be either directed (e.g., citation networks) or undirected (e.g., social network of users in facebook). the weights of the edges can be either binary or take any real value. note that while negative edge weights are possible, in this study we only consider non-negative weights. for example, in citation networks and social networks, takes binary values; in co-occurrence networks between different objects, can take any non-negative value. the weights of the edges in some networks may diverge as some objects co-occur many times while others may just co-occur a few times. embedding an information network into a low-dimensional space is useful in a variety of applications. to conduct the embedding, the network structures must be preserved. the first intuition is that the local network structure, i.e., the local pairwise proximity between the vertices, must be preserved. we define the local network structures as the first-order proximity between the vertices: theorem: (first-order proximity) the first-order proximity in a network is the local pairwise proximity between two vertices. for each pair of vertices linked by an edge (u, v), the weight on that edge, w\u2062uv, indicates the first-order proximity between u and v. if no edge is observed between u and v, their first-order proximity is 0. the first-order proximity usually implies the similarity of two nodes in a real-world network. for example, people who are friends with each other in a social network tend to share similar interests; pages linking to each other in world wide web tend to talk about similar topics. because of this importance, many existing graph embedding algorithms such as isomap, lle, laplacian eigenmap, and graph factorization have the objective to preserve the first-order proximity. however, in a real world information network, the links observed are only a small proportion, with many others missing. a pair of nodes on a missing link has a zero first-order proximity, even though they are intrinsically very similar to each other. therefore, first-order proximity alone is not sufficient for preserving the network structures, and it is important to seek an alternative notion of proximity that addresses the problem of sparsity. a natural intuition is that vertices that share similar neighbors tend to be similar to each other. for example, in social networks, people who share similar friends tend to have similar interests and thus become friends; in word co-occurrence networks, words that always co-occur with the same set of words tend to have similar meanings. we therefore define the second-order proximity, which complements the first-order proximity and preserves the network structure. theorem: (second-order proximity) the second-order proximity between a pair of vertices (u, v) in a network is the similarity between their neighborhood network structures. mathematically, let= pu (wu, 1,\u2026, wu,|v|) denote the first-order proximity of u with all the other vertices, then the second-order proximity between u and v is determined by the similarity between pu and pv. if no vertex is linked from/ to both u and v, the second-order proximity between u and v is 0. we investigate both first-order and second-order proximity for network embedding, which is defined as follows. theorem: (large-scale information network embedding) given a large network= g (v, e), the problem of large-scale information network embedding aims to represent each vertex\u2208vv into a low-dimensional space rd, i.e., learning a function: fg\u2192vrd, where\u226ad|v|. in the space rd, both the first-order proximity and the second-order proximity between the vertices are preserved. next, we introduce a large-scale network embedding model that preserves both first-and second-order proximities. section: line: large-scale information network embedding a desirable embedding model for real world information networks must satisfy several requirements: first, it must be able to preserve both the first-order proximity and the second-order proximity between the vertices; second, it must scale for very large networks, say millions of vertices and billions of edges; third, it can deal with networks with arbitrary types of edges: directed, undirected and/ or weighted. in this section, we present a novel network embedding model called the\" line,\" which satisfies all the three requirements. subsection: model description we describe the line model to preserve the first-order proximity and second-order proximity separately, and then introduce a simple way to combine the two proximity. subsubsection: line with first-order proximity the first-order proximity refers to the local pairwise proximity between the vertices in the network. to model the first-order proximity, for each undirected edge, we define the joint probability between vertex and as follows: where is the low-dimensional vector representation of vertex. eqn. ([reference]) defines a distribution over the space, and its empirical probability can be defined as, where. to preserve the first-order proximity, a straightforward way is to minimize the following objective function: where is the distance between two distributions. we choose to minimize the kl-divergence of two probability distributions. replacing with kl-divergence and omitting some constants, we have: note that the first-order proximity is only applicable for undirected graphs, not for directed graphs. by finding the that minimize the objective in eqn. ([reference]), we can represent every vertex in the d-dimensional space. subsubsection: line with second-order proximity the second-order proximity is applicable for both directed and undirected graphs. given a network, without loss of generality, we assume it is directed (an undirected edge can be considered as two directed edges with opposite directions and equal weights). the second-order proximity assumes that vertices sharing many connections to other vertices are similar to each other. in this case, each vertex is also treated as a specific\" context\" and vertices with similar distributions over the\" contexts\" are assumed to be similar. therefore, each vertex plays two roles: the vertex itself and a specific\" context\" of other vertices. we introduce two vectors and, where is the representation of when it is treated as a vertex while is the representation of when it is treated as a specific\" context\". for each directed edge, we first define the probability of\" context\" generated by vertex as: where is the number of vertices or\" contexts.\" for each vertex, eqn. ([reference]) actually defines a conditional distribution over the contexts, i.e., the entire set of vertices in the network. as mentioned above, the second-order proximity assumes that vertices with similar distributions over the contexts are similar to each other. to preserve the second-order proximity, we should make the conditional distribution of the contexts specified by the low-dimensional representation be close to the empirical distribution. therefore, we minimize the following objective function: where is the distance between two distributions. as the importance of the vertices in the network may be different, we introduce in the objective function to represent the prestige of vertex in the network, which can be measured by the degree or estimated through algorithms such as pagerank. the empirical distribution is defined as, where is the weight of the edge and is the out-degree of vertex, i.e., where is the set of out-neighbors of. in this paper, for simplicity we set as the degree of vertex, i.e.,, and here we also adopt kl-divergence as the distance function. replacing with kl-divergence, setting and omitting some constants, we have: by learning and that minimize this objective, we are able to represent every vertex with a d-dimensional vector. subsubsection: combining first-order and second-order proximities to embed the networks by preserving both the first-order and second-order proximity, a simple and effective way we find in practice is to train the line model which preserves the first-order proximity and second-order proximity separately and then concatenate the embeddings trained by the two methods for each vertex. a more principled way to combine the two proximity is to jointly train the objective function ([reference]) and ([reference]), which we leave as future work. subsection: model optimization optimizing objective ([reference]) is computationally expensive, which requires the summation over the entire set of vertices when calculating the conditional probability. to address this problem, we adopt the approach of negative sampling proposed in, which samples multiple negative edges according to some noisy distribution for each edge. more specifically, it specifies the following objective function for each edge: where is the sigmoid function. the first term models the observed edges, the second term models the negative edges drawn from the noise distribution and is the number of negative edges. we set as proposed in, where is the out-degree of vertex. for the objective function ([reference]), there exists a trivial solution:, for i= and. to avoid the trivial solution, we can still utilize the negative sampling approach ([reference]) by just changing to. we adopt the asynchronous stochastic gradient algorithm (asgd) for optimizing eqn. ([reference]). in each step, the asgd algorithm samples a mini-batch of edges and then updates the model parameters. if an edge is sampled, the gradient w.r.t. the embedding vector of vertex will be calculated as: note that the gradient will be multiplied by the weight of the edge. this will become problematic when the weights of edges have a high variance. for example, in a word co-occurrence network, some words co-occur many times (e.g., tens of thousands) while some words co-occur only a few times. in such networks, the scales of the gradients diverge and it is very hard to find a good learning rate. if we select a large learning rate according to the edges with small weights, the gradients on edges with large weights will explode while the gradients will become too small if we select the learning rate according to the edges with large weights. subsubsection: optimization via edge sampling the intuition in solving the above problem is that if the weights of all the edges are equal (e.g., network with binary edges), then there will be no problem of choosing an appropriate learning rate. a simple treatment is thus to unfold a weighted edge into multiple binary edges, e.g., an edge with weight is unfolded into binary edges. this will solve the problem but will significantly increase the memory requirement, especially when the weights of the edges are very large. to resolve this, one can sample from the original edges and treat the sampled edges as binary edges, with the sampling probabilities proportional to the original edge weights. with this edge-sampling treatment, the overall objective function remains the same. the problem boils down to how to sample the edges according to their weights. let denote the sequence of the weights of the edges. one can simply calculate the sum of the weights first, and then to sample a random value within the range of to see which interval [the random value falls into. this approach takes time to draw a sample, which is costly when the number of edges is large. we use the alias table method to draw a sample according to the weights of the edges, which takes only time when repeatedly drawing samples from the same discrete distribution. sampling an edge from the alias table takes constant time,, and optimization with negative sampling takes time, where is the number of negative samples. therefore, overall each step takes time. in practice, we find that the number of steps used for optimization is usually proportional to the number of edges. therefore, the overall time complexity of the line is, which is linear to the number of edges, and does not depend on the number of vertices. the edge sampling treatment improves the effectiveness of the stochastic gradient descent without compromising the efficiency. subsection: discussion we discuss several practical issues of the line model. low degree vertices. one practical issue is how to accurately embed vertices with small degrees. as the number of neighbors of such a node is very small, it is very hard to accurately infer its representation, especially with the second-order proximity based methods which heavily rely on the number of\" contexts.\" an intuitive solution to this is expanding the neighbors of those vertices by adding higher order neighbors, such as neighbors of neighbors. in this paper, we only consider adding second-order neighbors, i.e., neighbors of neighbors, to each vertex. the weight between vertex and its second-order neighbor is measured as in practice, one can only add a subset of vertices which have the largest proximity with the low degree vertex. new vertices. another practical issue is how to find the representation of newly arrived vertices. for a new vertex, if its connections to the existing vertices are known, we can obtain the empirical distribution and over existing vertices. to obtain the embedding of the new vertex, according to the objective function eqn. ([reference]) or eqn. ([reference]), a straightforward way is to minimize either one of the following objective functions by updating the embedding of the new vertex and keeping the embeddings of existing vertices. if no connections between the new vertex and existing vertices are observed, we must resort to other information, such as the textual information of the vertices, and we leave it as our future work. section: experiments we empirically evaluated the effectiveness and efficiency of the line. we applied the method to several large-scale real-world networks of different types, including a language network, two social networks, and two citation networks. subsection: experiment setup paragraph: data sets (1) language network. we constructed a word co-occurrence network from the entire set of english wikipedia pages. words within every 5-word sliding window are considered to be co-occurring with each other. words with frequency smaller than 5 are filtered out. (2) social networks. we use two social networks: flickr and youtubeavailable at http:// socialnetworks.mpi-sws.org/ data-imc2007.html. the flickr network is denser than the youtube network (the same network as used in deepwalk). (3) citation networks. two types of citation networks are used: an author citation network and a paper citation network. we use the dblp data set to construct the citation networks between authors and between papers. the author citation network records the number of papers written by one author and cited by another author. the detailed statistics of these networks are summarized into table [reference]. they represent a variety of information networks: directed and undirected, binary and weighted. each network contains at least half a million nodes and millions of edges, with the largest network containing around two million nodes and a billion edges. paragraph: compared algorithms we compare the line model with several existing graph embedding methods that are able to scale up to very large networks. we do not compare with some classical graph embedding algorithms such as mds, isomap, and laplacian eigenmap, as they can not handle networks of this scale. graph factorization (gf). we compare with the matrix factorization techniques for graph factorization. an information network can be represented as an affinity matrix, and is able to represent each vertex with a low-dimensional vector through matrix factorization. graph factorization is optimized through stochastic gradient descent and is able to handle large networks. it only applies to undirected networks. deepwalk. deepwalk is an approach recently proposed for social network embedding, which is only applicable for networks with binary edges. for each vertex, truncated random walks starting from the vertex are used to obtain the contextual information, and therefore only second-order proximity is utilized. line-sgd. this is the line model introduced in section [reference] that optimizes the objective eqn. ([reference]) or eqn. ([reference]) directly with stochastic gradient descent. with this approach, the weights of the edges are directly multiplied into the gradients when the edges are sampled for model updating. there are two variants of this approach: line-sgd (1st) and line-sgd (2nd), which use first-and second-order proximity respectively. line. this is the line model optimized through the edge-sampling treatment introduced in section [reference]. in each stochastic gradient step, an edge is sampled with the probability proportional to its weight and then treated as binary for model updating. there are also two variants: line (1st) and line (2nd). like the graph factorization, both line (1st) and line-sgd (1st) only apply to undirected graphs. line (2nd) and line-sgd (2nd) apply to both undirected and directed graphs. line (1st+ 2nd): to utilize both first-order and second-order proximity, a simple and effective way is to concatenate the vector representations learned by line (1st) and line (2nd) into a longer vector. after concatenation, the dimensions should be re-weighted to balance the two representations. in a supervised learning task, the weighting of dimensions can be automatically found based on the training data. in an unsupervised task, however, it is more difficult to set the weights. therefore we only apply line (1st+ 2nd) to the scenario of supervised tasks. paragraph: parameter settings the mini-batch size of the stochastic gradient descent is set as 1 for all the methods. similar to, the learning rate is set with the starting value and, where is the total number of mini-batches or edge samples. for fair comparisons, the dimensionality of the embeddings of the language network is set to 200, as used in word embedding. for other networks, the dimension is set as 128 by default, as used in. other default settings include: the number of negative samples for line and line-sgd; the total number of samples billion for line (1st) and line (2nd), billion for gf; window size, walk length, walks per vertex for deepwalk. all the embedding vectors are finally normalized by setting. subsection: quantitative results subsubsection: language network we start with the results on the language network, which contains two million nodes and a billion edges. two applications are used to evaluate the effectiveness of the learned embeddings: word analogy and document classification. word analogy. this task is introduced by mikolov et al.. given a word pair and a word, the task aims to find a word, such that the relation between and is similar to the relation between and, or denoted as:. for instance, given a word pair (\" china\",\"beijing\") and a word\" france,\" the right answer should be\" paris\" because\" beijing\" is the capital of\" china\" just as\" paris\" is the capital of\" france.\" given the word embeddings, this task is solved by finding the word whose embedding is closest to the vector in terms of cosine proximity, i.e.,. two categories of word analogy are used in this task: semantic and syntactic. significantly outperforms gf at the:** 0.01 and* 0.05 level, paired t-test. table [reference] reports the results of word analogy using the embeddings of words learned on the wikipedia corpora (skipgram) or the wikipedia word network (all other methods). for graph factorization, the weight between each pair of words is defined as the logarithm of the number of co-occurrences, which leads to better performance than the original value of co-occurrences. for deepwalk, different cutoff thresholds are tried to convert the language network into a binary network, and the best performance is achieved when all the edges are kept in the network. we also compare with the state-of-the-art word embedding model skipgram, which learns the word embeddings directly from the original wikipedia pages and is also implicitly a matrix factorization approach. the window size is set as 5, the same as used for constructing the language network. we can see that line (2nd) outperforms all other methods, including the graph embedding methods and the skipgram. this indicates that the second-order proximity better captures the word semantics compared to the first-order proximity. this is not surprising, as a high second-order proximity implies that two words can be replaced in the same context, which is a stronger indicator of similar semantics than first-order co-occurrences. it is intriguing that the line (2nd) outperforms the state-of-the-art word embedding model trained on the original corpus. the reason may be that a language network better captures the global structure of word co-occurrences than the original word sequences. among other methods, both graph factorization and line (1st) significantly outperform deepwalk even if deepwalk explores second-order proximity. this is because deepwalk has to ignore the weights (i.e., co-occurrences) of the edges, which is very important in a language network. the performance by the line models directly optimized with sgd is much worse, because the weights of the edges in the language network diverge, which range from a single digit to tens of thousands, making the learning process suffer. the line optimized by the edge-sampling treatment effectively addresses this problem, and performs very well using either first-order or second-order proximity. all the models are run on a single machine with 1 t memory, 40 cpu cores at 2.0ghz using 16 threads. both the line (1st) and line (2nd) are quite efficient, which take less than 3 hours to process such a network with 2 million nodes and a billion edges. both are at least 10% faster than graph factorization, and much more efficient than deepwalk (five times slower). the reason that line-sgds are slightly slower is that a threshold-cutting technique has to be applied to prevent the gradients from exploding. document classification. another way to evaluate the quality of the word embeddings is to use the word vectors to compute document representation, which can be evaluated with document classification tasks. to obtain document vectors, we choose a very simple approach, taking the average of the word vector representations in that document. this is because we aim to compare the word embeddings with different approaches instead of finding the best method for document embeddings. the readers can find advanced document embedding approaches in. we download the abstracts of wikipedia pages from and the categories of these pages from. we choose 7 diverse categories for classification including\" arts,\"\" history,\"\" human,\"\" mathematics,\"\" nature,\"\" technology,\" and\" sports.\" for each category, we randomly select 10, 000 articles, and articles belonging to multiple categories are discarded. we randomly sample different percentages of the labeled documents for training and use the rest for evaluation. all document vectors are used to train a one-vs-rest logistic regression classifier using the liblinear package. we report the classification metrics micro-f1 and macro-f1. the results are averaged over 10 different runs by sampling different training data. table [reference] reports the results of wikipedia page classification. similar conclusion can be made as in the word analogy task. the graph factorization outperforms deepwalk as deepwalk ignores the weights of the edges. the line-sgds perform worse due to the divergence of the weights of the edges. the line optimized by the edge-sampling treatment performs much better than directly deploying sgd. the line (2nd) outperforms line (1st) and is slightly better than the graph factorization. note that with the supervised task, it is feasible to concatenate the embeddings learned with line (1st) and line (2nd). as a result, the line (1st+ 2nd) method performs significantly better than all other methods. this indicates that the first-order and second-order proximities are complementary to each other. to provide the readers more insight about the first-order and second-order proximities, table [reference] compares the most similar words to a given word using first-order and second-order proximity. we can see that by using the contextual proximity, the most similar words returned by the second-order proximity are all semantically related words. the most similar words returned by the first-order proximity are a mixture of syntactically and semantically related words. subsubsection: social network significantly outperforms deepwalk at the:** 0.01 and* 0.05 level, paired t-test. compared with the language networks, the social networks are much sparser, especially the youtube network. we evaluate the vertex embeddings through a multi-label classification task that assigns every node into one or more communities. different percentages of the vertices are randomly sampled for training and the rest are used for evaluation. the results are averaged over 10 different runs. flickr network. let us first take a look at the results on the flickr network. we choose the most popular 5 communities as the categories of the vertices for multi-label classification. table [reference] reports the results. again, line (1st+ 2nd) significantly outperforms all other methods. line (1st) is slightly better than line (2nd), which is opposite to the results on the language network. the reasons are two fold: (1) first-order proximity is still more important than second-order proximity in social network, which indicates strong ties; (2) when the network is too sparse and the average number of neighbors of a node is too small, the second-order proximity may become inaccurate. we will further investigate this issue in section [reference]. line (1st) outperforms graph factorization, indicating a better capability of modeling the first-order proximity. line (2nd) outperforms deepwalk, indicating a better capability of modeling the second-order proximity. by concatenating the representations learned by line (1st) and line (2nd), the performance further improves, confirming that the two proximities are complementary to each other. significantly outperforms deepwalk at the:** 0.01 and* 0.05 level, paired t-test. significantly outperforms deepwalk at the:** 0.01 and* 0.05 level, paired t-test. significantly outperforms deepwalk at the:** 0.01 and* 0.05 level, paired t-test. youtube network. table [reference] reports the results on youtube network, which is extremely sparse and the average degree is as low as 5. in most cases with different percentages of training data, line (1st) outperforms line (2nd), consistent with the results on the flickr network. due to the extreme sparsity, the performance of line (2nd) is even inferior to deepwalk. by combining the representations learned by the line with both the first-and second-order proximity, the performance of line outperforms deepwalk with either 128 or 256 dimension, showing that the two proximities are complementary to each other and able to address the problem of network sparsity. it is interesting to observe how deepwalk tackles the network sparsity through truncated random walks, which enrich the neighbors or contexts of each vertex. the random walk approach acts like a depth-first search. such an approach may quickly alleviate the sparsity of the neighborhood of nodes by bringing in indirect neighbors, but it may also introduce nodes that are long range away. a more reasonable way is to expand the neighborhood of each vertex using a breadth-first search strategy, i.e., recursively adding neighbors of neighbors. to verify this, we expand the neighborhood of the vertices whose degree are less than 1, 000 by adding the neighbors of neighbors until the size of the extended neighborhood reaches 1, 000 nodes. we find that adding more than 1, 000 vertices does not further increase the performance. the results in the brackets in table [reference] are obtained on this reconstructed network. the performance of gf, line (1st) and line (2nd) all improves, especially line (2nd). in the reconstructed network, the line (2nd) outperforms deepwalk in most cases. we can also see that the performance of line (1st+ 2nd) on the reconstructed network does not improve too much compared with those on the original network. this implies that the combination of first-order and second-order proximity on the original network has already captured most information and line (1st+ 2nd) approach is a quite effective and efficient way for network embedding, suitable for both dense and sparse networks. subsubsection: citation network we present the results on two citation networks, both of which are directed networks. both the gf and line methods, which use first-order proximity, are not applicable for directed networks, and hence we only compare deepwalk and line (2nd). we also evaluate the vertex embeddings through a multi-label classification task. we choose 7 popular conferences including aaai, cikm, icml, kdd, nips, sigir, and www as the classification categories. authors publishing in the conferences or papers published in the conferences are assumed to belong to the categories corresponding to the conferences. dblp (authorcitation) network. table [reference] reports the results on the dblp (authorcitation) network. as this network is also very sparse, deepwalk outperforms line (2nd). however, by reconstructing the network through recursively adding neighbors of neighbors for vertices with small degrees (smaller than 500), the performance of line (2nd) significantly increases and outperforms deepwalk. the line model directly optimized by stochastic gradient descent, line (2nd), does not perform well as expected. dblp (papercitation) network. table [reference] reports the results on the dblp (papercitation) network. the line (2nd) significantly outperforms deepwalk. this is because the random walk on the paper citation network can only reach papers along the citing path (i.e., older papers) and can not reach other references. instead, the line (2nd) represents each paper with its references, which is obviously more reasonable. the performance of line (2nd) is further improved when the network is reconstructed by enriching the neighbors of vertices with small degrees (smaller than 200). subsection: network layouts an important application of network embedding is to create meaningful visualizations that layout a network on a two dimensional space. we visualize a co-author network extracted from the dblp data. we select some conferences from three different research fields: www, kdd from\" data mining,\" nips, icml from\" machine learning,\" and cvpr, iccv from\" computer vision.\" the co-author network is built from the papers published in these conferences. authors with degree less than 3 are filtered out, and finally the network contains 18, 561 authors and 207, 074 edges. laying out this co-author network is very challenging as the three research fields are very close to each other. we first map the co-author network into a low-dimensional space with different embedding approaches and then further map the low-dimensional vectors of the vertices to a 2-d space with the t-sne package. fig. [reference] compares the visualization results with different embedding approaches. the visualization using graph factorization is not very meaningful, in which the authors belonging to the same communities are not clustered together. the result of deepwalk is much better. however, many authors belonging to different communities are clustered tightly into the center area, most of which are high degree vertices. this is because deepwalk uses a random walk based approach to enrich the neighbors of the vertices, which brings in a lot of noise due to the randomness, especially for vertices with higher degrees. the line (2nd) performs quite well and generates meaningful layout of the network (nodes with same colors are distributed closer). subsection: performance w.r.t. network sparsity in this subsection, we formally analyze the performance of the above models w.r.t. the sparsity of networks. we use the social networks as examples. we first investigate how the sparsity of the networks affects the line (1st) and line (2nd). fig. [reference] shows the results w.r.t. the percentage of links on the flickr network. we choose flickr network as it is much denser than the youtube network. we randomly select different percentages of links from the original network to construct networks with different levels of sparsity. we can see that in the beginning, when the network is very sparse, the line (1st) outperforms line (2nd). as we gradually increase the percentage of links, the line (2nd) begins to outperform the line (1st). this shows that the second-order proximity suffers when the network is extremely sparse, and it outperforms first-order proximity when there are sufficient nodes in the neighborhood of a node. fig. [reference] shows the performance w.r.t. the degrees of the vertices on both the original and reconstructed youtube networks. we categorize the vertices into different groups according to their degrees including, and then evaluate the performance of vertices in different groups. overall, the performance of different models increases when the degrees of the vertices increase. in the original network, the line (2nd) outperforms line (1st) except for the first group, which confirms that the second-order proximity does not work well for nodes with a low degree. in the reconstructed dense network, the performance of the line (1st) or line (2nd) improves, especially the line (2nd) that preserves the second-order proximity. we can also see that the line (2nd) model on the reconstructed network outperforms deepwalk in all the groups. subsection: parameter sensitivity next, we investigate the performance w.r.t. the parameter dimension and the converging performance of different models w.r.t the number of samples on the reconstructed youtube network. fig. [reference] reports the performance of the line model w.r.t. the dimension. we can see that the performance of the line (1st) or line (2nd) drops when the dimension becomes too large. fig. [reference] shows the results of the line and deepwalk w.r.t. the number of samples during the optimization. the line (2nd) consistently outperforms line (1st) and deepwalk, and both the line (1st) and line (2nd) converge much faster than deepwalk. subsection: scalability finally, we investigate the scalability of the line model optimized by the edge-sampling treatment and asynchronous stochastic gradient descent, which deploys multiple threads for optimization. fig. [reference] shows the speed up w.r.t. the number of threads on the youtube data set. the speed up is quite close to linear. fig. [reference] shows that the classification performance remains stable when using multiple threads for model updating. the two figures together show that the inference algorithm of the line model is quite scalable. section: conclusion this paper presented a novel network embedding model called the\" line,\" which can easily scale up to networks with millions of vertices and billions of edges. it has carefully designed objective functions that preserve both the first-order and second-order proximities, which are complementary to each other. an efficient and effective edge-sampling method is proposed for model inference, which solved the limitation of stochastic gradient descent on weighted edges without compromising the efficiency. experimental results on various real-world networks prove the efficiency and effectiveness of line. in the future, we plan to investigate higher-order proximity beyond the first-order and second-order proximities in the network. besides, we also plan to investigate the embedding of heterogeneous information networks, e.g., vertices with multiple types. section: acknowledgments the authors thank the three anonymous reviewers for the helpful comments. the co-author ming zhang is supported by the national natural science foundation of china (nsfc grant no. 61472006); qiaozhu mei is supported by the national science foundation under grant numbers iis-1054199 and ccf-1048168. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "iw3c2"
                    ],
                    [
                        "florence"
                    ],
                    [
                        "florence italy"
                    ]
                ],
                "Method": [
                    [
                        "line"
                    ],
                    [
                        "large scale information network"
                    ],
                    [
                        "embedding"
                    ]
                ],
                "Metric": [
                    [
                        "micro f1"
                    ]
                ],
                "Task": [
                    [
                        "node classification"
                    ],
                    [
                        "link prediction"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "english wikipedia pages",
                        "wikipedia corpora",
                        "skipgram",
                        "wikipedia word network",
                        "wikipedia pages"
                    ]
                ],
                "Method": [
                    [
                        "line",
                        "large-scale information network embedding",
                        "low-dimensional embedding",
                        "sampling process",
                        "low-dimensional representation",
                        "line (1st",
                        "line (2nd",
                        "1st+ 2nd"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "node classification",
                        "document classification",
                        "document classification tasks",
                        "classification",
                        "wikipedia page classification",
                        "multi-label classification task",
                        "multi-label classification",
                        "classification categories"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "english wikipedia pages",
                        "wikipedia corpora",
                        "skipgram",
                        "wikipedia word network",
                        "wikipedia pages"
                    ]
                ],
                "Method": [
                    [
                        "line",
                        "large-scale information network embedding",
                        "low-dimensional embedding",
                        "sampling process",
                        "low-dimensional representation",
                        "line (1st",
                        "line (2nd",
                        "1st+ 2nd"
                    ]
                ],
                "Metric": [
                    [
                        "macro-f1"
                    ]
                ],
                "Task": [
                    [
                        "node classification",
                        "document classification",
                        "document classification tasks",
                        "classification",
                        "wikipedia page classification",
                        "multi-label classification task",
                        "multi-label classification",
                        "classification categories"
                    ]
                ]
            }
        ]
    },
    "0a3381f0432c5cfe491c718349d7a44e5814592c-8": {
        "doctext": "document: compositional sequence labeling models for error detection in learner writing in this paper, we present the first experiments using neural network models for the task of error detection in learner writing. we perform a systematic comparison of alternative compositional architectures and propose a framework for error detection based on bidirectional lstms. experiments on the conll-14 shared task dataset show the model is able to outperform other participants on detecting errors in learner writing. finally, the model is integrated with a publicly deployed self-assessment system, leading to performance comparable to human annotators. section: introduction automated systems for detecting errors in learner writing are valuable tools for second language learning and assessment. most work in recent years has focussed on error correction, with error detection performance measured as a byproduct of the correction output. however, this assumes that systems are able to propose a correction for every detected error, and accurate systems for correction might not be optimal for detection. while closed-class errors such as incorrect prepositions and determiners can be modeled with a supervised classification approach, content-content word errors are the 3rd most frequent error type and pose a serious challenge to error correction frameworks. evaluation of error correction is also highly subjective and human annotators have rather low agreement on gold-standard corrections. therefore, we treat error detection in learner writing as an independent task and propose a system for labeling each token as being correct or incorrect in context. common approaches to similar sequence labeling tasks involve learning weights or probabilities for context n-grams of varying sizes, or relying on previously extracted high-confidence context patterns. both of these methods can suffer from data sparsity, as they treat words as independent units and miss out on potentially related patterns. in addition, they need to specify a fixed context size and are therefore often limited to using a small window near the target. neural network models aim to address these weaknesses and have achieved success in various nlp tasks such as language modeling and speech recognition. recent developments in machine translation have also shown that text of varying length can be represented as a fixed-size vector using convolutional networks or recurrent neural networks. in this paper, we present the first experiments using neural network models for the task of error detection in learner writing. we perform a systematic comparison of alternative compositional structures for constructing informative context representations. based on the findings, we propose a novel framework for performing error detection in learner writing, which achieves state-of-the-art results on two datasets of error-annotated learner essays. the sequence labeling model creates a single variable-size network over the whole sentence, conditions each label on all the words, and predicts all labels together. the effects of different datasets on the overall performance are investigated by incrementally providing additional training data to the model. finally, we integrate the error detection framework with a publicly deployed self-assessment system, leading to performance comparable to human annotators. section: background and related work the field of automatically detecting errors in learner text has a long and rich history. most work has focussed on tackling specific types of errors, such as usage of incorrect prepositions, articles, verb forms, and adjective-noun pairs. however, there has been limited work on more general error detection systems that could handle all types of errors in learner text. chodorow1998 proposed a method based on mutual information and the chi-square statistic to detect sequences of part-of-speech tags and function words that are likely to be ungrammatical in english. gamon2011 used maximum entropy markov models with a range of features, such as pos tags, string features, and outputs from a constituency parser. the pilot helping our own shared task also evaluated grammatical error detection of a number of different error types, though most systems were error-type specific and the best approach was heavily skewed towards article and preposition errors. we extend this line of research, working towards general error detection systems, and investigate the use of neural compositional models on this task. the related area of grammatical error correction has also gained considerable momentum in the past years, with four recent shared tasks highlighting several emerging directions. the current state-of-the-art approaches can broadly be separated into two categories: phrase-based statistical machine translation techniques, essentially translating the incorrect source text into the corrected version averaged perceptrons and naive bayes classifiers making use of native-language error correction priors. error correction systems require very specialised models, as they need to generate an improved version of the input text, whereas a wider range of tagging and classification models can be deployed on error detection. in addition, automated writing feedback systems that indicate the presence and location of errors may be better from a pedagogic point of view, rather than providing a panacea and correcting all errors in learner text. in section [reference] we evaluate a neural sequence tagging model on the latest shared task test data, and compare it to the top participating systems on the task of error detection. section: sequence labeling architectures we construct a neural network sequence labeling framework for the task of error detection in learner writing. the model receives only a series of tokens as input, and outputs the probability of each token in the sentence being correct or incorrect in a given context. the architectures start with the vector representations of individual words,, where is the length of the sentence. different composition functions are then used to calculate a hidden vector representation of each token in context,. these representations are passed through a softmax layer, producing a probability distribution over the possible labels for every token in context: where is the weight matrix between the hidden vector and the output layer. we investigate six alternative neural network architectures for the task of error detection: convolutional, bidirectional recurrent, bidirectional lstm, and multi-layer variants of each of them. in the convolutional neural network (cnn, figure [reference] a) for token labeling, the hidden vector is calculated based on a fixed-size context window. the convolution acts as a feedforward network, using surrounding context words as input, and therefore it will learn to detect the presence of different types of n-grams. the assumption behind the convolutional architecture is that memorising erroneous token sequences from the training data is sufficient for performing error detection. the convolution uses tokens on either side of the target token, and the vectors for these tokens are concatenated, preserving the ordering: where is used as notation for vector concatenation of and. the combined vector is then passed through a non-linear layer to produce the hidden representation: the deep convolutional network (figure [reference] b) adds an extra convolutional layer to the architecture, using the first layer as input. it creates convolutions of convolutions, thereby capturing more complex higher-order features from the dataset. in a recurrent neural network (rnn), each hidden representation is calculated based on the current token embedding and the hidden vector at the previous time step: where is a nonlinear function, such as the sigmoid function. instead of a fixed context window, information is passed through the sentence using a recursive function and the network is able to learn which patterns to disregard or pass forward. this recurrent network structure is referred to as an elman-type network, after elman1990. the bidirectional rnn (figure [reference] c) consists of two recurrent components, moving in opposite directions through the sentence. while the unidirectional version takes into account only context on the left of the target token, the bidirectional version recursively builds separate context representations from either side of the target token. the left and right context are then concatenated and used as the hidden representation: recurrent networks have been shown to perform well on the task of language modeling, where they learn an incremental composition function for predicting the next token in the sequence. however, while language models can estimate the probability of each token, they are unable to differentiate between infrequent and incorrect token sequences. for error detection, the composition function needs to learn to identify semantic anomalies or ungrammatical combinations, independent of their frequency. the bidirectional model provides extra information, as it allows the network to use context on both sides of the target token. irsoy2014a created an extension of this architecture by connecting together multiple layers of bidirectional elman-type recurrent network modules. this deep bidirectional rnn (figure [reference] d) calculates a context-dependent representation for each token using a bidirectional rnn, and then uses this as input to another bidirectional rnn. the multi-layer structure allows the model to learn more complex higher-level features and effectively perform multiple recurrent passes through the sentence. the long-short term memory (lstm) is an advanced alternative to the elman-type networks that has recently become increasingly popular. it uses two separate hidden vectors to pass information between different time steps, and includes gating mechanisms for modulating its own output. lstms have been successfully applied to various tasks, such as speech recognition, machine translation, and natural language generation. two sets of gating values (referred to as the input and forget gates) are first calculated based on the previous states of the network: where is the current input, is the previous hidden state, and are biases, is the previous internal state (referred to as the cell), and is the logistic function. the new internal state is calculated based on the current input and the previous hidden state, and then interpolated with the previous internal state using and as weights: where is element-wise multiplication. finally, the hidden state is calculated by passing the internal state through a nonlinearity, and weighting it with. the values of are conditioned on the new internal state (), as opposed to the previous one (): because of the linear combination in equation ([reference]), the lstm is less susceptible to vanishing gradients over time, thereby being able to make use of longer context when making predictions. in addition, the network learns to modulate itself, effectively using the gates to predict which operation is required at each time step, thereby incorporating higher-level features. in order to use this architecture for error detection, we create a bidirectional lstm, making use of the advanced features of lstm and incorporating context on both sides of the target token. in addition, we experiment with a deep bidirectional lstm, which includes two consecutive layers of bidirectional lstms, modeling even more complex features and performing multiple passes through the sentence. for comparison with non-neural models, we also report results using crfs, which are a popular choice for sequence labeling tasks. we trained the crf++ implementation on the same dataset, using as features unigrams, bigrams and trigrams in a 7-word window surrouding the target word (3 words before and after). the predicted label is also conditioned on the previous label in the sequence. section: experiments we evaluate the alternative network structures on the publicly released first certificate in english dataset (fce-public, yannakoudakis2011). the dataset contains short texts, written by learners of english as an additional language in response to exam prompts eliciting free-text answers and assessing mastery of the upper-intermediate proficiency level. the texts have been manually error-annotated using a taxonomy of 77 error types. we use the released test set for evaluation, containing 2, 720 sentences, leaving 30, 953 sentences for training. we further separate 2, 222 sentences from the training set for development and hyper-parameter tuning. the dataset contains manually annotated error spans of various types of errors, together with their suggested corrections. we convert this to a token-level error detection task by labeling each token inside the error span as being incorrect. in order to capture errors involving missing words, the error label is assigned to the token immediately after the incorrect gap- this is motivated by the intuition that while this token is correct when considered in isolation, it is incorrect in the current context, as another token should have preceeded it. as the main evaluation measure for error detection we use, which was also the measure adopted in the conll-14 shared task on error correction. it combines both precision and recall, while assigning twice as much weight to precision, since accurate feedback is often more important than coverage in error detection applications. following chodorow2012, we also report raw counts for predicted and correct tokens. related evaluation measures, such as the-scorer and the i-measure, require the system to propose a correction and are therefore not directly applicable on the task of error detection. during the experiments, the input text was lowercased and all tokens that occurred less than twice in the training data were represented as a single unk token. word embeddings were set to size and initialised using the publicly released pretrained word2vec vectors. the convolutional networks use window size on either side of the target token and produce a 300-dimensional context-dependent vector. the recurrent networks use hidden layers of size 200 in either direction. we also added an extra hidden layer of size between each of the composition functions and the output layer- this allows the network to learn a separate non-linear transformation and reduces the dimensionality of the compositional vectors. the parameters were optimised using gradient descent with initial learning rate, the adam algorithm for dynamically adapting the learning rate, and batch size of 64 sentences. on the development set was evaluated at each epoch, and the best model was used for final evaluations. section: results table [reference] contains results for experiments comparing different composition architectures on the task of error detection. the crf has the lowest score compared to any of the neural models. it memorises frequent error sequences with high precision, but does not generalise sufficiently, resulting in low recall. the ability to condition on the previous label also does not provide much help on this task- there are only two possible labels and the errors are relatively sparse. the architecture using convolutional networks performs well and achieves the second-highest result on the test set. it is designed to detect error patterns from a fixed window of 7 words, which is large enough to not require the use of more advanced composition functions. in contrast, the performance of the bidirectional recurrent network (bi-rnn) is somewhat lower, especially on the test set. in elman-type recurrent networks, the context signal from distant words decreases fairly rapidly due to the sigmoid activation function and diminishing gradients. this is likely why the bi-rnn achieves the highest precision of all systems- the predicted label is mostly influenced by the target token and its immediate neighbours, allowing the network to only detect short high-confidence error patterns. the convolutional network, which uses 7 context words with equal attention, is able to outperform the bi-rnn despite the fixed-size context window. the best overall result and highest is achieved by the bidirectional lstm composition model (bi-lstm). this architecture makes use of the full sentence for building context vectors on both sides of the target token, but improves on bi-rnn by utilising a more advanced composition function. through the application of a linear update for the internal cell representation, the lstm is able to capture dependencies over longer distances. in addition, the gating functions allow it to adaptively decide which information to include in the hidden representations or output for error detection. we found that using multiple layers of compositional functions in a deeper network gave comparable or slightly lower results for all the composition architectures. this is in contrast to irsoy2014a, who experimented with elman-type networks and found some improvements using multiple layers of bi-rnns. the differences can be explained by their task benefiting from alternative features: the evaluation was performed on opinion mining where most target sequences are longer phrases that need to be identified based on their semantics, whereas many errors in learner writing are short and can only be identified by a contextual mismatch. in addition, our networks contain an extra hidden layer before the output, which allows the models to learn higher-level representations without adding complexity through an extra compositional layer. section: additional training data there are essentially infinitely many ways of committing errors in text and introducing additional training data should alleviate some of the problems with data sparsity. we experimented with incrementally adding different error-tagged corpora into the training set and measured the resulting performance. this allows us to provide some context to the results obtained by using each of the datasets, and gives us an estimate of how much annotated data is required for optimal performance on error detection. the datasets we consider are as follows: fce-public- the publicly released subset of fce, as described in section [reference]. nucle- the nus corpus of learner english, used as the main training set for conll shared tasks on error correction. ielts- a subset of the ielts examination dataset extracted from the cambridge learner corpus (clc, nicholls2003), containing 68, 505 sentences from all proficiency levels, also used by felice2014. fce- a larger selection of fce texts from the clc, containing 323, 192 sentences. cpe- essays from the proficient examination level in the clc, containing 210, 678 sentences. cae- essays from the advanced examination level in the clc, containing 219, 953 sentences. table [reference] contains results obtained by incrementally adding training data to the bi-lstm model. we found that incorporating the nucle dataset does not improve performance over using only the fce-public dataset, which is likely due to the two corpora containing texts with different domains and writing styles. the texts in fce are written by young intermediate students, in response to prompts eliciting letters, emails and reviews, whereas nucle contains mostly argumentative essays written by advanced adult learners. the differences in the datasets offset the benefits from additional training data, and the performance remains roughly the same. in contrast, substantial improvements are obtained when introducing the ielts and fce datasets, with each of them increasing the score by roughly. the ielts dataset contains essays from all proficiency levels, and fce from mid-level english learners, which provides the model with a distribution of 'average' errors to learn from. adding even more training data from high-proficiency essays in cpe and cae only provides minor further improvements. figure [reference] also shows on the fce-public test set as a function of the total number of tokens in the training data. the optimal trade-off between performance and data size is obtained at around 8 million tokens, after introducing the fce dataset. section: conll-14 shared task the conll-14 shared task focussed on automatically correcting errors in learner writing. the nucle dataset was provided as the main training dataset, but participants were allowed to include other annotated corpora and external resources. for evaluation, 25 students were recruited to each write two new essays, which were then annotated by two experts. we used the same methods from section [reference] for converting the shared task annotation to a token-level labeling task in order to evaluate the models on error detection. in addition, the correction outputs of all the participating systems were made available online, therefore we are able to report their performance on this task. in order to convert their output to error detection labels, the corrected sentences were aligned with the original input using levenshtein distance, and any changes proposed by the system resulted in the corresponding source words being labeled as errors. the results on the two annotations of the shared task test data can be seen in table [reference]. we first evaluated each of the human annotators with respect to the other, in order to estimate the upper bound on this task. the average of roughly 50% shows that the task is difficult and even human experts have a rather low agreement. it has been shown before that correcting grammatical errors is highly subjective, but these results indicate that trained annotators can disagree even on the number and location of errors. in the same table, we provide error detection results for the top 3 participants in the shared task: camb, cuui, and amu. they each preserve their relative ranking also in the error detection evaluation. the camb system has a lower precision but the highest recall, also resulting in the highest. cuui and amu are close in performance, with amu having slightly higher precision. after the official shared task, susanto2014 published a system which combines several alternative models and outperforms the shared task participants when evaluated on error correction. however, on error detection it receives lower results, ranking 3rd and 4th when evaluated on (p1+ p2+ s1+ s2 in table [reference]). the system has detected a small number of errors with high precision, and does not reach the highest. finally, we present results for the bi-lstm sequence labeling system for error detection. using only fce-public for training, the overall performance is rather low as the training set is very small and contains texts from a different domain. however, these results show that the model behaves as expected- since it has not seen similar language during training, it labels a very large portion of tokens as errors. this indicates that the network is trying to learn correct language constructions from the limited data and classifies unseen structures as errors, as opposed to simply memorising error sequences from the training data. when trained on all the datasets from section [reference], the model achieves the highest of all systems on both of the conll-14 shared task test annotations, with an absolute improvement of over the previous best result. it is worth noting that the full bi-lstm has been trained on more data than the other conll contestants. however, as the shared task systems were not restricted to the nucle training set, all the submissions also used differing amounts of training data from various sources. in addition, the conll systems are mostly combinations of many alternative models: the camb system is a hybrid of machine translation, a rule-based system, and a language model re-ranker; cuui consists of different classifiers for each individual error type; and p1+ p2+ s1+ s2 is a combination of four different error correction systems. in contrast, the bi-lstm is a single model for detecting all error types, and therefore represents a more scalable data-driven approach. section: essay scoring in this section, we perform an extrinsic evaluation of the efficacy of the error detection system and examine the extent to which it generalises at higher levels of granularity on the task of automated essay scoring. more specifically, we replicate experiments using the text-level model described by andersen2013, which is currently deployed in a self-assessment and tutoring system (sat), an online automated writing feedback tool actively used by language learners. the sat system predicts an overall score for a given text, which provides a holistic assessment of linguistic competence and language proficiency. the authors trained a supervised ranking perceptron model on the fce-public dataset, using features such as error-rate estimates from a language model and various lexical and grammatical properties of text (e.g., word n-grams, part-of-speech n-grams and phrase-structure rules). we replicate this experiment and add the average probability of each token in the essay being correct, according to the error detection model, as an additional feature for the scoring framework. the system was then retrained on fce-public and evaluated on correctly predicting the assigned essay score. table [reference] presents the experimental results. the human performance on the test set is calculated as the average inter-annotator correlation on the same data, and the existing sat system has demonstrated levels of performance that are very close to that of human assessors. nevertheless, the bi-lstm model trained only on fce-public complements the existing features, and the combined model achieves an absolute improvement of around 1% percent, corresponding to 20-31% relative error reduction with respect to the human performance. even though the bi-lstm is trained on the same dataset and the sat system already includes various linguistic features for capturing errors, our error detection model manages to further improve its performance. when the bi-lstm is trained on all the available data from section [reference], the combination achieves further substantial improvements. the relative error reduction on pearson's correlation is 64%, and the system actually outperforms human annotators on spearman's correlation. section: conclusions in this paper, we presented the first experiments using neural network models for the task of error detection in learner writing. six alternative compositional network architectures for modeling context were evaluated. based on the findings, we propose a novel error detection framework using token-level embeddings, bidirectional lstms for context representation, and a multi-layer architecture for learning more complex features. this structure allows the model to classify each token as being correct or incorrect, using the full sentence as context. the self-modulation architecture of lstms was also shown to be beneficial, as it allows the network to learn more advanced composition rules and remember dependencies over longer distances. substantial performance improvements were achieved by training the best model on additional datasets. we found that the largest benefit was obtained from training on 8 million tokens of text from learners with varying levels of language proficiency. in contrast, including even more data from higher-proficiency learners gave marginal further improvements. as part of future work, it would be beneficial to investigate the effect of automatically generated training data for error detection (e.g., rozovskaya2010). we evaluated the performance of existing error correction systems from conll-14 on the task of error detection. the experiments showed that success on error correction does not necessarily mean success on error detection, as the current best correction system (p1+ p2+ s1+ s2) is not the same as the best shared task detection system (camb). in addition, the neural sequence tagging model, specialised for error detection, was able to outperform all other participating systems. finally, we performed an extrinsic evaluation by incorporating probabilities from the error detection system as features in an essay scoring model. even without any additional data, the combination further improved performance which is already close to the results from human annotators. in addition, when the error detection model was trained on a larger training set, the essay scorer was able to exceed human-level performance. section: acknowledgments we would like to thank prof ted briscoe and the reviewers for providing useful feedback. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "conll-14"
                    ],
                    [
                        "conll-14 shared task dataset"
                    ],
                    [
                        "ielts examination dataset"
                    ],
                    [
                        "fce datasets"
                    ],
                    [
                        "ielts dataset"
                    ],
                    [
                        "fce public test set"
                    ]
                ],
                "Method": [
                    [
                        "compositional sequence labeling"
                    ]
                ],
                "Metric": [
                    [
                        "average errors"
                    ]
                ],
                "Task": [
                    [
                        "error detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "learner writing"
                    ],
                    [
                        "error detection"
                    ],
                    [
                        "token level error detection task"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "conll-14 shared task dataset",
                        "conll-14 shared task",
                        "conll contestants",
                        "conll-14"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": [
                    [
                        "error detection",
                        "detection",
                        "automatically detecting errors",
                        "grammatical error detection",
                        "error detection systems",
                        "grammatical error correction",
                        "error detection applications",
                        "error detection evaluation"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "first certificate in english dataset",
                        "fce-public",
                        "fce",
                        "fce texts",
                        "fce datasets",
                        "fce dataset"
                    ]
                ],
                "Method": [
                    [
                        "deep bidirectional lstm",
                        "bidirectional lstm composition model"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "error detection",
                        "detection",
                        "automatically detecting errors",
                        "grammatical error detection",
                        "error detection systems",
                        "grammatical error correction",
                        "error detection applications",
                        "error detection evaluation"
                    ]
                ]
            }
        ]
    },
    "0a6c36de8726b6feaab586046ddc1d1a008f44f9-9": {
        "doctext": "document: filtered channel features for pedestrian detection this paper starts from the observation that multiple top performing pedestrian detectors can be modelled by using an intermediate layer filtering low-level features in combination with a boosted decision forest. based on this observation we propose a unifying framework and experimentally explore different filter families. we report extensive results enabling a systematic analysis. using filtered channel features we obtain top performance on the challenging caltech and kitti datasets, while using only hog+ luv as low-level features. when adding optical flow features we further improve detection quality and report the best known results on the caltech dataset, reaching 93% recall at 1 fppi.=-1 section: introduction pedestrian detection is an active research area, with 1000+ papers published in the last decade, and well established benchmark datasets. it is considered a canonical case of object detection, and has served as playground to explore ideas that might be effective for generic object detection. although many different ideas have been explored, and detection quality has been steadily improving, arguably it is still unclear what are the key ingredients for good pedestrian detection; e.g. it remains unclear how effective parts, components, and features learning are for this task. current top performing pedestrian detection methods all point to an intermediate layer (such as max-pooling or filtering) between the low-level feature maps and the classification layer. in this paper we explore the simplest of such intermediary: a linear transformation implemented as convolution with a filter bank. we propose a framework for filtered channel features (see figure [reference]) that unifies multiple top performing methods, and that enables a systematic exploration of different filter banks. with our experiments we show that, with the proper filter bank, filtered channel features reach top detection quality. it has been shown that using extra information at test time (such as context, stereo images, optical flow, etc.) can boost detection quality. in this paper we focus on the ''core'' sliding window algorithm using solely hog+ luv features (i.e. oriented gradient magnitude and colour features). we consider context information and optical flow as add-ons, included in the experiments section for the sake of completeness and comparison with existing methods. using only hog+ luv features we already reach top performance on the challenging caltech and kitti datasets, matching results using optical flow and significantly more features (such as lbp and covariance). subsection: related work recent survey papers discuss the diverse set of ideas explored for pedestrian detection. the most recent survey indicates that the classifier choice (e.g. linear/ non-linear svm versus decision forest) is not a clear differentiator regarding quality; rather the features used seem more important. creativity regarding different types of features has not been lacking. hog) the classic hog descriptor is based on local image differences (plus pooling and normalization steps), and has been used directly, as input for a deformable parts model, or as features to be boosted. the integral channel features detector uses a simpler hog variant with sum pooling and no normalizations. many extensions of hog have been proposed (e.g.). lbp) instead of using the magnitude of local pixel differences, lbp uses the difference sign only as signal. colour) although the appearance of pedestrians is diverse, the background and skin areas do exhibit a colour bias. colour has shown to be an effective feature for pedestrian detection and hence multiple colour spaces have been explored (both hand-crafted and learned). local structure) instead of simple pixel values, some approaches try to encode a larger local structure based on colour similarities (soft-cue), segmentation methods (hard-decision), or by estimating local boundaries. covariance) another popular way to encode richer information is to compute the covariance amongst features (commonly colour, gradient, and oriented gradient). etc.) other features include bag-of-words over colour, hog, or lbp features; learning sparse dictionary encoders; and training features via a convolutional neural network. additional features specific for stereo depth or optical flow have been proposed, however we consider these beyond the focus of this paper. for our flow experiments we will use difference of frames from weakly stabilized videos (sdt). all the feature types listed above can be used in the integral channel features detector framework. this family of detectors is an extension of the old ideas from viola& jones. sums of rectangular regions are used as input to decision trees trained via adaboost. both the regions to pool from and the thresholds in the decision trees are selected during training. the crucial difference from the pioneer work is that the sums are done over feature channels other than simple image luminance. current top performing pedestrian detection methods (dominating inria, caltech and kitti datasets) are all extensions of the basic integral channel features detector (named chnftrs in, which uses only hog+ luv features). squareschnftrs, informedhaar, and ldcf, are discussed in detail in section [reference]. katamari exploits context and optical flow for improved performance. spatialpooling (+) adds max-pooling on top of sum-pooling, and uses additional features such as covariance, lbp, and optical flow. similarly, regionlets also uses extended features and max-pooling, together with stronger weak classifiers and training a cascade of classifiers. out of these, regionlets is the only method that has also shown good performance on general classes datasets such as pascal voc and imagenet. in this paper we will show that vanilla hog+ luv features have not yet saturated, and that, when properly used, they can reach top performance for pedestrian detection. subsection: contributions we point out the link between acf, (squares) chnftrs, informedhaar, and ldcf. see section [reference]. we provide extensive experiments to enable a systematic analysis of the filtered integral channels, covering aspects not explored by related work. we report the summary of trained models (corresponding days of single machine computation). see sections [reference], [reference] and [reference]. we show that top detection performance can be reached on caltech and kitti using hog+ luv features only. we additionally report the best known results on caltech. see section [reference]. section: filtered channel features before entering the experimental section, let us describe our general architecture. methods such as chnftrs, squareschnftrs and acf all use the basic architecture depicted in figure [reference] top part (best viewed in colours). the input image is transformed into a set of feature channels (also called feature maps), the feature vector is constructed by sum-pooling over a (large) set of rectangular regions. this feature vector is fed into a decision forest learned via adaboost. the split nodes in the trees are a simple comparison between a feature value and a learned threshold. commonly only a subset of the feature vector is used by the learned decision forest. adaboost serves both for feature selection and for learning the thresholds in the split nodes. a key observation, illustrated in figure [reference] (bottom), is that such sum-pooling can be re-written as convolution with a filter bank (one filter per rectangular shape) followed by reading a single value of the convolution's response map. this ''filter+ pick'' view generalizes the integral channel features detectors by allowing to use any filter bank (instead of only rectangular shapes). we name this generalization ''filtered channel features detectors''. in our framework, acf has a single filter in its bank, corresponding to a uniform pooling region. chnftrs was a very large (tens of thousands) filter bank comprised of random rectangular shapes. squareschnftrs, on the other hand, was only filters, each with a square-shaped uniform pooling region of different sizes. see figure [reference] for an illustration of the squareschnftrs filters, the upper-left filter corresponds to acf's one. the informedhaar method can also be seen as a filtered channel features detector, where the filter bank (and read locations) are based on a human shape template (thus the ''informed'' naming). ldcf is also a particular instance of this framework, where the filter bank consists of pca bases of patches from the training dataset. in sections [reference] and [reference] we provide experiments revisiting some of the design decisions of these methods. note that all the methods mentioned above (and in the majority of experiments below) use only hog+ luv feature channels (10 channels total). using linear filters and decision trees on top of these does not allow to reconstruct the decision functions obtained when using lbp or covariance features (used by spatialpooling and regionlets). we thus consider the approach considered here orthogonal to adding such types of features. subsection: evaluation protocol for our experiments we use the caltech and kitti datasets. the popular inria dataset is considered too small and too close to saturation to provide interesting results. all caltech results are evaluated using the provided toolbox, and summarised by log-average miss-rate (mr, lower is better) in the range for the ''reasonable'' setup. kitti results are evaluated via the online evaluation portal, and summarised as average precision (ap, higher is better) for the ''moderate'' setup. paragraph: caltech10x the raw caltech dataset consists of videos (acquired at) with every frame annotated. the standard training and evaluation considers one out of each frames (pedestrians over frames in training, pedestrians over frames in testing). in our experiments of section [reference] we will also consider a increased training set where every rd frame is used (linear growth in pedestrians and images). we name this extended training set ''caltech10x''. ldcf uses a similar extended set for training its model (every th frame). paragraph: flow methods using optical flow do not only use additional neighbour frames during training (depending on the method), but they also do so at test time. because they have access to additional information at test time, we consider them as a separate group in our results section. paragraph: validation set in order to explore the design space of our pedestrian detector we setup a caltech validation set by splitting the six training videos into five for training and one for testing (one of the splits suggested in). most of our experiments use this validation setup. we also report (a posteriori) our key results on the standard test set for comparison to the state of the art. for the kitti experiments we also validate some design choices (such as search range and number of scales) before submission on the evaluation server. there we use a validation setup. subsection: baselines paragraph: acf our experiments are based on the open source release of acf. our first baseline is vanilla acf re-trained on the standard caltech set (not caltech10x). on the caltech test set it obtains (on validation set). note that this baseline already improves over more than previously published methods on this dataset. there is also a large gap between acf-ours () and the original number from acf-caltech (). the improvement is mainly due to the change towards a larger model size (from to). all parameter details are described in section [reference], and kept identical across experiments unless explicitly stated. paragraph: informedhaar our second baseline is a re-implementation of informedhaar. here again we observe an important gain from using a larger model size (same change as for acf). while the original informedhaar paper reports, informedhaar-ours reaches on the caltech test set (on validation set). for both our baselines we use exactly the same training set as the original papers. note that the informedhaar-ours baseline () is right away the best known result for a method trained on the standard caltech training set. in section [reference] we will discuss our re-implementation of ldcf. subsection: model parameters unless otherwise specified we train all our models using the following parameters. feature channels are hog+ luv only. the final classifier includes level-2 decision trees (l2, 3 stumps per tree), trained via vanilla discrete adaboost. each tree is built by doing exhaustive greedy search for each node (no randomization). the model has size, and is built via four rounds of hard negative mining (starting from a model with trees, and then,,, trees). each round adds additional negatives to the training set. the sliding window stride is (both during hard negative mining and at test time). compared to the default acf parameters, we use a bigger model, more trees, more negative samples, and more boosting rounds. but we do use the same code-base and the same training set. starting from section [reference] we will also consider results with the caltech10x data, there we use level-4 decision trees (l4), and realboost instead of discrete adaboost. all other parameters are left unchanged. section: filter bank families given the general architecture and the baselines described in section [reference], we now proceed to explore different types of filter banks. some of them are designed using prior knowledge and they do not change when applied across datasets, others exploit data-driven techniques for learning their filters. sections [reference] and [reference] will compare their detection quality. paragraph: informedfilters starting from the informedhaar baseline we use the same ''informed'' filters but let free the positions where they are applied (instead of fixed in informedhaar); these are selected during the boosting learning. our initial experiments show that removing the position constraint has a small (positive) effect. additionally we observe that the original informedhaar filters do not include simple square pooling regions (\u00e0 la squareschnftrs), we thus add these too. we end up with filters in total, to be applied over each of the feature channels. this is equivalent to training decision trees over (non filtered) channel features. as illustrated in figure [reference] the informedfilters have different sizes, from to cells (), and each cell takes a value in. these filters are applied with a step size of. for a model of this results in features per channel, features in total. in practice considering border effects (large filters are not applied on the border of the model to avoid reading outside it) we end up with features. when training level-2 decision trees, at most features will be used, that is of the total. in this scenario (and all others considered in this paper) adaboost has a strong role of feature selection. paragraph: checkerboards as seen in section [reference] informedhaar is a strong baseline. it is however unclear how much the ''informed'' design of the filters is effective compared to other possible choices. checkerboards is a na\u00efve set of filters that covers the same sizes (in number of cells) as informedhaar/ informedfilters and for each size defines (see figure [reference]): a uniform square, all horizontal and vertical gradient detectors (values), and all possible checkerboard patterns. these configurations are comparable to informedfilters but do not use the human shape as prior. the total number of filters is a direct function of the maximum size selected. for up to cells we end up with filters, up to cells filters, up to cells filters, and up to cells filters. paragraph: randomfilters our next step towards removing a hand-crafted design is simply using random filters (see figure [reference]). given a desired number of filters and a maximum filter size (in cells), we sample the filter size with uniform distribution, and set its cell values to with uniform probability. we also experimented with values and observed a (small) quality decrease compared to the binary option). the design of the filters considered above completely ignores the available training data. in the following, we consider additional filters learned from data. paragraph: ldcf the work on pcanet showed that applying arbitrary non-linearities on top of pca projections of image patches can be surprisingly effective for image classification. following this intuition ldcf uses learned pca eigenvectors as filters (see figure [reference]). we present a re-implementation of based on acf's source code. we try to follow the original description as closely as possible. we use the same top filters of, selected per feature channel based on their eigenvalues (filters total). we do change some parameters to be consistent amongst all experiments, see sections [reference] and [reference]. the main changes are the training set (we use caltech10x, sampled every 3 frames, instead of every 4 frames in), and the model size (pixels instead of). as will be shown in section [reference], our implementation (ldcf-ours) clearly improves over the previously published numbers, showing the potential of the method. for comparison with pcaforeground we also consider training ldcf8 where the top filters are selected per channel (filters total). paragraph: pcaforeground in ldcf the filters are learned using all of the training data available. in practice this means that the learned filters will be dominated by background information, and will have minimal information about the pedestrians. put differently, learning filters from all the data assumes that the decision boundary is defined by a single distribution (like in linear discriminant analysis), while we might want to define it based on the relation between the background distribution and the foreground distribution (like fisher's discriminant analysis). in pcaforeground we train filters per feature channel, learned from background image patches, and learned from patches extracted over pedestrians (see figure [reference]). compared to ldcf8 the obtained filters are similar but not identical, all other parameters are kept identical. other than via pcaforeground/ ldcf8, it is not clear how to further increase the number of filters used in ldcf. past filters per channel, the eigenvalues decrease to negligible values and the eigenvectors become essentially random (similar to randomfilters). to keep the filtered channel features setup close to informedhaar, the filters are applied with a step of however, to stay close to the original ldcf, the ldcf/ pcaforeground filters are evaluated every. although (for example) ldcf8 uses only of the number of filters per channel compared to checkerboards4x4, due to the step size increase, the obtained feature vector size is. section: how many filters? given a fixed set of channel features, a larger filter bank provides a richer view over the data compared to a smaller one. with enough training data one would expect larger filter banks to perform best. we want thus to analyze the trade-off between number of filters and detection quality, as well as which filter bank family performs best. figure [reference] presents the results of our initial experiments on the caltech validation set. it shows detection quality versus number of filters per channel. this figure densely summarizes trained models. paragraph: informedfilters the first aspect to notice is that there is a meaningful gap between informedhaar-ours and informedfilters despite having a similar number of filters (versus). this validates the importance of letting adaboost choose the pooling locations instead of hand-crafting them. keep in mind that informedhaar-ours is a top performing baseline (see\u00a7 [reference]). secondly, we observe that (for the fixed training data available) filters is better than. below filters the performance degrades for all methods (as expected). to change the number of filters in informedfilters we train a full model (filters), pick the most frequently used filters (selected from node splitting in the decision forest), and use these to train the desired reduced model. we can select the most frequent filters across channels or per channel (marked as inf. filtersperchannel). we observe that per channel selection is slightly worse than across channels, thus we stick to the latter. using the most frequently used filters for selection is clearly a crude strategy since frequent usage does not guarantee discriminative power, and it ignores relation amongst filters. we find this strategy good enough to convey the main points of this work. paragraph: checkerboards also reaches best results in the filters region. here the number of filters is varied by changing the maximum filter size (in number of cells). regarding the lowest miss-rate there is no large gap between the ''informed'' filters and this na\u00efve baseline. paragraph: randomfilters the hexagonal dots and their deviation bars indicate the mean, maximum and minimum miss-rate obtained out of five random runs. when using a larger number of filters () we observe a lower (better) mean but a larger variance compared to when using fewer filters (). here again the gap between the best random run and the best result of other methods is not large. given a set of five models, we select the most frequently used filters and train new reduced models; these are shown in the randomfilters line. overall the random filters are surprisingly close to the other filter families. this indicates that expanding the feature channels via filtering is the key step for improving detection quality, while selecting the ''perfect'' filters is a secondary concern. paragraph: ldcf/ pcaforeground in contrast to the other filter bank families, ldcf under-performs when increasing the number of filters (from to) while using the standard caltech training set (consistent with the observations in). pcaforeground improves marginally over ldcf8. paragraph: takeaways from figure [reference] we observe two overall trends. first, the more filters the merrier, with filters as sweet spot for caltech training data. second, there is no flagrant difference between the different filter types. section: additional training data one caveat of the previous experiments is that as we increase the number of filters used, so does the number of features adaboost must pick from. since we increased the model capacity (compared to acf which uses a single filter), we consider using the caltech10x dataset (\u00a7 [reference]) to verify that our models are not starving for data. similar to the experiments in, we also reconsider the decision tree depth, since additional training data enables bigger models. results for two representative methods are collected in table [reference]. first we observe that already with the original training data, deeper trees do provide significant improvement over level-2 (which was selected when tuning over inria data). second, we notice that increasing the training data volume does provide the expected improvement only when the decision trees are deep enough. for our following experiments we choose to use level-4 decision trees () as a good balance between increased detection quality and reasonable training times. paragraph: realboost although previous papers on chnftrs detectors reported that different boosting variants all obtain equal results on this task, the recent indicated that realboost has an edge over discrete adaboost when additional training data is used. we observe the same behaviour in our caltech10x setup. as summarized in table [reference] using filtered channels, deeper trees, additional training data, and realboost does provide a significant detection quality boost. for the rest of the paper our models trained on caltech10x all use level-4 trees and realboost, instead of level-2 and discrete adaboost for the caltech1x models. paragraph: timing when using caltech data acf takes about one hour for training and one for testing. checkerboards4x4 takes about and hours respectively. when using caltech10x the training times for these methods augment to 2 and 29 hours, respectively. the training time does not increase proportionally with the training data volume because the hard negative mining reads a variable amount of images to attain the desired quota of negative samples. this amount increases when a detector has less false positive mistakes. subsection: validation set experiments based on the results in table [reference] we proceed to evaluate on caltech10x the most promising configurations (filter type and number) from section [reference]. the results over the caltech validation set are collected in table [reference]. we observe a clear overall gain from increasing the training data. interestingly with enough randomfilters we can outperform the strong performance of ldcf-ours. we also notice that the na\u00efve checkerboards outperforms the manual design of informedfilters. section: add-ons before presenting the final test set results of our ''core'' method (section [reference]), we also consider some possible ''add-ons'' based on the suggestions from. for the sake of evaluating complementarity, comparison with existing method, and reporting the best possible detection quality, we consider extending our detector with context and optical flow information. paragraph: context context is modelled via the 2ped re-scoring method of. it is a post-processing step that merges our detection scores with the results of a two person dpm trained on the inria dataset (with extended annotations). in the authors reported an improvement of (percent points) on the caltech set, across different methods. in an improvement of is reported over their strong detector (squareschnftrs+ dct+ sdt). in our experiments however we obtain a gain inferior to. we have also investigated fusing the 2ped detection results via a different, more principled, fusion method. we observe consistent results: as the strength of the starting point increases, the gain from 2ped decreases. when reaching our checkerboards results, all gains have evaporated. we believe that the 2ped approach is a promising one, but our experiments indicate that the used dpm template is simply too weak in comparison to our filtered channels. paragraph: optical flow optical flow is fed to our detector as an additional set of channels (not filtered). we use the implementation from sdt which uses differences of weakly stabilized video frames. on caltech, the authors of reported a gain over acf (), while reported a percent points improvement over their strong baseline (squareschnftrs+ dct+ 2ped\u2062%27.4mr). when using+ sdt our results are directly comparable to katamari and spatialpooling+ which both use optical flow too. using our stronger checkerboards results sdt provides a gain. here again we observe an erosion as the starting point improves (for confirmation, reproduced the acf+ sdt results,). we name our checkerboards+ sdt detector all-in-one. our filtered channel features results are strong enough to erode existing context and flow features. although these remain complementary cues, more sophisticated ways of extracting this information will be required to further progress in detection quality. it should be noted that despite our best efforts we could not reproduce the results from neither 2ped nor sdt on the kitti dataset (in spite of its apparent similarity to caltech). effective methods for context and optical flow across datasets have yet to be shown. our main contribution remains on the core detector (only hog+ luv features over local sliding window pixels in a single frame). section: test set results having done our exploration of the parameters space on the validation set, we now evaluate the most promising methods on the caltech and kitti test sets. paragraph: caltech test set figures [reference] and [reference] present our key results on the caltech test set. for proper comparison, only methods using the same training set should be compared (see for a similar table comparing previous methods). we include for comparison the baselines mentioned in section [reference], roerei [] the best known method trained without any caltech images, mt-dpm [] the best known method based on dpm, and sdn [] the best known method using convolutional neural networks. we also include the top performers katamari and spatialpooling+. we mark as '''' both the caltech10x training set and the one used in ldcf (see section [reference]). paragraph: kitti test set figure [reference] presents the results on the kitti test set (''moderate'' setup), together with all other reported methods using only monocular image content (no stereo or lidar data). the kitti evaluation server only recently has started receiving submissions (for this task, in the last year), and thus is less prone to dataset over-fitting. we train our model on the kitti training set using almost identical parameters as for caltech. the only change is a subtle pre-processing step in the hog+ luv computation. on kitti the input image is smoothed (radius) before the feature channels are computed, while on caltech we do not. this subtle change provided a (percent points) improvement on the kitti validation set. subsection: analysis with a (percent points) gap between acf/ informedhaar and acf/ informedhaar-ours (see figure [reference]), the results of our baselines show the importance of proper validation of training parameters (large enough model size and negative samples). informedhaar-ours is the best reported result when training with caltech1x. when considering methods trained on caltech10x, we obtain a clear gap with the previous best results (ldcf checkerboards). using our architecture and the adequate number of filters one can obtain strong results using only hog+ luv features. the exact type of filters seems not critical, in our experiments checkerboards4x3 gets best performance given the available training data. randomfilters reaches the same result, but requires training and merging multiple models. our results cut by half miss-rate of the best known convnet for pedestrian detection (sdn []), which in principle could learn similar low-level features and their filtering. when adding optical flow we further push the state of the art and reach, a comfortable improvement over the previous best optical flow method (spatialpooling+). this is the best reported result on this challenging dataset. the results on the kitti dataset confirm the strength of our approach, reaching, just below the best known result on this dataset. competing methods (regionlets [] and spatialpooling) both use hog together with additional lbp and covariance features. adding these remains a possibility for our system. note that our results also improve over methods using lidar+ image, such as fusion-dpm (, not included in figure [reference] for clarity). section: conclusion through this paper we have shown that the seemingly disconnected methods acf, (squares) chnftrs, informedhaar, and ldcf can be all put under the filtered channel features detectors umbrella. we have systematically explored different filter banks for such architecture and shown that they provide means for important improvements for pedestrian detection. our results indicate that hog+ luv features have not yet saturated, and that competitive results (over caltech and kitti datasets) can be obtained using only them. when optical flow information is added we set the new state of art for the caltech dataset, reaching (recall at false positive per image). in future work we plan to explore how the insights of this work can be exploited into a more general detection architecture such as convolutional neural networks. paragraph: acknowledgements we thank jan hosang for the help provided setting up some of the experiments. we also thank seong joon oh and sabrina hoppe for their useful comments. bibliography: references appendix: learned model in figures [reference] and [reference] we present some qualitative aspects of the final learned models checkerboards4x3 and randomfilters (see results section of main paper), not included in the main submission due to space limitations. in figure [reference] we compare the spatial distribution of our models versus a significantly weaker model (roerei, trained on inria, see figure 5 of main paper). we observe that our strong models focalize in similar areas than the weak roerei model. this indicates that using filtered channels does not change which areas of the pedestrian are informative, but rather that at the same locations filtered channels are able to extract more discriminative information. in all three models we observe that diagonal oriented channels focus on left and right shoulders. the u colour channel is mainly used around the face, while l (luminance) and gradient magnitude () channels are used all over the body. overall head, feet, and upper torso areas provide most clues for detection. in figure [reference] we observe that the filters usage distribution is similar across different filter bank families. [filters from roerei (scale) model. copied from] [final checkerboards4x3 model] [final randomfilters model] [filters used in our final checkerboards4x3 model] [filters used in our final randomfilters model]",
        "pred_templates": [
            {
                "Material": [
                    [
                        "caltech"
                    ],
                    [
                        "caltech dataset"
                    ],
                    [
                        "inria dataset"
                    ]
                ],
                "Method": [
                    [
                        "filtered channel features"
                    ],
                    [
                        "hog+ luv"
                    ]
                ],
                "Metric": [
                    [
                        "average precision"
                    ]
                ],
                "Task": [
                    [
                        "pedestrian detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "object detection"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "caltech",
                        "caltech dataset",
                        "caltech10x",
                        "caltech validation set",
                        "caltech set",
                        "caltech test set",
                        "caltech training set",
                        "caltech training data",
                        "caltech10x setup",
                        "caltech data",
                        "caltech images"
                    ]
                ],
                "Method": [
                    [
                        "checkerboards",
                        "checkerboards4x4",
                        "checkerboards4x3",
                        "checkerboards4x3 model"
                    ]
                ],
                "Metric": [
                    [
                        "log-average miss-rate",
                        "mr",
                        "miss-rate",
                        "minimum miss-rate"
                    ]
                ],
                "Task": [
                    [
                        "pedestrian detection",
                        "detection",
                        "2ped detection"
                    ]
                ]
            }
        ]
    },
    "0c47cad9729c38d9db1f75491b1ee4bd883a5d4e-10": {
        "doctext": "document: semi-supervised sequence modeling with cross-view training kevclark@cs.stanford.edu, thangluong@google.com, manning@cs.stanford.edu, qvl@google.com unsupervised representation learning algorithms such as word2vec and elmo improve the accuracy of many supervised nlp models, mainly because they can take advantage of large amounts of unlabeled text. however, the supervised models only learn from task-specific labeled data during the main training phase. we therefore propose cross-view training (cvt), a semi-supervised learning algorithm that improves the representations of a bi-lstm sentence encoder using a mix of labeled and unlabeled data. on labeled examples, standard supervised learning is used. on unlabeled examples, cvt teaches auxiliary prediction modules that see restricted views of the input (e.g., only part of a sentence) to match the predictions of the full model seeing the whole input. since the auxiliary modules and the full model share intermediate representations, this in turn improves the full model. moreover, we show that cvt is particularly effective when combined with multi-task learning. we evaluate cvt on five sequence tagging tasks, machine translation, and dependency parsing, achieving state-of-the-art results. section: introduction deep learning models work best when trained on large amounts of labeled data. however, acquiring labels is costly, motivating the need for effective semi-supervised learning techniques that leverage unlabeled examples. a widely successful semi-supervised learning strategy for neural nlp is pre-training word vectors mikolov2013distributedro. more recent work trains a bi-lstm sentence encoder to do language modeling and then incorporates its context-sensitive representations into supervised models dai2015semi, peters2018deep. such pre-training methods perform unsupervised representation learning on a large corpus of unlabeled data followed by supervised training. a key disadvantage of pre-training is that the first representation learning phase does not take advantage of labeled data- the model attempts to learn generally effective representations rather than ones that are targeted towards a particular task. older semi-supervised learning algorithms like self-training do not suffer from this problem because they continually learn about a task on a mix of labeled and unlabeled data. self-training has historically been effective for nlp yarowsky1995unsupervised, mcclosky2006effective, but is less commonly used with neural models. this paper presents cross-view training (cvt), a new self-training algorithm that works well for neural sequence models. in self-training, the model learns as normal on labeled examples. on unlabeled examples, the model acts as both a\u00e2\u0080\u009cteacher\u00e2\u0080\u009d that makes predictions about the examples and a\u00e2\u0080\u009cstudent\u00e2\u0080\u009d that is trained on those predictions. although this process has shown value for some tasks, it is somewhat tautological: the model already produces the predictions it is being trained on. recent research on computer vision addresses this by adding noise to the student's input, training the model so it is robust to input perturbations sajjadi2016regularization, wei2018improving. however, applying noise is difficult for discrete inputs like text. as a solution, we take inspiration from multi-view learning blum1998combining, xu2013aso and train the model to produce consistent predictions across different views of the input. instead of only training the full model as a student, cvt adds auxiliary prediction modules- neural networks that transform vector representations into predictions- to the model and also trains them as students. the input to each student prediction module is a subset of the model's intermediate representations corresponding to a restricted view of the input example. for example, one auxiliary prediction module for sequence tagging is attached to only the\" forward\" lstm in the model's first bi-lstm layer, so it makes predictions without seeing any tokens to the right of the current one. cvt works by improving the model's representation learning. the auxiliary prediction modules can learn from the full model's predictions because the full model has a better, unrestricted view of the input. as the auxiliary modules learn to make accurate predictions despite their restricted views of the input, they improve the quality of the representations they are built on top of. this in turn improves the full model, which uses the same shared representations. in short, our method combines the idea of representation learning on unlabeled data with classic self-training. cvt can be applied to a variety of tasks and neural architectures, but we focus on sequence modeling tasks where the prediction modules are attached to a shared bi-lstm encoder. we propose auxiliary prediction modules that work well for sequence taggers, graph-based dependency parsers, and sequence-to-sequence models. we evaluate our approach on english dependency parsing, combinatory categorial grammar supertagging, named entity recognition, part-of-speech tagging, and text chunking, as well as english to vietnamese machine translation. cvt improves over previously published results on all these tasks. furthermore, cvt can easily and effectively be combined with multi-task learning: we just add additional prediction modules for the different tasks on top of the shared bi-lstm encoder. training a unified model to jointly perform all of the tasks except machine translation improves results (outperforming a multi-task elmo model) while decreasing the total training time. section: cross-view training we first present cross-view training and describe how it can be combined effectively with multi-task learning. see figure [reference] for an overview of the training method. subsection: method let represent a labeled dataset and represent an unlabeled dataset we use to denote the output distribution over classes produced by the model with parameters on input. during cvt, the model alternates learning on a minibatch of labeled examples and learning on a minibatch of unlabeled examples. for labeled examples, cvt uses standard cross-entropy loss: cvt adds auxiliary prediction modules to the model, which are used when learning on unlabeled examples. a prediction module is usually a small neural network (e.g., a hidden layer followed by a softmax layer). each one takes as input an intermediate representation produced by the model (e.g., the outputs of one of the lstms in a bi-lstm model). it outputs a distribution over labels. each is chosen such that it only uses a part of the input; the particular choice can depend on the task and model architecture. we propose variants for several tasks in section [reference]. the auxiliary prediction modules are only used during training; the test-time prediction come from the primary prediction module that produces. on an unlabeled example, the model first produces soft targets by performing inference. cvt trains the auxiliary prediction modules to match the primary prediction module on the unlabeled data by minimizing where is a distance function between probability distributions (we use kl divergence). we hold the primary module's prediction fixed during training (i.e., we do not back-propagate through it) so the auxiliary modules learn to imitate the primary one, but not vice versa. cvt works by enhancing the model's representation learning. as the auxiliary modules train, the representations they take as input improve so they are useful for making predictions even when some of the model's inputs are not available. this in turn improves the primary prediction module, which is built on top of the same shared representations. we combine the supervised and cvt losses into the total loss,, and minimize it with stochastic gradient descent. in particular, we alternate minimizing over a minibatch of labeled examples and minimizing over a minibatch of unlabeled examples. for most neural networks, adding a few additional prediction modules is computationally cheap compared to the portion of the model building up representations (such as an rnn or cnn). therefore our method contributes little overhead to training time over other self-training approaches for most tasks. cvt does not change inference time or the number of parameters in the fully-trained model because the auxiliary prediction modules are only used during training. subsection: combining cvt with multi-task learning cvt can easily be combined with multi-task learning by adding additional prediction modules for the other tasks on top of the shared bi-lstm encoder. during supervised learning, we randomly select a task and then update using a minibatch of labeled data for that task. when learning on the unlabeled data, we optimize jointly across all tasks at once, first running inference with all the primary prediction modules and then learning from the predictions with all the auxiliary prediction modules. as before, the model alternates training on minibatches of labeled and unlabeled examples. examples labeled across many tasks are useful for multi-task systems to learn from, but most datasets are only labeled with one task. a benefit of multi-task cvt is that the model creates (artificial) all-tasks-labeled examples from unlabeled data. this significantly improves the model's data efficiency and training time. since running prediction modules is computationally cheap, computing is not much slower for many tasks than it is for a single one. however, we find the all-tasks-labeled examples substantially speed up model convergence. for example, our model trained on six tasks takes about three times as long to converge as the average model trained on one task, a 50% decrease in total training time. section: cross-view training models cvt relies on auxiliary prediction modules that have restricted views of the input. in this section, we describe specific constructions of the auxiliary prediction modules that are effective for sequence tagging, dependency parsing, and sequence-to-sequence learning. subsection: bi-lstm sentence encoder all of our models use a two-layer cnn-bilstm chiu2015named, ma2016end sentence encoder. it takes as input a sequence of words. first, each word is represented as the sum of an embedding vector and the output of a character-level convolutional neural network, resulting in a sequence of vectors. the encoder applies a two-layer bidirectional lstm graves2005framewise to these representations. the first layer runs a long short-term memory unit hochreiter1997long in the forward direction (taking as input at each step) and the backward direction (taking at each step) to produce vector sequences and. the output of the bi-lstm is the concatenation of these vectors: the second bi-lstm layer works the same, producing outputs, except it takes as input instead of. subsection: cvt for sequence tagging in sequence tagging, each token has a corresponding label. the primary prediction module for sequence tagging produces a probability distribution over classes for the label using a one-hidden-layer neural network applied to the corresponding encoder outputs: the auxiliary prediction modules take and, the outputs of the forward and backward lstms in the first bi-lstm layer, as inputs. we add the following four auxiliary prediction modules to the model (see figure [reference]): the\" forward\" module makes each prediction without seeing the right context of the current token. the\" future\" module makes each prediction without the right context or the current token itself. therefore it works like a neural language model that, instead of predicting which token comes next in the sequence, predicts which class of token comes next. the\" backward\" and\" past\" modules are analogous. subsection: cvt for dependency parsing in a dependency parse, words in a sentence are treated as nodes in a graph. typed directed edges connect the words, forming a tree structure describing the syntactic structure of the sentence. in particular, each word in a sentence receives exactly one in-going edge going from word (called the\" head\") to it (the\" dependent\") of type (the\" relation\"). we use a graph-based dependency parser similar to the one from dozat2017deep. this treats dependency parsing as a classification task where the goal is to predict which in-going edge connects to each word. first, the representations produced by the encoder for the candidate head and dependent are passed through separate hidden layers. a bilinear classifier applied to these representations produces a score for each candidate edge. lastly, these scores are passed through a softmax layer to produce probabilities. mathematically, the probability of an edge is given as: where is the scoring function: the bilinear classifier uses a weight matrix specific to the candidate relation as well as a weight matrix shared across all relations. note that unlike in most prior work, our dependency parser only takes words as inputs, not words and part-of-speech tags. we add four auxiliary prediction modules to our model for cross-view training: each one has some missing context (not seeing either the preceding or following words) for the candidate head and candidate dependent. subsection: cvt for sequence-to-sequence learning we use an encoder-decoder sequence-to-sequence model with attention sutskever2014sequence, bahdanau2014neural. each example consists of an input (source) sequence and output (target) sequence. the encoder's representations are passed into an lstm decoder using a bilinear attention mechanism luong2015effectiveat. in particular, at each time step the decoder computes an attention distribution over source sequence hidden states as where is the decoder's current hidden state. the source hidden states weighted by the attention distribution form a context vector:. next, the context vector and current hidden state are combined into an attention vector. lastly, a softmax layer predicts the next token in the output sequence:. we add two auxiliary decoders when applying cvt. the auxiliary decoders share embedding and lstm parameters with the primary decoder, but have different parameters for the attention mechanisms and softmax layers. for the first one, we restrict its view of the input by applying attention dropout, randomly zeroing out a fraction of its attention weights. the second one is trained to predict the next word in the target sequence rather than the current one:. since there is no target sequence for unlabeled examples, we can not apply teacher forcing to get an output distribution over the vocabulary from the primary decoder at each time step. instead, we produce hard targets for the auxiliary modules by running the primary decoder with beam search on the input sequence. this idea has previously been applied to sequence-level knowledge distillation by kim2016sequencelevelkd and makes the training procedure similar to back-translation sennrich2016improvingnm. section: experiments we compare cross-view training against several strong baselines on seven tasks: combinatory categorial grammar (ccg) supertagging: we use data from ccgbank hockenmaier2007ccgbank. text chunking: we use the conll-2000 data tjong2000introduction. named entity recognition (ner): we use the conll-2003 data tjong2003introduction. fine-grained ner (fgn): we use the ontonotes hovy2006ontonotes dataset. part-of-speech (pos) tagging: we use the wall street journal portion of the penn treebank marcus1993building. dependency parsing: we use the penn treebank converted to stanford dependencies version 3.3.0. machine translation: we use the english-vietnamese translation dataset from iwslt 2015 iwslt15. we report (tokenized) bleu scores on the tst2013 test set. we use the 1 billion word language model benchmark chelba2013one as a pool of unlabeled sentences for semi-supervised learning. subsection: model details and baselines we apply dropout during training, but not when running the primary prediction module to produce soft targets on unlabeled examples. in addition to the auxiliary prediction modules listed in section [reference], we find it slightly improves results to add another one that sees the whole input rather than a subset (but unlike the primary prediction module, does have dropout applied to its representations). unless indicated otherwise, our models have lstms with 1024-sized hidden states and 512-sized projection layers. see the appendix for full training details and hyperparameters. we compare cvt with the following other semi-supervised learning algorithms: word dropout. in this method, we only train the primary prediction module. when acting as a teacher it is run as normal, but when acting as a student, we randomly replace some of the input words with a removed token. this is similar to cvt in that it exposes the model to a restricted view of the input. however, it is less data efficient. by carefully designing the auxiliary prediction modules, it is possible to train the auxiliary prediction modules to match the primary one across many different views of the input a once, rather than just one view at a time. virtual adversarial training (vat). vat miyato2015distributional works like word dropout, but adds noise to the word embeddings of the student instead of dropping out words. notably, the noise is chosen adversarially so it most changes the model's prediction. this method was applied successfully to semi-supervised text classification by miyato2016adversarial. elmo. elmo incorporates the representations from a large separately-trained language model into a task-specific model. our implementaiton follows peters2018deep. when combining elmo with multi-task learning, we allow each task to learn its own weights for the elmo embeddings going into each prediction module. we found applying dropout to the elmo embeddings was crucial for achieving good performance. subsection: results results are shown in table [reference]. cvt on its own outperforms or is comparable to the best previously published results on all tasks. figure [reference] shows an example win for cvt over supervised learning.. of the prior results listed in table [reference], only taglm and elmo are semi-supervised. these methods first train an enormous language model on unlabeled data and incorporate the representations produced by the language model into a supervised classifier. our base models use 1024 hidden units in their lstms (compared to 4096 in elmo), require fewer training steps (around one pass over the billion-word benchmark rather than many passes), and do not require a pipelined training procedure. therefore, although they perform on par with elmo, they are faster and simpler to train. increasing the size of our cvt+ multi-task model so it has 4096 units in its lstms like elmo improves results further so they are significantly better than the elmo+ multi-task ones. we suspect there could be further gains from combining our method with language model pre-training, which we leave for future work. cvt+ multi-task. we train a single shared-encoder cvt model to perform all of the tasks except machine translation (as it is quite different and requires more training time than the other ones). multi-task learning improves results on all of the tasks except fine-grained ner, sometimes by large margins. prior work on many-task nlp such as hashimoto2016joint uses complicated architectures and training algorithms. our result shows that simple parameter sharing can be enough for effective many-task learning when the model is big and trained on a large amount of data. interestingly, multi-task learning works better in conjunction with cvt than with elmo. we hypothesize that the elmo models quickly fit to the data primarily using the elmo vectors, which perhaps hinders the model from learning effective representations that transfer across tasks. we also believe cvt alleviates the danger of the model\" forgetting\" one task while training on the other ones, a well-known problem in many-task learning. during multi-task cvt, the model makes predictions about unlabeled examples across all tasks, creating (artificial) all-tasks-labeled examples, so the model does not only see one task at a time. in fact, multi-task learning plus self training is similar to the learning without forgetting algorithm li2016learningwf, which trains the model to keep its predictions on an old task unchanged when learning a new task. to test the value of all-tasks-labeled examples, we trained a multi-task cvt model that only computes on one task at a time (chosen randomly for each unlabeled minibatch) instead of for all tasks in parallel. the one-at-a-time model performs substantially worse (see table [reference]). model generalization. in order to evaluate how our models generalize to the dev set from the train set, we plot the dev vs. train accuracy for our different methods as they learn (see figure [reference]). both cvt and multi-task learning improve model generalization: for the same train accuracy, the models get better dev accuracy than purely supervised learning. interestingly, cvt continues to improve in dev set accuracy while close to 100% train accuracy for ccg, chunking, and ner, perhaps because the model is still learning from unlabeled data even when it has completely fit to the train set. we also show results for a smaller multi-task+ cvt model. although it generalizes at least as well as the larger one, it halts making progress on the train set earlier. this suggests it is important to use sufficiently large neural networks for multi-task learning: otherwise the model does not have the capacity to fit to all the training data. auxiliary prediction module ablation. we briefly explore which auxiliary prediction modules are more important for the sequence tagging tasks in table [reference]. we find that both kinds of auxiliary prediction modules improve performance, but that the future and past modules improve results more than the forward and backward ones, perhaps because they see a more restricted and challenging view of the input. training models on small datasets. we explore how cvt scales with dataset size by varying the amount of training data the model has access to. unsurprisingly, the improvement of cvt over purely supervised learning grows larger as the amount of labeled data decreases (see figure [reference], left). using only 25% of the labeled data, our approach already performs as well or better than a fully supervised model using 100% of the training data, demonstrating that cvt is particularly useful on small datasets. training larger models. most sequence taggers and dependency parsers in prior work use small lstms (hidden state sizes of around 300) because larger models yield little to no gains in performance reimers2017reporting. we found our own supervised approaches also do not benefit greatly from increasing the model size. in contrast, when using cvt accuracy scales better with model size (see figure [reference], right). this finding suggests the appropriate semi-supervised learning methods may enable the development of larger, more sophisticated models for nlp tasks with limited amounts of labeled data. generalizable representations. lastly, we explore training the cvt+ multi-task model on five tasks, freezing the encoder, and then only training a prediction module on the sixth task. this tests whether the encoder's representations generalize to a new task not seen during its training. only training the prediction module is very fast because (1) the encoder (which is by far the slowest part of the model) has to be run over each example only once and (2) we do not back-propagate into the encoder. results are shown in table [reference]. training only a prediction module on top of multi-task representations works remarkably well, outperforming elmo embeddings and sometimes even a vanilla supervised model, showing the multi-task model is building up effective representations for language. in particular, the representations could be used like skip-thought vectors kiros2015skip to quickly train models on new tasks without slow representation learning. section: related work unsupervised representation learning. early approaches to deep semi-supervised learning pre-train neural models on unlabeled data, which has been successful for applications in computer vision jarrett2009best, lecun2010convolutional and nlp. particularly noteworthy for nlp are algorithms for learning effective word embeddings and language model pretraining dai2015semi,, peters2018deep, howard2018universal, radford2018improving. pre-training on other tasks such as machine translation has also been studied mccann2017learnedit. other approaches train\" thought vectors\" representing sentences through unsupervised or supervised learning. self-training. one of the earliest approaches to semi-supervised learning is self-training scudder1965probability, which has been successfully applied to nlp tasks such as word-sense disambiguation yarowsky1995unsupervised and parsing mcclosky2006effective. in each round of training, the classifier, acting as a\" teacher,\" labels some of the unlabeled data and adds it to the training set. then, acting as a\" student,\" it is retrained on the new training set. many recent approaches (including the consistentency regularization methods discussed below and our own method) train the student with soft targets from the teacher's output distribution rather than a hard label, making the procedure more akin to knowledge distillation hinton2015distilling. it is also possible to use multiple models or prediction modules for the teacher, such as in tri-training zhou2005tri, ruder2018strong. consistency regularization. recent works add noise (e.g., drawn from a gaussian distribution) or apply stochastic transformations (e.g., horizontally flipping an image) to the student's inputs. this trains the model to give consistent predictions to nearby data points, encouraging distributional smoothness in the model. consistency regularization has been very successful for computer vision applications bachman2014learning, laine2016temporal, tarvainen2017weight. however, stochastic input alterations are more difficult to apply to discrete data like text, making consistency regularization less used for natural language processing. one solution is to add noise to the model's word embeddings miyato2016adversarial; we compare against this approach in our experiments. cvt is easily applicable to text because it does not require changing the student's inputs. multi-view learning. multi-view learning on data where features can be separated into distinct subsets has been well studied xu2013aso. particularly relevant are co-training blum1998combining and co-regularization sindhwani2005aca, which trains two models with disjoint views of the input. on unlabeled data, each one acts as a\" teacher\" for the other model. in contrast to these methods, our approach trains a single unified model where auxiliary prediction modules see different, but not necessarily independent views of the input. self supervision. self-supervised learning methods train auxiliary prediction modules on tasks where performance can be measured without human-provided labels. recent work has jointly trained image classifiers with tasks like relative position and colorization doersch2017multi, sequence taggers with language modeling rei2017semi, and reinforcement learning agents with predicting changes in the environment. unlike these approaches, our auxiliary losses are based on self-labeling, not labels deterministically constructed from the input. multi-task learning. there has been extensive prior work on multi-task learning caruana1997multitaskl, ruder2017anoo. for nlp, most work has focused on a small number of closely related tasks luong2015multitaskst, zhang2016stack, sgaard2016deepml, peng2017deepml. many-task systems are less commonly developed. collobert2008aua propose a many-task system sharing word embeddings between the tasks, hashimoto2016joint train a many-task model where the tasks are arranged hierarchically according to their linguistic level, and subramanian2018learning train a shared-encoder many-task model for the purpose of learning better sentence representations for use in downstream tasks, not for improving results on the original tasks. section: conclusion we propose cross-view training, a new method for semi-supervised learning. our approach allows models to effectively leverage their own predictions on unlabeled data, training them to produce effective representations that yield accurate predictions even when some of the input is not available. we achieve excellent results across seven nlp tasks, especially when cvt is combined with multi-task learning. section: acknowledgements we thank abi see, christopher clark, he he, peng qi, reid pryzant, yuaho zhang, and the anonymous reviewers for their thoughtful comments and suggestions. we thank takeru miyato for help with his virtual adversarial training code and emma strubell for answering our questions about ontonotes ner. kevin is supported by a google phd fellowship. bibliography: references appendix: detailed results we provide a more detailed version of the test set results in the paper, adding two decimals of precision, standard deviations of the 5 runs for each model, and more prior work, in table [reference]. appendix: model details our models use two layer cnn-bilstm encoders chiu2015named, ma2016end, lample2016neural and task-specific prediction modules. see section [reference] of the paper for details. we provide a few minor details not covered there below. sequence tagging. for chunking and named entity recognition, we use a bioes tagging scheme. we apply label smoothing szegedy2016rethinking, pereyra2017regularizing with a rate of 0.1 to the target labels when training on the labeled data. dependency parsing. we omit punctuation from evaluation, which is standard practice for the ptb-sd 3.3.0 dataset. root is represented with a fixed vector instead of using a vector from the encoder, but otherwise dependencies coming from root are scored the same way as the other dependencies. machine translation. we apply dropout to the output of each lstm layer in the decoder. our implementation is heavily based off of the google nmt tutorial luong17. we attribute our significantly better results to using pre-trained word embeddings, a character-level cnn, a larger model, stronger regularization, and better hyperparameter tuning. target words occurring 5 or fewer times in the train set are replaced with a unk token (but not during evaluation). we use a beam size of 10 when performing beam search. we found it slightly beneficial to apply label smoothing with a rate of 0.1 to the teacher's predictions (unlike our other tasks, the teacher only provides hard targets to the students for translation). multi-task learning. several of our datasets are constructed from the penn treebank. however, we treat them as separate rather than providing examples labeled across multiple tasks to our model during supervised training. furthermore, the penn treebank tasks do not all use the same train/ dev/ test splits. we ensure the training split of one task never overlaps the evaluation split of another by discarding the overlapping examples from the train sets. other details. we apply dropout hinton2012improving to the word embeddings and outputs of each bi-lstm. we use an exponential-moving-average (ema) of the model weights from training for the final model; we found this to slightly improve accuracy and significantly reduce the variance in accuracy between models trained with different random initializations. the model is trained using sgd with momentum polyak1964some, sutskever2013importance. word embeddings are initialized with glove vectors pennington2014glove and fine-tuned during training. the full set of model hyperparameters are listed in table [reference]. baselines. baselines were run with the same architecture and hyperparameters as the cvt model. for the\" word dropout\" model, we randomly replace words in the input sentence with a removed token with probability 0.1 (this value worked well on the dev sets). for virtual adversarial training, we set the norm of the perturbation to be 1.5 for ccg, 1.0 for dependency parsing, and 0.5 for the other tasks (these values worked best on the dev sets). otherwise, the implementation is as described in miyato2016adversarial; we based our implementation off of their code. we were unable to successfully apply vat to machine translation, perhaps because the student is provided hard targets for that task. for elmo, we applied dropout to the elmo embeddings before they are incorporated into the rest of the model. when training the multi-task elmo model, each prediction module has its own set of softmax-normalized weights (in peters2018deep) for the elmo emeddings going into the task-specific prediction modules. all tasks share the same weights for the elmo embeddings going into the shared bi-lstm encoder. appendix: cvt for image recognition although the focus of our work is on nlp, we also applied cvt to image recognition and found it performs competitively with existing methods. most of the semi-supervised image recognition approaches we compare against rely on the inputs being continuous, so they would be difficult to apply to text. more specifically, consistency regularization methods sajjadi2016regularization, laine2016temporal, miyato2017virtual rely on adding continuous noise and applying image-specific transformations like cropping to inputs, gans salimans2016improved, wei2018improving are very difficult to train on text due to its discrete nature, and mixup zhang2017mixup, verma2018manifold requires a way of smoothly interpolating between different inputs. approach. our image recognition models are based on convolutional neural networks, which produce a set of features from an image. the first two dimensions of index into the spatial coordinates of feature vectors and is the size of the feature vectors. for shallower cnns, a particular feature vector corresponds to a region of the input image. for example, would be a-dimensional vector of features extracted from the upper left corner. for deeper cnns, a particular feature vector would be extracted from the whole image, but still only use a\" region\" of the representations from an earlier layer. the cnns in our experiments are all in the first category. the primary prediction layers of our cnns take as input the mean of over the first two dimensions, which results in a-dimensional vector that is fed into a softmax layer: we add auxiliary prediction layers to the top of the cnn. the th layer takes a single feature vector as input: data. we evaluated our models on the cifar-10 krizhevsky2009learning dataset. following previous work, we make the datasets semi-supervised by only using the provided labels for a subset of the examples in the training set; the rest are treated as unlabeled examples. model. we use the convolutional neural network from miyato2017virtual, adapting their tensorflow implementation. their model contains 9 convolutional layers and 2 max pooling layers. see appendix d of miyato et al.'s paper for more details. we add 36 auxiliary softmax layers to the collection of feature vectors produced by the cnn. each auxiliary layer sees a patch of the image ranging in size from pixels (the corner) to pixels (the center) of the pixel images. for some experiments, we combine cvt with standard consistency regularization by adding a perturbation (e.g., a small random vector) to the student's inputs when computing. results. the results are shown in table [reference]. unsurprisingly, adding continuous noise to the inputs works much better with images, where the inputs are naturally continuous, than with language. therefore we see much better results from vat on semi-supervised cifar-10 compared to on our nlp tasks. however, we still find incorporating cvt improves over models without cvt. our cvt+ vat models are competitive with current start-of-the-art approaches. we found the gains from cvt are larger when no data augmentation is applied, perhaps because random translations of the input expose the model to different\" views\" in a similar manner as with cvt. appendix: negative results we briefly describe a few ideas we implemented that did not seem to be effective in initial experiments. note these findings are from early one-off experiments. we did not pursue them further after our first attempts did not pan out, so it is possible that some of these approaches could be effective with the proper adjustments and tuning. hard vs soft targets: classic self-training algorithms train the student model with one-hot\" hard\" targets corresponding to the teacher's highest probability prediction. in our experiments, this decreased performance compared to using soft targets. this finding is consistent with research on knowledge distillation hinton2015distilling, furlanello2018born where soft targets also work notably better than hard targets. confidence thresholding: classic self-training often only trains the student on a subset of the unlabeled examples on which the teacher has confident predictions (i.e., the output distribution has low entropy). we tried both\" hard\" (where the student ignores low-confidence examples) and\" soft\" (where examples are weighted according to the teacher's confidence) versions of this for training our models, but they did not seem to improve performance. mean teacher: the mean teacher method tarvainen2017weight tracks an exponential moving average (ema) of model weights, which are used to produce targets for the students. the idea is that these targets may be better quality due to a self-ensembling effect. however, we found this approach to have little to no benefit in our experiments, although using ema model weights at test time did improve results slightly. purely supervised cvt: lastly, we explored adding cross-view losses to purely supervised classifiers. we hoped that adding auxiliary softmax layers with different views of the input would act as a regularizer on the model. however, we found little to no benefit from this approach. this negative result suggests that the gains from cvt are from the improved semi-supervised learning mechanism, not the additional prediction layers regularizing the model.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "english vietnamese translation dataset"
                    ]
                ],
                "Method": [
                    [
                        "cross view training"
                    ],
                    [
                        "cvt"
                    ]
                ],
                "Metric": [
                    [
                        "tokenized bleu scores"
                    ]
                ],
                "Task": [
                    [
                        "semi supervised sequence modeling"
                    ],
                    [
                        "sequence modeling"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "ccgbank"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "accuracy",
                        "dev",
                        "train accuracy"
                    ]
                ],
                "Task": [
                    [
                        "combinatory categorial grammar supertagging",
                        "combinatory categorial grammar",
                        "ccg",
                        "supertagging"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "conll-2003"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": [
                    [
                        "named entity recognition",
                        "fine-grained ner",
                        "ontonotes ner",
                        "image recognition"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "ontonotes"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": [
                    [
                        "named entity recognition",
                        "fine-grained ner",
                        "ontonotes ner",
                        "image recognition"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "penn treebank"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "part-of-speech",
                        "pos"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing",
                        "dependency parse",
                        "ner",
                        "parsing"
                    ]
                ]
            }
        ]
    },
    "0dc9eb7d17f2def56ad930945f2521653f04c3fa-11": {
        "doctext": "skip-gram language modeling using sparse non-negative matrix probability estimation section: abstract we present a novel family of language model (lm) estimation techniques named sparse non-negative matrix (snm) estimation. a first set of experiments empirically evaluating it on the one billion word benchmark [reference] shows that snm n-gram lms perform almost as well as the well-established kneser-ney (kn) models. when using skip-gram features the models are able to match the state-of-the-art recurrent neural network (rnn) lms; combining the two modeling techniques yields the best known result on the benchmark. the computational advantages of snm over both maximum entropy and rnn lm estimation are probably its main strength, promising an approach that has the same flexibility in combining arbitrary features effectively and yet should scale to very large amounts of data as gracefully as n-gram lms do. section: introduction a statistical language model estimates probability values p (w) for strings of words w in a vocabulary v whose size is in the tens, hundreds of thousands and sometimes even millions. typically the string w is broken into sentences, or other segments such as utterances in automatic speech recognition, which are often assumed to be conditionally independent; we will assume that w is such a segment, or sentence. estimating full sentence language models is computationally hard if one seeks a properly normalized probability model 1 over strings of words of finite length in [reference] we note that in some practical systems the constraint on using a properly normalized language v*. a simple and sufficient way to ensure proper normalization of the model is to decompose the sentence probability according to the chain rule and make sure that the end-of-sentence symbol</ s> is predicted with non-zero probability in any context. with w= w 1, w 2,..., w n we get: p (w i|w 1, w 2,..., w i\u22121) since the parameter space of p (w k|w 1, w 2,..., w k\u22121) is too large, the language model is forced to put the context w k\u22121= w 1, w 2,..., w k\u22121 into an equivalence class determined by a function\u03c6 (w k\u22121). as a result, research in language modeling consists of finding appropriate equivalence classifiers\u03c6 and methods to estimate p (w k|\u03c6 (w k\u22121)). the most successful paradigm in language modeling uses the (n\u2212 1)- gram equivalence classification, that is, defines\u03c6 (w k\u22121).= w k\u2212n+ 1, w k\u2212n+ 2,..., w k\u22121 once the form\u03c6 (w k\u22121) is specified, only the problem of estimating p (w k|\u03c6 (w k\u22121)) from training data remains. section: perplexity as a measure of language model quality a statistical language model can be evaluated by how well it predicts a string of symbols w t-commonly referred to as test data-generated by the source to be modeled. a commonly used quality measure for a given model m is related to the entropy of the underlying source and was introduced under the name of perplexity (ppl): for an excellent discussion on the use of perplexity in statistical language modeling, as well as various estimates for the entropy of english the reader is referred to [reference], section 8.4, pages 141-142 and the additional reading suggested in section 8.5 of the same book. model is side-stepped at a gain in modeling power and simplicity. very likely, not all words in the test string w t are part of the language model vocabulary. it is common practice to map all words that are out-of-vocabulary to a distinguished unknown word symbol, and report the out-of-vocabulary (oov) rate on test data-the rate at which one encounters oov words in the test string w tas yet another language model performance metric besides perplexity. usually the unknown word is assumed to be part of the language model vocabulary-open vocabulary language models-and its occurrences are counted in the language model perplexity calculation, eq. (3). a situation less common in practice is that of closed vocabulary language models where all words in the test data will always be part of the vocabulary v. section: skip-gram language modeling recently, neural network (nn) smoothing [reference], [reference], [reference], and in particular recurrent neural networks [reference] (rnn) have shown excellent performance in language modeling [reference]. their excellent performance is attributed to a combination of leveraging long-distance context, and training a vector representation for words. another simple way of leveraging long distance context is to use skip-grams. in our approach, a skip-gram feature extracted from the context w k\u22121 is characterized by the tuple (r, s, a) where:\u2022 r denotes number of remote context words\u2022 s denotes the number of skipped words\u2022 a denotes the number of adjacent context words relative to the target word w k being predicted. for example, in the sentence,< s> the quick brown fox jumps over the lazy dog</ s> a (1, 2, 3) skip-gram feature for the target word dog is: [brown skip-2 over the lazy] for performance reasons, it is recommended to limit s and to limit either (r+ a) or limit both r and s; not setting any limits will result in events containing a set of skip-gram features whose total representation size is quintic in the length of the sentence. we configure the skip-gram feature extractor to produce all features f, defined by the equivalence class\u03c6 (w k\u22121), that meet constraints on the minimum and maximum values for:\u2022 the number of context words used r+ a;\u2022 the number of remote words r;\u2022 the number of adjacent words a;\u2022 the skip length s. we also allow the option of not including the exact value of s in the feature representation; this may help with smoothing by sharing counts for various skip features. tied skip-gram features will look like: [curiousity skip -* the cat] in order to build a good probability estimate for the target word w k in a context w k\u22121 we need a way of combining an arbitrary number of skip-gram features f k\u22121, which do not fall into a simple hierarchy like regular n-gram features. the following section describes a simple, yet novel approach for combining such predictors in a way that is computationally easy, scales up gracefully to large amounts of data and as it turns out is also very effective from a modeling point of view. section: sparse non-negative matrix modeling section: model definition in the sparse non-negative matrix (snm) paradigm, we represent the training data as a sequence of events e= e 1, e 2,... where each event e\u2208 e consists of a sparse non-negative feature vector f and a sparse non-negative target word vector t. both vectors are binary-valued, indicating the presence or absence of a feature or target words, respectively. hence, the training data consists of|e||p os (f)| positive and|e||p os (f)| (|v|\u2212 1) negative training examples, where p os (f) denotes the number of positive elements in the vector f. a language model is represented by a non-negative matrix m that, when applied to a given feature vector f, produces a dense prediction vector y: upon evaluation, we normalize y such that we end up with a conditional probability distribution p m (t|f) for a model m. for each word w\u2208 v that corresponds to index j in t, and its feature vector f that is defined by the equivalence class\u03c6 applied to the history h (w) of that word in a text, the conditional probability p m (w|\u03c6 (h (w))) then becomes: for convenience, we will write p (t j|f) instead of p m (t j|f) in the rest of the paper. as required by the denominator in eq. (5), this computation involves summing over all of the present features for the entire vocabulary. however, if we precompute the row sums|v| u=1 m iu and store them together with the model, the evaluation can be done very efficiently in only|p os (f)| time. moreover, only the positive entries in m i need to be considered, making the range of the sum sparse. section: adjustment function and metafeatures we let the entries of m be a slightly modified version of the relative frequencies: where c is a feature-target count matrix, computed over the entire training corpus and a (i, j) is a real-valued function, dubbed adjustment function. for each featuretarget pair (f i, t j), the adjustment function extracts k new features\u03b1 k, called metafeatures, which are hashed as keys to store corresponding weights\u03b8 (hash (\u03b1 k)) in a huge hash table. to limit memory usage, we use a flat hash table and allow collisions, although this has the potentially undesirable effect of tying together the weights of different metafeatures. computing the adjustment function for any (f i, t j) then amounts to summing the weights that correspond to its metafeatures: from the given input features, such as regular n-grams and skip n-grams, we construct our metafeatures as conjunctions of any or all of the following elementary metafeatures:\u2022 feature identity, e.g. [brown skip-2 over the lazy]\u2022 feature type, e.g. (1, 2, 3) skip-grams\u2022 feature count c i*\u2022 target identity, e.g. dog where we reused the example from section 2. note that the seemingly absent feature-target identity is represented by the conjunction of the feature identity and the target identity. since the metafeatures may involve the feature count and feature-target count, in the rest of the paper we will write\u03b1 k (i, j, c i*, c ij). this will become important later when we discuss leave-one-out training. each elementary metafeature is joined with the others to form more complex metafeatures which in turn are joined with all the other elementary and complex metafeatures, ultimately ending up with all 2 5\u2212 1 possible combinations of metafeatures. before they are joined, count metafeatures are bucketed together according to their (floored) log 2 value. as this effectively puts the lowest count values, of which there are many, into a different bucket, we optionally introduce a second (ceiled) bucket to assure smoother transitions. both buckets are then weighted according to the log 2 fraction lost by the corresponding rounding operation. note that if we apply double bucketing to both the feature and feature-target count, the amount of metafeatures per input feature becomes 2 7\u2212 1. we will come back to these metafeatures in section 4.4 where we examine their individual effect on the model. section: loss function estimating a model m corresponds to finding optimal weights\u03b8 k for all the metafeatures for all events in such a way that the average loss over all events between the target vector t and the prediction vector y is minimized, according to some loss function l. the most natural choice of loss function is one that is based on the multinomial distribution. that is, we consider t to be multinomially distributed with|v| possible outcomes. the loss function l multi then is: another possibility is the loss function based on the poisson distribution 2: we consider each t j in t to be poisson distributed with parameter y j. the conditional probability of p p oisson (t|f) then is: and the corresponding poisson loss function is: where we dropped the last term, since t j is binary-valued 3. although this choice is not obvious in the context of language modeling, it is well suited to gradient-based optimization and, as we will see, the experimental results are in fact excellent. section: model estimation the adjustment function is learned by applying stochastic gradient descent on the loss function. that is, for each feature-target pair (f i, t j) in each event we need to update the parameters of the metafeatures by calculating the gradient with respect to the adjustment function. for the multinomial loss, this gradient is: the problem with this update rule is that we need to sum over the entire vocabulary v in the denominator. for most features f i, this is not a big deal as c iu= 0, but some features occur with many if not all targets e.g. the empty feature for unigrams. although we might be able to get away with this by re-using these sums and applying them to many/ all events in a mini batch, we chose to work with the poisson loss in our first implementation. if we calculate the gradient of the poisson loss, we get the following: if we were to apply this gradient to each (positive and negative) training example, it would be computationally too expensive, because even though the second term is zero for all the negative training examples, the first term needs to be computed for all|e||p os (f)||v| training examples. however, since the first term does not depend on y j, we are able to distribute the updates for the negative examples over the positive ones by adding in gradients for a fraction of the events where f i= 1, but t j= 0. in particular, instead of adding the term f i m ij, we add f i t j which lets us update the gradient only on positive examples. we note that this update is only strictly correct for batch training, and not for online training since m ij changes after each update. nonetheless, we found this to yield good results as well as seriously reducing the computational cost. the online gradient applied to each training example then becomes: which is non-zero only for positive training examples, hence speeding up computation by a factor of|v|. these aggregated gradients however do not allow us to use additional data to train the adjustment function, since they tie the update computation to the relative frequencies. instead, we have to resort to leave-one-out training to prevent the model from overfitting the training data. we do this by excluding the event, generating the gradients, from the counts used to compute those gradients. so, for each positive example (f i, t j) of each event e= (f, t), we compute the gradient, excluding f i from c i* and f i t j from c ij. for the gradients of the negative examples on the other hand we only exclude f i from c i* and we leave c ij untouched, since here we did not observe t j. in order to keep the aggregate computation of the gradients for the negative examples, we distribute them uniformly over all the positive examples with the same feature; each of the c ij positive examples will then compute the gradient of negative examples. to summarize, when we do leave-one-out training we apply the following gradient update rule on all positive training examples: where y\u2032 j is the product of leaving one out for all the relevant features i.e. section: experiments section: corpus: one billion benchmark our experimental setup used the one billion word benchmark corpus 4 made available by [reference]. for completeness, here is a short description of the corpus, containing only monolingual english data:\u2022 total number of training tokens is about 0.8 billion\u2022 the vocabulary provided consists of 793471 words including sentence boundary markers< s>,<\\s>, and was constructed by discarding all words with count below 3\u2022 words outside of the vocabulary were mapped to< unk> token, also part of the vocabulary\u2022 sentence order was randomized\u2022 the test data consisted of 159658 words (without counting the sentence beginning marker< s> which is never predicted by the language model)\u2022 the out-of-vocabulary (oov) rate on the test set was 0.28%. section: snm for n-gram lms when trained using solely n-gram features, snm comes very close to the stateof-the-art kneser-ney [reference] (kn) models. table 1 shows that katz [reference] performs considerably worse than both snm and kn which only differ by about 5%. when we interpolate these two models linearly, the added gain is only about 1%, suggesting that they are approximately modeling the same things. the difference between kn and snm becomes smaller when we increase the size of the context, going from 5% for 5-grams to 3% for 8-grams, which indicates that snm is better suited to a large number of features. section: sparse non-negative modeling for skip n-grams when we incorporate skip-gram features, we can either build a' pure' skip-gram snm that contains no regular n-gram features, except for unigrams, and interpolate this model with kn, or we can build a single snm that has both the regular ngram features and the skip-gram features. we compared the two approaches by choosing skip-gram features that can be considered the skip-equivalent of 5-grams i.e. they contain at most 4 words. in particular, we used skip-gram features where the remote span is limited to at most 3 words for skips of length between 1 and 3 (r= [1. section:]). we then built a model that uses both these features and regular 5-grams (snm5-skip), as well as one that only uses the skip-gram features (snm5-skip (no n-grams)). section: model num. params ppl snm5-skip (no n-grams) 61 b 69.8 snm5-skip 62 b 54.2 kn5+ snm5-skip (no n-grams) 56.5 kn5+ snm5-skip 53.6 table 2: number of parameters (in billions) and perplexity results for snm5-skip models with and without n-grams, as well as perplexity results for the interpolation with kn5. as it turns out and as can be seen from table 2, it is better to incorporate all the features into one single snm model than to interpolate with a kn 5-gram model (kn5). interpolating the all-in-one snm5-skip with kn5 yields almost no additional gain. the best snm results so far (snm10-skip) were achieved using 10-grams, together with untied skip features of at most 5 words with a skip of exactly 1 word (s= 1, r+ a= [1. section:]). this mixture of rich short-distance and shallow long-distance features enables the model to achieve state-of-the-art results, as can be seen in table 3. when we compare the perplexity of this model with the state-of-the art rnn results in [reference], the difference is only 3%. moreover, although our model has more parameters than the rnn (33 vs 20 billion), training takes about a tenth of the time (24 hours vs 240 hours). interestingly, when we interpolate the two models, we have an additional gain of 20%, and as far as we know, the perplexity of 41.3 is already the best ever reported on this database, beating the previous best by 6% [reference]. finally, when we optimize interpolation weights over all models in [reference], including snm5-skip and snm10-skip, the contribution of the other models as well as the perplexity reduction is negligible, as can be seen in table 3, which also summarizes the perplexity results for each of the individual models. section: ablation experiments to find out how much, if anything at all, each metafeature contributes to the adjustment function, we ran a series of ablation experiments in which we ablated one metafeature at a time. when we experimented on snm5, we found, unsurprisingly, that the most important metafeature is the feature-target count. at first glance, it does not seem to matter much whether the counts are stored in 1 or 2 buckets, but the second bucket really starts to pay off for models with a large number of singleton features e.g. snm10-skip 5. this is not the case for the feature counts, where having a single bucket is always better, although in general the feature counts do not contribute much. in any case, feature counts are definitely the least important for the model. the remaining metafeatures all contribute more or less equally, all of which can be seen in table 4. section: related work snm estimation is closely related to all n-gram lm smoothing techniques that rely on mixing relative frequencies at various orders. unlike most of those, it combines the predictors at various orders without relying on a hierarchical nesting of the contexts, setting it closer to the family of maximum entropy (me) [reference], or exponential models. we are not the first ones to highlight the effectiveness of skip n-grams at capturing dependencies across longer contexts, similar to rnn lms; previous such results were reported in [reference]. [reference] attempts to capture long range dependencies in language where the skip n-grams are identified using a left-to-right syntactic parser. approaches such as [reference] leverage latent semantic information, whereas [reference] integrates both syntactic and topic-based modeling in a unified approach. the speed-ups to me, and rnn lm training provided by hierarchically predicting words at the output layer [reference], and subsampling [reference] still require updates that are linear in the vocabulary size times the number of words in the training data, whereas the snm updates in eq. (15) for the much smaller adjustment function eliminate the dependency on the vocabulary size. scaling up rnn lm training is described in [reference] and [reference]. the computational advantages of snm over both maximum entropy and rnn lm estimation are probably its main strength, promising an approach that has the same flexibility in combining arbitrary features effectively and yet should scale to very large amounts of data as gracefully as n-gram lms do. section: section: conclusions and future work we have presented snm, a new family of lm estimation techniques. a first empirical evaluation on the one billion word benchmark [reference] shows that snm n-gram lms perform almost as well as the well-established kn models. when using skip-gram features the models are able to match the stat-of-the-art rnn lms; combining the two modeling techniques yields the best known result on the benchmark. future work items include model pruning, exploring richer features similar to [reference], as well as richer metafeatures in the adjustment model, mixing snm models trained on various data sources such that they perform best on a given development set, and estimation techniques that are more flexible in this respect. section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "one billion word benchmark"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": [
                    [
                        "skip gram language modeling"
                    ],
                    [
                        "modeling"
                    ],
                    [
                        "estimation"
                    ],
                    [
                        "snm estimation"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "one billion word benchmark",
                        "one billion benchmark"
                    ]
                ],
                "Method": [
                    [
                        "sparse non-negative matrix probability estimation",
                        "sparse non-negative matrix",
                        "snm",
                        "snm n-gram lms",
                        "non-negative matrix m",
                        "sparse non-negative modeling",
                        "pure' skip-gram snm",
                        "snm5-skip",
                        "snm5",
                        "snm model",
                        "snm10-skip",
                        "snm estimation",
                        "snm updates",
                        "snm models"
                    ]
                ],
                "Metric": [
                    [
                        "params"
                    ]
                ],
                "Task": [
                    [
                        "skip-gram language modeling",
                        "language modeling",
                        "statistical language modeling"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "one billion word benchmark",
                        "one billion benchmark"
                    ]
                ],
                "Method": [
                    [
                        "sparse non-negative matrix probability estimation",
                        "sparse non-negative matrix",
                        "snm",
                        "snm n-gram lms",
                        "non-negative matrix m",
                        "sparse non-negative modeling",
                        "pure' skip-gram snm",
                        "snm5-skip",
                        "snm5",
                        "snm model",
                        "snm10-skip",
                        "snm estimation",
                        "snm updates",
                        "snm models"
                    ]
                ],
                "Metric": [
                    [
                        "perplexity",
                        "ppl"
                    ]
                ],
                "Task": [
                    [
                        "skip-gram language modeling",
                        "language modeling",
                        "statistical language modeling"
                    ]
                ]
            }
        ]
    },
    "107010b7f2abe3c0c9df62bcef35eb77f6fc76df-12": {
        "doctext": "domain-adversarial training of neural networks section: abstract we introduce a new representation learning approach for domain adaptation, in which data at training and test time come from similar but different distributions. our approach is directly inspired by the theory on domain adaptation suggesting that, for effective domain transfer to be achieved, predictions must be made based on features that can not discriminate between the training (source) and test (target) domains. the approach implements this idea in the context of neural network architectures that are trained on labeled data from the source domain and unlabeled data from the target domain (no labeled target-domain data is necessary). as the training progresses, the approach promotes the emergence of features that are (i) discriminative for the main learning task on the source domain and (ii) indiscriminate with respect to the shift between the domains. we show that this adaptation behaviour can be achieved in almost any feed-forward model by augmenting it with few standard layers and a new gradient reversal layer. the resulting augmented architecture can be trained using standard backpropagation and stochastic gradient descent, and can thus be implemented with little effort using any of the deep learning packages. we demonstrate the success of our approach for two distinct classification problems (document sentiment analysis and image classification), where state-of-the-art domain adaptation performance on standard benchmarks is achieved. we also validate the approach for descriptor learning task in the context of person re-identification application. section: introduction the cost of generating labeled data for a new machine learning task is often an obstacle for applying machine learning methods. in particular, this is a limiting factor for the further progress of deep neural network architectures, that have already brought impressive advances to the state-of-the-art across a wide variety of machine-learning tasks and applications. for problems lacking labeled data, it may be still possible to obtain training sets that are big enough for training large-scale deep models, but that suffer from the shift in data distribution from the actual data encountered at\" test time\". one important example is training an image classifier on synthetic or semi-synthetic images, which may come in abundance and be fully labeled, but which inevitably have a distribution that is different from real images [reference][reference][reference][reference]. another example is in the context of sentiment analysis in written reviews, where one might have labeled data for reviews of one type of product (e.g., movies), while having the need to classify reviews of other products (e.g., books). learning a discriminative classifier or other predictor in the presence of a shift between training and test distributions is known as domain adaptation (da). the proposed approaches build mappings between the source (training-time) and the target (test-time) domains, so that the classifier learned for the source domain can also be applied to the target domain, when composed with the learned mapping between domains. the appeal of the domain adaptation approaches is the ability to learn a mapping between domains in the situation when the target domain data are either fully unlabeled (unsupervised domain annotation) or have few labeled samples (semi-supervised domain adaptation). below, we focus on the harder unsupervised case, although the proposed approach (domain-adversarial learning) can be generalized to the semi-supervised case rather straightforwardly. unlike many previous papers on domain adaptation that worked with fixed feature representations, we focus on combining domain adaptation and deep feature learning within one training process. our goal is to embed domain adaptation into the process of learning representation, so that the final classification decisions are made based on features that are both discriminative and invariant to the change of domains, i.e., have the same or very similar distributions in the source and the target domains. in this way, the obtained feed-forward network can be applicable to the target domain without being hindered by the shift between the two domains. our approach is motivated by the theory on domain adaptation [reference], that suggests that a good representation for cross-domain transfer is one for which an algorithm can not learn to identify the domain of origin of the input observation. we thus focus on learning features that combine (i) discriminativeness and (ii) domaininvariance. this is achieved by jointly optimizing the underlying features as well as two discriminative classifiers operating on these features: (i) the label predictor that predicts class labels and is used both during training and at test time and (ii) the domain classifier that discriminates between the source and the target domains during training. while the parameters of the classifiers are optimized in order to minimize their error on the training set, the parameters of the underlying deep feature mapping are optimized in order to minimize the loss of the label classifier and to maximize the loss of the domain classifier. the latter update thus works adversarially to the domain classifier, and it encourages domain-invariant features to emerge in the course of the optimization. crucially, we show that all three training processes can be embedded into an appropriately composed deep feed-forward network, called domain-adversarial neural network (dann) (illustrated by figure 1, page 12) that uses standard layers and loss functions, and can be trained using standard backpropagation algorithms based on stochastic gradient descent or its modifications (e.g., sgd with momentum). the approach is generic as a dann version can be created for almost any existing feed-forward architecture that is trainable by backpropagation. in practice, the only non-standard component of the proposed architecture is a rather trivial gradient reversal layer that leaves the input unchanged during forward propagation and reverses the gradient by multiplying it by a negative scalar during the backpropagation. we provide an experimental evaluation of the proposed domain-adversarial learning idea over a range of deep architectures and applications. we first consider the simplest dann architecture where the three parts (label predictor, domain classifier and feature extractor) are linear, and demonstrate the success of domain-adversarial learning for such architecture. the evaluation is performed for synthetic data as well as for the sentiment analysis problem in natural language processing, where dann improves the state-of-the-art marginalized stacked autoencoders (msda) of [reference] on the common amazon reviews benchmark. we further evaluate the approach extensively for an image classification task, and present results on traditional deep learning image data sets-such as mnist [reference] and svhn [reference])- as well as on office benchmarks [reference], where domain-adversarial learning allows obtaining a deep architecture that considerably improves over previous state-of-the-art accuracy. finally, we evaluate domain-adversarial descriptor learning in the context of person re-identification application [reference], where the task is to obtain good pedestrian image descriptors that are suitable for retrieval and verification. we apply domainadversarial learning, as we consider a descriptor predictor trained with a siamese-like loss instead of the label predictor trained with a classification loss. in a series of experiments, we demonstrate that domain-adversarial learning can improve cross-data-set re-identification considerably. section: related work the general approach of achieving domain adaptation explored under many facets. over the years, a large part of the literature has focused mainly on linear hypothesis (see for instance [reference][reference][reference][reference]. more recently, non-linear representations have become increasingly studied, including neural network representations [reference] and most notably the state-of-the-art msda [reference]. that literature has mostly focused on exploiting the principle of robust representations, based on the denoising autoencoder paradigm [reference]. concurrently, multiple methods of matching the feature distributions in the source and the target domains have been proposed for unsupervised domain adaptation. some ap-proaches perform this by reweighing or selecting samples from the source domain [reference], while others seek an explicit feature space transformation that would map source distribution into the target one [reference][reference][reference]). an important aspect of the distribution matching approach is the way the (dis) similarity between distributions is measured. here, one popular choice is matching the distribution means in the kernelreproducing hilbert space [reference], whereas [reference] and [reference] map the principal axes associated with each of the distributions. our approach also attempts to match feature space distributions, however this is accomplished by modifying the feature representation itself rather than by reweighing or geometric transformation. also, our method uses a rather different way to measure the disparity between distributions based on their separability by a deep discriminatively-trained classifier. note also that several approaches perform transition from the source to the target domain [reference][reference] by changing gradually the training distribution. among these methods, [reference] does this in a\" deep\" way by the layerwise training of a sequence of deep autoencoders, while gradually replacing source-domain samples with target-domain samples. this improves over a similar approach of [reference] that simply trains a single deep autoencoder for both domains. in both approaches, the actual classifier/ predictor is learned in a separate step using the feature representation learned by autoencoder (s). in contrast to [reference][reference], our approach performs feature learning, domain adaptation and classifier learning jointly, in a unified architecture, and using a single learning algorithm (backpropagation). we therefore argue that our approach is simpler (both conceptually and in terms of its implementation). our method also achieves considerably better results on the popular office benchmark. while the above approaches perform unsupervised domain adaptation, there are approaches that perform supervised domain adaptation by exploiting labeled data from the target domain. in the context of deep feed-forward architectures, such data can be used to\" fine-tune\" the network trained on the source domain [reference][reference][reference]. our approach does not require labeled target-domain data. at the same time, it can easily incorporate such data when they are available. an idea related to ours is described in [reference]. while their goal is quite different (building generative deep networks that can synthesize samples), the way they measure and minimize the discrepancy between the distribution of the training data and the distribution of the synthesized data is very similar to the way our architecture measures and minimizes the discrepancy between feature distributions for the two domains. moreover, the authors mention the problem of saturating sigmoids which may arise at the early stages of training due to the significant dissimilarity of the domains. the technique they use to circumvent this issue (the\" adversarial\" part of the gradient is replaced by a gradient computed with respect to a suitable cost) is directly applicable to our method. also, recent and concurrent reports by [reference] focus on domain adaptation in feed-forward networks. their set of techniques measures and minimizes the distance between the data distribution means across domains (potentially, after embedding distributions into rkhs). their approach is thus different from our idea of matching distributions by making them indistinguishable for a discriminative classifier. below, we compare our approach to; [reference] on the office benchmark. another approach to deep domain adaptation, which is arguably more different from ours, has been developed in parallel by [reference]. from a theoretical standpoint, our approach is directly derived from the seminal theoretical works of [reference]. indeed, dann directly optimizes the notion of h-divergence. we do note the work of [reference], in which hmm representations are learned for word tagging using a posterior regularizer that is also inspired by ben-david et al.'s work. in addition to the tasks being different-huang and yates (2012) focus on word tagging problems -, we would argue that dann learning objective more closely optimizes the h-divergence, with huang and yates (2012) relying on cruder approximations for efficiency reasons. a part of this paper has been published as a conference paper [reference]. this version extends [reference] very considerably by incorporating the report [reference] (presented as part of the second workshop on transfer and multi-task learning), which brings in new terminology, in-depth theoretical analysis and justification of the approach, extensive experiments with the shallow dann case on synthetic data as well as on a natural language processing task (sentiment analysis). furthermore, in this version we go beyond classification and evaluate domain-adversarial learning for descriptor learning setting within the person re-identification application. section: domain adaptation we consider classification tasks where x is the input space and y= {0, 1,..., l\u22121} is the set of l possible labels. moreover, we have two different distributions over x\u00d7y, called the source domain d s and the target domain d t. an unsupervised domain adaptation learning algorithm is then provided with a labeled source sample s drawn i.i.d. from d s, and an unlabeled target sample with n= n+ n being the total number of samples. the goal of the learning algorithm is to build a classifier\u03b7: x\u2192 y with a low target risk while having no information about the labels of d t. section: domain divergence to tackle the challenging domain adaptation task, many approaches bound the target error by the sum of the source error and a notion of distance between the source and the target distributions. these methods are intuitively justified by a simple assumption: the source risk is expected to be a good indicator of the target risk when both distributions are similar. several notions of distance have been proposed for domain adaptation [reference][reference][reference]. in this paper, we focus on the h-divergence used by [reference], and based on the earlier work of [reference]. note that we assume in definition 1 below that the hypothesis class h is a (discrete or continuous) set of binary classifiers\u03b7: x\u2192 {0, 1}. 1 definition 1 [reference][reference] that is, the h-divergence relies on the capacity of the hypothesis class h to distinguish between examples generated by d x s from examples generated by d x t. [reference] proved that, for a symmetric hypothesis class h, one can compute the empirical where i [a] is the indicator function which is 1 if predicate a is true, and 0 otherwise. section: proxy distance ben-david et al. [reference] suggested that, even if it is generally hard to computed h (s, t) exactly (e.g., when h is the space of linear classifiers on x), we can easily approximate it by running a learning algorithm on the problem of discriminating between source and target examples. to do so, we construct a new data set where the examples of the source sample are labeled 0 and the examples of the target sample are labeled 1. then, the risk of the classifier trained on the new data set u approximates the\" min\" part of equation (1). given a generalization error on the problem of discriminating between source and target examples, the h-divergence is then approximated b\u0177 in [reference], the valued a is called the, where a is a subset of x. note that, by choosing a= {a\u03b7|\u03b7\u2208 h}, with a\u03b7 the set represented by the characteristic function\u03b7, the a-distance and the h-divergence of definition 1 are identical. in the experiments section of this paper, we compute the pad value following the approach of [reference][reference], i.e., we train either a linear svm or a deeper mlp classifier on a subset of u (equation 2), and we use the obtained classifier error on the other subset as the value of in equation (3). more details and illustrations of the linear svm case are provided in section 5.1.5. section: generalization bound on the target risk the work of [reference] is upper bounded by its empirical estimated h (s, t) plus a constant complexity term that depends on the vc dimension of h and the size of samples s and t. by combining this result with a similar bound on the source risk, the following theorem is obtained., and is the empirical source risk. the previous result tells us that r d t (\u03b7) can be low only when the\u03b2 term is low, i.e., only when there exists a classifier that can achieve a low risk on both distributions. it also tells us that, to find a classifier with a small r d t (\u03b7) in a given class of fixed vc dimension, the learning algorithm should minimize (in that class) a trade-off between the source risk r s (\u03b7) and the empirical h-divergenced h (s, t). as pointed-out by [reference], a strategy to control the h-divergence is to find a representation of the examples where both the source and the target domain are as indistinguishable as possible. under such a representation, a hypothesis with a low source risk will, according to theorem 2, perform well on the target data. in this paper, we present an algorithm that directly exploits this idea. section: domain-adversarial neural networks (dann) an original aspect of our approach is to explicitly implement the idea exhibited by theorem 2 into a neural network classifier. that is, to learn a model that can generalize well from one domain to another, we ensure that the internal representation of the neural network contains no discriminative information about the origin of the input (source or target), while preserving a low risk on the source (labeled) examples. in this section, we detail the proposed approach for incorporating a\" domain adaptation component\" to neural networks. in subsection 4.1, we start by developing the idea for the simplest possible case, i.e., a single hidden layer, fully connected neural network. we then describe how to generalize the approach to arbitrary (deep) network architectures. section: example case with a shallow neural network let us first consider a standard neural network (nn) architecture with a single hidden layer. for simplicity, we suppose that the input space is formed by m-dimensional real vectors. thus, x= r m. the hidden layer g f learns a function g f: x\u2192 r d that maps an example into a new d-dimensional representation 2, and is parameterized by a matrix-vector pair (w, b)\u2208 r d\u00d7m\u00d7 r d: with sigm (a)= similarly, the prediction layer g y learns a function here we have l=|y|. by using the softmax function, each component of vector g y (g f (x)) denotes the conditional probability that the neural network assigns x to the class in y represented by that component. given a source example (x i, y i), the natural classification loss to use is the negative log-probability of the correct label: training the neural network then leads to the following optimization problem on the source domain: where, y i is a shorthand notation for the prediction loss on the i-th example, and r (w, b) is an optional regularizer that is weighted by hyper-parameter\u03bb. the heart of our approach is to design a domain regularizer directly derived from the h-divergence of definition 1. to this end, we view the output of the hidden layer g f (\u00b7) (equation 4) as the internal representation of the neural network. thus, we denote the source sample representations as similarly, given an unlabeled sample from the target domain we denote the corresponding representations based on equation (1), the empirical h-divergence of a symmetric hypothesis class h between samples s (g f) and let us consider h as the class of hyperplanes in the representation space. inspired by the proxy a-distance (see section 3.2), we suggest estimating the\" min\" part of equation (6) by a domain classification layer g d that learns a logistic regressor parameterized by a vector-scalar pair (u, z)\u2208 r d\u00d7 r, that models the probability that a given input is from the source domain d hence, the function g d (\u00b7) is a domain regressor. we define its loss by where d i denotes the binary variable (domain label) for the i-th example, which indicates whether x i come from the source distribution (recall that for the examples from the source distribution (d i= 0), the corresponding labels y i\u2208 y are known at training time. for the examples from the target domains, we do not know the labels at training time, and we want to predict such labels at test time. this enables us to add a domain adaptation term to the objective of equation (5), giving the following regularizer: where this regularizer seeks to approximate the h-divergence of equation (6), as 2 (1\u2212r (w, b)) is a surrogate ford h s (g f), t (g f). in line with theorem 2, the optimization problem given by equations (5) and (8) implements a trade-off between the minimization of the source risk r s (\u00b7) and the divergenced h (\u00b7,\u00b7). the hyper-parameter\u03bb is then used to tune the trade-off between these two quantities during the learning process. for learning, we first note that we can rewrite the complete optimization objective of equation (5) as follows: where we are seeking the parameters\u0175, v, b,\u0109,\u00fb,\u1e91 that deliver a saddle point given by thus, the optimization problem involves a minimization with respect to some parameters, as well as a maximization with respect to the others. algorithm 1 shallow dann-stochastic training update while stopping criterion is not met do 6: for i from 1 to n do 7:# forward propagation 8: 32:# update neural network parameters 33: end for 41: end while note: in this pseudo-code, e (y) refers to a\" one-hot\" vector, consisting of all 0s except for a 1 at position y, and is the element-wise product. we propose to tackle this problem with a simple stochastic gradient procedure, in which updates are made in the opposite direction of the gradient of equation (9) for the minimizing parameters, and in the direction of the gradient for the maximizing parameters. stochastic estimates of the gradient are made, using a subset of the training samples to compute the averages. algorithm 1 provides the complete pseudo-code of this learning procedure. 3 in words, during training, the neural network (parameterized by w, b, v, c) and the domain regressor (parameterized by u, z) are competing against each other, in an adversarial way, over the objective of equation (9). for this reason, we refer to networks trained according to this objective as domain-adversarial neural networks (dann). dann will effectively attempt to learn a hidden layer g f (\u00b7) that maps an example (either source or target) into a representation allowing the output layer g y (\u00b7) to accurately classify source samples, but crippling the ability of the domain regressor g d (\u00b7) to detect whether each example belongs to the source or target domains. section: generalization to arbitrary architectures for illustration purposes, we' ve so far focused on the case of a single hidden layer dann. however, it is straightforward to generalize to other sophisticated architectures, which might be more appropriate for the data at hand. for example, deep convolutional neural networks are well known for being state-of-the-art models for learning discriminative features of images [reference]. let us now use a more general notation for the different components of dann. namely, let g f (\u00b7;\u03b8 f) be the d-dimensional neural network feature extractor, with parameters\u03b8 f. also, let g y (\u00b7;\u03b8 y) be the part of dann that computes the network's label prediction output layer, with parameters\u03b8 y, while g d (\u00b7;\u03b8 d) now corresponds to the computation of the domain prediction output of the network, with parameters\u03b8 d. note that for preserving the theoretical guarantees of theorem 2, the hypothesis class h d generated by the domain prediction component g d should include the hypothesis class h y generated by the label prediction component g y. thus, we will note the prediction loss and the domain loss respectively by training dann then parallels the single layer case and consists in optimizing by finding the saddle point\u03b8 f,\u03b8 y,\u03b8 d such that as suggested previously, a saddle point defined by equations (11-12) can be found as a stationary point of the following gradient updates: where\u00b5 is the learning rate. we use stochastic estimates of these gradients, by sampling examples from the data set. the updates of equations (13-15) are very similar to stochastic gradient descent (sgd) updates for a feed-forward deep model that comprises feature extractor fed into the label figure 1: the proposed architecture includes a deep feature extractor (green) and a deep label predictor (blue), which together form a standard feed-forward architecture. unsupervised domain adaptation is achieved by adding a domain classifier (red) connected to the feature extractor via a gradient reversal layer that multiplies the gradient by a certain negative constant during the backpropagation-based training. otherwise, the training proceeds standardly and minimizes the label prediction loss (for source examples) and the domain classification loss (for all samples). gradient reversal ensures that the feature distributions over the two domains are made similar (as indistinguishable as possible for the domain classifier), thus resulting in the domain-invariant features. predictor and into the domain classifier (with loss weighted by\u03bb). the only difference is that in (13), the gradients from the class and domain predictors are subtracted, instead of being summed (the difference is important, as otherwise sgd would try to make features dissimilar across domains in order to minimize the domain classification loss). since sgdand its many variants, such as adagrad [reference] or adadelta [reference]- is the main learning algorithm implemented in most libraries for deep learning, it would be convenient to frame an implementation of our stochastic saddle point procedure as sgd. fortunately, such a reduction can be accomplished by introducing a special gradient reversal layer (grl), defined as follows. the gradient reversal layer has no parameters associated with it. during the forward propagation, the grl acts as an identity transformation. during the backpropagation however, the grl takes the gradient from the subsequent level and changes its sign, i.e., multiplies it by\u22121, before passing it to the preceding layer. implementing such a layer using existing object-oriented packages for deep learning is simple, requiring only to define procedures for the forward propagation (identity transformation), and backpropagation (multiplying by\u22121). the layer requires no parameter update. the grl as defined above is inserted between the feature extractor g f and the domain classifier g d, resulting in the architecture depicted in figure 1. as the backpropagation process passes through the grl, the partial derivatives of the loss that is downstream the grl (i.e., l d) w.r.t. the layer parameters that are upstream the grl (i.e.,\u03b8 f) get multiplied by\u22121, i.e.,. therefore, running sgd in the resulting model implements the updates of equations (13-15) and converges to a saddle point of equation (10). mathematically, we can formally treat the gradient reversal layer as a\" pseudo-function\" r (x) defined by two (incompatible) equations describing its forward and backpropagation behaviour: where i is an identity matrix. we can then define the objective\" pseudo-function\" of (\u03b8 f,\u03b8 y,\u03b8 d) that is being optimized by the stochastic gradient descent within our method: running updates (13-15) can then be implemented as doing sgd for (18) and leads to the emergence of features that are domain-invariant and discriminative at the same time. after the learning, the label predictor g y (g f (x;\u03b8 f);\u03b8 y) can be used to predict labels for samples from the target domain (as well as from the source domain). note that we release the source code for the gradient reversal layer along with the usage examples as an extension to caffe. 4 section: experiments in this section, we present a variety of empirical results for both shallow domain adversarial neural networks (subsection 5.1) and deep ones (subsections 5.2 and 5.3). section: experiments with shallow neural networks in this first experiment section, we evaluate the behavior of the simple version of dann described by subsection 4.1. note that the results reported in the present subsection are obtained using algorithm 1. thus, the stochastic gradient descent approach here consists of sampling a pair of source and target examples and performing a gradient step update of all parameters of dann. crucially, while the update of the regular parameters follows as usual the opposite direction of the gradient, for the adversarial parameters the step must follow the gradient's direction (since we maximize with respect to them, instead of minimizing). section: experiments on a toy problem as a first experiment, we study the behavior of the proposed algorithm on a variant of the inter-twinning moons 2d problem, where the target distribution is a rotation of the source one. as the source sample s, we generate a lower moon and an upper moon labeled 0 and 1 respectively, each of which containing 150 examples. the target sample t is obtained by the following procedure: (1) we generate a sample s the same way s has been generated; (2) we rotate each example by 35\u2022; and (3) we remove all the labels. thus, t contains 300 unlabeled examples. we have represented those examples in figure 2. we study the adaptation capability of dann by comparing it to the standard neural network (nn). in these toy experiments, both algorithms share the same network architecture, with a hidden layer size of 15 neurons. we train the nn using the same procedure as the dann. that is, we keep updating the domain regressor component using target sample t (with a hyper-parameter\u03bb= 6; the same value is used for dann), but we disable the adversarial back-propagation into the hidden layer. to do so, we execute algorithm 1 by omitting the lines numbered 22 and 31. this allows recovering the nn learning algorithm-based on the source risk minimization of equation (5) without any regularizer-and simultaneously train the domain regressor of equation (7) to discriminate between source and target domains. with this toy experience, we will first illustrate how dann adapts its decision boundary when compared to nn. moreover, we will also illustrate how the representation given by the hidden layer is less adapted to the source domain task with dann than with nn (this is why we need a domain regressor in the nn experiment). we recall that this is the founding idea behind our proposed algorithm. the analysis of the experiment appears in figure 2, where upper graphs relate to standard nn, and lower graphs relate to dann. by looking at the lower and upper graphs pairwise, we compare nn and dann from four different perspectives, described in details below. the column\" label classification\" of figure 2 shows the decision boundaries of dann and nn on the problem of predicting the labels of both source and the target examples. as expected, nn accurately classifies the two classes of the source sample s, but is not fully adapted to the target sample t. on the contrary, the decision boundary of dann perfectly classifies examples from both source and target samples. in the studied task, dann clearly adapts to the target distribution. the column\" representation pca\" studies how the domain adaptation regularizer affects the representation g f (\u00b7) provided by the network hidden layer. the graphs are obtained by applying a principal component analysis (pca) on the set of all representation of source and target data points, i.e., s (g f)\u222a t (g f). thus, given the trained network (nn or dann), every point from s and t is mapped into a 15-dimensional feature space through the hidden layer, and projected back into a two-dimensional plane by the pca transformation. in the dann-pca representation, we observe that target points are homogeneously spread out among source points; in the nn-pca representation, a number of target points belong to clusters containing no source points. hence, labeling the target points seems an easier task given the dann-pca representation. to push the analysis further, the pca graphs tag four crucial data points by the letters a, b, c and d, that correspond to the moon extremities in the original space (note that the original point locations are tagged in the first column graphs). we observe that points a and b are very close to each other in the nn-pca representation, while they clearly belong to different classes. the same happens to points c and d. conversely, these four points are at the opposite four corners in the dann-pca representation. note also that the target point a (resp. d)- that is difficult to classify in the original space-is located in the\"+\" cluster (resp.\"\u2212\u2212\u2212\"cluster) in the dann-pca representation. therefore, the representation promoted by dann is better suited to the adaptation problem. the column\" domain classification\" shows the decision boundary on the domain classification problem, which is given by the domain regressor g d of equation (7). more precisely, an example x is classified as a source example when g d (g f (x))\u2265 0.5, and is classified as a domain example otherwise. remember that, during the learning process of dann, the g d regressor struggles to discriminate between source and target domains, while the hidden representation g f (\u00b7) is adversarially updated to prevent it to succeed. as explained above, we trained a domain regressor during the learning process of nn, but without allowing it to influence the learned representation g f (\u00b7). on one hand, the dann domain regressor clearly fails to generalize source and target distribution topologies. on the other hand, the nn domain regressor shows a better (although imperfect) generalization capability. inter alia, it seems to roughly capture the rotation angle of the target distribution. this again corroborates that the dann representation does not allow discriminating between domains. the column\" hidden neurons\" shows the configuration of hidden layer neurons (by equation 4, we have that each neuron is indeed a linear regressor). in other words, each of the fifteen plot line corresponds to the coordinates x\u2208 r 2 for which the i-th component of g f (x) equals 1 2, for i\u2208 {1,..., 15}. we observe that the standard nn neurons are grouped in three clusters, each one allowing to generate a straight line of the zigzag decision boundary for the label classification problem. however, most of these neurons are also able to (roughly) capture the rotation angle of the domain classification problem. hence, we observe that the adaptation regularizer of dann prevents these kinds of neurons to be produced. it is indeed striking to see that the two predominant patterns in the nn neurons (i.e., the two parallel lines crossing the plane from lower left to upper right) are vanishing in the dann neurons. section: unsupervised hyper-parameter selection to perform unsupervised domain adaption, one should provide ways to set hyper-parameters (such as the domain regularization parameter\u03bb, the learning rate, the network architecture for our method) in an unsupervised way, i.e., without referring to labeled data in the target domain. in the following experiments of sections 5.1.3 and 5.1.4, we select the hyper-parameters of each algorithm by using a variant of reverse cross-validation approach proposed by [reference], that we call reverse validation. to evaluate the reverse validation risk associated to a tuple of hyper-parameters, we proceed as follows. given the labeled source sample s and the unlabeled target sample t, we split each set into training sets (s and t respectively, containing 90% of the original examples) and the validation sets (s v and t v respectively). we use the labeled set s and the unlabeled target set t to learn a classifier\u03b7. then, using the same algorithm, we learn a reverse classifier\u03b7 r using the self-labeled set {(x,\u03b7 (x))} x\u2208t and the unlabeled part of s as target sample. finally, the reverse classifier\u03b7 r is evaluated on the validation set s v of source sample. we then say that the classifier\u03b7 has a reverse validation risk of r s v (\u03b7 r). the process is repeated with multiple values of hyper-parameters and the selected parameters are those corresponding to the classifier with the lowest reverse validation risk. note that when we train neural network architectures, the validation set s v is also used as an early stopping criterion during the learning of\u03b7, and self-labeled validation set {(x,\u03b7 (x))} x\u2208t v is used as an early stopping criterion during the learning of\u03b7 r. we also observed better accuracies when we initialized the learning of the reverse classifier\u03b7 r with the configuration learned by the network\u03b7. section: experiments on sentiment analysis data sets we now compare the performance of our proposed dann algorithm to a standard neural network with one hidden layer (nn) described by equation (5), and a support vector machine (svm) with a linear kernel. we compare the algorithms on the amazon reviews data set, as pre-processed by [reference]. this data set includes four domains, each one composed of reviews of a specific kind of product (books, dvd disks, electronics, and kitchen appliances). reviews are encoded in 5 000 dimensional feature vectors of unigrams and bigrams, and labels are binary:\" 0\" if the product is ranked up to 3 stars, and\" 1\" if the product is ranked 4 or 5 stars. we perform twelve domain adaptation tasks. all learning algorithms are given 2 000 labeled source examples and 2 000 unlabeled target examples. then, we evaluate them on separate target test sets (between 3 000 and 6 000 examples). note that nn and svm do not use the unlabeled target sample for learning. here are more details about the procedure used for each learning algorithms leading to the empirical results of table 1: classification accuracy on the amazon reviews data set, and pairwise poisson binomial test.\u2022 for the dann algorithm, the adaptation parameter\u03bb is chosen among 9 values between 10\u22122 and 1 on a logarithmic scale. the hidden layer size l is either 50 or 100. finally, the learning rate\u00b5 is fixed at 10\u22123.\u2022 for the nn algorithm, we use exactly the same hyper-parameters grid and training procedure as dann above, except that we do not need an adaptation parameter. note that one can train nn by using the dann implementation (algorithm 1) with\u03bb= 0.\u2022 for the svm algorithm, the hyper-parameter c is chosen among 10 values between 10\u22125 and 1 on a logarithmic scale. this range of values is the same as used by [reference] in their experiments. as presented at section 5.1.2, we used reverse cross validation selecting the hyper-parameters for all three learning algorithms, with early stopping as the stopping criterion for dann and nn. the\" original data\" part of table 1a shows the target test accuracy of all algorithms, and table 1b reports the probability that one algorithm is significantly better than the others according to the poisson binomial test [reference]. we note that dann has a significantly better performance than nn and svm, with respective probabilities 0.87 and 0.83. as the only difference between dann and nn is the domain adaptation regularizer, we conclude that our approach successfully helps to find a representation suitable for the target domain. section: combining dann with denoising autoencoders we now investigate on whether the dann algorithm can improve on the representation learned by the state-of-the-art marginalized stacked denoising autoencoders (msda) proposed by [reference]. in brief, msda is an unsupervised algorithm that learns a new robust feature representation of the training samples. it takes the unlabeled parts of both source and target samples to learn a feature map from input space x to a new representation space. as a denoising autoencoders algorithm, it finds a feature representation from which one can (approximately) reconstruct the original features of an example from its noisy counterpart. [reference] showed that using msda with a linear svm classifier reaches state-of-the-art performance on the amazon reviews data sets. as an alternative to the svm, we propose to apply our shallow dann algorithm on the same representations generated by msda (using representations of both source and target samples). note that, even if msda and dann are two representation learning approaches, they optimize different objectives, which can be complementary. we perform this experiment on the same amazon reviews data set described in the previous subsection. for each source-target domain pair, we generate the msda representations using a corruption probability of 50% and a number of layers of 5. we then execute the three learning algorithms (dann, nn, and svm) on these representations. more precisely, following the experimental procedure of [reference], we use the concatenation of the output of the 5 layers and the original input as the new representation. thus, each example is now encoded in a vector of 30 000 dimensions. note that we use the same grid search as in the previous subsection 5.1.3, but use a learning rate\u00b5 of 10\u22124 for both dann and the nn. the results of\" msda representation\" columns in table 1a confirm that combining msda and dann is a sound approach. indeed, the poisson binomial test shows that dann has a better performance than the nn and the svm, with probabilities 0.92 and 0.88 respectively, as reported in table 1b. we note however that the standard nn and the svm find the best solution on respectively the second and the fourth tasks. this suggests that dann and msda adaptation strategies are not fully complementary. section: proxy distance the theoretical foundation of the dann algorithm is the domain adaptation theory of [reference][reference]. we claimed that dann finds a representation in which the source and the target example are hardly distinguishable. our toy experiment of section 5.1.1 already points out some evidence for that and here we provide analysis on real data. to do so, we compare the proxy a-distance (pad) on various representations of the amazon reviews data set; these representations are obtained by running either nn, dann, msda, or msda and dann combined. recall that pad, as described in section 3.2, is a metric estimating the similarity of the source and the target representations. more precisely, to obtain a pad value, we use the following procedure: (1) we construct the data set u of equation (2) using both source and target representations of the training samples; (2) we randomly split u in two subsets of equal size; (3) we train linear svms on the first subset of u using a large range of c values; (4) we compute the error of all obtained classifiers on the second subset of u; and (5) we use the lowest error to compute the pad value of equation (3). firstly, figure 3a compares the pad of dann representations obtained in the experiments of section 5.1.3 (using the hyper-parameters values leading to the results of table 1) to the pad computed on raw data. as expected, the pad values are driven down by the dann representations. secondly, figure 3b compares the pad of dann representations to the pad of standard nn representations. as the pad is influenced by the hidden layer size (the discriminating power tends to increase with the representation length), we fix here the size to 100 neurons for both algorithms. we also fix the adaptation parameter of dann to\u03bb 0.31; it was the value that has been selected most of the time during our preceding experiments on the amazon reviews data set. again, dann is clearly leading to the lowest pad values. lastly, figure 3c presents two sets of results related to section 5.1.4 experiments. on one hand, we reproduce the results of [reference], which noticed that the msda representations have greater pad values than original (raw) data. although the msda approach clearly helps to adapt to the target task, it seems to contradict the theory of bendavid et al.. on the other hand, we observe that, when running dann on top of msda (using the hyper-parameters values leading to the results of table 1), the obtained representations have much lower pad values. these observations might explain the improvements provided by dann when combined with the msda procedure. section: experiments with deep networks on image classification we now perform extensive evaluation of a deep version of dann (see subsection 4.2) on a number of popular image data sets and their modifications. these include large-scale data sets of small images popular with deep learning methods, and the office data sets [reference], which are a de facto standard for domain adaptation in computer vision, but have much fewer images. section: baselines the following baselines are evaluated in the experiments of this subsection. the source-only model is trained without consideration for target-domain data (no domain classifier branch included into the network). the train-on-target model is trained on the target domain with class labels revealed. this model serves as an upper bound on da methods, assuming that target data are abundant and the shift between the domains is considerable. in addition, we compare our approach against the recently proposed unsupervised da method based on subspace alignment (sa) [reference], which is simple to setup and test on new data sets, but has also been shown to perform very well in experimental comparisons with other\" shallow\" da methods. to boost the performance of this baseline, we pick its most important free parameter (the number of principal components) from the range {2,..., 60}, so that the test performance on the target domain is maximized. to apply sa in our setting, we train a source-only model and then consider the activations of the last hidden layer in the label predictor (before the final linear classifier) as descriptors/ features, and learn the mapping between the source and the target domains [reference]. since the sa baseline requires training a new classifier after adapting the features, and in order to put all the compared settings on an equal footing, we retrain the last layer of the label predictor using a standard linear svm [reference] for all four considered methods (including ours; the performance on the target domain remains approximately the same after the retraining). for the office data set [reference], we directly compare the performance of our full network (feature extractor and label predictor) against recent da approaches using previously published results. section: cnn architectures and training procedure in general, we compose feature extractor from two or three convolutional layers, picking their exact configurations from previous works. more precisely, four different architectures were used in our experiments. the first three are shown in figure 4. for the office domains, we use pre-trained alexnet from the caffe-package. the adaptation architecture is identical to. [reference] for the domain adaption component, we use three (x\u21921024\u21921024\u21922) fully connected layers, except for mnist where we used a simpler (x\u2192100\u21922) architecture to speed up the experiments. admittedly these choices for domain classifier are arbitrary, and better adaptation performance might be attained if this part of the architecture is tuned. (x\u21921024\u21921024\u21922) for the loss functions, we set l y and l d to be the logistic regression loss and the binomial cross-entropy respectively. following [reference] we also use dropout and 2-norm restriction when we train the svhn architecture. section: a 2-layer domain classifier the other hyper-parameters are not selected through a grid search as in the small scale experiments of section 5.1, which would be computationally costly. instead, the learning rate is adjusted during the stochastic gradient descent using the following formula: where p is the training progress linearly changing from 0 to 1,\u00b5 0= 0.01,\u03b1= 10 and\u03b2= 0.75 (the schedule was optimized to promote convergence and low error on the source domain). a momentum term of 0.9 is also used. the domain adaptation parameter\u03bb is initiated at 0 and is gradually changed to 1 using the following schedule: where\u03b3 was set to 10 in all experiments (the schedule was not optimized/ tweaked). this strategy allows the domain classifier to be less sensitive to noisy signal at the early stages of the training procedure. note however that these\u03bb p were used only for updating the feature extractor component g f. for updating the domain classification component, we used a fixed\u03bb= 1, to ensure that the latter trains as fast as the label predictor g y. [reference] finally, note that the model is trained on 128-sized batches (images are preprocessed by the mean subtraction). a half of each batch is populated by the samples from the source domain (with known labels), the rest constitutes the target domain (with labels not revealed to the algorithms except for the train-on-target baseline). section: visualizations we use t-sne (van der maaten, 2013) projection to visualize feature distributions at different points of the network, while color-coding the domains (figure 5). as we already observed with the shallow version of dann (see figure 2), there is a strong correspondence 6. equivalently, one can use the same\u03bbp for both feature extractor and domain classification components, but use a learning rate of\u00b5/\u03bbp for the latter. between the success of the adaptation in terms of the classification accuracy for the target domain, and the overlap between the domain distributions in such visualizations. section: results on image data sets we now discuss the experimental settings and the results. in each case, we train on the source data set and test on a different target domain data set, with considerable shifts between domains (see figure 6). the results are summarized in table 2 and table 3. mnist\u2192 mnist-m. our first experiment deals with the mnist data set [reference]. in order to obtain the target domain (mnist-m) we blend digits from the original set over patches randomly extracted from color photos from bsds500 [reference]. this operation is formally defined for two images i 1, i 2 as i out ijk=|i 1 ijk\u2212 i 2 ijk|, where i, j are the coordinates of a pixel and k is a channel index. in other words, an output sample is produced by taking a patch from a photo and inverting its pixels at positions corresponding to the pixels of a digit. for a human the classification task becomes only slightly harder compared to the original data set (the digits are still clearly distinguishable) whereas for a cnn trained on mnist this domain is quite distinct, as the background and the strokes are no longer constant. consequently, the source-only model performs poorly. our approach succeeded at aligning feature distributions (figure 5), which led to successful adaptation results (considering that the adaptation is unsupervised). at the same time, the improvement over source-only model achieved by subspace alignment (sa) [reference]) is quite modest, thus highlighting the difficulty of the adaptation task. synthetic numbers\u2192 svhn. to address a common scenario of training on synthetic data and testing on real data, we use street-view house number data set svhn [reference] as the target domain and synthetic digits as the source. the latter (syn numbers) consists of\u2248 500, 000 images generated by ourselves from windows tm fonts by varying the text (that includes different one -, two -, and three-digit numbers), positioning, orientation, background and stroke colors, and the amount of blur. the degrees of variation were chosen manually to simulate svhn, however the two data sets are still rather distinct, the biggest difference being the structured clutter in the background of svhn images. the proposed backpropagation-based technique works well covering almost 80% of the gap between training with source data only and training on target domain data with known target labels. in contrast, sa [reference] results in a slight classification accuracy drop (probably due to the information loss during the dimensionality reduction), indicating that the adaptation task is even more challenging than in the case of the mnist experiment. mnist\u2194 svhn. in this experiment, we further increase the gap between distributions, and test on mnist and svhn, which are significantly different in appearance. training on svhn even without adaptation is challenging-classification error stays high during the first 150 epochs. in order to avoid ending up in a poor local minimum we, therefore, do not use learning rate annealing here. obviously, the two directions (mnist\u2192 svhn and svhn\u2192 mnist) are not equally difficult. as svhn is more diverse, a model trained on svhn is expected to be more generic and to perform reasonably on the mnist data set. this, indeed, turns out to be the case and is supported by the appearance of the table 2: classification accuracies for digit image classifications for different source and target domains. mnist-m corresponds to difference-blended digits over nonuniform background. the first row corresponds to the lower performance bound (i.e., if no adaptation is performed). the last row corresponds to training on the target domain data with known class labels (upper bound on the da performance). for each of the two da methods [reference] we show how much of the gap between the lower and the upper bounds was covered (in brackets). for all five cases, our approach outperforms [reference] considerably, and covers a big portion of the gap. table 3: accuracy evaluation of different da approaches on the standard office [reference]) data set. all methods (except sa) are evaluated in the\" fullytransductive\" protocol (some results are reproduced from [reference]. our method (last row) outperforms competitors setting the new state-of-the-art. syn and real denote available labeled data (100, 000 synthetic and 430 real images respectively); adapted means that\u2248 31, 000 unlabeled target domain images were used for adaptation. the best performance is achieved by employing both the labeled samples and the large unlabeled corpus in the target domain. feature distributions. we observe a quite strong separation between the domains when we feed them into the cnn trained solely on mnist, whereas for the svhn-trained network the features are much more intermixed. this difference probably explains why our method succeeded in improving the performance by adaptation in the svhn\u2192 mnist scenario (see table 2) but not in the opposite direction (sa is not able to perform adaptation in this case either). unsupervised adaptation from mnist to svhn gives a failure example for our approach: it does n't manage to improve upon the performance of the non-adapted model which achieves\u2248 0.25 accuracy (we are unaware of any unsupervised da methods capable of performing such adaptation). synthetic signs\u2192 gtsrb. overall, this setting is similar to the syn numbers\u2192 svhn experiment, except the distribution of the features is more complex due to the significantly larger number of classes (43 instead of 10). for the source domain we obtained 100, 000 synthetic images (which we call syn signs) simulating various imaging conditions. in the target domain, we use 31, 367 random training samples for unsupervised adaptation and the rest for evaluation. once again, our method achieves a sensible increase in performance proving its suitability for the synthetic-to-real data adaptation. as an additional experiment, we also evaluate the proposed algorithm for semi-supervised domain adaptation, i.e., when one is additionally provided with a small amount of labeled target data. here, we reveal 430 labeled examples (10 samples per class) and add them to the training set for the label predictor. figure 7 shows the change of the validation error throughout the training. while the graph clearly suggests that our method can be beneficial in the semi-supervised setting, thorough verification of semi-supervised setting is left for future work. office data set. we finally evaluate our method on office data set, which is a collection of three distinct domains: amazon, dslr, and webcam. unlike previously discussed data sets, office is rather small-scale with only 2817 labeled images spread across 31 different categories in the largest domain. the amount of available data is crucial for a successful training of a deep model, hence we opted for the fine-tuning of the cnn pre-trained on the imagenet (alexnet from the caffe package, see as it is done in some recent da works [reference][reference]. we make our approach more comparable with by using exactly the same network architecture replacing domain mean-based regularization with the domain classifier. following previous works, we assess the performance of our method across three transfer tasks most commonly used for evaluation. our training protocol is adopted from; [reference]; [reference] as during adaptation we use all available labeled source examples and unlabeled target examples (the premise of our method is the abundance of unlabeled data in the target domain). also, all source domain data are used for training. under this\" fully-transductive\" setting, our method is able to improve previously-reported state-of-the-art accuracy for unsupervised adaptation very considerably (table 3), especially in the most challenging amazon\u2192 webcam scenario (the two domains with the largest domain shift). interestingly, in all three experiments we observe a slight over-fitting (performance on the target domain degrades while accuracy on the source continues to improve) as training progresses, however, it does n't ruin the validation accuracy. moreover, switching off the domain classifier branch makes this effect far more apparent, from which we conclude that our technique serves as a regularizer. section: experiments with deep image descriptors for re-identification in this section we discuss the application of the described adaptation method to person re-identification (re-i d) problem. the task of person re-identification is to associate people seen from different camera views. more formally, it can be defined as follows: given two sets of images from different cameras (probe and gallery) such that each person depicted in the probe set has an image in the gallery set, for each image of a person from the probe set find an image of the same person in the gallery set. disjoint camera views, different illumination conditions, various poses and low quality of data make this problem difficult even for humans (e.g., [reference], reports human performance at rank1=71.08%). unlike classification problems that are discussed above, re-identification problem implies that each image is mapped to a vector descriptor. the distance between descriptors is then used to match images from the probe set and the gallery set. to evaluate results of re-i d methods the cumulative match characteristic (cmc) curve is commonly used. it is a plot of the identification rate (recall) at rank-k, that is the probability of the matching gallery image to be within the closest k images (in terms of descriptor distance) to the probe image. most existing works train descriptor mappings and evaluate them within the same data set containing images from a certain camera network with similar imaging conditions. several papers, however, observed that the performance of the resulting re-identification systems drops very considerably when descriptors trained on one data set and tested on another. it is therefore natural to handle such cross-domain evaluation as a domain-adaptation problem, where each camera network (data set) constitutes a domain. recently, several papers with significantly improved re-identification performance [reference][reference][reference] have been presented, with [reference] reporting good results in cross-data-set evaluation scenario. at the moment, deep learning methods [reference] do not achieve state-of-the-art results probably because of the limited size of the training sets. domain adaptation thus represents a viable direction for improving deep re-identification descriptors. section: data sets and protocols following [reference], we use prid [reference], viper [reference], cuhk [reference] as target data sets for our experiments. the prid data set exists in two versions, and as in [reference] we use a single-shot variant. it contains images of 385 persons viewed from camera a and images of 749 persons viewed from camera b, 200 persons appear in both cameras. the viper data set also contains images taken with two cameras, and in total 632 persons are captured, for every person there is one image for each of the two camera views. the cuhk data set consists of images from five pairs of cameras, two images for each person from each of the two cameras. we refer to the subset of this data set that includes the first pair of cameras only as cuhk/ p1 (as most papers use this subset). see figure 8 for samples of these data sets. we perform extensive experiments for various pairs of data sets, where one data set serves as a source domain, i.e., it is used to train a descriptor mapping in a supervised way with known correspondences between probe and gallery images. the second data set is used as a target domain, so that images from that data set are used without probe-gallery correspondence. in more detail, cuhk/ p1 is used for experiments when cuhk serves as a target domain and two settings (\" whole cuhk\" and cuhk/ p1) are used for experiments when cuhk serves as a source domain. given prid as a target data set, we randomly choose 100 persons appearing in both camera views as training set. the images of the other 100 persons from camera a are used as probe, all images from camera b excluding those used in training (649 in total) are used as gallery at test time. for viper, we use random 316 persons for training and all others for testing. for cuhk, 971 persons are split into 485 for training and 486 for testing. unlike [reference], we use all images in the first pair of cameras of cuhk instead of choosing one image of a person from each camera view. we also performed two experiments with all images of the whole cuhk data set as source domain and viper and prid data sets as target domains as in the original paper [reference]. following [reference], we augmented our data with mirror images, and during test time we calculate similarity score between two images as the mean of the four scores corresponding to different flips of the two compared images. in case of cuhk, where there are 4 images (including mirror images) for each of the two camera views for each person, all 16 combinations' scores are averaged. section: cnn architectures and training procedure in our experiments, we use siamese architecture described in [reference] (deep metric learning or dml) for learning deep image descriptors on the source data set. this architecture incorporates two convolution layers (with 7\u00d7 7 and 5\u00d7 5 filter banks), followed by relu and max pooling, and one fully-connected layer, which gives 500-dimensional descriptors as an output. there are three parallel flows within the cnn for processing three part of an image: the upper, the middle, and the lower one. the first convolution layer shares parameters between three parts, and the outputs of the second convolution layers are concatenated. during training, we follow [reference] and calculate pairwise cosine similarities between 500-dimensional features within each batch and backpropagate the loss for all pairs within batch. to perform domain-adversarial training, we construct a dann architecture. the feature extractor includes the two convolutional layers (followed by max-pooling and relu) discussed above. the label predictor in this case is replaced with descriptor predictor that includes one fully-connected layer. the domain classifier includes two fully-connected layers with 500 units in the intermediate representation (x\u2192500\u21921). for the verification loss function in the descriptor predictor we used binomial deviance loss, defined in [reference] with similar parameters:\u03b1= 2,\u03b2= 0.5, c= 2 (the asymmetric cost parameter for negative pairs). the domain classifier is trained with logistic loss as in subsection 5.2.2. we used learning rate fixed to 0.001 and momentum of 0.9. the schedule of adaptation similar to the one described in subsection 5.2.2 was used. we also inserted dropout layer with rate 0.5 after the concatenation of outputs of the second max-pooling layer. 128-sized batches were used for source data and 128-sized batches for target data. figure 9 shows results in the form of cmc-curves for eight pairs of data sets. depending on the hardness of the annotation problem we trained either for 50, 000 iterations (cuhk/ p1\u2192 viper, viper\u2192 cuhk/ p1, prid\u2192 viper) or for 20, 000 iterations (the other five pairs). section: results on re-identification data sets after the sufficient number of iterations, domain-adversarial training consistently improves the performance of re-identification. for the pairs that involve prid data set, which is more dissimilar to the other two data sets, the improvement is considerable. overall, this demonstrates the applicability of the domain-adversarial learning beyond classification problems. section: conclusion the paper proposes a new approach to domain adaptation of feed-forward neural networks, which allows large-scale training based on large amount of annotated data in the source domain and large amount of unannotated data in the target domain. similarly to many previous shallow and deep da techniques, the adaptation is achieved through aligning the distributions of features across the two domains. however, unlike previous approaches, the alignment is accomplished through standard backpropagation training. the approach is motivated and supported by the domain adaptation theory of [reference]. the main idea behind dann is to enjoin the network hidden layer to learn a representation which is predictive of the source example labels, but uninformative about the domain of the input (source or target). we implement this new approach within both shallow and deep feed-forward architectures. the latter allows simple implementation within virtually any deep learning package through the introduction of a simple gradient reversal layer. we have shown that our approach is flexible and achieves state-of-the-art results on a variety of benchmark in domain adaptation, namely for sentiment analysis and image classification tasks. a convenient aspect of our approach is that the domain adaptation component can be added to almost any neural network architecture that is trainable with backpropagation. towards this end, we have demonstrated experimentally that the approach is not confined to classification tasks but can be used in other feed-forward architectures, e.g., for descriptor learning for person re-identification. section: section: acknowledgments this work has been supported by national science and engineering research council (nserc) discovery grants 262067 and 0122405 as well as the russian ministry of science and education grant rfmefi57914x0071. computations were performed on the colosse supercomputer grid at universit\u00e9 laval, under the auspices of calcul qu\u00e9bec and compute canada. the operations of colosse are funded by the nserc, the canada foundation for innovation (cfi), nanoqu\u00e9bec, and the fonds de recherche du qu\u00e9bec-nature et technologies (frqnt). we also thank the graphics& media lab, faculty of computational mathematics and cybernetics, lomonosov moscow state university for providing the synthetic road signs data set. section:",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "domain adversarial training of neural networks"
                    ],
                    [
                        "adversarial training of neural networks"
                    ],
                    [
                        "domain adversarial neural networks"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ],
                    [
                        "classification accuracies"
                    ]
                ],
                "Task": [
                    [
                        "sentiment analysis"
                    ],
                    [
                        "image classification"
                    ],
                    [
                        "image classification task"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "written reviews",
                        "sentiment analysis data sets",
                        "amazon reviews data set",
                        "books",
                        "dvd disks",
                        "electronics",
                        "kitchen appliances",
                        "reviews",
                        "amazon reviews data sets",
                        "source domain data"
                    ]
                ],
                "Method": [
                    [
                        "domain-adversarial training of neural networks",
                        "domain-adversarial neural network",
                        "dann",
                        "domain-adversarial neural networks",
                        "backpropagation-based training"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "document sentiment analysis",
                        "sentiment analysis",
                        "sentiment analysis problem"
                    ]
                ]
            }
        ]
    },
    "1130d8fdd931225c2d7563c3808367726cfa1c3a-13": {
        "doctext": "document: pixelgan autoencoders in this paper, we describe the ''pixelgan autoencoder'', a generative autoencoder in which the generative path is a convolutional autoregressive neural network on pixels (pixelcnn) that is conditioned on a latent code, and the recognition path uses a generative adversarial network (gan) to impose a prior distribution on the latent code. we show that different priors result in different decompositions of information between the latent code and the autoregressive decoder. for example, by imposing a gaussian distribution as the prior, we can achieve a global vs. local decomposition, or by imposing a categorical distribution as the prior, we can disentangle the style and content information of images in an unsupervised fashion. we further show how the pixelgan autoencoder with a categorical prior can be directly used in semi-supervised settings and achieve competitive semi-supervised classification results on the mnist, svhn and norb datasets. numbers, compressnatbib section: introduction in recent years, generative models that can be trained via direct back-propagation have enabled remarkable progress in modeling natural images. one of the most successful models is the generative adversarial network (gan) gan, which employs a two player min-max game. the generative model,, samples the prior and generates the sample. the discriminator,, is trained to identify whether a point is a sample from the data distribution or a sample from the generative model. the generator is trained to maximally confuse the discriminator into believing that generated samples come from the data distribution. the cost function of gan is gans can be considered within the wider framework of implicit generative models mohamed2016learning, ference, dustin. implicit distributions can be sampled through their generative path, but their likelihood function is not tractable. recently, several papers have proposed another application of gan-style algorithms for approximate inference, mohamed2016learning, ference, dustin, ranganath2016operator, aae, avb, ali, bigan. these algorithms use implicit distributions to learn posterior approximations that are more expressive than the distributions with tractable densities that are often used in variational inference. for example, adversarial autoencoders (aae) aae use a universal approximator posterior as the implicit posterior distribution and use adversarial training to match the aggregated posterior of the latent code to the prior distribution. adversarial variational bayes ference, avb uses a more general amortized gan inference framework within a maximum-likelihood learning setting. another type of gan inference technique is used in the ali ali and bigan bigan models, which have been shown to approximate maximum likelihood learning ference. in these models, both the recognition and generative models are implicit and are jointly learnt by an adversarial training process. variational autoencoders (vae) vae, rezende are another state-of-the-art image modeling technique that use neural networks to parametrize the posterior distribution and pair it with a top-down generative network. both networks are jointly trained to maximize a variational lower bound on the data log-likelihood. a different framework for learning density models is autoregressive neural networks such as nade nade, made made, pixelrnn pixelrnn and pixelcnn pixelcnn. unlike variational autoencoders, which capture the statistics of the data in hierarchical latent codes, the autoregressive models learn the image densities directly at the pixel level without learning a hierarchical latent representation. in this paper, we present the pixelgan autoencoder as a generative autoencoder that combines the benefits of latent variable models with autoregressive architectures. the pixelgan autoencoder is a generative autoencoder in which the generative path is a pixelcnn that is conditioned on a latent variable. the latent variable is inferred by matching the aggregated posterior distribution to the prior distribution by an adversarial training technique similar to that of the adversarial autoencoder aae. however, whereas in adversarial autoencoders the statistics of the data distribution are captured by the latent code, in the pixelgan autoencoder they are captured jointly by the latent code and the autoregressive decoder. we show that imposing different distributions as the prior results in different factorizations of information between the latent code and the autoregressive decoder. for example, in: pixelgan_gaussian] section [reference], we show that by imposing a gaussian distribution on the latent code, we can achieve a global vs. local decomposition of information. in this case, the global latent code no longer has to model all the irrelevant and fine details of the image, and can use its capacity to capture more relevant and global statistics of the image. another type of decomposition of information that can be learnt by pixelgan autoencoders is a discrete vs. continuous decomposition. in: pixelgan_cat] section [reference], we show that we can achieve this decomposition by imposing a categorical prior on the latent code using adversarial training. in this case, the categorical latent code captures the discrete underlying factors of variation in the data, such as class label information, and the autoregressive decoder captures the remaining continuous structure, such as style information, in an unsupervised fashion. we then show how pixelgan autoencoders with categorical priors can be directly used in clustering and semi-supervised scenarios and achieve very competitive classification results on several datasets in: experiments] section [reference]. finally, we present one of the main potential applications of pixelgan autoencoders in learning cross-domain relations between two different domains in: cross-domain] section [reference]. section: pixelgan autoencoders let be a datapoint that comes from the distribution and be the hidden code. the recognition path of the pixelgan autoencoder (: pixelgan_gaussian] figure [reference]) defines an implicit posterior distribution by using a deterministic neural function that takes the input along with random noise with a fixed distribution and outputs. the aggregated posterior of this model is defined as follows: this parametrization of the implicit posterior distribution was originally proposed in the adversarial autoencoder work aae as the universal approximator posterior. we can sample from this implicit distribution, by evaluating at different samples of, but the density function of this posterior distribution is intractable. endix: input_noise] appendix [reference] discusses the importance of the input noise in training pixelgan autoencoders. the generative path is a conditional pixelcnn pixelcnn that conditions on the latent vector using an adaptive bias in pixelcnn layers. the inference is done by an amortized gan inference technique that was originally proposed in the adversarial autoencoder work aae. in this method, an adversarial network is attached on top of the hidden code vector of the autoencoder and matches the aggregated posterior distribution,, to an arbitrary prior,. samples from and are provided to the adversarial network as the negative and positive examples respectively, and the generator of the adversarial network, which is also the encoder of the autoencoder, tries to match to by the gradient that comes through the discriminative adversarial network. the adversarial network, the pixelcnn decoder and the encoder are trained jointly in two phases- the reconstruction phase and the adversarial phase- executed on each mini-batch. in the reconstruction phase, the ground truth input along with the hidden code inferred by the encoder are provided to the pixelcnn decoder. the pixelcnn decoder weights are updated to maximize the log-likelihood of the input. the encoder weights are also updated at this stage by the gradient that comes through the conditioning vector of the pixelcnn. in the adversarial phase, the adversarial network updates both its discriminative network and its generative network (the encoder) to match to. once the training is done, we can sample from the model by first sampling from the prior distribution, and then sampling from the conditional likelihood parametrized by the pixelcnn decoder. we now establish a connection between the pixelgan autoencoder cost and maximum likelihood learning using a decomposition of the aggregated evidence lower bound (elbo) proposed in surgery: the first term in elbo] equation [reference] is the reconstruction term and the second term is the marginal kl divergence between the aggregated posterior and the prior distribution. the third term is the mutual information between the latent code and the input. this is a regularization term that encourages and to be decoupled by removing the information of the data distribution from the hidden code. if the training set has examples, is bounded as follows (see surgery). in order to maximize the elbo, we need to minimize all the three terms of elbo] equation [reference]. we consider two cases for the decoder: deterministic decoder. if the decoder is deterministic or has very limited stochasticity such as the simple factorized decoder of the vae, the mutual information term acts in the complete opposite direction of the reconstruction term. this is because the only way to minimize the reconstruction error of is to learn a hidden code that is relevant to, which results in maximizing. indeed, it can be shown that minimizing the reconstruction term maximizes a variational lower bound on i m, infogan. for example, in the case of the vae trained on mnist, since the reconstruction is precise, the mutual information term is dominated and is close to its maximum value surgery. stochastic decoder. if we use a powerful decoder such as the pixelcnn, the reconstruction term and the mutual information term will not compete with each other anymore and the network can minimize both independently. in this case, the optimal solution for maximizing the elbo would be to model solely by and thereby minimizing the reconstruction term, and at the same time, minimizing the mutual information term by ignoring the latent code. as a result, even though the model achieves a high likelihood, the latent code does not learn any useful representation, which is undesirable. this problem has been observed in several previous works bowman, vlae and different techniques such as annealing the weight of the kl term bowman or weakening the decoder vlae have been proposed to make and more dependent. as suggested in ference_ml, vlae, we think that the maximum likelihood objective by itself is not a useful objective for representation learning especially when a powerful decoder is used. in pixelgan autoencoders, in order to encourage learning more useful representations, we modify the elbo (elbo] equation [reference]) by removing the mutual information term from it, since this term is explicitly encouraging to become independent of. so our cost function only includes the reconstruction term and the marginal kl term. the reconstruction term is optimized by the reconstruction phase of training and the marginal kl term is approximately optimized by the adversarial phase. note that since the mutual information term is upper bounded by a constant (), we are still maximizing a lower bound on the log-likelihood of data. however, this bound is weaker than the elbo, which is the price that is paid for learning more useful latent representations by balancing the decomposition of information between the latent code and the autoregressive decoder. for implementing the conditioning adaptive bias in the pixelcnn decoder, we explore two different architectures pixelcnn. in the location-invariant bias, for each pixelcnn layer, we use the latent code to construct a vector that is broadcasted within each feature map of the layer and then added as an adaptive bias to that layer. in the location-dependent bias, we use the latent code to construct a spatial feature map that is broadcasted across different feature maps and then added only to the first layer of the decoder as an adaptive bias. we will discuss the effect of these architectures on the learnt representation in: mnist_code] figure [reference] of: pixelgan_gaussian] section [reference] and their implementation details in endix: conditioning_of_pixelcnn] appendix [reference]. subsection: pixelgan autoencoders with gaussian priors here, we show that pixelgan autoencoders with gaussian priors can decompose the global and local statistics of the images between the latent code and the autoregressive decoder.: mnist] figure [reference] a shows the samples of a pixelgan autoencoder model with the location-dependent bias trained on the mnist dataset. for the purpose of better illustrating the decomposition of information, we have chosen a 2-d gaussian latent code and a limited the receptive field of size 9 for the pixelgan autoencoder.: mnist] figure [reference] b shows the samples of a pixelcnn model with the same limited receptive field size of 9 and: mnist] figure [reference] c shows the samples of an adversarial autoencoder with the 2-d gaussian latent code. the pixelcnn can successfully capture the local statistics, but fails to capture the global statistics due to the limited receptive field size. in contrast, the adversarial autoencoder, whose sample quality is very similar to that of the vae, can successfully capture the global statistics, but fails to generate the details of the images. however, the pixelgan autoencoder, with the same receptive field and code size, can combine the best of both and generates sharp images with global statistics. in pixelgan autoencoders, both the pixelcnn depth and the conditioning architecture affect the decomposition of information between the latent code and the autoregressive decoder. we investigate these effects in: mnist_code] figure [reference] by training a pixelgan autoencoder on mnist where the code size is chosen to be for the visualization purpose. as shown in: mnist_code] figure [reference] a, b, when a shallow decoder is used, most of the information will be encoded in the hidden code and there is a clean separation between the digit clusters. as we make the pixelcnn more powerful (: mnist_code] figure [reference] c, d), we can see that the hidden code is still used to capture some relevant information of the input, but the separation of digit clusters is not as sharp when the limited code size of 2 is used. in the next section, we will show that by using a larger code size (e.g., 30), we can get a much better separation of digit clusters even when a powerful pixelcnn is used. the conditioning architecture also affects the decomposition of information. in the case of the location-invariant bias, the hidden code is encouraged to learn the global information that is location-invariant (the what information and not the where information) such as the class label information. for example, we can see in: mnist_code] figure [reference] a, c that the network has learnt to use one of the axes of the 2d gaussian code to explicitly encode the digit label even though a continuous prior is imposed. in this case, we can potentially get a much better separation if we impose a discrete prior. this makes this architecture suitable for the discrete vs. continuous decomposition and we use it for our clustering and semi-supervised learning experiments. in the case of the location-dependent bias (: mnist_code] figure [reference] b, d), the hidden code is encouraged to learn the global information that has location dependent information such as low-frequency content of the image, similar to what the hidden code of an adversarial or variational autoencoder would learn (: mnist] figure [reference] c). this makes this architecture suitable for the global vs. local decomposition experiments such as: mnist] figure [reference] a. from: mnist_code] figure [reference], we can see that the class label information is mostly captured by while the style information of the images is captured by both and. this decomposition of information has also been studied in other works that combine the latent variable models with autoregressive decoders such as pixelvae pixelvae and variational lossy autoencoders (vlae) vlae. for example, the vlae model vlae proposes to use the depth of the pixelcnn decoder to control the decomposition of information. in their model, the pixelcnn decoder is designed to have a shallow depth (small local receptive field) so that the latent code is forced to capture more global information. this approach is very similar to our example of the pixelgan autoencoder in: mnist] figure [reference]. however, the question that has remained unanswered is whether it is possible to achieve a complete decomposition of content and style in an unsupervised fashion, where the class label or discrete structure information is encoded in the latent code, and the remaining continuous structure such as style is captured by a powerful and deep pixelcnn decoder. this kind of decomposition is particularly interesting as it can be directly used for clustering and semi-supervised classification. in the next section, we show that we can learn this decomposition of content and style by imposing a categorical distribution on the latent representation using adversarial training. note that this discrete vs. continuous decomposition is very different from the global vs. local decomposition, because a continuous factor of variation such as style can have both global and local effect on the image. indeed, in order to achieve the discrete vs. continuous decomposition, we have to use very deep and powerful pixelcnn decoders (up to 20 residual blocks) to capture both the global and local statistics of the style by the pixelcnn while the discrete content of the image is captured by the categorical latent variable. subsection: pixelgan autoencoders with categorical priors in this section, we present an architecture of the pixelgan autoencoder that can separate the discrete information (e.g., class label) from the continuous information (e.g., style information) in the images. we then show how our architecture can be naturally adopted for the semi-supervised settings. the architecture that we use is similar to: pixelgan_gaussian] figure [reference], with the difference that we impose a categorical distribution as the prior rather the gaussian distribution (: pixelgan_cat] figure [reference]) and also use the location-independent bias architecture. another difference is that we use a convolutional network as the inference network to encourage the encoder to preserve the content and lose the style information of the image. the inference network has a softmax output and predicts a one-hot vector whose dimension is the number of discrete labels or categories that we wish the data to be clustered into. the adversarial network is trained directly on the continuous probability outputs of the softmax layer of the encoder. imposing a categorical distribution at the output of the encoder imposes two constraints. the first constraint is that the encoder has to make confident decisions about the class labels of the inputs. the adversarial training pushes the output of the encoder to the corners of the softmax simplex, by which it ensures that the autoencoder can not use the latent vector to carry any continuous style information. the second constraint imposed by adversarial training is that the aggregated posterior distribution of should match the categorical prior distribution with uniform outcome probabilities. this constraint enforces the encoder to evenly distribute the class labels across the corners of the softmax simplex. because of these constraints, the latent variable will only capture the discrete content of the image and all the continuous style information will be captured by the autoregressive decoder. in order to better understand and visualize the effect of the adversarial training on shaping the hidden code distribution, we train a pixelgan autoencoder on the first three digits of mnist (18000 training and 3000 test points) and choose the number of clusters to be 3. suppose is the hidden code which in this case is the output probabilities of the softmax layer of the inference network. in: pixelgan_cluster_toy] figure [reference] a, we project the 3d softmax simplex of onto a 2d triangle and plot the hidden codes of the training examples when no distribution is imposed on the hidden code. we can see from this figure that the network has learnt to use the surface of the softmax simplex to encode style information of the digits and thus the three corners of the simplex do not have any meaningful interpretation.: pixelgan_cluster_toy] figure [reference] b corresponds to the code space of the same network when a categorical distribution is imposed using the adversarial training. in this case, we can see the network has successfully learnt to encode the label information of the three digits in the three corners of the simplex, and all the style information has been separately captured by the autoregressive decoder. this network achieves an almost perfect test error-rate of on the first three digits of mnist, even though it is trained in a purely unsupervised fashion. once the pixelgan autoencoder is trained, its encoder can be used for clustering new points and its decoder can be used to generate samples from each cluster. figure [reference] illustrates the samples of the pixelgan autoencoder trained on the full mnist dataset. the number of clusters is set to be 30 and each row corresponds to the conditional samples of one of the clusters (only 16 are shown). we can see that the discrete latent code of the network has learnt discrete factors of variation such as class label information and some discrete style information. for example digit s are put in different clusters based on how much tilted they are. the network is also assigning different clusters to digit s (based on whether they have a loop) and digit s (based on whether they have a dash in the middle). in: experiments: unsup] section [reference], we will show that by using the encoder of this network, we can obtain about 5% error rate in classifying digits in an unsupervised fashion, just by matching each cluster to a digit type. semi-supervised pixelgan autoencoders. the pixelgan autoencoder can be used in a semi-supervised setting. in order to incorporate the label information, we add a semi-supervised training phase. specifically, we set the number of clusters to be the same as the number of class labels and after executing the reconstruction and the adversarial phases on an unlabeled mini-batch, the semi-supervised phase is executed on a labeled mini-batch, by updating the weights of the encoder to minimize the cross-entropy cost. the semi-supervised cost also reduces the mode-missing behavior of the gan training by enforcing the encoder to learn all the modes of the categorical distribution. in: experiments: semi] section [reference], we will evaluate the performance of the pixelgan autoencoders on the semi-supervised classification tasks. section: experiments in this paper, we presented the pixelgan autoencoder as a generative model, but the currently available metrics for evaluating the likelihood of gan-based generative models such as parzen window estimate are fundamentally flawed theis. so in this section, we only present the performance of the pixelgan autoencoder on downstream tasks such as unsupervised clustering and semi-supervised classification. the details of all the experiments can be found in endix: experiment] appendix [reference]. subsection: unsupervised clustering we trained a pixelgan autoencoder in an unsupervised fashion on the mnist dataset (: pixelgan_cluster] figure [reference]). we chose the number of clusters to be 30 and used the following evaluation protocol: once the training is done, for each cluster, we found the validation example that maximizes, and assigned the label of to all the points in the cluster. we then computed the test error based on the assigned class labels to each cluster. as shown in the first column of le: semi] table [reference], the performance of pixelgan autoencoders is on par with other gan-based clustering algorithms such as catgan catgan, infogan infogan and adversarial autoencoders aae. subsection: semi-supervised classification le: semi] table [reference] and: plot] figure [reference] report the results of semi-supervised classification experiments on the mnist, svhn and norb datasets. on the mnist dataset with 20, 50 and 100 labels, our classification results are highly competitive. note that the classification rate of unsupervised clustering of mnist is better than semi-supervised mnist with 20 labels. this is because in the unsupervised case, the number of clusters is 30, but in the semi-supervised case, there are only 10 class labels which makes it more likely to confuse two digits. on the svhn dataset with 500 and 1000 labels, the pixelgan autoencoder outperforms all the other methods except the recently proposed temporal ensembling work temporal-ensembling which is not a generative model. on the norb dataset with 1000 labels, the pixelgan autoencoder outperforms all the other reported results.: disentangle] figure [reference] shows the conditional samples of the semi-supervised pixelgan autoencoder on the mnist, svhn and norb datasets. each column of this figure presents sampled images conditioned on a fixed one-hot latent code. we can see from this figure that the pixelgan autoencoder can achieve a rather clean separation of style and content on these datasets with very few labeled data. section: learning cross-domain relations with pixelgan autoencoders in this section, we discuss how the pixelgan autoencoder can be viewed in the context of learning cross-domain relations between two different domains. we also describe how the problem of clustering or semi-supervised learning can be cast as the problem of finding a smooth cross-domain mapping from the data distribution to the categorical distribution. recently several gan-based methods have been developed to learn a cross-domain mapping between two different domains discogan, cyclegan, cross-domain-ilya, aae, cross-domain-nlp. in cross-domain-ilya, an unsupervised cost function called the output distribution matching (odm) is proposed to find a cross-domain mapping between two domains and by imposing the following unsupervised constraint on the uncorrelated samples from and: where denotes the distribution of the random variable. the adversarial training is proposed as one of the methods for matching these distributions. if we have access to a few labeled pairs, then can be further trained on them in a supervised fashion to satisfy. for example, in speech recognition, we want to find a cross-domain mapping from a sequence of phonemes to a sequence of characters. by optimizing the odm cost function in odm] equation [reference], we can find a smooth function that takes phonemes at its input and outputs a sequence of characters that respects the language model. however, the main problem with this method is that the network can learn to ignore part of the input distribution and still satisfy the odm cost function by its output distribution. this problem has also been observed in other works such as discogan. one way to avoid this problem is to add a reconstruction term to the odm cost function by introducing a reverse mapping from the output of the encoder to the input domain. the is essentially the idea of the adversarial autoencoder aae which learns a generative model by finding a cross-domain mapping between a gaussian distribution and the data distribution. using the odm cost function along with a reconstruction term to learn cross-domain relations have been explored in several previous works. for example, infogan infogan adds a mutual information term to the odm cost function and optimizes a variational lower bound on this term. it can be shown that maximizing this variational bound is indeed minimizing the reconstruction cost of an autoencoder i m. similarly, in cross-domain-nlp, zhangadversarial, an adversarial autoencoder is used to learn the cross-domain relations of the vector representations of words from two different languages. the architecture of the recent works of discogan discogan and cyclegan cyclegan are also similar to an adversarial autoencoder in which the latent representation is enforced to have the distribution of the other domain. here we describe how our proposed pixelgan autoencoder can be potentially used in all these application areas to learn better cross-domain relations. suppose we want to learn a mapping from domain to. in the architecture of: pixelgan_gaussian] figure [reference], we can use independent samples of at the input and instead of imposing a gaussian distribution on the latent code, we can impose the distribution of the second domain using its independent samples. unlike adversarial autoencoders, the encoder of pixelgan autoencoders does not have to retain all the input information in order to have a lossless reconstruction. so the encoder can use all its capacity to learn the most relevant mapping from to and at the same time, the pixelcnn decoder can capture the remaining information that has been lost by the encoder. we can adopt the odm idea for semi-supervised learning by assuming is the image domain and is the label domain (: related] figure [reference] a). independent samples of and correspond to samples from the data distribution and the categorical distribution. the function can be parametrized by a neural network that is trained to satisfy the odm cost function by matching the aggregated distribution to the categorical distribution using adversarial training. the few labeled examples are used to further train to satisfy. however, as explained above, the problem with this method is that the network can learn to generate the categorical distribution by ignoring some part of the input distribution. the adversarial autoencoder (: related] figure [reference] b) solves this problem by adding an inverse mapping from the categorical distribution to the data distribution. however, the main drawback of the adversarial autoencoder architecture is that due to the reconstruction term, the latent representation now has to model all the underlying factors of variation in the image. for example, in the architecture of: related] figure [reference] b, while we are only interested in the one-hot label representation to do semi-supervised learning, we also need to infer the style of the image so that we can have a lossless reconstruction of the image. the pixelgan autoencoder solves this problem by enabling the encoder to only infer the factor of variation that we are interested in (i.e., label information), while the remaining structure of the input (i.e., style information) is automatically captured by the autoregressive decoder. section: conclusion in this paper, we proposed the pixelgan autoencoder, which is a generative autoencoder that combines a generative pixelcnn with a gan inference network that can impose arbitrary priors on the latent code. we showed that imposing different distributions as the prior enables us to learn a latent representation that captures the type of statistics that we care about, while the remaining structure of the image is captured by the pixelcnn decoder. specifically, by imposing a gaussian prior, we were able to disentangle the low-frequency and high-frequency statistics of the images, and by imposing a categorical prior we were able to disentangle the style and content of images and learn representations that are specifically useful for clustering and semi-supervised learning tasks. while the main focus of this paper was to demonstrate the application of pixelgan autoencoders in downstream tasks such as semi-supervised learning, we discussed how these architectures have many other potentials such as learning cross-domain relations between two different domains. section: acknowledgments we would like to thank nathan killoran for helpful discussions. we also thank nvidia for gpu donations. bibliography: references section: implementation details in this section, we describe two important architecture design choices for training pixelgan autoencoders. subsection: input noise in all the semi-supervised experiments, we found it crucial to use the universal approximator posterior discussed in: pixelgan] section [reference], as opposed to a deterministic posterior. specifically, the input noise that we use is an additive gaussian noise, which results in a posterior distribution that is more expressive than that of a model without the input corruption. this is similar to the denoising criterion idea proposed in denoising-vae. we believe this additive noise is also playing an important role in preventing the mode-missing behavior of the gan when imposing a degenerate distribution such as the categorical distribution. similar related ideas have been used to stabilize gan training such as instance noise instance or one-sided label noise improved-gan. subsection: conditioning of pixelcnn there are three methods to implement how the pixelcnn conditions on the latent vector. location-invariant bias. this is the method that was proposed in the conditional pixelcnn model pixelcnn. suppose the size of the convolutional layer of the decoder is (batch, width, height, channels). then the pixelcnn can use a linear mapping to convert the conditioning tensor of size (batch, condition_size) to generate a tensor of size (batch, channels) that is then broadcasted and added to the feature maps of all the layers of the pixelcnn decoder as an adaptive bias. in this method, the hidden code is encouraged to learn the global information that is location-invariant (the what information and not the where information) such as the class label information. we use this method in all the clustering and semi-supervised learning experiments. location-dependent bias. suppose the size of the convolutional layer of the pixelcnn decoder is (batch, width, height, channels). then the pixelcnn can use a one layer neural network to convert the conditioning tensor of size (batch, condition_size) to generate a spatial tensor of size (batch, width, height, k) followed by a convolutional layer to construct a tensor of size (batch, width, height, channels) that is then added only to the feature maps of the first layer of the decoder as an adaptive bias (similar to the vpn model vpn). when, we can simply broadcast the tensor of size (batch, width, height, k=1) to get a tensor of size (batch, width, height, channels) instead of using the convolution. in this method, the latent vector has spatial and location-dependent information within the feature map. this is the method that we used in experiments of: mnist] figure [reference] a. input channel. another method for conditioning is proposed in the pixelvae pixelvae and the variational lossy autoencoder (vlae) vlae. in this method, first a tensor of size (batch, width, height, k) is constructed using the conditioning tensor similar to the location-dependent bias. this tensor is then concatenated to the input of the pixelcnn. the performance and computational complexity of this method is very similar to that of the location-dependent bias method. section: experiment details we used tensorflow tensorflow2015-whitepaper in all of our experiments. as suggested in gan, in order to improve the stability of gan training, the generator of the gan in all our experiments is trained to maximize rather than minimizing. subsection: mnist dataset the mnist dataset has 50 k training points, 10 k validation points and 10 k test points. we perform experiments on both the binary mnist and the real-valued mnist. in the real valued mnist experiments, we subtract 127.5 from the data points and then divide them by 127.5 and use the discretized logistic mixture likelihood pixelcnn++ as the cost function for the pixelcnn. in the case of binary mnist, the data points are binarized by setting pixel values larger than 0.5 to 1, and values smaller than 0.5 to 0. subsubsection: pixelgan autoencoders with gaussian prior on mnist here we describe the model architecture used for training the pixelgan autoencoder with a gaussian prior on the binary mnist dataset in: mnist] figure [reference] a. the pixelcnn decoder uses both the vertical and horizontal stacks similar to pixelcnn. the cost function of the pixelcnn is the cross-entropy cost function. the pixelcnn uses the location-dependent bias as described in endix: conditioning_of_pixelcnn] appendix [reference]. specifically, a tensor of size (batch, width, height, 1) is constructed from the conditioning vector by using a one-layer neural network with 1000 hidden units, relu activation and linear output. this tensor is then broadcasted and added only to the feature maps of the first layer of the pixelcnn decoder. the pixelcnn is designed to have a local receptive field by having 3 residual blocks (filter size of 3x5, 32 feature maps, relu non-linearity as in pixelcnn). the adversarial discriminator has two layers of 2000 hidden units with relu activation function. the encoder architecture has two fully-connected layers of size 2000 with relu non-linearity. the last layer of the encoder has a linear activation function. on the latent representation of size, we impose a gaussian distribution with standard deviation of. we used the gradient descent with momentum algorithm for optimizing all the cost functions of the network. for the pixelcnn reconstruction cost, we used the learning rate of 0.001 and the momentum value of 0.9. after 25 epochs we reduce the learning rate to 0.0001. for both of the generator and the discriminator costs, the learning rates and the momentum values were set to 0.1. subsubsection: unsupervised clustering of mnist here we describe the model architecture used for clustering the binary mnist dataset in: pixelgan_cluster] figure [reference] and: experiments: unsup] section [reference]. the pixelcnn decoder uses both the vertical and horizontal stacks similar to pixelcnn. the cost function of the pixelcnn is the cross-entropy cost function. the pixelcnn uses the location-invariant bias as described in endix: conditioning_of_pixelcnn] appendix [reference] and has 15 residual blocks (filter size of 3x5, 32 feature maps, relu non-linearity as in pixelcnn). the adversarial discriminator has two layers of 3000 hidden units with relu activation function. the encoder architecture has a convolutional layer (filter size of 7, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2), followed by another convolutional layer (filter size of 7, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2) with no fully-connected layer. the last layer of the encoder has the softmax activation function. we found it important to use batch-normalization batch for all the layers of the encoder including the softmax layer. the number of clusters is chosen to be. the clusters are represented by a discrete one-hot variable of size 30. on the continuous probability output of the softmax, we impose a categorical distribution with uniform probabilities. we use adam adam optimizer with learning rate of for optimizing the pixelcnn reconstruction cost function, but we found it important to use the gradient descent with momentum algorithm for optimizing the generator and the discriminator costs of the adversarial network. for both of the generator and the discriminator costs, the momentum values were set to 0.1 and the learning rates were set to 0.01. we use an input dropout noise with the keep probability of at the input layer and only at the training time. the model architecture used for: pixelgan_cluster_toy] figure [reference] is the same as this architecture except that the number of clusters is chosen to be. subsubsection: semi-supervised mnist we performed semi-supervised learning experiments on both binary and real-valued mnist dataset. we found that the semi-supervised error-rate of the real-valued mnist is roughly the same as the binary mnist (about 1.10% with 100 labels), but it takes longer to train due to the logistic mixture likelihood cost function pixelcnn++. so in le: semi] table [reference], we only report the performance with the binary mnist, but in: disentangle] figure [reference] b we are showing the samples of the real-valued mnist with 100 labels. binary mnist. here we describe the model architecture used for the semi-supervised learning experiments on the binary mnist in: experiments: semi] section [reference] and le: semi] table [reference]. the pixelcnn decoder uses both the vertical and horizontal stacks similar to pixelcnn and uses the cross-entropy cost function. the pixelcnn uses the location-invariant bias as described in endix: conditioning_of_pixelcnn] appendix [reference]. the pixelcnn has 6 residual blocks (filter size of 3x5, 32 feature maps, relu non-linearity as in pixelcnn). the adversarial discriminator has two layers of 1000 hidden units with relu activation function. the encoder architecture has three convolutional layers (filter size of 5, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2), followed by another three convolutional layers (filter size of 5, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2) with no fully-connected layer. the last layer of the encoder has the softmax activation function. all the convolutional layers of the encoder except the softmax layer use batch-normalization batch. on the latent representation, we impose a categorical distribution with uniform probabilities. the semi-supervised cost is the cross-entropy cost function at the output of. we use adam adam optimizer with learning rate of for optimizing the pixelcnn cost and the cross-entropy cost, but we found it important to use the gradient descent with momentum algorithm for optimizing the generator and the discriminator costs of the adversarial network. for both of the generator and the discriminator costs, the momentum values were set to 0.1 and the learning rates were set to 0.1. we add a gaussian noise with standard deviation of to the input layer as described in endix: input_noise] appendix [reference]. the labeled examples were chosen at random but evenly distributed across the classes. real-valued mnist. here we describe the model architecture used for the semi-supervised learning experiments on the real-valued mnist in: disentangle] figure [reference] b. the pixelcnn decoder uses both the vertical and horizontal stacks similar to pixelcnn and uses a discretized logistic mixture likelihood cost function with 10 logistic distribution as proposed in pixelcnn++. the pixelcnn uses the location-invariant bias as described in endix: conditioning_of_pixelcnn] appendix [reference]. the pixelcnn has 20 residual blocks (filter size of 2x3, 64 feature maps, gated sigmoid-tanh non-linearity as in pixelcnn). the adversarial discriminator has two layers of 1000 hidden units with relu activation function. the encoder architecture has three convolutional layers (filter size of 5, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2), followed by another three convolutional layers (filter size of 5, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2) with no fully-connected layer. the last layer of the encoder has the softmax activation function. all the convolutional layers of the encoder except the softmax layer use batch-normalization batch. on the latent representation, we impose a categorical distribution with uniform probabilities. the semi-supervised cost is the cross-entropy cost function at the output of. we use adam adam optimizer with learning rate of for optimizing the pixelcnn cost and the cross-entropy cost, but we found it important to use the gradient descent with momentum algorithm for optimizing the generator and the discriminator costs of the adversarial network. for both of the generator and the discriminator costs, the momentum values were set to 0.1 and the learning rates were set to 0.1. after 150 epochs, we divide all the learning rates by 10. we add a gaussian noise with standard deviation of to the input layer as described in endix: input_noise] appendix [reference]. the labeled examples were chosen at random but evenly distributed across the classes. subsection: svhn dataset the svhn dataset has about 530 k training points and 26 k test points. we use 10 k points for the validation set. similar to vat, we downsample the images from to and then subtracte 127.5 from the data points and then divide them by 127.5. subsubsection: semi-supervised svhn here we describe the model architecture used for the semi-supervised learning experiments on the svhn dataset in: experiments: semi] section [reference]. the pixelcnn decoder uses both the vertical and horizontal stacks similar to pixelcnn. the cost function of the pixelcnn is a discretized logistic mixture likelihood cost function with 10 logistic distribution as proposed in pixelcnn++. the pixelcnn uses the location-invariant bias as described in endix: conditioning_of_pixelcnn] appendix [reference] and has 20 residual blocks (filter size of 3x5, 32 feature maps, gated sigmoid-tanh non-linearity as in pixelcnn). the adversarial discriminator has two layers of 1000 hidden units with relu activation function. the encoder architecture has two convolutional layers (filter size of 5, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2), followed by another two convolutional layers (filter size of 5, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2) with no fully-connected layer. the last layer of the encoder has the softmax activation function. all the convolutional layers of the encoder except the softmax layer use batch-normalization batch. on the latent representation, we impose a categorical distribution with uniform probabilities. the semi-supervised cost is the cross-entropy cost function at the output of. we use adam adam optimizer for optimizing all the cost function. for the pixelcnn cost and the cross-entropy cost we use the learning rate of and for the generator and the discriminator costs of the adversarial network we use the learning rate of. we add a gaussian noise with standard deviation of to the input layer as described in endix: input_noise] appendix [reference]. subsection: norb dataset the norb dataset has about 24 k training points and 24 k test points. we use 4 k points for the validation set. this dataset has 5 object categories: animals, human figures, airplanes, trucks and cars. we downsample the images to have the size of, subtract 127.5 from the data points and then divide them by 127.5. subsubsection: semi-supervised norb the pixelcnn decoder uses both the vertical and horizontal stacks similar to pixelcnn. the cost function of the pixelcnn is a discretized logistic mixture likelihood cost function with 10 logistic distribution as proposed in pixelcnn++. the pixelcnn uses the location-invariant bias as described in endix: conditioning_of_pixelcnn] appendix [reference] and has 15 residual blocks (filter size of 3x5, 32 feature maps, gated sigmoid-tanh non-linearity as in pixelcnn). the adversarial discriminator has two layers of 1000 hidden units with relu activation function. the encoder architecture has a convolutional layer (filter size of 7, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2), followed by another convolutional layer (filter size of 7, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2), followed by another convolutional layer (filter size of 7, 32 feature maps, relu activation) and a max-pooling layer (pooling size 2) with no fully-connected layer. the last layer of the encoder has the softmax activation function. all the convolutional layers of the encoder except the softmax layer use batch-normalization batch. on the latent representation, we impose a categorical distribution with uniform probabilities. the semi-supervised cost is the cross-entropy cost function at the output of. we use adam adam optimizer for optimizing all the cost function. for the pixelcnn cost and the cross-entropy cost we use the learning rate of and for the generator and the discriminator costs of the adversarial network we use the learning rate of. we add a gaussian noise with standard deviation of to the input layer as described in endix: input_noise] appendix [reference]. the labeled examples were chosen at random but evenly distributed across the classes. in the case of norb with 1000 labels, the test error after 10 epochs is 12.97%, after 100 epochs is 11.63% and after 500 epochs is 8.17%.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "mnist"
                    ],
                    [
                        "mnist svhn"
                    ],
                    [
                        "real valued mnist"
                    ],
                    [
                        "real valued mnist dataset"
                    ]
                ],
                "Method": [
                    [
                        "pixelgan"
                    ],
                    [
                        "pixelgan autoencoders"
                    ],
                    [
                        "pixelgan autoencoder"
                    ],
                    [
                        "pixelgan autoencoder a generative autoencoder"
                    ],
                    [
                        "gan"
                    ],
                    [
                        "pixelgan autoencoder"
                    ],
                    [
                        "pixelgan autoencoder"
                    ],
                    [
                        "pixelgan autoencoders"
                    ],
                    [
                        "pixelgan autoencoder"
                    ],
                    [
                        "pixelgan autoencoder"
                    ],
                    [
                        "pixelgan autoencoder"
                    ],
                    [
                        "aae"
                    ],
                    [
                        "pixelgan autoencoder"
                    ],
                    [
                        "pixelgan autoencoder"
                    ]
                ],
                "Metric": [
                    [
                        "test error rate"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "mnist",
                        "binary mnist",
                        "real-valued mnist",
                        "real-valued mnist dataset"
                    ]
                ],
                "Method": [
                    [
                        "pixelgan autoencoders"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "semi-supervised setting",
                        "unsupervised clustering",
                        "unsupervised case",
                        "unsupervised clustering of mnist"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "mnist",
                        "binary mnist",
                        "real-valued mnist",
                        "real-valued mnist dataset"
                    ]
                ],
                "Method": [
                    [
                        "pixelgan autoencoders"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "classification"
                    ]
                ]
            }
        ]
    },
    "11356cd6bb0f2776a88cd584ff108470414c6594-14": {
        "doctext": "document: submanifold sparse convolutional networks convolutional network are the de-facto standard for analysing spatio-temporal data such as images, videos, 3d shapes, etc. whilst some of this data is naturally dense (for instance, photos), many other data sources are inherently sparse. examples include pen-strokes forming on a piece of paper, or (colored) 3d point clouds that were obtained using a lidar scanner or rgb-d camera. standard ''dense'' implementations of convolutional networks are very inefficient when applied on such sparse data. we introduce a sparse convolutional operation tailored to processing sparse data that differs from prior work on sparse convolutional networks in that it operates strictly on submanifolds, rather than ''dilating'' the observation with every layer in the network. our empirical analysis of the resulting submanifold sparse convolutional networks shows that they perform on par with state-of-the-art methods whilst requiring substantially less computation. section: introduction convolutional networks constitute the state-of-the art method for a wide range of tasks that involve the analysis of data with spatial and/ or temporal structure, such as photographs, videos, or three-dimensional surface models. while such data frequently comprises a densely filled (2d or 3d) grid, other spatio-temporal datasets are naturally sparse. for instance, handwriting is made up of one-dimensional lines in two-dimensional space, pictures made by rgb-d cameras are three-dimensional point clouds, and off models form two-dimensional surfaces in 3d space. the curse of dimensionality applies, in particular, on data that lives on grids that have three or more dimensions: the number of points on the grid grows exponentially with its dimensionality. in such scenarios, it becomes increasingly important to exploit data sparsity whenever possible in order to reduce the computational resources needed for data processing. indeed, exploiting sparsity is paramount when analyzing, for instance, rgb-d videos which are sparsely populated 4d structures. traditional convolutional network implementations are optimized for data that lives on densely populated grids, and can not process sparse data efficiently. more recently, a number of convolutional network implementations have been presented that are tailored to work efficiently on sparse data. mathematically, some of these implementations are identical to a regular convolutional network, but they require fewer computational resources in terms of flops and/ or in terms of memory. octnets slightly modify the convolution operator to produce ''averaged'' hidden states in parts of the grid that are away from regions of interest. one of the downsides of prior sparse implementations of convolutional networks is that they ''dilate'' the sparse data in every layer, because they implement a ''full'' convolution. in this work, we show that it is possible to successfully train convolutional networks that keep the same sparsity pattern throughout the layers of the network, without dilating the feature maps. to this end, we explore two novel convolution operators: sparse convolution (sc) and valid sparse convolution (vsc). in our experiments with recognizing handwritten digits and 3d shapes, networks using sc and vsc achieve state-of-the-art performance whilst reducing the computation and memory requirements by. section: motivation we define a-dimensional convolutional network as a network that takes as input that is a-dimensional tensor: the input tensor contains spatiotemporal dimensions (such as length, width, height, time, etc.) and one additional feature space dimension (for instance, rgb color channels, surface normal vectors, etc.). a sparse input corresponds to a-dimensional grid of sites that is associated with a feature vector. we define a site in the input to be active if any element in the feature vector is not in its ground state, for instance, if it is non-zero. in many practical problems, thresholding may be used to eliminate sites at which the feature vector is within a very small distance from the ground state. note that even though the input tensor is-dimensional, activity is a-dimensional phenomenon: entire planes along the feature dimension are either active or not. the hidden layers of a convolutional network are also represented by-dimensional grids of feature-space vectors. when propagating the input data through the network, a site in a hidden layer is active if any of the sites in the layer that it takes as input is active. (note that when using convolutions, each site is connected to sites in the hidden layer below.) activity in a hidden layer thus follows an inductive definition in which each layer determines the set of active states in the next. in each hidden layer, inactive sites all have the same feature vector: the one corresponding to the ground state. note that the ground state in a hidden layer is often not equal to zero, in particular, when convolutions with a bias term are used. however, irrespective of the value of the ground state, the ground-state value only needs to be calculated once per forward pass during training (and only once for all forward passes at test time). this allows for substantial savings in computational and memory requirements; the exact savings depend on the data sparsity and the network depth. in this paper, we argue that the framework described above is unduly restrictive, in particular, because the convolution operation has not been modified to accommodate the sparsity of the input data. if the input data contains a single active site, then after applying a convolution, there will be active sites. applying a second convolution of the same size will yield active sites, and so on. this rapid growth of the number of active sites is a poor prospect when implementing modern convolutional network architectures that comprise tens or even hundreds of convolutions, such as vgg networks, resnets, and densenets. of course, convolutional networks are not often applied to inputs that only have a single active site, but the aforementioned ''dilation'' problems are equally problematic when the input data comprises one-dimensional curves in spaces with two or more dimensions, or two-dimensional surfaces in three or more dimensions. to address the problems with dilation of active sites, we propose two slightly different convolution operations for use in convolutional networks. what the two operations have in common is that they both ignore the ground state: they replace the ground state with a zero vector to simplify the convolution operations. the difference between both operations is in how they handle active sites: instead of automatically making a site active if any of the inputs to its receptive field is active (thereby dilating the set of active sites), our most efficient convolutional operation only considers the central input. as a result, the output set of active sites exactly mirrors that of the input set. we empirically demonstrate that use of our adapted convolutional operators allows us to build much deeper networks that achieve state-of-the-art results whilst requiring much fewer resources by preserving sparsity. subsection: submanifold dilation in figure [reference], we show an example of a one-dimensional curve that is embedded on a two-dimensional grid. the figure shows that even when we apply small convolutions on this grid, the sparsity on the grid rapidly disappears. at the same time, if we restrict the output of the convolution only to the set of active input points, hidden layers in the network can not capture a lot of information that may relevant to the classification of the curve. in particular, two neighboring connected components will be treated completely independently. luckily, nearly all convolutional networks incorporate some form of pooling, or use strided convolutions. these operations are essential in the sparse convolutional networks we investigate, as they allow neighboring components to merge. in particular, the closer the components are, the smaller the number of poolings/ strided convolutions is that is necessary for the components to merge in the hidden-layer representations. subsection: very deep convolutional networks in image classification, very deep convolutional networks with small filters, often of size pixels and a padding of pixel (to preserve the size of the feature maps), have proven to be very effective. such small filters were used successfully in vgg networks, which have relatively wide layers. the introduction of residual networks (resnets) showed that deeper but narrow networks with small filters are more efficient. the success of very deep resnets, resnext models, and densenets with bottleneck connections shows that it can be useful to calculate a relatively small number of features at a time and amalgamate these features into a larger state variable, either by vector-addition or feature-vector concatenation. unfortunately, these techniques are impractical using existing sparse convolutional network implementations. one problem is that networks with multiple paths will tend to generate different sets of active paths, which would have to be merged to reconnect the outputs. it seems that this would be difficult to perform this merging efficiently. more importantly, resnets and densenets generate such large receptive fields that sparsity would almost immediately be destroyed by the explosion in the number of active sites. section: (valid) sparse convolutions: sc and vsc we define a sparse convolution sc (with input feature planes, output feature planes, a filter size of, and stride. we assume and to be odd integers, but we can allow generalization to non-square filters, e.g., or, if we want to implement inception-style factorised convolutions. an sc convolution computes the set of active sites in the same way as a regular convolution: it looks for the presence of any active sites in its receptive field of size. if the input has size then the output will have size. an sc convolution differs from a regular convolution in that it discards the ground state for non-active sites by assuming that the input from those sites is exactly zero. whereas this is a seemingly small change to the convolution operation, it may bring computational benefits in practice. next, we define a second type of sparse convolution, which forms the main contribution of this paper. again, let denote an odd number, or collection of odd numbers, e.g., or. we define a valid sparse convolution vsc as a modified sc convolution. first, we pad the input with on each side, so that the output will have the same size as the input. next, we restrict an output site to be active if and only if the site at the corresponding site in the input is active (i.e., if the central site in the receptive field is active). whenever an output site is determined to be active, its output feature vector is calculated by the sc operation. table [reference] presents the computational and memory requirements of a regular convolution (c) and of our sc and vsc convolutions. to construct convolutional networks using sc and vsc, we also need activation functions, batch normalization, and pooling. activation functions are defined as usual, but are restricted to the set of active sites. similarly, we define batch normalization in terms of regular batch-normalization applied over the set of active sites. max-pooling mp and average-pooling ap operations are defined as a variant of sc. mp takes the maximum of the zero vector and the input feature vectors in the receptive field. ap calculates times the sum of the active input vectors. we also define a deconvolution operation dc as an inverse of the sc convolution. the set of active output sites from a dc convolution is exactly the set of input active sites to the matching sc convolution. the set of connections between input-output sites is simply inverted. subsection: submanifold convolutional networks we use a combination of vsc convolutions, strided sc convolutions, and sparse pooling operations to build sparse versions of the popular vgg, resnet, and densenet convolutional networks. the blocks we use in our networks are presented in figure [reference]. we refer to our networks as submanifold convolutional networks, because they are optimised to process low-dimensional data living in a space of higher dimensionality. we use the name vgg to refer to networks that contain a number of vsc (,, 3, 1) convolutions, separated by max-pooling. each convolution is followed by batch normalization and a relu non-linearity. similarly, we define ''pre-activated resnets'' in which most data processing is performed by pairs of vsc (,, 3, 1) convolutions, and in which the residual connections are identity functions. whenever the number of input/ output features is different, we use a vsc (,, 1, 1) instead. whenever there is change of scale, we replace the first convolution and the residual connection by a sc (,, 3, 2) convolution. this ensures that two branches can use the same hash table of active sites, and reduces additions to a simple sum of two equally sized matrices. the increased size of the residual connection's receptive field also prevents excessive information loss. we also experiment with submanifold densenets. herein, the word dense does not refer to a lack of spatial sparsity but rather to the pattern of connections between convolution operations. a simple densenet module is a sequence of convolutions in which each convolution takes as input the concatenated output of all the previous convolution operations. the bottleneck layers in our submanifold densenets are implemented in the same way as for resnets. section: implementation to implement (v) sc convolutions efficiently, we store the state of a input/ hidden layer in two parts: a hash table and a matrix. the matrix has size and contains one row for each of the active sites. the hash table contains (location, row) pairs for all active sites: the location is a tuple of integer coordinates, and the row number indicates the corresponding row in the feature matrix. given a convolution with filter size, we define a rule book to be a collection of integer matrices of size. to implement an sc (convolution, we: iterate once through the the input hash-table. we build the output hash table and rule book on-the-fly by iterating over points in the output layer that receive input from a given point in the input layer. when an output site is visited for the first time, a new entry is created in the output hash table. based on the spatial offset between the input and output points, a (input index, output index) pair is added to the rule book. initialize the output matrix to all zeros. for each, there is a parameter matrix with size. for each, multiply the-th row of the input feature matrix by and add it to the-th row of the the output feature matrix. this can be implemented very efficiently on gpus because it is a matrix-matrix multiply-add operation. to implement a vsc convolution, we re-use the input hash table for the output, and construct an appropriate rule book. note that because the sparsity pattern does not change, the same rule book can be re-used in vgg/ resnet/ densenet networks until a pooling or subsampling layer is encountered. if there are active points in the input layer, the cost of building the input hash-table is. for vgg/ resnet/ densenet networks, assuming the number of active sites reduces by a multiplicative factor with each pooling operation, the cost of building all the hash-tables and rule-books is also, regardless of the depth of the network. section: experiments we perform experiments on a 2d and a 3d dataset with sparse images. the casia dataset contains samples of 3755 gbk level-1 characters with approximately 240 train and 60 test images per class. cjvk characters are good test cases for our models because they are a worst-case scenario for sparse convolutional networks: when drawn at scale, about 8% of the pixels are active, but this percentage rapidly decreases after pooling due to the small density of the pen strokes. this makes them a good test case for our models. the modelnet-40 datasethttp:/// contain 2468 cad models that contain shapes corresponding to 40 classes. we follow the preprocessing of before feeding the models into our convolutional networks. all cad models were rendered as surfaces at size. subsection: results on casia we first experiment with two vgg architectures on the casia dataset. we trained all models for 100 epochs using batches of size 100, sgd with momentum 0.9, a weight decay of, and a learning rate decay of 5% per epoch. for simplicity, we do not employ any data augmentation. the architectures of our vgg networks and their performances are presented in table [reference]. we observe that ''regular'' c convolutions and ''sparse'' sc convolutions achieve the same error: this result suggests that discarding the ground state has essentially no negative impact on performance. this is an argument for always discarding ground states, as it makes things easier computationally and algorithmically. comparing sc with vsc convolutions, we observe a minimal loss in performance by considering only the valid part of the convolution. this minimal loss in accuracy does facilitate great computational improvements: networks using vsc use 2 to 3 less computation and memory. next, we performed experiments on casia with submanifold resnets. the key difference between our implementation of resnets and regular resnets is that stride-2 resnet modules use sc (,, 3, 2) convolutions for the strided convolution, rather than sc (,, 1, 2). this change is necessary to ensure the two branches produce the same set of active sites, which simplifies bookkeeping and turns the addition operation into a simple matrix-matrix addition. unlike the vsc convolutions that are used in most layers, the sc (,, 3, 2) we use after downsampling leads sites to be active if any of its inputs are active, which avoids information loss in the transition. the architectures of our resnet networks and their performances are presented in table [reference]. the results with resnets are in line with those obtained using vgg networks: we obtain reductions in computational and memory requirements by at least a factor of 2 at a minimal loss in accuracy. we also performed experiments with densenets; please see table [reference]. next we experimented with adding extra connections to vgg networks to increase the effective receptive fields of the hidden states; see table [reference] for results. in the table, denotes a vsc convolution performed in parallel with a chain of sc-vsc-dc operations; outputs are concatenated to produce output feature planes. to simplify the network design, we switched to size-3 stride-2 max-pooling, matching the sc convolutions in the sc-vsc-dc branches, and reduce the input size from 64 64 to 63 63. figure [reference] presents an overview of all our results on the casia dataset. subsection: results on modelnet in a second set of experiments, we compare two submanifold vgg networks with a state-of-the-art dense convolutional network on the modelnet-40 dataset. the results of these experiments are shown in table [reference]: the left part of the table shows the architecture and performance of our submanifold vgg networks, whereas the right part of the table shows that of the dense 3dnin network. the results clearly demonstrate that submanifold have the potential for designing convolutional networks for sparse data that obtain state-of-the-art performance with limited computational requirements: in particular, our vgg-a network makes 2% more errors at 13 fewer computations, and our vgg-b performs roughly on par with the dense 3dnin whilst performing fewer computations. section: related work this paper is not the first to study sparse convolutional networks. most prior networks for sparse data implements a standard convolutional operator that increases the number of active sites with each layer. by contrast, our submanifold convolutional networks allows sparse data to be processed whilst retraining a much greater degree of sparsity. we have shown that this makes it practical to train deep and efficient vgg and resnet models. submanifold convolutional networks are also much sparser than octnets. octnet stores data in oct-trees: a data structure in which the grid cube is progressively subdivided into smaller sub-cubes until the sub-cubes are either empty or contain a single active site. to compare the efficiency of octnets with that of submanifold convolutional networks, we picked a random sample from the modelnet-40 dataset and rendered it in a cube with grid points. the resulting grid had 423 active sites, which corresponds to 1.3% of the total number of sites. each active site had on average 12.4 active neighbors (the maximum possible number of neighbors is 27). vsc convolutions, therefore, require only 0.6% of the work of a dense (c) convolution. however, in the octtree, 80%, 13%, 4%, and 3% of the volume of the cube is covered by sub-cubes of size,, and, respectively. as a result, an octnet convolution, which operates over the surfaces of the smaller cubes, requires about 35% of the computations that a dense (c) convolution requires. in this particular example, an octnet convolution thus has a computational cost that is 60 times higher than that of a vsc convolution. submanifold convolutional networks also have advantages in terms of memory requirements. in particular, a submanifold network stores a single feature vector for each of the active sites. by contrast, octtrees have about twice as many empty child nodes as active nodes, which implies they have to store roughly three times as many features as a submanifold convolutional network. having said that, some of the ideas of may be combined with vsc convolutions. in particular, it is possible to use oct-trees as a specialized hash function in vsc convolutions. such an oct-tree-based hash function has the potential to be faster than a standard universal hash function that operates on integer tuple keys, like in our implementation of vsc. section: conclusion we introduced a new sparse convolutional operator, called valid sparse convolution (vsc), that facilitates the design of efficient, deep convolutional networks for sparse data. we have shown that vsc convolutions lead to substantial computational savings whilst maintain state-of-the-art accuracies on two datasets: a dataset comprising one-dimensional manifolds embedded in two-dimensional space, and a dataset comprising two-dimensional surfaces embedded in three-dimensional space. as part of this paper, we are releasing easy-to-use implementations of vsc and the other sparse operations we used in the networks described in this paper. we will also release code to reproduce the results of our experiments. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "rgb d camera"
                    ],
                    [
                        "modelnet-40"
                    ]
                ],
                "Method": [
                    [
                        "submanifold sparse convolutional networks"
                    ],
                    [
                        "submanifold sparse convolutional networks convolutional network"
                    ],
                    [
                        "submanifold sparse convolutional networks"
                    ],
                    [
                        "sc"
                    ],
                    [
                        "vsc"
                    ]
                ],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "submanifold sparse convolutional networks"
                    ]
                ],
                "Metric": [],
                "Task": []
            }
        ]
    },
    "11da0c54ba904a1cb31a09d10da55f73e8825c61-15": {
        "doctext": "document: natural language inference by tree-based convolution and heuristic matching in this paper, we propose the tbcnn-pair model to recognize entailment and contradiction between two sentences. in our model, a tree-based convolutional neural network (tbcnn) captures sentence-level semantics; then heuristic matching layers like concatenation, element-wise product/ difference combine the information in individual sentences. experimental results show that our model outperforms existing sentence encoding-based approaches by a large margin. section: introduction recognizing entailment and contradiction between two sentences (called a premise and a hypothesis) is known as natural language inference (nli) in inference. provided with a premise sentence, the task is to judge whether the hypothesis can be inferred (entailment), or the hypothesis can not be true (contradiction). several examples are illustrated in table [reference]. nli is in the core of natural language understanding and has wide applications in nlp, e.g., question answering and automatic summarization. moreover, nli is also related to other tasks of sentence pair modeling, including paraphrase detection, relation recognition of discourse units, etc. traditional approaches to nli mainly fall into two groups: feature-rich models and formal reasoning methods. feature-based approaches typically leverage machine learning models, but require intensive human engineering to represent lexical and syntactic information in two sentences. formal reasoning, on the other hand, converts a sentence into a formal logical representation and uses interpreters to search for a proof. however, such approaches are limited in terms of scope and accuracy. the renewed prosperity of neural networks has made significant achievements in various nlp applications, including individual sentence modeling as well as sentence matching. a typical neural architecture to model sentence pairs is the\" siamese\" structure, which involves an underlying sentence model and a matching layer to determine the relationship between two sentences. prevailing sentence models include convolutional networks and recurrent/ recursive networks. although they have achieved high performance, they may either fail to fully make use of the syntactical information in sentences or be difficult to train due to the long propagation path. recently, we propose a novel tree-based convolutional neural network (tbcnn) to alleviate the aforementioned problems and have achieved higher performance in two sentence classification tasks. however, it is less clear whether tbcnn can be harnessed to model sentence pairs for implicit logical inference, as is in the nli task. in this paper, we propose the tbcnn-pair neural model to recognize entailment and contradiction between two sentences. we leverage our newly proposed tbcnn model to capture structural information in sentences, which is important to nli. for example, the phrase\" riding bicycles on the streets\" in table [reference] can be well recognized by tbcnn via the dependency relations dobj (riding, bicycles) and prep_on (riding, street). as we can see, tbcnn is more robust than sequential convolution in terms of word order distortion, which may be introduced by determinators, modifiers, etc. a pooling layer then aggregates information along the tree, serving as a way of semantic compositonality. finally, two sentences' information is combined by several heuristic matching layers, including concatenation, element-wise product and difference; they are effective in capturing relationships between two sentences, but remain low complexity. to sum up, the main contributions of this paper are two-fold: (1) we are the first to introduce tree-based convolution to sentence pair modeling tasks like nli; (2) leveraging additional heuristics further improves the accuracy while remaining low complexity, outperforming existing sentence encoding-based approaches to a large extent, including feature-rich methods and long short term memory (lstm)- based recurrent networks. section: related work entailment recognition can be viewed as a task of sentence pair modeling. most neural networks in this field involve a sentence-level model, followed by one or a few matching layers. they are sometimes called\" siamese\" architectures. cnn: nips and cnn: naacl apply convolutional neural networks (cnns) as the individual sentence model, where a set of feature detectors over successive words are designed to extract local features. lstm: aaai build sentence pair models upon recurrent neural networks (rnns) to iteratively integrate information along a sentence. recurparaphrase dynamically construct tree structures (analogous to parse trees) by recursive autoencoders to detect paraphrase between two sentences. as shown, inherent structural information in sentences is oftentimes important to natural language understanding. the simplest approach to match two sentences, perhaps, is to concatenate their vector representations. concatenation is also applied in our previous work of matching the subject and object in relation classification. cnn: emnlp apply additional heuristics, namely euclidean distance, cosine measure, and element-wise absolute difference. the above methods operate on a fixed-size vector representation of a sentence, categorized as sentence encoding-based approaches. thus the matching complexity is, i.e., independent of the sentence length. word-by-word similarity matrices are introduced to enhance interaction. to obtain the similarity matrix, cnn: nips (arc-ii) concatenate two words' vectors (after convolution), recurparaphrase compute euclidean distance, and lstm: aaai apply tensor product. in this way, the complexity is of, where is the length of a sentence; hence similarity matrices are difficult to scale and less efficient for large datasets. recently, attention introduce several context-aware methods for sentence matching. they report that rnns over a single chain of two sentences are more informative than separate rnns; a static attention over the first sentence is also useful when modeling the second one. such context-awareness interweaves the sentence modeling and matching steps. in some scenarios like sentence pair re-ranking, it is not feasible to pre-calculate the vector representations of sentences, so the matching complexity is of. attention further develop a word-by-word attention mechanism and obtain a higher accuracy with a complexity order of. section: our approach we follow the\" siamese\" architecture (like most work in section [reference]) and adopt a two-step strategy to classify the relation between two sentences. concretely, our model comprises two parts: a tree-based convolutional neural network models each individual sentence (figure [reference] a). notice that, the two sentences, premise and hypothesis, share a same tbcnn model (with same parameters), because this part aims to capture general semantics of sentences. a matching layer combines two sentences' information by heuristics (figure [reference] b). after individual sentence models, we design a sentence matching layer to aggregate information. we use simple heuristics, including concatenation, element-wise product and difference, which are effective and efficient. finally, we add a softmax layer for output. the training objective is cross-entropy loss, and we adopt mini-batch stochastic gradient descent, computed by back-propagation. subsection: tree-based convolution the tree-based convolutoinal neural network (tbcnn) is first proposed in our previous work to classify program source code; later, we further propose tbcnn variants to model sentences. this subsection details the tree-based convolution process. the basic idea of tbcnn is to design a set of subtree feature detectors sliding over the parse tree of a sentence; either a constituency tree or a dependency tree applies. in this paper, we prefer the dependency tree-based convolution for its efficiency and compact expressiveness. concretely, a sentence is first converted to a dependency parse tree. each node in the dependency tree corresponds to a word in the sentence; an edge indicates is governed by. edges are labeled with grammatical relations (e.g., nsubj) between the parent node and its children. words are represented by pretrained vector representations, also known as word embeddings. now, we consider a set of two-layer subtree feature detectors sliding over the dependency tree. at a position where the parent node is with child nodes, the output of the feature detector,, is let us assume word embeddings (and) are of dimensions; that the convolutional layer is-dimensional. is the weight matrix; is the bias vector. denotes the dependency relation between and. is the non-linear activation function, and we apply relu in our experiments. after tree-based convolution, we obtain a set of feature maps, which are one-one corresponding to original words in the sentence. therefore, they may vary in size and length. a dynamic pooling layer is applied to aggregate information along different parts of the tree, serving as a way of semantic compositionality. we use the pooling operation, which takes the maximum value in each dimension. then we add a fully-connected hidden layer to further mix the information in a sentence. the obtained vector representation of a sentence is denoted as (also called a sentence embedding). notice that the same tree-based convolution applies to both the premise and hypothesis. tree-based convolution along with pooling enables structural features to reach the output layer with short propagation paths, as opposed to the recursive network, which is also structure-sensitive but may suffer from the problem of long propagation path. by contrast, tbcnn is effective and efficient in learning such structural information. subsection: matching heuristics in this part, we introduce how vector representations of individual sentences are combined to capture the relation between the premise and hypothesis. as the dataset is large, we prefer matching operations because of efficiency concerns. concretely, we have three matching heuristics: concatenation of the two sentence vectors, element-wise product, and element-wise difference. the first heuristic follows the most standard procedure of the\" siamese\" architectures, while the latter two are certain measures of\" similarity\" or\" closeness.\" these matching layers are further concatenated (figure [reference] b), given by where and are the sentence vectors of the premise and hypothesis, respectively;\"\" denotes element-wise product; semicolons refer to column vector concatenation. is the output of the matching layer. we would like to point out that, with subsequent linear transformation, element-wise difference is a special case of concatenation. if we assume the subsequent transformation takes the form of, where is the weights for concatenated sentence representations, then element-wise difference can be viewed as such that. (is the weights corresponding to element-wise difference.) thus, our third heuristic can be absorbed into the first one in terms of model capacity. however, as will be shown in the experiment, explicitly specifying this heuristic significantly improves the performance, indicating that optimization differs, despite the same model capacity. moreover, word embedding studies show that linear offset of vectors can capture relationships between two words, but it has not been exploited in sentence-pair relation recognition. although element-wise distance is used to detect paraphrase in cnn: emnlp, it mainly reflects\" similarity\" information. our study verifies that vector offset is useful in capturing generic sentence relationships, akin to the word analogy task. section: evaluation subsection: dataset to evaluate our tbcnn-pair model, we used the newly published stanford natural language inference (snli) dataset. the dataset is constructed by crowdsourced efforts, each sentence written by humans. moreover, the snli dataset is magnitudes of larger than previous resources, and hence is particularly suitable for comparing neural models. the target labels comprise three classes: entailment, contradiction, and neutral (two irrelevant sentences). we applied the standard train/ validation/ test split, contraining 550k, 10k, and 10k samples, respectively. figure [reference] presents additional dataset statistics, especially those relevant to dependency parse trees. subsection: hyperparameter settings all our neural layers, including embeddings, were set to 300 dimensions. the model is mostly robust when the dimension is large, e.g., several hundred. word embeddings were pretrained ourselves by word2vec on the english wikipedia corpus and fined tuned during training as a part of model parameters. we applied penalty of; dropout was chosen by validation with a granularity of 0.1 (figure [reference]). we see that a large dropout rate (0.3) hurts the performance (and also makes training slow) for such a large dataset as opposed to small datasets in other tasks. initial learning rate was set to 1, and a power decay was applied. we used stochastic gradient descent with a batch size of 50. subsection: performance table [reference] compares our model with previous results. as seen, the tbcnn sentence pair model, followed by simple concatenation alone, outperforms existing sentence encoding-based approaches (without pretraining), including a feature-rich method using 6 groups of human-engineered features, long short term memory (lstm)- based rnns, and traditional cnns. this verifies the rationale for using tree-based convolution as the sentence-level neural model for nli. table [reference] compares different heuristics of matching. we first analyze each heuristic separately: using element-wise product alone is significantly worse than concatenation or element-wise difference; the latter two are comparable to each other. combining different matching heuristics improves the result: the tbcnn-pair model with concatenation, element-wise product and difference yields the highest performance of 82.1%. as analyzed in section [reference], the element-wise difference matching layer does not add to model complexity and can be absorbed as a special case into simple concatenation. however, explicitly using such heuristic yields an accuracy boost of 1-2%. further applying element-wise product improves the accuracy by another 0.5%. the full tbcnn-pair model outperforms all existing sentence encoding-based approaches, including a 1024d gated recurrent unit (gru)- based rnn with\" skip-thought\" pretraining. the results obtained by our model are also comparable to several attention-based lstms, which are more computationally intensive than ours in terms of complexity order. subsection: complexity concerns for most sentence models including tbcnn, the overall complexity is at least. however, an efficient matching approach is still important, especially to retrieval-and-reranking systems. for example, in a retrieval-based question-answering or conversation system, we can largely reduce response time by performing sentence matching based on precomputed candidates' embeddings. by contrast, context-aware matching approaches as described in section [reference] involve processing each candidate given a new user-issued query, which is time-consuming in terms of most industrial products. in our experiments, the matching part (figure [reference] b) counts 1.71% of the total time during prediction (single-cpu, c++ implementation), showing the potential applications of our approach in efficient retrieval of semantically related sentences. section: conclusion in this paper, we proposed the tbcnn-pair model for natural language inference. our model relies on the tree-based convolutional neural network (tbcnn) to capture sentence-level semantics; then two sentences' information is combined by several heuristics including concatenation, element-wise product and difference. experimental results on a large dataset show a high performance of our tbcnn-pair model while remaining a low complexity order. section: acknowledgments we thank all anonymous reviewers for their constructive comments, especially those on complexity issues. we also thank sam bowman, edward grefenstette, and tim rockt\u00e4schel for their discussion. this research was supported by the national basic research program of china (the 973 program) under grant no. 2015cb352201 and the national natural science foundation of china under grant nos. 61232015, 61421091, and 61502014. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "stanford natural language inference"
                    ],
                    [
                        "snli dataset"
                    ]
                ],
                "Method": [
                    [
                        "heuristic matching"
                    ],
                    [
                        "tbcnn"
                    ],
                    [
                        "tbcnn pair"
                    ],
                    [
                        "tbcnn pair model"
                    ],
                    [
                        "tree based convolutional neural network"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "natural language inference"
                    ],
                    [
                        "language inference"
                    ],
                    [
                        "inference"
                    ],
                    [
                        "nli"
                    ],
                    [
                        "nli in inference"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "stanford natural language inference",
                        "snli"
                    ]
                ],
                "Method": [
                    [
                        "tbcnn-pair model",
                        "tree-based convolutional neural network",
                        "tbcnn",
                        "tbcnn-pair neural model",
                        "tbcnn model",
                        "tree-based convolutoinal neural network",
                        "tbcnn sentence pair model"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "natural language inference",
                        "nli",
                        "nli task"
                    ]
                ]
            }
        ]
    },
    "1235dd37312cb20aced0e97d953f6379d8a0c7d4-16": {
        "doctext": "document: grounded textual entailment capturing semantic relations between sentences, such as entailment, is a long-standing challenge for computational semantics. logic-based models analyse entailment in terms of possible worlds (interpretations, or situations) where a premise p entails a hypothesis h iff in all worlds where p is true, h is also true. statistical models view this relationship probabilistically, addressing it in terms of whether a human would likely infer h from p. in this paper, we wish to bridge these two perspectives, by arguing for a visually-grounded version of the textual entailment task. specifically, we ask whether models can perform better if, in addition to p and h, there is also an image (corresponding to the relevant\" world\" or\" situation\"). we use a multimodal version of the snli dataset and we compare\" blind\" and visually-augmented models of textual entailment. we show that visual information is beneficial, but we also conduct an in-depth error analysis that reveals that current multimodal models are not performing\" grounding\" in an optimal fashion. section: introduction correspondence should be addressed to raffaella bernardi () and albert gatt (albert.gatt@um.edu.mt). this work is licensed under a creative commons attribution 4.0 international license. license details:. the dataset, annotation and code is available from. evaluating the ability to infer information from a text is a crucial test of the capability of models to grasp meaning. as a result, the computational linguistics community has invested huge efforts into developing textual entailment (te) datasets. after formal semanticists developed fracas in the mid' 90, an increase in statistical approaches to computational semantics gave rise to the need for suitable evaluation datasets. hence, recognizing textual entailment (rte) shared tasks have been organized regularly. recent work on compositional distributional models has motivated the development of the sick dataset of sentence pairs in entailment relations for evaluating such models. further advances with neural networks (nns) have once more motivated efforts to develop a large natural language inference dataset, snli, since nns need to be trained on big data. however, meaning is not something we obtain just from text and the ability to reason is not unimodal either. the importance of enriching meaning representations with other modalities has been advocated by cognitive scientists, (e.g.,) and computational linguists (e.g.,). while efforts have been put into developing multimodal datasets for the task of checking semantic text similarity text, we are not aware of any available datasets to tackle the problem of grounded textual entailment (gte). our paper is a first effort in this direction. [b] 0.45 [scale=0.5] figures/ warm-entailment [b] 0.45 [scale=0.5] figures/ neutral-mis textual entailment is defined in terms of the likelihood of two sentences (a premise p and an hypothesis h) to be in a certain relation: p entails, contradicts or is unrelated to h. for instance, the premise\" people trying to get warm in front of a chimney\" and the hypothesis\" people trying to get warm at home\" are highly likely to be in an entailment relation. our question is whether having an image that illustrates the event (e.g., figure [reference]) can help a model to capture the relation. in order to answer this question, we augment the largest available te dataset with images, we enhance a state of the art model of textual entailment to take images into account and we evaluate it against the gte task. the inclusion of images can also alter relations which, based on text alone, would seem likely. for example, to a\" blind\" model the sentences of the sentence pair in figure [reference] would seem to be unrelated, but when the two sentences are viewed in the context of the image, they do become related. a suitable gte model therefore has to perform two sub-tasks: (a) it needs to ground its linguistic representations of p, h or both in non-linguistic (visual) data; (b) it needs to reason about the possible relationship between p and h (modulo the visual information). section: related work grounding language through vision has recently become the focus of several tasks, including image captioning (ic, e.g.) and visual question answering (vqa, eg.), and even more recently, visual reasoning and visual dialog. our focus is on grounded textual entailment (gte). while the literature on te is rather vast, gte is still rather unexplored territory. paragraph: textual entailment throughout the history of computational linguistics various datasets have been built to evaluate computational semantics models on the te task. usually they contain data divided into entailment, contradiction or unknown classes. the\" unknown\" label has sometimes been replaced with the\" unrelated\" or\" neutral\" label, capturing slightly different types of phenomena. interestingly, the\" entailment\" and\" contradiction\" classes also differ across datasets. in the mid -'90s a group of formal semanticists developed fracas (framework for computational semantics). the dataset contains logical entailment problems in which a conclusion has to be derived from one or more premises (but not necessarily all premises are needed to verify the entailment). the entailments are driven by logical properties of linguistic expressions, like the monotonicity of quantifiers, or their conservativity property etc. hence, the set of premises entails the conclusion iff in all the interpretations (worlds) in which the premises are true the conclusion is also true; otherwise the conclusion contradicts the premises. in 2005, the pascal rte (recognizing textual entailment) challenge was launched, to become a task organized annually. in 2008, the rte-4 committee made the task more fine-grained by requiring the classification of the pairs as\" entailment\",\" contradiction\" and\" unknown\". the rte datasets, unlike fracas, contain real-life natural language sentences and the sort of entailment problems which occur in corpora collected from the web. importantly, the sentence pair relations are annotated as entailment, contradiction or neutral based on a likelihood condition: if a human reading the premise would typically infer that the conclusion (called the hypothesis) is most likely true (entailment), its negation is most likely true (contradiction) or the conclusion can be either true or false (neutral). at semeval 2014, in order to evaluate compositional distributional semantics models focusing on the compositionality ability of those models, the sick dataset (sentences involving compositional knowledge) was used in a shared entailment task. sentence pairs were obtained through re-writing rules and annotated with the three rte labels via a crowdsourcing platform. both in rte and sick the label assigned to the sentence pairs captures the relation holding between the two sentences. a different approach has been used to build the much larger snli (stanford natural language inference) dataset: premises are taken from a dataset of images annotated with descriptive captions; the corresponding hypotheses were produced through crowdsourcing, where for a given premise, annotators provided a sentence which is true or not true with respect to a possible image which the premise could describe. a consequence of this choice is that the contradiction relation can be assigned to pairs which are rather unrelated (\" a person in a black wetsuit is surfing a small wave\" and\" a woman is trying to sleep on her bed\"), differently from what happens in rte and sick. since the inception of rte shared tasks, there has been an increasing emphasis on data-driven approaches which, given the hypothesis h and premise p, seek to classify the semantic relation (see for a review). more recently, neural approaches have come to dominate the scene, as shown by the recent repeval 2017 task, where all submissions relied on bidirectional lstm models, with or without pretrained embeddings. rte also intersects with a number of related inference problems, including semantic text similarity and question answering, and some models have been proposed to address several such problems. in one popular approach, both p and h are encoded within the same embedding space, using a single rnn, with a decision made based on the encodings of the two sentences. this is the approach we adopt for our baseline lstm in section [reference], based on the model proposed by snli: emnlp2015, albeit with some modifications (see also). a second promising approach, based on which we adapt our state of the art model, relies on matching and aggregation. here, the decision concerning the relationship between p and h is based on an aggregate representation achieved after the two sentences are matched. yet another area where neural approaches are being applied to sentence pairs in an entailment relationship is generation, where an rnn generates an entailed hypothesis (or a chain of such hypotheses) given an encoding of the premise. paragraph: vision and textual entailment in recent years, several models have been proposed to integrate the language and vision modalities; usually the integration is operationalized by element-wise multiplication between linguistic and visual vectors. though the interest in these modalities has spread in an astonishing way thanks to various multimodal tasks proposed, including the ic, vqa, visual reasoning and visual dialogue tasks mentioned above, very little work has been done on grounding entailment. interestingly, youn: from14 has proposed the idea of considering images as the\" possible worlds\" on which sentences find their denotation. hence, they released a\" visual denotation graph\" which associates sentences with their denotation (sets of images). the idea has been further exploited by lai: lear17 and han: visd17. vend: orde16 look at hypernymy, textual entailment and image captioning as special cases of a single visual-semantic hierarchy over words, sentences and images, and they claim that modelling the partial order structure of this hierarchy in visual and linguistic semantic spaces improves model performance on those three tasks. we share with this work the idea that the image can be taken as a possible world. however, we do n't use sets of images to obtain the visual denotation of text in order to check whether entailment is logically valid/ highly likely. rather, we take the image to be the world/ situation in which the text finds its interpretation. the only work that is close to ours is an unpublished student report, which however lacks the in-depth analysis presented here. section: annotated dataset of images and sentence pairs we took as our starting point the stanford natural language inference (snli) dataset, the largest natural language inference dataset available with sentence pairs labelled with entailment, contradiction and neutral relations. we augmented this dataset with images. it has been shown very recently that snli contains language bias, such that a simple classifier can achieve high accuracy in predicting the three classes just by having as input the hypothesis sentence. a subset of the snli test set with 'hard' cases, where such a simplistic classifier fails (hereafter snli) has been released. hence, in this paper we will report our results on both the full dataset and the hard test set, but then zoom in on snli to understand the models' behaviour. we briefly introduce snli and the new test set and compare them through our annotation of linguistic phenomena. subsection: dataset construction paragraph: snli and snli test set the snli dataset was built through amazon mechanical turk. workers were shown captions of photographs without the photo and were asked to write a new caption that (a) is definitely a true description of the photo (entailment); (b) might be a true description of the photo (neutral); (c) is definitely a false description of the photo (contradiction). examples were provided for each of the three cases. the premises are captions which come mostly from flickr30 k; only 4 k captions are from visualgenome. in total, the dataset contains 570, 152 sentence pairs, balanced with respect to the three labels. around 10% of these data have been validated (4 annotators for each example plus the label assigned through the previous data collection phase). the development and test datasets contain 10 k examples each. moreover, each image/ flickr caption occurs in only one of the three sets, and all the examples in the development and test sets have been validated. paragraph: v-snli and v-snli test set our grounded version of snli, v-snli, has been built by matching each sentence pair in snli with the corresponding image coming from the flickr30 k dataset; thus the v-snli dataset is slightly smaller than the original, which also contains captions from visualgenome. v-snli consists of 565, 286 pairs (187, 969 neutral, 188, 453 contradiction, and 188, 864 entailment). training, test, and development splits have been built according to the splits in snli. the main statistics of the splits of the dataset are reported in table [reference] together with statistics for the visual counterpart of hard snli, namely v-snli. by construction, v-snli contains datapoints such that the premise is always true with respect to the image, whereas the hypothesis can be either true (entailment or neutral cases) or false (contradiction or neutral cases.) subsection: dataset annotation for deeper analysis and comparison of the contents of snli and snli, we have annotated the snli dataset by both automatically detecting some surface linguistic cues and manually labelling less trivial phenomena. using an in-house annotation interface, we collected human judgments aiming to (a) filter out those cases for which the gold-standard annotation was considered to be wrong; (b) connect the three ungrounded relations to various linguistic phenomena. to achieve this, we annotated a random sample of the snli test set containing 527 sentence pairs (185 entailment, 171 contradiction, 171 neutral), out of which 176 were from the hard test set (56 entailment, 62 contradiction, 58 neutral). all the pairs were annotated by at least two annotators, as follows: (a) we filtered out all the pairs which had a wrong gold label (see table [reference] for details). when our annotators did not agree whether a given relation holds for a specific pair, we appealed to the corresponding five judgments coming from the validation stage of the snli dataset to reach a consensus based on the majority of labels. (b) we considered as valid any linguistic tag assigned by at least one annotator. since the annotation for (a) is binary whereas for (b) it is multi-class, we used cohen's for the former and also scott's and krippendorff's for the latter as suggested by passonneau pass: inte06. the inter-annotator agreement for the relation type (a) was; for (b) linguistic tags it was,, and. paragraph: linguistic phenomena following the error analysis approach described in recent work, we compiled a new list of linguistic features that can be of interest when contrasting snli and snli, as well as for evaluating rte models. some of these were detected automatically, while others were assigned manually. automatic tags included synonym and antonym, which were detected using wordnet. quantifier, pronoun, diff tense, superlative and bare np were identified using penn treebank labels, while labels such as negation were found with a straightforward keyword search. the tag long has been assigned to sentence pairs with a premise containing more than 30 tokens, or a hypothesis with more than 16 tokens. details about the tags used in the manual annotation are presented in table [reference]. we examined the differences in the tags distributions between the snli and snli test sets (table [reference]). interestingly, the hard sentence pairs from our random sample include proportionately more antonyms but fewer pronouns, as well as examples with different verb tenses in the premise and hypothesis, compared to the full test set. furthermore, snli contains a significantly larger proportion of gold-standard labels which become wrong when the image is factored in (- test with). section: models in this section, we describe a variety of models that were compared on both v-snli and v-snli, ranging from baseline models based on snli: emnlp2015 to a state of the art model by wang2017. we compare the original 'blind' version of a model with a visually-augmented counterpart. in what follows, we use p and h to refer to a premise and hypothesis, respectively. paragraph: lstm baseline (blind) this model exploits a recurrent neural network with long short-term memory units to encode both p and h in 512d vectors. the two vectors are then concatenated in a stack of three 512d layers having a relu activation function, with a final softmax layer to classify the relation between the two sentences as entailment, contradiction or neutral. the model is inspired by the lstm baseline proposed by snli: emnlp2015. the model exploits the 300, 000 most frequent pretrained glove embeddings and improves them during the training process. to regularize the model, dropout is applied to the inputs and outputs of the recurrent layers and to the relu fully connected layers with a keeping probability of 0.5. the model is trained using the adam optimizer with a learning rate of 0.001 until its accuracy on the development set drops for three successive iterations. paragraph: v-lstm baseline the lstm model described above is augmented with a visual component following a standard visual question answering baseline model. following initial representation of p and h in 512d vectors through an lstm, a fully-connected layer projects the l2-normalized 4096d image vector coming from the penultimate layer of a vggnet16 convolutional neural network to a reduced 512d vector. a fully-connected layer with a relu activation function is also applied to p and h to obtain two 512d vectors. the multimodal fusion between the text and the image is obtained by performing an element-wise multiplication between the vector of the text representation and the reduced vector of the image. the multimodal fusion is performed between the image and both the premise and the hypothesis, resulting in two multimodal representations. the relation between them is captured as in the model described above. this model uses glove embeddings and the same optimization and procedure described above. we have also adapted a state-of-the-art attention-based model for ic and vqa to the gte task. it obtains results comparable to the v-lstm. this lack of improvement might be due to the need of further parameter tuning. we report the details of our implementation and its results in the supplementary material. paragraph: bimpm the bilateral multi-perspective matching (bimpm) model obtains state-of-the-art performance on the snli dataset, achieving a maximum accuracy of 86.9%, and going up to 88.8% in an ensemble setup. an initial embedding layer vectorises words in p and h using pretrained glove embeddings, and passing them to a context representation layer, which uses bidirectional lstms (bilstms) to encode context vectors for each time-step. the core part of the model is the subsequent matching layer, where each contextual embedding or time-step of p is matched against all the embeddings of h, and vice versa. the output of this layer is composed of two sequences of matching vectors, which constitute the input to another bilstm at the aggregation layer. the vectors from the last time-step of the bilstm are concatenated into a fixed-length vector, which is passed to the final prediction tier, a two-layer feed-forward network which classifies the relation between p and h via softmax. matching is performed via a cosine operation, which yields an-dimensional vector, where is the number of perspectives. wang2017 experiment with four different matching strategies. in their results, the best-performing version of the bimpm model used all four matching strategies. we adopt this version of the model in what follows. paragraph: v-bimpm model we enhanced bimpm to account for the image, too. our version of this model is referred to as the v-bimpm. here, the feature vector for an image is obtained from the layer before the fully-connected layer of a vggnet-16. this results in a tensor, which we consider as 49 512-dimensional vectors. the same matching operations are performed, except that matching occurs between p, h, and the image. since the textual and visual vectors have different dimensionality and belong to different spaces, we first map them to a mutual space using an affine transformation. we match textual and image vectors using a cosine operation, as before. full details of the model are reported in the supplementary materials for this paper. section: experiments and results the models described in the previous sections were evaluated on both (v -) snli and (v -) snli. for the visually-augmented models, we experimented with configurations where image vectors were combined with both p and h (namely p+ i and h+ i), or only with h (p and h+ i). the best setting was invariably the one where only h was grounded; hence, we focus on these results in what follows, comparing them to\" blind\" models. in view of recent results suggesting that biases in snli afford a high accuracy in the prediction task with only the hypothesis sentence as input, we also include results for the blind models without the premise (denoted with [h] in what follows). table [reference] shows the results of the various models on the full v-snli dataset. the same models are compared in table [reference] on v-snli. first, note that the lstm [h] model evinces a drop in performance compared to lstm (from 81.49% to 68.49%), though the drop is much greater on the unbiased snli subset (from 60.99 to 25.57%). this confirms the results reported by guru: anno18 and justifies our additional focus on this subset of the data. the effect of grounding in these models is less clear. the lstm baseline performs worse when it is visually augmented; this is the case of v-snli and, even more drastically, v-snli. it is also true irrespective of the relationship type. on the other hand, the v-bimpm model improves marginally across the board, compared to bimpm, on the v-snli data. on the hard subset, the images appear to hurt performance somewhat in the case of contradiction (from 77.62% to 76.12%), but improve it by a substantial margin on neutral cases (from 59.36% to 63.67%). the neutral case is the hardest for all models, with the possible exception of lstm [h] on the full dataset. overall, the results suggest that factoring in images either hinders performance (as in the case of the v-lstm baseline), or helps only marginally (as in the case of v-bimpm). in the latter case, we also observe instances where factoring in images hurts performance. in an effort to understand the results, we turn to a more detailed error analysis of the v-bimpm model, first in relation to the dataset annotations, and then by zooming in somewhat closer on v-snli. subsection: error analysis by linguistic annotation label in table [reference], accuracies for the blind and grounded version of bimpm are broken down by the labels given to the sentence pairs in the annotated subset of snli described in section [reference]. we only observe a significant difference in the entity case, that is, where the referents in p and h are inconsistent. here, the blind model outperforms the grounded one, an unexpected result, since one would assume a grounded model to be better equipped to identify mismatched referents. hence, in the following we aim to understand whether the models properly deal with the grounding sub-task. subsection: error analysis on grounding in the snli we next turn to the\" hard\" subset of the data, where v-bimpm showed some improvement over the blind case, but suffered on contradiction cases (table [reference]). we analysed the 207 cases in snli where the v-bimpm made incorrect predictions compared to the blind model, that is, where the image hurt performance. these were annotated independently by two of the authors (raw inter-annotator agreement: 96%) who (a) read the two sentences, p and h; (b) checked whether the relation annotated in the dataset actually held or whether it was an annotation error; (c) in those cases where it held, checked whether including the image actually resulted in a change in the relation. table [reference] displays the proportions of image mismatch and incorrect annotations. as the table suggests, in the cases where images hinder performance in the v-bimpm, it is usually because the image changes the relation (thus, these are cases of image mismatch; see section [reference] for an example); this occurs in a large proportion of cases labelled as neutral in the dataset. inspired by the work in, we further explored the impact of visual grounding in both the v-lstm and v-bimpm by comparing their performance on snli, with the same subset incorporating image\" foils\". vectors for the images in the v-snli test set were compared pairwise using cosine, and for each test case in v-snli, the actual image was replaced with the most dissimilar image in the full test set. the rationale is that, if visual grounding is really helpful in recognising the semantic relationship between p and h, we should observe a drop in performance when the images are unrelated to the scenario described by the sentences. the results are displayed in table [reference], which also reproduces the original results on v-snli from table [reference] for ease of reference. as the results show, models are not hurt by the foil image, contrary to our expectations. v-bimpm overall drops just by 0.67% whereas v-lstm drop is somewhat higher (- 2.11%) showing it might be doing a better job on the grounding sub-task. as a final check, we sought to isolate the grounding from the reasoning sub-task, focusing only on the former. we compared the models when grounding only the hypothesis [h+ i], while leaving out the premise. note that this test is different from the evaluation of the model using only the hypothesis [h]: whereas in that case the input is not expected to provide any useful information to perform the task, here it is. as we noted in section [reference], by construction the premise is always true with respect to the image while the hypothesis can be either true (entailment or neutral cases) or false (contradiction or neutral cases). a model that is grounding the text adequately would be expected to confuse both entailment and contradiction cases with neutral ones; on the other hand, neutral cases should be confused with entailments or contradictions. confusing contradictions with entailments would be a sign that a model is grounding inadequately, since it is not recognising that h is false with respect to the image. as the left panel of table [reference] shows, v-bimpm outperforms v-lstm by a substantial margin, though the performance of both models drops substantially with this setup. the right panel in the table shows that neither model is free of implausible errors (confusing entailments and contradictions), though v-bimpm makes substantially fewer of these. section: conclusion this paper has investigated the potential of grounding the textual entailment task in visual data. we argued that a grounded textual entailment model needs to perform two tasks: (a) the grounding itself, and (b) reasoning about the relation between the sentences, against the visual information. our results suggest that a model based on matching and aggregation like the bimpm model can perform very well at the reasoning task, classifying entailment relations correctly much more frequently than a baseline v-lstm. on the other hand, it is not clear that grounding is being performed adequately in this model. it is primarily in the case of contradictions that the image seems to play a direct role in biasing the classification towards the right or wrong class, depending on whether the image is correct. in summary, two conclusions can be drawn from these results. first, in those cases where the inclusion of visual information results in a loss of accuracy, this is often due to the image resulting in a change in the original relation annotated in the dataset. a related observation is that using foil images results in a greater drop in performance on contradiction cases, possibly because in such cases, grounding serves to identify a mismatch between the hypothesis and the scene described by the premise, a situation which is rendered opaque by the introduction of foils. second, in those cases where improvements are observed in the state of the art v-bimpm, the precise role played by the image is not straightforward. indeed, we find that this model still marginally outperforms the 'blind', text-only model overall, when the images involved are foils rather than actual images. we believe that further research on grounded te is worthy of the nlp community's attention. while linking language with perception is currently a topical issue, there has been relatively little work on linking grounding directly with inference. by drawing closer to a joint solution to the grounding and inference tasks, models will also be better able to address language understanding in the real world. the present paper presented a first step in this direction using a version of an existing te dataset which was augmented with images that could be paired directly with the premises, since these were originally captions for those images. however, it is important to note that in this dataset premise-hypotheses pairs were not generated directly with reference to the images themselves. an important issue to consider in future work on gte, besides the development of better models, is the development of datasets in which the role of perceptual information is controlled, ensuring that the data on which models are trained represents truly grounded inferences. section: acknowledgements we kindly acknowledge the european network on integrating vision and language (iv& l net) ict cost action ic1307. moreover, we thank the erasmus mundus european program in language and communication technology. marc tanti's work is partially funded by the endeavour scholarship scheme (malta), part-financed by the european union's european social fund (esf). finally, we gratefully acknowledge the support of nvidia corporation with the donations to the university of trento of the gpus used in our research. section: appendix a: bottom-up top-down attention (vqa) we adapted the visual question answering model proposed in to the grounded textual entailment task. the model presents a more fine-grained attention mechanism which allows to identify the most important regions discovered in the image and to perform attention over each of them. the model uses a a recurrent neural network with long short-term memory units to encode the premise p and hypothesis h in 512d vectors. a bottom-up attention mechanism exploits a fast r-cnn based on a resnet-101 convolutional neural network to obtain region proposals corresponding to the 36 most informative regions of the image. a top-down attention mechanism is used between the premise (resp. hypothesis) and each of the l2-normalized 2048d image vectors corresponding to the region proposals to obtain an attention score for each of them. then, a 2048d image vector encoding the most interesting visual features for the premise (hypothesis) is obtained as a sum of the 36 image vectors weighted by the corresponding attention scores for the premise (hypothesis). a fully-connected layer with a gated tanh activation function is applied to the image vector of the most interesting visual features for the premise and for the hypothesis to obtain a reduced 512d vector for each of them. a fully-connected layer with a gated tanh activation function is also applied to the premise and to the hypothesis in order to obtain a reduced 512d vector for each of them. the multimodal fusion between the premise (hypothesis) and the image vector of the most interesting visual features for the premise (hypothesis) is obtained by performing an element-wise multiplication between the reduced vector of the premise (hypothesis) and the reduced vector of the most interesting visual features for the premise (hypothesis). after that, the model feeds the concatenation of the two resulting multimodal representations to a stack of three 512d layers having a gated tanh activation function, with a final softmax layer to classify the relation between the two sentences as entailment, contradiction or neutral. this model uses glove embeddings and the same optimization tricks and procedure of the lstm and v-lstm models. we report the accuracies of the vqa models against the various tests reported in the paper. for ease of comparison we reproduce the full table from the main paper, with the addition of the vqa results. section: appendix b: v-bimpm model details arrows, calc, fit positioning, shapes.multipart, shapes.callouts decorations.pathreplacing hbox= [rectangle, minimum width=7pt, minimum height=25pt] vbox= [rectangle, fill= black!25, minimum width=35pt, minimum height=10pt] blue hbox= [hbox, fill= blue] dots hbox= [hbox] green hbox= [hbox, fill= green] green vbox= [vbox, fill= green] tbox= [rectangle, minimum width=45pt, minimum height=20pt, draw= black, text centered, text= black] red arrow= [-\u00bf, red] match arrow= [-\u00bf, black] red matching= [text= red, inner sep=0] black matching= [text= black, inner sep=0] context container/.style= draw= orange, rectangle callout, inner sep=0.6em 0.95! [scale=0.2] [] (prem_text) at (10,- 7) premise; [] (hypo_text) at (35,- 7) hypothesis; [blue hbox, label= below:] (w-1) at (0, 0); [blue hbox, right of= w-1, node distance=0.7 cm, label= below:] (w-2); [dots hbox, right of= w-2, node distance=0.7 cm, label= below:\u2026] (w-3)\u2026; [blue hbox, right of= w-3, node distance=0.7 cm, label= below:] (w-4); [dots hbox, right of= w-4, node distance=0.7 cm, label= below:\u2026] (w-5)\u2026; [blue hbox, right of= w-5, node distance=0.7 cm, label= below:] (w-6); [blue hbox, right of= w-6, node distance=1.5cm*1.2, label= below:] (w-7); [blue hbox, right of= w-7, node distance=0.7 cm, label= below:] (w-8); [dots hbox, right of= w-8, node distance=0.7 cm, label= below:\u2026] (w-9)\u2026; [blue hbox, right of= w-9, node distance=0.7 cm, label= below:] (w-10); [dots hbox, right of= w-10, node distance=0.7 cm, label= below:\u2026] (w-11)\u2026; [blue hbox, right of= w-11, node distance=0.7 cm, label= below:] (w-12); [inner sep=0pt, right of= w-12, node distance=1.5cm*2.15] (image) [width=.10] figures/ cat.jpg; [blue hbox] (c-1) at (0, 1.5cm*7); [blue hbox, right of= c-1, node distance=0.7 cm] (c-2); [dots hbox, right of= c-2, node distance=0.7 cm] (c-3)\u2026; [blue hbox, right of= c-3, node distance=0.7 cm] (c-4); [dots hbox, right of= c-4, node distance=0.7 cm] (c-5)\u2026; [blue hbox, right of= c-5, node distance=0.7 cm] (c-6); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-1)- (c-2); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-2)- (c-3); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-3)- (c-4); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-4)- (c-5); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-5)- (c-6); [blue hbox, above of= c-1, node distance=1.5cm/ 1.2] (c-1u); [blue hbox, right of= c-1u, node distance=0.7 cm] (c-2u); [dots hbox, right of= c-2u, node distance=0.7 cm] (c-3u)\u2026; [blue hbox, right of= c-3u, node distance=0.7 cm] (c-4u); [dots hbox, right of= c-4u, node distance=0.7 cm] (c-5u)\u2026; [blue hbox, right of= c-5u, node distance=0.7 cm] (c-6u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-2u)- (c-1u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-3u)- (c-2u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-4u)- (c-3u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-5u)- (c-4u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-6u)- (c-5u); [red arrow, shorten\u00bf= 10pt, shorten\u00a1=-3pt] (w-3)- (c-3); [inner sep=0] (p-callout-pointer) at (); [context container, callout absolute pointer= (p-callout-pointer), fit= (c-1) (c-6u)] (premise-callout); [blue hbox, right of= c-6, node distance=1.5cm*1.2] (c-7); [blue hbox, right of= c-7, node distance=0.7 cm] (c-8); [dots hbox, right of= c-8, node distance=0.7 cm] (c-9)\u2026; [blue hbox, right of= c-9, node distance=0.7 cm] (c-10); [dots hbox, right of= c-10, node distance=0.7 cm] (c-11)\u2026; [blue hbox, right of= c-11, node distance=0.7 cm] (c-12); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-7)- (c-8); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-8)- (c-9); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-9)- (c-10); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-10)- (c-11); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-11)- (c-12); [blue hbox, right of= c-6u, node distance=1.5cm*1.2] (c-7u); [blue hbox, right of= c-7u, node distance=0.7 cm] (c-8u); [dots hbox, right of= c-8u, node distance=0.7 cm] (c-9u)\u2026; [blue hbox, right of= c-9u, node distance=0.7 cm] (c-10u); [dots hbox, right of= c-10u, node distance=0.7 cm] (c-11u)\u2026; [blue hbox, right of= c-11u, node distance=0.7 cm] (c-12u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-8u)- (c-7u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-9u)- (c-8u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-10u)- (c-9u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-11u)- (c-10u); [red arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (c-12u)- (c-11u); [red arrow, shorten\u00bf= 10pt, shorten\u00a1=-3pt] (w-9)- (c-9); [inner sep=0] (h-callout-pointer) at (); [context container, callout absolute pointer= (h-callout-pointer), fit= (c-7)(c-12u)] (left-callout); [blue hbox, right of= c-12, node distance=1.5cm*1.2, yshift=1.2 cm, label= below:] (ci-1); [blue hbox, right of= ci-1, node distance=0.7 cm, label= below:] (ci-2); [dots hbox, right of= ci-2, node distance=0.7 cm, label= below:\u2026] (ci-3)\u2026; [blue hbox, right of= ci-3, node distance=0.7 cm, label= below:] (ci-4); [dots hbox, right of= ci-4, node distance=0.7 cm, label= below:\u2026] (ci-5)\u2026; [blue hbox, right of= ci-5, node distance=0.7 cm, label= below:] (ci-6); [red arrow, shorten\u00bf= 9pt, shorten\u00a1= 5pt] (image)- (ci-3) node [pos=0.35, right, font=] vggnet; [inner sep=0em] (i-callout-pointer) at (-(-\u2062ci1)(\u20623cm,-\u20621 cm)); container, callout absolute pointer= (i-callout-pointer), fit= (ci-1)(ci-6), inner sep=0.26em] (left-callout); [blue hbox, above of= c-1u, node distance=1.5cm*2.9] (m-1); hbox, right of= m-1, node distance=0.5 cm] (m-2); hbox, right of= m-2, node distance=0.5 cm,] (m-3)\u2026; hbox, right of= m-3, node distance=0.5 cm] (m-4); hbox, right of= m-4, node distance=0.5 cm] (m-5)\u2026; hbox, right of= m-5, node distance=0.5 cm,] (m-6); ([xshift=0pt, yshift=-0.2cm] m-6.south east)- ([xshift=0pt, yshift=-0.2cm] m-1.south west) node [black, midway, yshift=-0.35 cm] p vs h; [blue hbox, right of= m-6, node distance=0.9cm*1.5] (m-7); hbox, right of= m-7, node distance=0.5 cm] (m-8); hbox, right of= m-8, node distance=0.5 cm] (m-9)\u2026; hbox, right of= m-9, node distance=0.5 cm] (m-10); hbox, right of= m-10, node distance=0.5 cm] (m-11)\u2026; hbox, right of= m-11, node distance=0.5 cm] (m-12); ([xshift=0pt, yshift=-0.2cm] m-12.south east)- ([xshift=0pt, yshift=-0.2cm] m-7.south west) node [black, midway, yshift=-0.35 cm] h vs p; [blue hbox, right of= m-12, node distance=0.9cm*1.5] (mi-13); hbox, right of= mi-13, node distance=0.5 cm] (mi-14); hbox, right of= mi-14, node distance=0.5 cm] (mi-15)\u2026; hbox, right of= mi-15, node distance=0.5 cm] (mi-16); hbox, right of= mi-16, node distance=0.5 cm] (mi-17)\u2026; hbox, right of= mi-17, node distance=0.5 cm] (mi-18); ([xshift=0pt, yshift=-0.2cm] mi-18.south east)- ([xshift=0pt, yshift=-0.2cm] mi-13.south west) node [black, midway, yshift=-0.35 cm] h vs image; [blue hbox, right of= mi-18, node distance=0.9cm*1.5] (mi-19); hbox, right of= mi-19, node distance=0.5 cm] (mi-20); hbox, right of= mi-20, node distance=0.5 cm] (mi-21)\u2026; hbox, right of= mi-21, node distance=0.5 cm] (mi-22); hbox, right of= mi-22, node distance=0.5 cm] (mi-23)\u2026; hbox, right of= mi-23, node distance=0.5 cm] (mi-24); ([xshift=0pt, yshift=-0.2cm] mi-24.south east)- ([xshift=0pt, yshift=-0.2cm] mi-19.south west) node [black, midway, yshift=-0.35 cm] image vs h; [red matching, below of= m-1, node distance=1.5cm*1.5] (mp-1)\u2297; matching, below of= m-2, node distance=1.5cm*1.5] (mp-2)\u2297; matching, below of= m-4, node distance=1.5cm*1.5] (mp-3)\u2297; matching, below of= m-6, node distance=1.5cm*1.5] (mp-4)\u2297; [red matching, below of= m-7, node distance=1.5cm*1.5] (mp-5)\u2297; matching, below of= m-8, node distance=1.5cm*1.5] (mp-6)\u2297; matching, below of= m-10, node distance=1.5cm*1.5] (mp-7)\u2297; matching, below of= m-12, node distance=1.5cm*1.5] (mp-8)\u2297; [black matching, below of= mi-13, node distance=1.5cm*1.5] (mp-9)\u2297; matching, below of= mi-14, node distance=1.5cm*1.5] (mp-10)\u2297; matching, below of= mi-16, node distance=1.5cm*1.5] (mp-11)\u2297; matching, below of= mi-18, node distance=1.5cm*1.5] (mp-12)\u2297; [black matching, below of= mi-19, node distance=1.5cm*1.5] (mp-13)\u2297; matching, below of= mi-20, node distance=1.5cm*1.5] (mp-14)\u2297; matching, below of= mi-22, node distance=1.5cm*1.5] (mp-15)\u2297; matching, below of= mi-24, node distance=1.5cm*1.5] (mp-16)\u2297; mp-1); h-callout-pointer)\u2423 edge [->,\u2423 out=165,\u2423 in=-70] mp-2); h-callout-pointer)\u2423 edge [->,\u2423 out=160,\u2423 in=-75] mp-3); h-callout-pointer)\u2423 edge [->,\u2423 out=155,\u2423 in=-80] mp-4); mp-5); p-callout-pointer)\u2423 edge [->,\u2423 out=110,\u2423 in=-100] mp-6); p-callout-pointer)\u2423 edge [->,\u2423 out=65,\u2423 in=-90] mp-7); p-callout-pointer)\u2423 edge [->,\u2423 out=60,\u2423 in=-90] mp-8); mp-13); h-callout-pointer)\u2423 edge [->,\u2423 out=20,\u2423 in=-100] mp-14); h-callout-pointer)\u2423 edge [->,\u2423 out=15,\u2423 in=-105] mp-15); h-callout-pointer)\u2423 edge [->,\u2423 out=10,\u2423 in=-110] mp-16); mp-9); i-callout-pointer)\u2423 edge [->,\u2423 out=145,\u2423 in=-60] mp-10); i-callout-pointer)\u2423 edge [->,\u2423 out=140,\u2423 in=-105] mp-11); i-callout-pointer)\u2423 edge [->,\u2423 out=65,\u2423 in=-60] mp-12); [red arrow, shorten\u00bf= 18pt] (mp-1)- (m-1); arrow, shorten\u00bf= 18pt] (mp-2)- (m-2); arrow, shorten\u00bf= 18pt] (mp-3)- (m-4); arrow, shorten\u00bf= 18pt] (mp-4)- (m-6); [red arrow, shorten\u00bf= 18pt] (mp-5)- (m-7); arrow, shorten\u00bf= 18pt] (mp-6)- (m-8); arrow, shorten\u00bf= 18pt] (mp-7)- (m-10); arrow, shorten\u00bf= 18pt] (mp-8)- (m-12); [red arrow, shorten\u00bf= 18pt] (mp-9)- (mi-13); arrow, shorten\u00bf= 18pt] (mp-10)- (mi-14); arrow, shorten\u00bf= 18pt] (mp-11)- (mi-16); arrow, shorten\u00bf= 18pt] (mp-12)- (mi-18); arrow, shorten\u00bf= 18pt] (mp-13)- (mi-19); arrow, shorten\u00bf= 18pt] (mp-14)- (mi-20); arrow, shorten\u00bf= 18pt] (mp-15)- (mi-22); arrow, shorten\u00bf= 18pt] (mp-16)- (mi-24); [match arrow, shorten\u00a1= 6pt] (c-1u)- (mp-1); arrow, shorten\u00a1= 6pt] (c-2u)- (mp-2); arrow, shorten\u00a1= 7pt] (c-4u) to [out=80, in=-45] (mp-3); arrow, shorten\u00a1= 6pt] (c-6u) to [out=100, in=-45] (mp-4); [match arrow, shorten\u00a1= 9pt] (c-7u) to [out=110, in=-40] (mp-5); arrow, shorten\u00a1= 7pt] (c-8u) to [out=100, in=-35] (mp-6); arrow, shorten\u00a1= 20pt] (c-10u)- (mp-7); arrow, shorten\u00a1= 22pt] (c-12u)- (mp-8); [match arrow, shorten\u00a1= 22pt] (c-7u)- (mp-9); arrow, shorten\u00a1= 20pt] (c-8u)- (mp-10); arrow, shorten\u00a1= 7pt] (c-10u) to [out=80, in=220] (mp-11); arrow, shorten\u00a1= 7pt] (c-12u) to [out=80, in=230] (mp-12); [match arrow, shorten\u00a1= 3pt] (ci-1) to [out=80, in=220] (mp-13); arrow, shorten\u00a1= 3pt] (ci-2) to [out=90, in=220] (mp-14); arrow, shorten\u00a1= 10pt] (ci-4) to [out=60, in=-70] (mp-15); arrow, shorten\u00a1= 3pt] (ci-6)- (mp-16); [blue hbox, above of= m-1, node distance=1.5cm*1.2] (a-1); hbox, right of= a-1, node distance=0.5 cm] (a-2); hbox, right of= a-2, node distance=0.5 cm] (a-3)\u2026; hbox, right of= a-3, node distance=0.5 cm] (a-4); hbox, right of= a-4, node distance=0.5 cm] (a-5)\u2026; hbox, right of= a-5, node distance=0.5 cm] (a-6); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (a-1)- (a-2); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-2)- (a-3); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-3)- (a-4); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-4)- (a-5); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-5)- (a-6); [green hbox, above of= a-1, node distance=1.5cm/ 1.2] (a-1u); hbox, right of= a-1u, node distance=0.5 cm] (a-2u); hbox, right of= a-2u, node distance=0.5 cm] (a-3u)\u2026; hbox, right of= a-3u, node distance=0.5 cm] (a-4u); hbox, right of= a-4u, node distance=0.5 cm] (a-5u)\u2026; hbox, right of= a-5u, node distance=0.5 cm] (a-6u); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (a-2u)- (a-1u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-3u)- (a-2u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-4u)- (a-3u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-5u)- (a-4u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-6u)- (a-5u); [blue hbox, right of= a-6, node distance=0.9cm*1.5] (a-7); hbox, right of= a-7, node distance=0.5 cm] (a-8); hbox, right of= a-8, node distance=0.5 cm] (a-9)\u2026; hbox, right of= a-9, node distance=0.5 cm] (a-10); hbox, right of= a-10, node distance=0.5 cm] (a-11)\u2026; hbox, right of= a-11, node distance=0.5 cm] (a-12); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (a-7)- (a-8); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-8)- (a-9); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-9)- (a-10); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-10)- (a-11); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-11)- (a-12); [green hbox, right of= a-6u, node distance=0.9cm*1.5] (a-7u); hbox, right of= a-7u, node distance=0.5 cm] (a-8u); hbox, right of= a-8u, node distance=0.5 cm] (a-9u)\u2026; hbox, right of= a-9u, node distance=0.5 cm] (a-10u); hbox, right of= a-10u, node distance=0.5 cm] (a-11u)\u2026; hbox, right of= a-11u, node distance=0.5 cm] (a-12u); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (a-8u)- (a-7u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-9u)- (a-8u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-10u)- (a-9u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (a-11u)- (a-10u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (a-12u)- (a-11u); [blue hbox, right of= a-12, node distance=0.9cm*1.5] (ai-13); hbox, right of= ai-13, node distance=0.5 cm] (ai-14); hbox, right of= ai-14, node distance=0.5 cm] (ai-15)\u2026; hbox, right of= ai-15, node distance=0.5 cm] (ai-16); hbox, right of= ai-16, node distance=0.5 cm] (ai-17)\u2026; hbox, right of= ai-17, node distance=0.5 cm] (ai-18); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (ai-13)- (ai-14); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-14)- (ai-15); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-15)- (ai-16); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-16)- (ai-17); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-17)- (ai-18); [green hbox, right of= a-12u, node distance=0.9cm*1.5] (ai-13u); hbox, right of= ai-13u, node distance=0.5 cm] (ai-14u); hbox, right of= ai-14u, node distance=0.5 cm] (ai-15u)\u2026; hbox, right of= ai-15u, node distance=0.5 cm] (ai-16u); hbox, right of= ai-16u, node distance=0.5 cm] (ai-17u)\u2026; hbox, right of= ai-17u, node distance=0.5 cm] (ai-18u); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (ai-14u)- (ai-13u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-15u)- (ai-14u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-16u)- (ai-15u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-17u)- (ai-16u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-18u)- (ai-17u); [blue hbox, right of= ai-18, node distance=0.9cm*1.5] (ai-19); hbox, right of= ai-19, node distance=0.5 cm] (ai-20); hbox, right of= ai-20, node distance=0.5 cm] (ai-21)\u2026; hbox, right of= ai-21, node distance=0.5 cm] (ai-22); hbox, right of= ai-22, node distance=0.5 cm] (ai-23)\u2026; hbox, right of= ai-23, node distance=0.5 cm] (ai-24); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (ai-19)- (ai-20); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-20)- (ai-21); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-21)- (ai-22); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-22)- (ai-23); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-23)- (ai-24); [green hbox, right of= ai-18u, node distance=0.9cm*1.5] (ai-19u); hbox, right of= ai-19u, node distance=0.5 cm] (ai-20u); hbox, right of= ai-20u, node distance=0.5 cm] (ai-21u)\u2026; hbox, right of= ai-21u, node distance=0.5 cm] (ai-22u); hbox, right of= ai-22u, node distance=0.5 cm] (ai-23u)\u2026; hbox, right of= ai-23u, node distance=0.5 cm] (ai-24u); arrow, shorten\u00bf= 1pt, shorten\u00a1= 1pt] (ai-20u)- (ai-19u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-21u)- (ai-20u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-22u)- (ai-21u); arrow, shorten\u00bf= 0pt, shorten\u00a1=-2pt] (ai-23u)- (ai-22u); arrow, shorten\u00bf=-2pt, shorten\u00a1= 0pt] (ai-24u)- (ai-23u); arrow, shorten\u00bf= 6pt, shorten\u00a1=-5pt] (m-3)- (a-3); arrow, shorten\u00bf= 6pt, shorten\u00a1=-5pt] (m-9)- (a-9); arrow, shorten\u00bf= 6pt, shorten\u00a1=-5pt] (mi-15)- (ai-15); arrow, shorten\u00bf= 6pt, shorten\u00a1=-5pt] (mi-21)- (ai-21); [green vbox, above of= a-3u, node distance=1.5cm*1.2, xshift=-0.3 cm] (ap-1); vbox, right of= ap-1, node distance=0.9cm*2] (ap-2); vbox, right of= ap-2, node distance=0.9cm*2] (ap-3); vbox, right of= ap-3, node distance=0.9cm*2] (ap-4); vbox, right of= ap-4, node distance=0.9cm*2] (ap-5); vbox, right of= ap-5, node distance=0.9cm*2] (ap-6); vbox, right of= ap-6, node distance=0.9cm*2] (ap-7); vbox, right of= ap-7, node distance=0.9cm*2] (ap-8); [red arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (a-1u)- (ap-1); arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (a-6.east)- ([xshift=-1 cm] ap-2.south east); [red arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (a-7u)- (ap-3); arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (a-12.west)- ([xshift=-0.5cm] ap-4.south); [red arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (ai-13u)- (ap-5); arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (ai-18.west)- ([xshift=-1cm] ap-6); [red arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (ai-19u)- (ap-7); arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] (ai-24.west)- (ap-8); [tbox, above of= ap-4, node distance=0.9cm*1.6, xshift=1 cm] (softmax) softmax; of= softmax, node distance=0.9 cm] (output) p (y|premise, image, hypothesis); arrow, shorten\u00bf= 3pt, shorten\u00a1= 3pt] ([xshift=1.5cm] ap-4.north east)- (softmax); [decorate, thick, decoration= brace, amplitude=6pt, yshift=0pt] ([yshift=-65pt, xshift=-50pt] w-1.south west)- ([xshift=-50pt, yshift=-125pt] c-1.south west) node [black, midway, xshift=-1 cm, yshift=-0.2 cm, rotate=90, anchor= north] embedding layer; [decorate, thick, decoration= brace, amplitude=6pt, yshift=0pt] ([yshift=-5pt, xshift=-50pt] c-1.south west)- ([xshift=-50pt, yshift=25pt] c-1u.north west) node [black, midway, xshift=-1 cm, rotate=90, anchor= north] context layer; [decorate, thick, decoration= brace, amplitude=6pt, yshift=0pt] ([yshift=-95pt, xshift=-50pt] mp-1.south west)- ([xshift=-50pt, yshift=-45pt] m-1.north west) node [black, midway, xshift=-1 cm, rotate=90, anchor= north] matching layer; [decorate, thick, decoration= brace, amplitude=6pt, yshift=0pt] ([xshift=-50pt] a-1.south west)- ([xshift=-50pt, yshift=1.5cm*3] a-1u.north west) node [black, midway, xshift=-1 cm, rotate=90, anchor= north] aggregation layer; [decorate, thick, decoration= brace, amplitude=6pt, yshift=0pt] ([xshift=-50pt, yshift=1.5cm*5.5] a-1u.north west)- ([xshift=-50pt, yshift=1.5cm*12.5] a-1u.north west) node [black, midway, xshift=-1 cm, rotate=90, anchor= north] prediction layer; here, we report some further details of our implementation of the v-bimpm model described in section 4 of the main paper, based on the work of wang2017. our model is displayed in figure [reference]. the core part of the original bimpm is the matching layer. given two-dimensional vectors and, each replicated times (is the number of 'perspectives') and a trainable weight matrix, matching involves a cosine similarity computation that yields an-dimensional matching vector, whose elements are defined as follows: the matching operations included are the following: full-matching, where each forward or backward contextual embedding of the premise p (resp. the hypothesis h) is matched to the last time-step of h (resp. p); max-pooling, where each forward/ backward contextual embedding of one sentence is compared to the embeddings of the other, retaining the maximum value for each dimension; attentive matching, where first, the pairwise cosine similarity between forward/ backward embeddings of p and h is estimated, before calculating an attentive vector over the weighted sum of contextual embeddings for h and matching each forward/ backward embedding of p against the attentive vector; max-attentive matching, a version of attentive matching where the contextual embedding with the highest cosine is used as the attentive vector, instead of the weighted sum. the visually-augmented version of the original model, v-bimpm, is displayed in figure [reference]. to perform multimodal matching, the visual and textual vectors are mapped to a mutual space using the following affine transformation: where,,, and are the weight matrix, the bias, the input features and output features, respectively, and is any text (p or h). given weight matrices for text and for images, we compute the matching vector between a textual vector and image vector as: bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "multimodal version of the snli dataset"
                    ],
                    [
                        "snli"
                    ],
                    [
                        "snli dataset"
                    ],
                    [
                        "fracas"
                    ],
                    [
                        "stanford natural language inference"
                    ],
                    [
                        "snli"
                    ],
                    [
                        "snli dataset"
                    ],
                    [
                        "full v snli dataset"
                    ]
                ],
                "Method": [
                    [
                        "grounded textual entailment"
                    ],
                    [
                        "bilateral multi perspective matching bimpm"
                    ],
                    [
                        "bilateral multi perspective matching bimpm model"
                    ]
                ],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "v-snli",
                        "v-snli test",
                        "v-snli dataset",
                        "v-lstm baseline",
                        "v-lstm",
                        "v -) snli"
                    ]
                ],
                "Method": [
                    [
                        "bimpm",
                        "bilateral multi-perspective matching"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy",
                        "accuracies"
                    ]
                ],
                "Task": [
                    [
                        "natural language inference",
                        "inference"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "v-snli",
                        "v-snli test",
                        "v-snli dataset",
                        "v-lstm baseline",
                        "v-lstm",
                        "v -) snli"
                    ]
                ],
                "Method": [
                    [
                        "v-bimpm",
                        "v-bimpm model"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy",
                        "accuracies"
                    ]
                ],
                "Task": [
                    [
                        "natural language inference",
                        "inference"
                    ]
                ]
            }
        ]
    },
    "14318685b5959b51d0f1e3db34643eb2855dc6d9-17": {
        "doctext": "document: going deeper with convolutions we propose a deep convolutional neural network architecture codenamed\u00e2\u0080\u009cinception\u00e2\u0080\u009d, which was responsible for setting the new state of the art for classification and detection in the imagenet large-scale visual recognition challenge 2014 (ilsvrc\u00e2\u0080\u009914). the main hallmark of this architecture is the improved utilization of the computing resources inside the network. this was achieved by a carefully crafted design that allows for increasing the depth and width of the network while keeping the computational budget constant. to optimize quality, the architectural decisions were based on the hebbian principle and the intuition of multi-scale processing. one particular incarnation used in our submission for ilsvrc\u00e2\u0080\u009914 is called googlenet, a 22 layers deep network, the quality of which is assessed in the context of classification and detection. parskip [] section: introduction in the last three years, mainly due to the advances of deep learning, more concretely convolutional networks, the quality of image recognition and object detection has been progressing at a dramatic pace. one encouraging news is that most of this progress is not just the result of more powerful hardware, larger datasets and bigger models, but mainly a consequence of new ideas, algorithms and improved network architectures. no new data sources were used, for example, by the top entries in the ilsvrc 2014 competition besides the classification dataset of the same competition for detection purposes. our googlenet submission to ilsvrc 2014 actually uses fewer parameters than the winning architecture of krizhevsky et al from two years ago, while being significantly more accurate. the biggest gains in object-detection have not come from the utilization of deep networks alone or bigger models, but from the synergy of deep architectures and classical computer vision, like the r-cnn algorithm by girshick et al. another notable factor is that with the ongoing traction of mobile and embedded computing, the efficiency of our algorithms- especially their power and memory use- gains importance. it is noteworthy that the considerations leading to the design of the deep architecture presented in this paper included this factor rather than having a sheer fixation on accuracy numbers. for most of the experiments, the models were designed to keep a computational budget of billion multiply-adds at inference time, so that the they do not end up to be a purely academic curiosity, but could be put to real world use, even on large datasets, at a reasonable cost. in this paper, we will focus on an efficient deep neural network architecture for computer vision, codenamed\u00e2\u0080\u009cinception\u00e2\u0080\u009d, which derives its name from the\u00e2\u0080\u009cnetwork in network\u00e2\u0080\u009d paper by lin et al in conjunction with the famous\" we need to go deeper\" internet meme. in our case, the word\" deep\" is used in two different meanings: first of all, in the sense that we introduce a new level of organization in the form of the\" inception module\" and also in the more direct sense of increased network depth. in general, one can view the inception model as a logical culmination of while taking inspiration and guidance from the theoretical work by arora et al. the benefits of the architecture are experimentally verified on the ilsvrc 2014 classification and detection challenges, on which it significantly outperforms the current state of the art. section: related work starting with lenet-5, convolutional neural networks (cnn) have typically had a standard structure- stacked convolutional layers (optionally followed by contrast normalization and max-pooling) are followed by one or more fully-connected layers. variants of this basic design are prevalent in the image classification literature and have yielded the best results to-date on mnist, cifar and most notably on the imagenet classification challenge.\u00e2 for larger datasets such as imagenet, the recent trend has been to increase the number of layers and layer size, while using dropout to address the problem of overfitting. despite concerns that max-pooling layers result in loss of accurate spatial information, the same convolutional network architecture as has also been successfully employed for localization, object detection and human pose estimation. inspired by a neuroscience model of the primate visual cortex, serre et al. use a series of fixed gabor filters of different sizes in order to handle multiple scales, similarly to the inception model. however, contrary to the fixed 2-layer deep model of, all filters in the inception model are learned. furthermore, inception layers are repeated many times, leading to a 22-layer deep model in the case of the googlenet model. network-in-network is an approach proposed by lin et al. in order to increase the representational power of neural networks. when applied to convolutional layers, the method could be viewed as additional convolutional layers followed typically by the rectified linear activation. this enables it to be easily integrated in the current cnn pipelines. we use this approach heavily in our architecture. however, in our setting, convolutions have dual purpose: most critically, they are used mainly as dimension reduction modules to remove computational bottlenecks, that would otherwise limit the size of our networks.\u00e2 this allows for not just increasing the depth, but also the width of our networks without significant performance penalty. the current leading approach for object detection is the regions with convolutional neural networks (r-cnn) proposed by girshick et al.. r-cnn decomposes the overall detection problem into two subproblems: to first utilize low-level cues such as color and superpixel consistency for potential object proposals in a category-agnostic fashion, and to then use cnn classifiers to identify object categories at those locations. such a two stage approach leverages the accuracy of bounding box segmentation with low-level cues, as well as the highly powerful classification power of state-of-the-art cnns. we adopted a similar pipeline in our detection submissions, but have explored enhancements in both stages, such as multi-box prediction for higher object bounding box recall, and ensemble approaches for better categorization of bounding box proposals. section: motivation and high level considerations the most straightforward way of improving the performance of deep neural networks is by increasing their size. this includes both increasing the depth- the number of levels- of the network and its width: the number of units at each level. this is as an easy and safe way of training higher quality models, especially given the availability of a large amount of labeled training data. however this simple solution comes with two major drawbacks. bigger size typically means a larger number of parameters, which makes the enlarged network more prone to overfitting, especially if the number of labeled examples in the training set is limited. this can become a major bottleneck, since the creation of high quality training sets can be tricky and expensive, especially if expert human raters are necessary to distinguish between fine-grained visual categories like those in imagenet (even in the 1000-class ilsvrc subset) as demonstrated by figure [reference]. another drawback of uniformly increased network size is the dramatically increased use of computational resources. for example, in a deep vision network, if two convolutional layers are chained, any uniform increase in the number of their filters results in a quadratic increase of computation. if the added capacity is used inefficiently (for example, if most weights end up to be close to zero), then a lot of computation is wasted. since in practice the computational budget is always finite, an efficient distribution of computing resources is preferred to an indiscriminate increase of size, even when the main objective is to increase the quality of results. the fundamental way of solving both issues would be by ultimately moving from fully connected to sparsely connected architectures, even inside the convolutions. besides mimicking biological systems, this would also have the advantage of firmer theoretical underpinnings due to the groundbreaking work of arora et al.. their main result states that if the probability distribution of the data-set is representable by a large, very sparse deep neural network, then the optimal network topology can be constructed layer by layer by analyzing the correlation statistics of the activations of the last layer and clustering neurons with highly correlated outputs. although the strict mathematical proof requires very strong conditions, the fact that this statement resonates with the well known hebbian principle- neurons that fire together, wire together- suggests that the underlying idea is applicable even under less strict conditions, in practice. on the downside, today\u00e2\u0080\u0099s computing infrastructures are very inefficient when it comes to numerical calculation on non-uniform sparse data structures. even if the number of arithmetic operations is reduced by, the overhead of lookups and cache misses is so dominant that switching to sparse matrices would not pay off. the gap is widened even further by the use of steadily improving, highly tuned, numerical libraries that allow for extremely fast dense matrix multiplication, exploiting the minute details of the underlying cpu or gpu hardware. also, non-uniform sparse models require more sophisticated engineering and computing infrastructure. most current vision oriented machine learning systems utilize sparsity in the spatial domain just by the virtue of employing convolutions. however, convolutions are implemented as collections of dense connections to the patches in the earlier layer. convnets have traditionally used random and sparse connection tables in the feature dimensions since in order to break the symmetry and improve learning, the trend changed back to full connections with in order to better optimize parallel computing. the uniformity of the structure and a large number of filters and greater batch size allow for utilizing efficient dense computation. this raises the question whether there is any hope for a next, intermediate step: an architecture that makes use of the extra sparsity, even at filter level, as suggested by the theory, but exploits our current hardware by utilizing computations on dense matrices. the vast literature on sparse matrix computations (e.g.) suggests that clustering sparse matrices into relatively dense submatrices tends to give state of the art practical performance for sparse matrix multiplication. it does not seem far-fetched to think that similar methods would be utilized for the automated construction of non-uniform deep-learning architectures in the near future. the inception architecture started out as a case study of the first author for assessing the hypothetical output of a sophisticated network topology construction algorithm that tries to approximate a sparse structure implied by for vision networks and covering the hypothesized outcome by dense, readily available components. despite being a highly speculative undertaking, only after two iterations on the exact choice of topology, we could already see modest gains against the reference architecture based on. after further tuning of learning rate, hyperparameters and improved training methodology, we established that the resulting inception architecture was especially useful in the context of localization and object detection as the base network for and. interestingly, while most of the original architectural choices have been questioned and tested thoroughly, they turned out to be at least locally optimal. one must be cautious though: although the proposed architecture has become a success for computer vision, it is still questionable whether its quality can be attributed to the guiding principles that have lead to its construction. making sure would require much more thorough analysis and verification: for example, if automated tools based on the principles described below would find similar, but better topology for the vision networks. the most convincing proof would be if an automated system would create network topologies resulting in similar gains in other domains using the same algorithm but with very differently looking global architecture. at very least, the initial success of the inception architecture yields firm motivation for exciting future work in this direction. section: architectural details the main idea of the inception architecture is based on finding out how an optimal local sparse structure in a convolutional vision network can be approximated and covered by readily available dense components. note that assuming translation invariance means that our network will be built from convolutional building blocks. all we need is to find the optimal local construction and to repeat it spatially. arora et al. suggests a layer-by layer construction in which one should analyze the correlation statistics of the last layer and cluster them into groups of units with high correlation. these clusters form the units of the next layer and are connected to the units in the previous layer. we assume that each unit from the earlier layer corresponds to some region of the input image and these units are grouped into filter banks. in the lower layers (the ones close to the input) correlated units would concentrate in local regions. this means, we would end up with a lot of clusters concentrated in a single region and they can be covered by a layer of convolutions in the next layer, as suggested in. however, one can also expect that there will be a smaller number of more spatially spread out clusters that can be covered by convolutions over larger patches, and there will be a decreasing number of patches over larger and larger regions. in order to avoid patch-alignment issues, current incarnations of the inception architecture are restricted to filter sizes, and, however this decision was based more on convenience rather than necessity. it also means that the suggested architecture is a combination of all those layers with their output filter banks concatenated into a single output vector forming the input of the next stage. additionally, since pooling operations have been essential for the success in current state of the art convolutional networks, it suggests that adding an alternative parallel pooling path in each such stage should have additional beneficial effect, too (see figure [reference]). as these\" inception modules\" are stacked on top of each other, their output correlation statistics are bound to vary: as features of higher abstraction are captured by higher layers, their spatial concentration is expected to decrease suggesting that the ratio of and convolutions should increase as we move to higher layers. one big problem with the above modules, at least in this na\u00efve form, is that even a modest number of convolutions can be prohibitively expensive on top of a convolutional layer with a large number of filters. this problem becomes even more pronounced once pooling units are added to the mix: their number of output filters equals to the number of filters in the previous stage. the merging of the output of the pooling layer with the outputs of convolutional layers would lead to an inevitable increase in the number of outputs from stage to stage. even while this architecture might cover the optimal sparse structure, it would do it very inefficiently, leading to a computational blow up within a few stages. this leads to the second idea of the proposed architecture: judiciously applying dimension reductions and projections wherever the computational requirements would increase too much otherwise. this is based on the success of embeddings: even low dimensional embeddings might contain a lot of information about a relatively large image patch. however, embeddings represent information in a dense, compressed form and compressed information is harder to model. we would like to keep our representation sparse at most places (as required by the conditions of) and compress the signals only whenever they have to be aggregated en masse. that is, convolutions are used to compute reductions before the expensive and convolutions. besides being used as reductions, they also include the use of rectified linear activation which makes them dual-purpose. the final result is depicted in figure [reference]. in general, an inception network is a network consisting of modules of the above type stacked upon each other, with occasional max-pooling layers with stride 2 to halve the resolution of the grid. for technical reasons (memory efficiency during training), it seemed beneficial to start using inception modules only at higher layers while keeping the lower layers in traditional convolutional fashion. this is not strictly necessary, simply reflecting some infrastructural inefficiencies in our current implementation. one of the main beneficial aspects of this architecture is that it allows for increasing the number of units at each stage significantly without an uncontrolled blow-up in computational complexity. the ubiquitous use of dimension reduction allows for shielding the large number of input filters of the last stage to the next layer, first reducing their dimension before convolving over them with a large patch size. another practically useful aspect of this design is that it aligns with the intuition that visual information should be processed at various scales and then aggregated so that the next stage can abstract features from different scales simultaneously. the improved use of computational resources allows for increasing both the width of each stage as well as the number of stages without getting into computational difficulties. another way to utilize the inception architecture is to create slightly inferior, but computationally cheaper versions of it. we have found that all the included the knobs and levers allow for a controlled balancing of computational resources that can result in networks that are faster than similarly performing networks with non-inception architecture, however this requires careful manual design at this point. section: googlenet we chose googlenet as our team-name in the ilsvrc14 competition. this name is an homage to yann lecun\u00e2\u0080\u0099s pioneering lenet 5 network. we also use googlenet to refer to the particular incarnation of the inception architecture used in our submission for the competition. we have also used a deeper and wider inception network, the quality of which was slightly inferior, but adding it to the ensemble seemed to improve the results marginally. we omit the details of that network, since our experiments have shown that the influence of the exact architectural parameters is relatively minor. here, the most successful particular instance (named googlenet) is described in table [reference] for demonstrational purposes. the exact same topology (trained with different sampling methods) was used for 6 out of the 7 models in our ensemble. all the convolutions, including those inside the inception modules, use rectified linear activation. the size of the receptive field in our network is taking rgb color channels with mean subtraction.\" reduce\" and\" reduce\" stands for the number of filters in the reduction layer used before the and convolutions. one can see the number of filters in the projection layer after the built-in max-pooling in the\u00e2\u0080\u009cpool proj\u00e2\u0080\u009d column. all these reduction/ projection layers use rectified linear activation as well. the network was designed with computational efficiency and practicality in mind, so that inference can be run on individual devices including even those with limited computational resources, especially with low-memory footprint. the network is 22 layers deep when counting only layers with parameters (or 27 layers if we also count pooling). the overall number of\u00e2\u0080\u009clayers\u00e2\u0080\u009d (independent building blocks) used for the construction of the network is about 100. however this number depends on the machine learning infrastructure system used. the use of average pooling before the classifier is based on, although our implementation differs in that we use an extra linear layer. this enables adapting and fine-tuning our networks for other label sets easily, but it is mostly convenience and we do not expect it to have a major effect. it was found that a move from fully connected layers to average pooling improved the top-1 accuracy by about 0.6%, however the use of dropout remained essential even after removing the fully connected layers. given the relatively large depth of the network, the ability to propagate gradients back through all the layers in an effective manner was a concern. one interesting insight is that the strong performance of relatively shallower networks on this task suggests that the features produced by the layers in the middle of the network should be very discriminative. by adding auxiliary classifiers connected to these intermediate layers, we would expect to encourage discrimination in the lower stages in the classifier, increase the gradient signal that gets propagated back, and provide additional regularization. these classifiers take the form of smaller convolutional networks put on top of the output of the inception (4a) and (4d) modules. during training, their loss gets added to the total loss of the network with a discount weight (the losses of the auxiliary classifiers were weighted by 0.3). at inference time, these auxiliary networks are discarded. the exact structure of the extra network on the side, including the auxiliary classifier, is as follows: an average pooling layer with filter size and stride, resulting in an output for the (4a), and for the (4d) stage. a convolution with 128 filters for dimension reduction and rectified linear activation. a fully connected layer with 1024 units and rectified linear activation. a dropout layer with 70% ratio of dropped outputs. a linear layer with softmax loss as the classifier (predicting the same 1000 classes as the main classifier, but removed at inference time). a schematic view of the resulting network is depicted in figure [reference]. section: training methodology our networks were trained using the distbelief distributed machine learning system using modest amount of model and data-parallelism. although we used cpu based implementation only, a rough estimate suggests that the googlenet network could be trained to convergence using few high-end gpus within a week, the main limitation being the memory usage. our training used asynchronous stochastic gradient descent with 0.9 momentum, fixed learning rate schedule (decreasing the learning rate by 4% every 8 epochs). polyak averaging was used to create the final model used at inference time. our image sampling methods have changed substantially over the months leading to the competition, and already converged models were trained on with other options, sometimes in conjunction with changed hyperparameters, like dropout and learning rate, so it is hard to give a definitive guidance to the most effective single way to train these networks. to complicate matters further, some of the models were mainly trained on smaller relative crops, others on larger ones, inspired by. still, one prescription that was verified to work very well after the competition includes sampling of various sized patches of the image whose size is distributed evenly between 8% and 100% of the image area and whose aspect ratio is chosen randomly between and. also, we found that the photometric distortions by andrew howard were useful to combat overfitting to some extent. in addition, we started to use random interpolation methods (bilinear, area, nearest neighbor and cubic, with equal probability) for resizing relatively late and in conjunction with other hyperparameter changes, so we could not tell definitely whether the final results were affected positively by their use. section: ilsvrc 2014 classification challenge setup and results the ilsvrc 2014 classification challenge involves the task of classifying the image into one of 1000 leaf-node categories in the imagenet hierarchy. there are about 1.2 million images for training, 50, 000 for validation and 100, 000 images for testing. each image is associated with one ground truth category, and performance is measured based on the highest scoring classifier predictions. two numbers are usually reported: the top-1 accuracy rate, which compares the ground truth against the first predicted class, and the top-5 error rate, which compares the ground truth against the first 5 predicted classes: an image is deemed correctly classified if the ground truth is among the top-5, regardless of its rank in them. the challenge uses the top-5 error rate for ranking purposes. we participated in the challenge with no external data used for training. in addition to the training techniques aforementioned in this paper, we adopted a set of techniques during testing to obtain a higher performance, which we elaborate below. we independently trained 7 versions of the same googlenet model (including one wider version), and performed ensemble prediction with them. these models were trained with the same initialization (even with the same initial weights, mainly because of an oversight) and learning rate policies, and they only differ in sampling methodologies and the random order in which they see input images. during testing, we adopted a more aggressive cropping approach than that of krizhevsky et al.. specifically, we resize the image to 4 scales where the shorter dimension (height or width) is 256, 288, 320 and 352 respectively, take the left, center and right square of these resized images (in the case of portrait images, we take the top, center and bottom squares). for each square, we then take the 4 corners and the center crop as well as the square resized to, and their mirrored versions. this results in crops per image. a similar approach was used by andrew howard in the previous year's entry, which we empirically verified to perform slightly worse than the proposed scheme. we note that such aggressive cropping may not be necessary in real applications, as the benefit of more crops becomes marginal after a reasonable number of crops are present (as we will show later on). the softmax probabilities are averaged over multiple crops and over all the individual classifiers to obtain the final prediction. in our experiments we analyzed alternative approaches on the validation data, such as max pooling over crops and averaging over classifiers, but they lead to inferior performance than the simple averaging. in the remainder of this paper, we analyze the multiple factors that contribute to the overall performance of the final submission. our final submission in the challenge obtains a top-5 error of 6.67% on both the validation and testing data, ranking the first among other participants. this is a 56.5% relative reduction compared to the supervision approach in 2012, and about 40% relative reduction compared to the previous year's best approach (clarifai), both of which used external data for training the classifiers. the following table shows the statistics of some of the top-performing approaches. we also analyze and report the performance of multiple testing choices, by varying the number of models and the number of crops used when predicting an image in the following table. when we use one model, we chose the one with the lowest top-1 error rate on the validation data. all numbers are reported on the validation dataset in order to not overfit to the testing data statistics. section: ilsvrc 2014 detection challenge setup and results the ilsvrc detection task is to produce bounding boxes around objects in images among 200 possible classes. detected objects count as correct if they match the class of the groundtruth and their bounding boxes overlap by at least 50% (using the jaccard index). extraneous detections count as false positives and are penalized. contrary to the classification task, each image may contain many objects or none, and their scale may vary from large to tiny. results are reported using the mean average precision (map). the approach taken by googlenet for detection is similar to the r-cnn by, but is augmented with the inception model as the region classifier. additionally, the region proposal step is improved by combining the selective search approach with multi-box predictions for higher object bounding box recall. in order to cut down the number of false positives, the superpixel size was increased by. this halves the proposals coming from the selective search algorithm. we added back 200 region proposals coming from multi-box resulting, in total, in about 60% of the proposals used by, while increasing the coverage from 92% to 93%. the overall effect of cutting the number of proposals with increased coverage is a 1% improvement of the mean average precision for the single model case. finally, we use an ensemble of 6 convnets when classifying each region which improves results from 40% to 43.9% accuracy. note that contrary to r-cnn, we did not use bounding box regression due to lack of time. we first report the top detection results and show the progress since the first edition of the detection task. compared to the 2013 result, the accuracy has almost doubled. the top performing teams all use convolutional networks. we report the official scores in table [reference] and common strategies for each team: the use of external data, ensemble models or contextual models. the external data is typically the ilsvrc12 classification data for pre-training a model that is later refined on the detection data. some teams also mention the use of the localization data. since a good portion of the localization task bounding boxes are not included in the detection dataset, one can pre-train a general bounding box regressor with this data the same way classification is used for pre-training. the googlenet entry did not use the localization data for pretraining. in table [reference], we compare results using a single model only. the top performing model is by deep insight and surprisingly only improves by 0.3 points with an ensemble of 3 models while the googlenet obtains significantly stronger results with the ensemble. section: conclusions our results seem to yield a solid evidence that approximating the expected optimal sparse structure by readily available dense building blocks is a viable method for improving neural networks for computer vision. the main advantage of this method is a significant quality gain at a modest increase of computational requirements compared to shallower and less wide networks. also note that our detection work was competitive despite of neither utilizing context nor performing bounding box regression and this fact provides further evidence of the strength of the inception architecture. although it is expected that similar quality of result can be achieved by much more expensive networks of similar depth and width, our approach yields solid evidence that moving to sparser architectures is feasible and useful idea in general. this suggest promising future work towards creating sparser and more refined structures in automated ways on the basis of. section: acknowledgements we would like to thank sanjeev arora and aditya bhaskara for fruitful discussions on. also we are indebted to the distbelief team for their support especially to rajat monga, jon shlens, alex krizhevsky, jeff dean, ilya sutskever and andrea frome. we would also like to thank to tom duerig and ning ye for their help on photometric distortions. also our work would not have been possible without the support of chuck rosenberg and hartwig adam. bibliography: references",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "deep convolutional neural network"
                    ],
                    [
                        "deep convolutional neural network architecture"
                    ],
                    [
                        "codenamed\u00e2\u0080\u009cinception\u00e2\u0080\u009d"
                    ]
                ],
                "Metric": [
                    [
                        "top-1 accuracy"
                    ],
                    [
                        "top-1 accuracy rate"
                    ],
                    [
                        "top-1 error rate"
                    ]
                ],
                "Task": [
                    [
                        "detection purposes"
                    ],
                    [
                        "detection submissions"
                    ],
                    [
                        "detection task"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "imagenet"
                    ]
                ],
                "Method": [
                    [
                        "inception module",
                        "inception model",
                        "inception",
                        "inception architecture"
                    ]
                ],
                "Metric": [
                    [
                        "top-1 accuracy",
                        "top-1 error rate"
                    ]
                ],
                "Task": [
                    [
                        "classification",
                        "classification challenge",
                        "ilsvrc12 classification data"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "imagenet"
                    ]
                ],
                "Method": [
                    [
                        "inception module",
                        "inception model",
                        "inception",
                        "inception architecture"
                    ]
                ],
                "Metric": [
                    [
                        "top-5 error rate",
                        "top-5 error"
                    ]
                ],
                "Task": [
                    [
                        "classification",
                        "classification challenge",
                        "ilsvrc12 classification data"
                    ]
                ]
            },
            {
                "Material": [],
                "Method": [
                    [
                        "inception module",
                        "inception model",
                        "inception",
                        "inception architecture"
                    ]
                ],
                "Metric": [
                    [
                        "mean average precision",
                        "map"
                    ]
                ],
                "Task": [
                    [
                        "detection",
                        "object detection"
                    ]
                ]
            }
        ]
    },
    "16051bbe3a7f7c77a952ebf76722ea655e8906ca-18": {
        "doctext": "image super-resolution via feature-augmented random forest section: abstract-recent random-forest (rf)- based image super-resolution approaches inherit some properties from dictionary-learning-based algorithms, but the effectiveness of the properties in rf is overlooked in the literature. in this paper, we present a novel feature-augmented random forest (farf) for image super-resolution, where the conventional gradient-based features are augmented with gradient magnitudes and different feature recipes are formulated on different stages in an rf. the advantages of our method are that, firstly, the dictionary-learning-based features are enhanced by adding gradient magnitudes, based on the observation that the non-linear gradient magnitude are with highly discriminative property. secondly, generalized locality-sensitive hashing (lsh) is used to replace principal component analysis (pca) for feature dimensionality reduction and original high-dimensional features are employed, instead of the compressed ones, for the leaf-nodes' regressors, since regressors can benefit from higher dimensional features. this original-compressed coupled feature sets scheme unifies the unsupervised lsh evaluation on both image super-resolution and content-based image retrieval (cbir). finally, we present a generalized weighted ridge regression (gwrr) model for the leaf-nodes' regressors. experiment results on several public benchmark datasets show that our farf method can achieve an average gain of about 0.3 db, compared to traditional rf-based methods. furthermore, a fine-tuned farf model can compare to or (in many cases) outperform some recent stateof-the-art deep-learning-based algorithms. section: introduction in the past few years, random forest (rf) [reference][reference] as a machine-learning tool, working via an ensemble of multiple decision trees, has been employed for efficient classification or regression problems, and applied to a large variety of computer-vision applications, such as object recognition [reference], face alignment [reference][reference][reference], data clustering [reference], single image super-resolution (sisr) [reference][reference], and so on. the rf method, which benefits from its simple implementation of binary trees, has been widely used, and exhibits a number of merits, including (1) it works with an ensemble of multiple decision trees to express the principle that\" two heads are better than one\", [reference] it is easy to be sped up with parallel processing technology, on both the training and inference stages, (3) it has sub-linear search complexity, because of the use of the binary tree structure, (4) the bagging strategy for feature candidates on splitnodes enable it to handle high-dimensional features and avoid over-fitting on regression, and (5) the clustering-regression scheme employs the\" divide and conquer\" strategy, which can tackle the classification and regression tasks with more stable performance. the rf-based image super-resolution approach can be considered as a clustering/ classificationbased method, as shown in fig. 1. but the clustering and regression problems in rf require with different discriminative features, which have not been systematically studied in existing literature. feature engineering has been a research hotspot for decades. several features have been proposed for learning the mapping functions from low-resolution (lr) patches to high-resolution (hr) patches on image restoration problems. pioneer work in [reference] used a simple high-pass filter as simple as subtracting a low-pass filtered values from the input image raw values. meanwhile, most algorithms [reference][reference][reference][reference][reference] follow the approach in [reference], which concatenates the first-and second-order gradients to form the features, as an inexpensive solution to approximating high-pass filtering. since rf is used as a dictionarylearning-based tool, it inherits many properties from the conventional dictionary-learning-based algorithms on feature extraction. however, the discriminative ability of those gradient-based features for random forest has been overlooked in the literature. we found, from experiments, that augmented features based on two gradient-magnitude filters can achieve more than 0.1db quality improvement in rf based sisr, with the same parameter setting. in most dictionary-learning-based algorithms, principal component analysis (pca) is used for dimensionality reduction before classification and regression processes. the impact of using pca has also been paid less attention in the literature. pca projection may damage the structure of features, which are originally discriminative for clustering at the split-nodes and regression at the leaf-nodes. motivated from content-based image retrieval (cbir) [reference][reference], where the coarse-level search uses compressed features, while the fine-level search uses augmented features. therefore, in our method, we use the original features rather than the compressed features generated by pca as worked in [reference][reference][reference][reference][reference][reference], so that more accurate regression and higher image quality improvement can be achieved. moreover, the unsupervised locality-sensitive hashing (lsh) model, instead of pca, is employed for feature dimensionality reduction, which can reduce the damage on the feature structure for the compressed features used on clustering at the split-nodes and thus improve the final image quality. for regression problems at the leaf-nodes, we propose a generalized weighted ridge regression (gwrr) as an extension of the work in [reference]. gwrr models are generated based on the data distributions from the leaf-nodes. the main contribution of our method is on feature augmentation, so we call our method featureaugmented random forest (farf). the pipeline of our farf method, which includes feature extraction, the training stage, and inference stages for sisr, is shown in fig. 1. in the farf-based image sr scheme, higher discriminative features are extracted by using the first-and second-order gradients and their magnitudes. then, the conventional pca is replaced by the generalized lsh for dimensionality reduction, and the compressed features are used for clustering in the split-nodes on an rf. finally, the respective regressors at the leaf-nodes are learned by using the original high dimensional features with the gwrr models. having introduced the main idea of our paper, the remainder of this paper is organized as follows. in section 2, we review the related works on sisr, particularly the rf-based approaches and our insights. in section 3, we introduce the proposed method farf, including the discriminative feature augmented by the gradient-magnitude filters, the generalized weighted ridge regression (gwrr) model, and the fine-tuned farf version. in section 4, we evaluate our farf scheme on public datasets, and conclusions are given in section 5. section: image super-resolution via random forest section: image super-resolution image sr attempts to achieve an impressive hr quality image from one or a set of lr images via artistic skills, which has been an active research topic for decades in the image restoration area. generalized sr includes interpolation algorithms, such as the classic bicubic interpolation, and other edge-preserving algorithms [reference][reference][reference][reference][reference]. the traditional super-resolution algorithms are based on pixel operations. intuitively, operating on a\" big pixel\", i.e. a patch [reference], is more effective. since patch-based algorithms can preserve the local texture structure of an image, various methods based on image patches, such as non-local means [reference], self-similarity [reference], manifold learning [reference], block-matching and 3d filtering (bm3d) [reference], sparse representation [reference], etc. have been proposed. the neighbor-embedding (ne) methods [reference][reference] are the milestone for patch-based dictionary learning methods. ne learns the mapping between low-and high-resolution patches, with the use of manifold learning. based on the locally linear embedding (lle) theory, an lr patch can be represented as a linear combination of its nearest neighbors in a learned dictionary, and its hr counterpart can be approximated as a linear combination of the corresponding hr patches of its lr neighbors, with the same coefficients. although the ne method is simple and sounds practical, a problem with the method is how to build a feasible patch dictionary. for example, for a patch size of 5\u00d75, with 256 gray levels, it is necessary to have a massive dataset, which has millions of patches, in order to achieve high-quality reconstructed hr patches, if the patches are collected directly from natural scene images. because of the large dictionary size, it is time consuming to search for a neighbor in such a large dataset. other method to reduce the dictionary size is to learn a relatively smaller dictionary with discrete cosine transform (dct) or wavelet fixed basis, which the adaptiveness is sacrificed. in 2010, yang et al. [reference] proposed a sparse prior for dictionary learning. using sparse coding, image representation can work with a relatively smaller dictionary while keep the adaptiveness by learning the basis from data directly, which opens the era for sparse coding in the image inverse problems. with the sparse constraint used in the sparse-coding super-resolution (scsr) framework, an lr patch and its corresponding hr patch can both be reconstructed through two learned coupled dictionaries, with the same coefficients as following: where and denote an lr patch and its hr counterpart, respectively, and d and d\u210e are the low and high-resolution coupled dictionaries trained jointly from lr and hr patch samples. the value of in\u2016\u2016\u03d1 is the sparsity factor of the coefficients.\u2016\u2016 0, called the 0-norm, is the non-zero count of the coefficients in. the lr and hr coupled dictionaries are trained jointly with a sparsity constraint, as following: an lr patch of an input lr image y can be formulated in terms of d as following: where is a feature-extraction operator on the lr patches, which aims to extract discriminative features from lr patches, rather than using the raw pixel intensity. although the 0-norm of\u03b1 is an ideal regularization term for the sparse constraint, this strong constraint leads to an np-hard problem in solving the coefficients\u03b1. yang et al. [reference] relaxed the 0-norm to 1-norm, so as to achieve a feasible solution as following: and an equivalent formulation can be achieved by using the lagrange multiplier, where the parameter balances the sparsity of the solution and the fidelity of the approximation to. as the sparse constraint in [reference] is still a bottleneck on training dictionaries considering the computation, an intuitive way to solve it is to relax the constraint again to 2-norm. meanwhile, the effectiveness of sparsity is challenged [reference][reference] by researchers as to whether sparsity or collaborative representation really helps in image classification and restoration. as a natural solution to that, timofte et al. proposed an anchored neighborhood regression (anr) [reference] framework, where there is no sparse constraint in the model. anr replaces the sparse-decomposition optimization (1-norm) with a ridge regression (i.e. 2-norm), where the coefficients can be computed offline and each coefficient can be stored as an atom (anchor) in the dictionary. this offline learning can greatly speed-up the prediction stage, and this approach has subsequently led to several variant algorithms. timofte et al. later extended the anr approach to the a+ [reference]. in a+ [reference], the coupled dictionaries are trained from a large pool of training samples (in the order of millions) rather than only from the anchoring atoms, which greatly improves the image quality. after that, more extensions based on anr and a+ have emerged [reference][reference][reference][reference][reference]. however, in the above-mentioned dictionary-learning methods, the complexity of finding those similar patches by comparing an input patch with all the dictionary items has been overlooked. recently, algorithms using random forest (rf) [reference][reference][reference] have achieved state-of-the-art performances, in terms of both accuracy and efficiency for classification and regression tasks. this is mainly due to the use of ensemble learning and sublinear search based on binary trees. schulter et al. [reference] adopted random forest and the clustering-regression scheme to learn regressors from the patches in leaf-nodes for sisr. with the same number of regressors, the rf-based algorithm can outperform or achieve comparable performance with a+ and its variants, in terms of accuracy but with less computational complexity. in recent years, deep learning has achieved promising performances on image super-resolution [reference][reference][reference][reference]. in [reference][reference], milestone works on image super-resolution based on deep learning were presented, where a convolutional neural network (srcnn) was proposed to learn an end-to-end mapping between lr and hr images for image super-resolution. later a scheme with very deep networks for sisr was proposed in [reference], where the convergence rate of the deep network is improved by using residual learning and extremely high learning rates. in addition, ledig et al. [reference] introduced a generative adversarial network (gan) based image super-resolution model (srgan), where the image perceptual loss function is reformulated as the combination of content loss and adversarial loss. although deeplearning-based approaches have achieved promising progress on sisr, the heavy computational requirement is still a large burden even though the implementation is accelerated by gpu. this may limit them from those applications without powerful gpu, such as smart mobile terminals. cluster all the feature data assigned to this node. this results in separating the three data samples (quadrangle, pentagon and hexagon) into three leaf nodes. section: image super-resolution via random forest in the inference stage, each decision tree returns a class probability (|) for a given test sample\u2208, and the final class label* is then obtained via averaging, as follows: a splitting function (;\u03b8) is typically parameterized by two values: (i) a feature dimensional index:\u03b8\uf0ce{1,...,}, and (ii) a threshold\u03b8\uf0ce\u211d. the splitting function is defined as follows: where the outcome defines to which child node is routed, and 0 and 1 are the two labels belonging to the left and right child node, respectively. each node chooses the best splitting function\u03b8* out of a randomly sampled set {\u03b8}, and the threshold\u03b8 is determined by optimizing the following function: where and are the sets of samples that are routed to the left and right child nodes, respectively, and|| represents the number of samples in the set. during the training of an rf, the decision trees are provided with a random subset of the training data (i.e. bagging), and are trained independently. training a single decision tree involves recursively splitting each node, such that the training data in the newly created child node is clustered conforming to class labels. each tree is grown until a stopping criterion is reached (e.g. the number of samples in a node is less than a threshold or the tree depth reaches a maximum value) and the class probability distributions are estimated in the leaf nodes. after fulfilling one of the stopping criteria, the density model () in each leaf node is estimated by using all the samples falling into the leaf node, which will be used as a prediction of class probabilities in the inference stage. a simple way to estimate the probability distribution function () is by averaging all the samples in the leaf node, and there are many variants, such as fitting a gaussian distribution, kernel density estimation, etc. in (9), () is the local score for a set of samples in s (s is either l or r), which is usually calculated by entropy, as shown in eqn. [reference], and it can be replaced by variance [reference][reference][reference] or by the gini index [reference]. where is the number of classes, and (|) is the probability for class, which is estimated from the set. for the regression problem, the differential entropy is used, and is defined as, where (|) denotes the conditional probability of a target variable given an input sample. assuming that (.,.) is of gaussian distribution, and has only a set of finite samples, the differential entropy can be written as, where det (\u03c3) is the determinant of the estimated covariance matrix of the target variables in. rf-based approaches hold some properties, which make them powerful classifiers as svm (support vector machine) [reference] and adaboost (short for\" adaptive boosting\") [reference]. both svm and adaboost work as to approximate the bayes decision rule-known to be the optimal classifiers-via minimizing a margin-based global loss function. rf-based image super-resolution (sr), following a recent emerging stream [reference][reference] on single-image sr, formulates the sr problem as a clustering-regression problem. these emerging approaches attempt to reconstruct an hr image from patches with the aid of an external database. these methods first decompose an image into patches, then classify the patches into different clusters, and later regressors are trained for all the clusters respectively, which generate mappings from an input lr patch's features to its corresponding hr patch. in the inference stage, an lr image follows the same procedures, such that it is divided into patches and features are extracted from each patch. then, the patches are classified into different clusters using k-nn [reference][reference] or rf [reference][reference][reference], and their super-resolved hr patches are computed through regression in the leaf nodes (see fig. 1). this kind of clustering-regression-based random forest [reference][reference][reference] methods has achieved state-of-the-art performance in sisr, both in terms of accuracy and efficiency. section: feature-augmented random forest classification and regression can be regarded as probability problems from the statistical theory. historical frequentist probability is the probability obtained from the relative frequency in a large number of trials. in contrast, the bayesian probability is an interpretation of the concept of probability, in which probability is interpreted as an expectation taking the knowledge and personal belief into account. from the bayesian theory, the posterior probability of a random event is a conditional probability, which can be calculated if the relevant evidence or context is considered. therefore, the posterior probability is the probability (|) of the parameters given the evidence. we denote the probability distribution function of the prior for parameters as (), and the likelihood as (|), which is the probability of given. then, based on the bayesian rule, the posterior probability can be defined as follows: the posterior probability can be denoted in a memorable form as: based on the bayesian framework, the likelihood term and the prior term are both required to be determined in order to solve the inverse problems, and the extracted features are normally worked as prior or likelihood, particularly on some image restoration problems. from this point of view, most research works, from classic feature extractors to deep-learning neural networks, are essentially done under the bayesian inference framework. since sisr is a well-known ill-posed problem, researchers have put their efforts into the priors of the problem with skills from mathematics, computer vision and machine learning. one of the obvious and most studied priors is the edge prior, which can be found in many pioneering works: new edgedirected interpolation (nedi) [reference], soft-decision adaptive interpolation (sai) [reference], directional filtering and data-fusion (dfdf) [reference], modified edge-directed interpolation (medi) [reference], and so on. the edge prior is effective on image processing, and the first and second-order gradients are studied and employed by yang et al. [reference] in a pioneering dictionary-learning-based algorithm. however, the effect of edgebased features has not been investigated in depth. for the clustering and classification problems, feature engineering is a critical research point, and in some cases, the chosen feature may dominate the performance. as shown in eqn. (6), a feature filter, whose coefficients are computed to fit the most relevant parts in the lr image patches, is employed, and the generated features can achieve more accurate predictions for reconstructing their counterpart hr image patches, as shown in fig. 3. section: augmented features via gradient magnitude filters normally it is unstable to directly use pixel intensities as features, which are susceptible to the environmental lighting variations and camera noise. instead, the differences between the neighboring pixels' intensity values, which are computationally efficient, and are immune to lighting changes and noise, are examined. this type of features can be implemented efficiently through convolutional filters. typically, the feature filter can be chosen as a high-pass filter, while in [reference][reference][reference][reference], the first and second-order gradient operators are used to generate an up-sampled version from a low-resolution image, then four patches are extracted from the gradient maps at each location, and finally the patches are concatenated to form feature vectors. the four 1-d filters used to extract the derivatives are described in eqn. (14), these features can work well on dictionary-learning-based methods, because when searching a matched patch in a dictionary, the distance is calculated based on the whole feature vectors with the euclidean distance. however, when training a split node in a decision tree of an rf, only one or a few of the feature dimensions are chosen as candidate features for comparison. therefore, more discriminative features are required for rf, when compared with dictionary-learning-based methods. the first and second-order gradients of an image can provide the directions of edges in a perceptual manner as shown in fig. 4 and fig. 5, which can be calculated as eqn. (15), where/ and/ are the gradients in the x-axis and y-axis directions, respectively, at a given pixel. meanwhile, the gradient magnitude image can provide the edge strength, as described in eqn. [reference]. fig. 4 shows a toy example of a man-made\" circle\" image, to demonstrate its discriminative property. with a natural image shown in fig. 5, it can be observed that the gradient magnitude image has more detailed textures than the gradient images (/ and/), as well as the sum of the horizontal gradient and vertical gradient image, i.e./+/, perceptually. an explanation for this phenomenon is that non-linear features are usually more discriminative. thus, in our work, all the first and second-order gradients, and gradient magnitude are employed, and are concatenated to form more discriminative, augmented features. on the other hand, the image orientation (gradient angle) is defined by the following formulation, where atan () is the gradient orientation, with a value between-90\uf0b0 and 90\uf0b0. as shown in eqn. (17), when the value of is equal to 0 or close to 0, the value of\u2220\u2207 becomes infinitely large and unstable, i.e., different will result in approximately the same\u2220\u2207 value. based on this analysis, we only use the two gradient magnitude filters derived from the four gradient filters [reference] to generate the augmented features. experiments validate that the use of the augmented features can improve the conventional rf algorithm [reference] to achieve a performance gain of more than 0.1db, which is a remarkable improvement, with the same setting and parameters. section: fine-grained features for regression the inference stage of the rf-based image super-resolution process is similar to the content-based image retrieval (cbir) framework, as shown in fig. 1. the general approximated nearest neighbor (ann) search framework [reference][reference] is an efficient strategy for large-scale image retrieval, which mainly consists of 4 parts: (1) extracting compact features (e.g., locality-sensitive hashing (lsh) [reference] feature) for a query image; (2) coarse-level search using hamming distance to measure the similarity between binary compact hash features, then narrow the search scope into a smaller candidate group; (3) fine-level search by using euclidean distance to measure the similarity between their corresponding feature vectors; and (4) finding the object in the smaller candidate group that is the nearest one to the query image. in the inference stage of conventional rf-based sisr, pca projection is worked as a hash-like function to compress the feature dimension for decreasing the search range, which can speed up the searching as the coarse-level search in a cbir framework, but the impact of using pca on feature dimensionality reduction has been overlooked in previous works [reference][reference][reference][reference][reference][reference]. inspired by the finelevel search using augmented features in cbir frameworks, the high dimensional features in the leaf nodes in an rf can further improve the prediction accuracy in the regression step, which has not been studied previously. consequently, we use the original features, rather than pca or the lsh compressed features, to perform ridge regression in the leaf nodes. experimental results show that the new rf scheme can greatly improve the quality of super-resolved images, by using this augmented feature. another explanation for this is that the regression problems can benefit more from higher dimensional features than classification problems. based on the observation that the original edge-like features are used for the final regressors in the leaf nodes and the compressed features (either produced by pca or lsh) are used for clustering in the split nodes, a new clustering-regression-based sisr approach can be designed as shown in fig. 6. in this new scheme, the original-compressed coupled feature sets are worked for different purposes at different stages, i.e., the original edge features are used for regression in the leaf nodes, and the compressed features derived from the lsh-like functions are employed for node splitting (clustering) in the training stage, and node searching in the inference stage in the split nodes. section: fig. 6: augmented features for regressors and the lsh compressed features for searching in a random forest in the new scheme, we unify the research of lsh-based sisr and image retrieval (cbir) [reference][reference]. in brief, the new achievement on unsupervised lsh can be evaluated not only in cbir systems, but also in the clustering-regression rf-based sisr methods. moreover, as evidence from [reference], proper unsupervised lsh models, e.g., iterative quantization (itq) [reference] used for feature dimension reduction instead of pca, can reduce the damage on the image structure. this can further improve the superresolved image quality. different from [reference] using an itq-like algorithm to rotate the original features into a new feature space, with the use of the proposed original-compressed coupled feature sets, any unsupervised lsh generated features can directly be employed. section: generalized weighted ridge regression model in this sub-section, we further analyze the ridge regression employed in the rf leaf nodes. the anchored neighborhood regression (anr) [reference] model relaxes the 1-norm in eqn. (6) to the 2-norm constraint, with least-squares minimization as the following equation, based on the ridge regression [reference] theory, this 2-norm constrained least square regression regularized problem has a closed-form solution, according to the tikhonov regularization theory, as follows: with the assumption in [reference], where hr patches and their counterpart lr patches share the same reconstructed coefficient\u03b1, i.e.= d\u210e, from eqn. [reference] we have if we define as a pre-calculated projection matrix, as follows, then the hr patches can be reconstructed with=. having studied the model in eqn. (18), the authors in [reference] argued that different weights should be given to different atoms when reconstructing an hr patch so as to emphasize the similarity to the anchor atom. based on this idea, [reference] proposed a weighted collaborative representation (wcr) model by generalizing the normal collaborative representation (cr) model in the anr, where is a diagonal weight matrix, in which the non-zero entries are proportional to the similarities between the atoms and the anchor atom. same as the anr model, a new closed-form solution can be computed offline through the following and the new projection matrix can be derived as the wcr model further improves the anr/ a+ model in terms of image quality, while keeping the same level of computation. in [reference], the local geometry prior of the data sub-space is used. however, all the weighted ridge regression models [reference][reference] are constructed based on an existing dictionary, e.g., zeyde et al. [reference] used k-svd to train a sparse-coding-based dictionary with 1024 items. this limits the models to collect samples in a smaller sub-space when constructing linear regressors based on existing anchor points. section: fig. 7: gaussian mixture model (gmm) is used to generate the weights for weighted ridge regression, and the weight of each entry lies on its belonging cluster's weight and its weight in the belonging cluster. when training the regressors in an rf, there is no existing anchor point in the clustered groups of the leaf nodes, similar to the previous models [reference][reference]. a solution to mentioned problem is inspired from the work on image classification using locality-constrained linear coding (llc) [reference], where gaussian mixture model (gmm) is used to describe the locality-constrained affine subspace coding (lasc) [reference]. we employ gmm to construct the data distribution in the sub-space for each leaf node, which derives the weights of all the entries in the ridge regression models. through the derived weights, we can obtain a generalized weighted ridge regression (gwrr) model for ridge regression. the new projection matrix is given as follows: where is a diagonal weight matrix, and the weight of each diagonal entry is related to its belonging cluster's weight and its local weight in its belongingwhi cluster, as illustrated in the right part of fig. 7. obviously, a query entry falling into a bigger cluster and closer to the center of the belonging cluster achieves a larger weight. in a rough form, the diagonal weight matrix is given as follows: where is the weight of the th entry, is number of samples in the leaf nodes, is the th cluster's weight for the th entry, is the th entry's local weight in the th cluster, which is approximated with the inverse value of the distance to the center of the belonging cluster, and is the number of clusters generated by the gmm model for a leaf node. experimental results in table-1 show that the proposed gwrr model can achieve the same level of performance as wcr [reference], and obtain 0.2db gain more than the anr [1] model. note that when the number of samples in a leaf node becomes bigger, the performance of the gwrr model will achieve less advantage than the normal regression model, because the higher weights will be averaged by a large number of other samples. theoretically, the regression of a leaf node can benefit from the gwrr model, particularly when there are a few samples falling into the leaf node. section: initial estimation with iterative back projection generally speaking, sisr is a low-level computer vision task, which attempts to restore an hr image from a single input lr image. a mathematical model for image degradation can be formulated as follows: where\u212c is a low-pass (blur) filter and\uf069 denotes the down-sampling operator with factor. based on a given lr image, how to achieve an approximated hr image\u0302 is a classic inverse problem, which requires priors based on the bayesian theory. irani and peleg [reference] firstly proposed an iterative back projection (ibp) method for sr reconstruction, and ibp is the most effective way to obtain an hr image when comparing it with other sr methods. in the ibp method, the reconstruction error of an estimated lr image\u0302 is the difference between the input lr and the synthesized image\u0302 generated from the estimated hr image\u0302 as follows: ibp is an efficient approach to obtain the hr image by minimizing the reconstruction error defined by eqn. [reference]. for the ibp approach on sisr, the updating procedure can be summarized as the following two steps, performed iteratively:\u2022 compute the reconstruction error (\u0302) with the following equation: where\u2191 is the up-sampling operator and is a constant back-projection kernel to approximate the inverse operation of the low-pass filter\u212c.\u2022 update the estimating hr image\u0302 by back-projecting errors as follows: where\u0302 is the estimated hr image at the-th iteration. most learning-based algorithms [reference][reference][reference][reference] follow the milestone work in [reference], which uses the coarse estimation firstly obtained via bicubic interpolation. as we know, the classic ibp algorithm is an efficient way to obtain high-quality up-scaled images, but it will inevitably produce artifacts (such as ringing, jaggy effects, and noise) at the output, because the kernel operator in eqn. (29) is hard to estimate accurately. that is the reason why algorithms with ibp need an additional denoising process [reference][reference][reference]. however, the sparse-constraint-based approach [reference] does not have this denoising capability. as the 2-norm constraint-based ridge regression has the denoising effect, due to its averaging-like process, this means that the ridge regression-based rf scheme has the denoise capability intrinsically. based on this observation, we obtain the coarse estimation of an hr image\u0302 by applying ibp to the corresponding input lr image. experimental results in table-2 and table-3 validate that using ibp, instead of bicubic, to obtain the initial coarse estimation can help the rf-based sr method obtain a remarkable improvement. as the number of trees is an important parameter in rf-based approaches, we plot the performance with respect to the number of trees. as shown in fig. 8, the performance of the rf-based image superresolution method increases as expected, but the increment becomes relatively smaller after a certain number of trees are used. the experimental results in fig. 8 section: fine-tuning with proper trees in random forest section: psnr section: set14 million samples from the dataset are used for all training stages. it shows that using 45 trees is an optimal number, as a trade-off between performance and computational cost. therefore, we set the number of trees for the proposed farf method at 45, and our method with this number is denoted as farf*. the performances of our methods, and other methods, are tabulated in table-2 and table-3. we also compare our methods with a recently proposed deep-learning-based algorithm, srcnn algorithm [reference][reference], and our methods outperform it in some cases. section: algorithm workflow the training and inference stages of the proposed farf algorithm are described in algorithm 1 and algorithm 2, respectively. to help the readers understand our paper, the source code of our algorithm will be available at: https:// github.com/ harleyhk/ farf, for reference. section: experiments in this section, we evaluate our algorithm on standard super-resolution benchmarks set 5, set14 and b100 [reference], and compare it with some state-of-the-art methods. they are bicubic interpolation, adjusted anchored neighborhood regression (a+) [reference], standard rf [reference], alternating regression forests (arf) [reference], and the convolutional neural-network-based image super-resolution (srcnn) [reference][reference], as listed in table-2 and table-table-2: results of the proposed method compared with state-of-the-art works on 3 datasets in terms of psnr (db) using three different magnification factors (#) (\u00d72,\u00d73,\u00d74). table-2 summarizes the performances of our proposed algorithm on the 3 datasets, in terms of the average peak signal to noise ratio (psnr) scores, with different magnification factors (\u00d72,\u00d73,\u00d74). the objective quality metric, psnr, in table-2 also shows that the fine-tuned farf, i.e. farf*, can further improve the image quality, which is comparable to recently proposed state-of-the-art deeplearning-based algorithms, such as srcnn [reference][reference]. comparing our proposed farf algorithm to other methods, the improved visual quality of our results is obvious, as shown in fig. 9. this shows that our method can produce more details, particularly on some texture-rich regions. fig. 9: super-resolution (\u00d73) images from b100, bicubic, a+ (accv-2014) [reference], arf (cvpr-2015) [reference], srcnn (pami-2016) [reference], our proposed algorithm farf, and ground truth. the results show that our farf algorithm can produce more details and its performance is comparable to a recent state-of-the-art deep-learning method [reference]. section: conclusions this paper presents a feature-augmented random forest (farf) scheme for the single image superresolution (sisr) task by augmenting features and redesigning the inner structure of a random forest (rf), with different feature recipes at different stages, where the compressed features are used for clustering in the split nodes and the original features are used for regression in the leaf nodes. the contributions of this paper are threefold: (1) the more discriminative gradient magnitude-based augmented features are proposed for clustering on split nodes and regression on leaf nodes; (2) by extending principal component analysis (pca) to a generalized unsupervised locality-sensitive hashing (lsh) model for dimensionality reduction, we lay out an original compressed coupled feature set for tackling the clustering-regression tasks, which unify sisr and content-based image retrieval (cbir) for lsh evaluation; and (3) we have extended wcr model to a generalized gwrr model for ridge regression. the proposed fafr scheme can achieve highly competitive quality results, e.g., obtaining about a 0.3db gain in psnr, on average, when compared to conventional rf-based super-resolution approaches. furthermore, a fine-tuned version of our proposed farf approach is provided, whose performance is comparable to recent state-of-the-art deep-learning-based algorithms. section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "set14"
                    ],
                    [
                        "b100"
                    ]
                ],
                "Method": [
                    [
                        "augmented random forest"
                    ],
                    [
                        "farf"
                    ],
                    [
                        "gwrr"
                    ]
                ],
                "Metric": [
                    [
                        "average gain"
                    ]
                ],
                "Task": [
                    [
                        "image super resolution"
                    ],
                    [
                        "super resolution"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "b100"
                    ]
                ],
                "Method": [
                    [
                        "fafr scheme"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "average peak signal to noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "single image super-resolution",
                        "sisr",
                        "image super-resolution model",
                        "srgan",
                        "rf-based image super-resolution",
                        "sr",
                        "rf-based sisr",
                        "super-resolved images",
                        "super-resolution",
                        "single image superresolution"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set14"
                    ]
                ],
                "Method": [
                    [
                        "fafr scheme"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "average peak signal to noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "single image super-resolution",
                        "sisr",
                        "image super-resolution model",
                        "srgan",
                        "rf-based image super-resolution",
                        "sr",
                        "rf-based sisr",
                        "super-resolved images",
                        "super-resolution",
                        "single image superresolution"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set 5"
                    ]
                ],
                "Method": [
                    [
                        "feature-augmented random forest",
                        "farf",
                        "featureaugmented random forest",
                        "farf*.",
                        "farf algorithm"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "average peak signal to noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "single image super-resolution",
                        "sisr",
                        "image super-resolution model",
                        "srgan",
                        "rf-based image super-resolution",
                        "sr",
                        "rf-based sisr",
                        "super-resolved images",
                        "super-resolution",
                        "single image superresolution"
                    ]
                ]
            }
        ]
    },
    "160563abbd75265b19afc8b4169bab9e1eb33d97-19": {
        "doctext": "document: massively multilingual sentence embeddings for zero-shot cross-lingual transfer and beyond we introduce an architecture to learn joint multilingual sentence representations for 93 languages, belonging to more than 30 different language families and written in 28 different scripts. our system uses a single bilstm encoder with a shared bpe vocabulary for all languages, which is coupled with an auxiliary decoder and trained on publicly available parallel corpora. this enables us to learn a classifier on top of the resulting sentence embeddings using english annotated data only, and transfer it to any of the 93 languages without any modification. our approach sets a new state-of-the-art on zero-shot cross-lingual natural language inference for all the 14 languages in the xnli dataset but one. we also achieve very competitive results in cross-lingual document classification (mldoc dataset). our sentence embeddings are also strong at parallel corpus mining, establishing a new state-of-the-art in the bucc shared task for 3 of its 4 language pairs. finally, we introduce a new test set of aligned sentences in 122 languages based on the tatoeba corpus, and show that our sentence embeddings obtain strong results in multilingual similarity search even for low-resource languages. our pytorch implementation, pre-trained encoder and the multilingual test set will be freely available. section: introduction while the recent advent of deep learning has led to impressive progress in natural language processing (nlp), these techniques are known to be particularly data hungry, limiting their applicability in many practical scenarios. an increasingly popular approach to alleviate this issue is to first learn general language representations on unlabeled data, which are then integrated in task-specific downstream systems. this approach was first popularized by word embeddings mikolov2013distributed, pennington2014glove, but has recently been superseded by sentence-level representations alexis:2017:emnlp, peters:2018:naacl_elmo, devlin:2018:arxiv_bert. nevertheless, all these works learn a separate model for each language and are thus unable to leverage information across different languages, greatly limiting their potential performance for low-resource languages. in this work, we are interested in universal language agnostic sentence embeddings, that is, vector representations of sentences that are general with respect to two dimensions: the input language and the nlp task. the motivations for such a representation are multiple: the hope that languages with limited resources benefit from joint training over many languages, the desire to perform zero-shot transfer of an nlp model from one language (e.g. english) to another, and the possibility to handle code-switching. we achieve this by using a single encoder that can handle multiple languages, so that semantically similar sentences in different languages are close in the resulting embedding space. most research in multilingual nlp focuses on high-resource languages like chinese, arabic or major european languages, and is usually limited to a few (most often only two) languages. in contrast, we learn joint sentence representations for 93 different languages, including under-resourced and minority languages (see tables [reference] and [reference]). our system is trained on freely available parallel texts only. the contributions of this paper are as follows: we substantially improve on previous work to learn joint multilingual sentence representations. we learn one shared encoder that can handle 93 different languages. all languages are jointly embedded in a shared space, in contrast to most other works which usually consider separate english/ foreign alignments. we cover 34 language families and 28 different scripts. we outperform the state-of-the-art on zero-shot cross-lingual natural language inference (xnli dataset) and classification (mldoc dataset), bitext mining (bucc dataset) and multilingual similarity search (tatoeba dataset), for almost all considered languages. these results were obtained with a single pre-trained bilstm encoder for all 93 languages and tasks, without any fine-tuning. we define a new test set based on the freely available tatoeba corpus and provide baseline results for 122 languages. we report accuracy for multilingual similarity search on this test set, but the corpus could also be used for mt evaluation. the remaining of this paper is organized as follows. in the next section, we first summarize related work. section [reference] then describe our approach in detail. all experimental results are given in sections [reference] and [reference], and the paper concludes with a discussion and directions for future research. dataset details and additional result analysis can be found in the appendix. section: related work following the success of word embeddings mikolov2013distributed, pennington2014glove, there has been an increasing interest in learning continuous vector representations of longer linguistic units like sentences. these sentence embeddings are commonly obtained using a recurrent neural network (rnn) encoder, which is typically trained in an unsupervised way over large collections of unlabelled corpora. for instance, the skip-thought model of couple the encoder with an auxiliary decoder, and train the entire system end-to-end to predict the surrounding sentences over a large collection of books. it was later shown that more competitive results could be obtained by training the encoder over labeled natural language inference (nli) data alexis:2017:emnlp. this was recently extended to multitask learning, combining different training objectives like that of skip-thought, nli and machine translation google:2018:arxiv_srep, mlia-msr:2018:iclr_srep. while the previous methods consider a single language at a time, multilingual representations have attracted a large attention in recent times. most of this research focuses on cross-lingual word embeddings ruder2017survey, which are commonly learned jointly from parallel corpora gouws2015bilbowa, luong2015bilingual. an alternative approach that is becoming increasingly popular is to train word embeddings independently for each language over monolingual corpora, and then map them to a shared space based on a bilingual dictionary mikolov2013exploiting, artetxe2018generalizing or even in a fully unsupervised manner. cross-lingual word embeddings are often used to build bag-of-word representations of longer linguistic units by taking their respective centroid. while this approach has the advantage of requiring a weak (or even no) cross-lingual signal, it has been shown that the resulting sentence embeddings works rather poorly in practical cross-lingual transfer settings conneau:2018:emnlp_xnli. a more competitive approach that we follow here is to use a sequence-to-sequence encoder-decoder architecture schwenk:2017:repl4nlp, hassan2018achieving. the full system is trained end-to-end on parallel corpora akin to neural machine translation: the encoder maps the source sequence into a fixed-length vector representation, which is used by the decoder to create the target sequence. this decoder is then discarded, and the encoder is kept to embed sentences in any of the training languages. while some proposals use a separate encoder for each language schwenk:2017:repl4nlp, sharing a single encoder for all languages also gives strong results schwenk:2018:acl_mine. nevertheless, most existing work is either limited to few, rather close languages or, more commonly, consider pairwise joint embeddings with english and one foreign language only. to the best of our knowledge, all existing work on learning multilingual representations for a large number of languages is limited to word embeddings ammar2016massively, ours being the first paper exploring massively multilingual sentence representations. finally, while all the previous approaches learn a fixed-length representation for each sentence, a recent research line has obtained very strong results using variable-length representations instead, consisting of contextualized embeddings of the words in the sentence peters:2018:naacl_elmo, howard2018universal, devlin:2018:arxiv_bert. for that purpose, these methods train either an rnn or self-attentional encoder over unnanotated corpora using some form of language modeling. a classifier can then be learned on top of the resulting encoder, which is commonly further fine-tuned during this supervised training. despite the strong performance of these approaches in monolingual settings, we argue that fixed-length approaches provide a more generic, flexible and compatible representation form for our multilingual scenario, and our model indeed outperforms the multilingual bert model devlin:2018:arxiv_bert in zero-shot transfer (see section [reference]). section: proposed method we use a single, language agnostic bilstm encoder to build our sentence embeddings, which is coupled with an auxiliary decoder and trained over parallel corpora. from section [reference] to [reference], we describe its architecture, our training strategy to scale to up to 93 languages, and the training data used for that purpose. subsection: architecture figure [reference] illustrates the architecture of the proposed system, which is based on schwenk:2018:acl_mine. as it can be seen, sentence embeddings are obtained by applying a max-pooling operation over the output of a bilstm encoder. these sentence embeddings are used to initialize the decoder lstm through a linear transformation, and are also concatenated to its input embeddings at every time step. note that there is no other connection between the encoder and the decoder, as we want all relevant information of the input sequence to be captured by the sentence embedding. we use a single encoder and decoder in our system, which are shared by all languages involved. for that purpose, we build a joint byte-pair encoding (bpe) vocabulary with 50k operations, which is learned on the concatenation of all training corpora. this way, the encoder has no explicit signal on what the input language is, encouraging it to learn language independent representations. in contrast, the decoder takes a language id embedding that specifies the language to generate, which is concatenated to the input and sentence embeddings at every time step. scaling up to almost hundred languages, which use very different syntax, writing scripts and linguistic concepts, naturally calls for an encoder with sufficient capacity. in this paper, we limit our study to a stacked bilstm with 1 to 5 layers, each 512-dimensional. the resulting sentence representations (after concatenating both directions) are 1024 dimensional. the decoder has always one layer of dimension 2048. the input embedding size is set to 320, while the language id embedding has 32 dimensions. training [- 1pt] corpus [- 2pt] size tatoeba [- 1pt] test set [- 2pt] size training [- 1pt] corpus [- 2pt] size tatoeba [- 1pt] test set [- 2pt] size subsection: training strategies in preceding work, each sentence at the input was jointly translated into all other languages. while this approach was shown to learn high-quality representations, it poses two obvious drawbacks when trying to scale to a large number of languages. first, it requires an n-way parallel corpus, which is difficult to obtain for all languages. second, it has a quadratic cost with respect to the number of languages, making training prohibitively slow as the number of languages is increased. in our preliminary experiments, we observed that similar results can be obtained by using less target languages- two seem to be enough. at the same time, we relax the requirement for n-way parallel corpora by considering independent alignments with the two target languages, e.g. we do not require each source sentence to be translated into the two target languages. training minimizes the cross-entropy loss on the training corpus, alternating over all combinations of the languages involved. for that purpose, we use adam with a constant learning rate of 0.001 and dropout set to 0.1, and train for a fixed number of epochs. our implementation is based on fairseq, and we make use of its multi-gpu support to train on 16 nvidia v100 gpus with a total batch size of 128, 000 tokens. unless otherwise specified, we train our model for 17 epochs, which takes about 5 days. stopping training early decreases the overall performance only slightly. subsection: training data and pre-processing as described in section [reference], training requires bitexts aligned with two target languages. we choose english and spanish for that purpose, as most of the data is aligned with these languages. we collect training corpora for 93 input languages by combining the europarl, united nations, opensubtitles2018, global voices, tanzil and tatoeba corpus, which are all publicly available on the opus website. appendix [reference] provides a more detailed description of this training data, while tables [reference] and [reference] summarize the list of all languages used for training, their language family, writing script and the size of the bitexts. our training data comprises a total of 223 million parallel sentences. in preliminary experiments, we observed that the domain of the training data played a key role in the performance of our sentence embeddings in different tasks. some tasks (bucc, mldoc) tend to perform better when the encoder is trained on long and formal sentences, whereas other tasks (xnli, tatoeba) benefit from training on shorter and more informal sentences. in an attempt to achieve a general purpose sentence encoder that performs well on all tasks, we aimed at balancing the size of training corpora with long and short sentences. for that purpose, we used at most two million sentences from opensubtitles, although more data is available for some languages. all pre-processing is done with moses tools: punctuation normalization, removing non-printing characters and tokenization. as the only exception, chinese and japanese texts were segmented with jieba and mecab, respectively. all the languages are kept in their original script with the exception of greek, which we romanize into the latin alphabet. section: experimental evaluation in contrast with the well-established evaluation frameworks for english sentence representations, there is not yet a commonly accepted standard to evaluate multilingual sentence embeddings. the most notable effort in this regard is probably the xnli corpus, an nli test set similar to multinli for which the premises and hypotheses were translated into 14 languages by professional translators. we train an nli classifier on top of our multilingual sentence embedding using english training data, and evaluate its zero-shot transfer performance in the remaining languages (section [reference]). so as to obtain a more complete picture of the behavior of our multilingual sentence representations, we also evaluate them in cross-lingual document classification (mldoc, section [reference]), and bitext mining (bucc, section [reference]). however, all these datasets only cover a subset of our 93 languages, so we also introduce a new test set for multilingual similarity search in 122 languages, including several languages for which we have no training data but whose language family is covered (section [reference]). we remark that we use the same pre-trained bilstm encoder for all tasks and languages without any fine-tuning. subsection: xnli: cross-lingual nli nli has become a widely used task to evaluate sentence representations snli:2015, multinli:2017. given two sentences, a premise and a hypothesis, the task consists in deciding whether there is an entailment, contradiction or neutral relationship between them. xnli is a recent effort to create a dataset similar to the english multinli for several languages. 2, 500 development and 5, 000 test sentences have been translated from english into 14 languages by professional translators, making results across different languages directly comparable. note that no human translated training data is provided; instead, different systems are to use english training data from multinli, and their transfer performance is evaluated on the rest of languages. we train a classifier on top of our multilingual encoder using the usual combination of the two sentence embeddings:, where and are the premise and hypothesis. for that purpose, we use a feed-forward neural network with two hidden layers of size 512 and 384, trained with adam. all hyperparameters were optimized on the english xnli development corpus, and then, the same classifier was applied to all languages of the xnli test set. as such, we did not use any training or development data in any of the foreign languages. note, moreover, that the multilingual sentence embeddings are fixed and not fine-tuned on the task or the language. we report our results in table [reference], along with several baselines from conneau:2018:emnlp_xnli and the recently released multilingual bert model devlin:2018:arxiv_bert. as it can be seen, our proposed method establishes a new state-of-the-art in zero-shot cross-lingual transfer (i.e. training a classifier on english data and applying it to all other languages) for all languages but spanish. our transfer results are strong and homogeneous across all languages: for 11 of them, the zero-short performance is (at most) 5% lower than the one on english, including distant languages like arabic, chinese and vietnamese, and we also achieve remarkable good results on low-resource languages like swahili. in contrast, bert achieves excellent results on english, outperforming our system by 7.5 points, but its zero-shot cross-lingual transfer performance is much weaker. for instance, the loss in accuracy for both arabic and chinese is 2.5 points for our system, compared to 19.3 and 17.6 points for bert. finally, we also outperform all baselines of conneau:2018:emnlp_xnli by a substantial margin, with the additional advantage that we use a single pre-trained encoder, whereas x-bilstm learns a separate encoder for each language by aligning it to the english one. for completeness, we also provide results that include the use of machine translation (mt). this can be done in two ways: 1) translate the test data into english and apply the english nli classifier, or 2) translate the english training data and train a language specific nli classifier for each language. it should be stressed that we are not evaluating multilingual sentence embeddings anymore, but rather the quality of the mt system and a monolingual model. moreover, the use of mt incurs in an important overhead with either strategy: translating test makes inference substantially more expensive, whereas translating train results in a separate model for each language. as shown in table [reference], our approach outperforms all translation baselines of conneau:2018:emnlp_xnli with the exception of urdu. we also outperform mt bert for arabic and thai, and are very close for urdu. finally, it is worth mentioning that, thanks to its multilingual nature, our system can also handle premises and hypothesis in different languages. as reported in appendix [reference], the proposed method obtains very strong results in these settings, even for distant language combinations like french-chinese. subsection: mldoc: cross-lingual classification cross-lingual document classification is a typical application of multilingual representations. in order to evaluate our sentence embeddings in this task, we use the mldoc dataset of schwenk:2018:lrec_mldoc, which is an improved version of the reuters benchmark lewis: reuters:2004, with uniform class priors and a wider language coverage. there are 1, 000 training and development documents and 4, 000 test documents for each language, divided in 4 different genders. just as with the xnli evaluation, we consider the zero-shot transfer scenario: we train a classifier on top of our multilingual encoder using the english training data, optimizing hyper-parameters on the english development set, and evaluating the resulting system in the remaining languages. we use a feed-forward neural network with one hidden layer of 10 units. as shown in table [reference], our system obtains the best published results for 5 of the 7 transfer languages. we believe that our weaker performance on japanese can be attributed to the domain and sentence length mismatch between mldoc and the parallel corpus we use for this language (opensubtitles). subsection: bucc: bitext mining bitext mining is another natural application for multilingual sentence embeddings. given two comparable corpora in different languages, the task consists in identifying sentence pairs that are translations of each other. for that purpose, one would commonly score sentence pairs by taking the cosine similarity of their respective embeddings, so parallel sentences can be extracted through nearest neighbor retrieval and filtered by setting a fixed threshold over this cosine score schwenk:2018:acl_mine. however, it was recently shown that this approach suffers from scale inconsistency issues guo2018effective, and artetxe2018margin proposed the following alternative score addressing it: where and are the source and target sentences, and denotes the nearest neighbors of in the other language. the paper explores different margin functions, with ratio () yielding the best results. this notion of margin is related to csls as proposed in conneau:2018:iclr_muse. the reader is referred to artetxe2018margin for a detailed discussion. we use this method to evaluate our sentence embeddings on the bucc mining task zweigenbaum2017overview, zweigenbaum2018overview, using exact same hyper-parameters as artetxe2018margin. the goal is to extract parallel sentences from a comparable corpus between english and four foreign languages: german, french, russian and chinese. the dataset consists of 150 k to 1.2 m sentences for each language, split into a sample, training and test set, with about 2-3% of the sentences being parallel. as shown in our results in table [reference], our sentence embeddings establish a new state-of-the-art for all language pairs with the exception of english-chinese test. quite remarkably, we also outperform artetxe2018margin themselves, who use two separate models covering 4 languages each (english/ french/ spanish/ german and english/ french/ russian/ chinese). the average performance over the four languages increased from 93.27 to 93.92. not only are our results better, but our model also covers many more languages, so it can potentially be used to mine bitext for any combination of the 93 languages supported. subsection: tatoeba: similarity search while xnli, mldoc and bucc are well established benchmarks with comparative results available, they only cover a small subset of our 93 languages. so as to better assess the performance of our model in all these different languages, we introduce a new test set of similarity search for 122 languages based on the tatoeba corpus. the dataset consists of up to 1, 000 english-aligned sentence pairs for each language. appendix [reference] describes how the dataset was constructed in more details. evaluation is done by finding the nearest neighbor for each sentence in the other language according to cosine similarity and computing the error rate. we report our results in tables [reference] and [reference]. contrasting these results with those of xnli, one would assume that similarity error rates below 5% are indicative of strong downstream performance. this is the case for 37 languages, while there are 48 languages with an error rate below 10% and 55 with less than 20%, covering 22 different families and 15 different scripts. there are only 15 languages with error rates above 50%. we believe that our competitive results for many low-resource languages are indicative of the benefits of joint training, which is also supported by our ablation results in section [reference]. in relation to that, appendix [reference] reports similarity search results for 29 additional languages without any training data, showing that our encoder can also generalize to unseen languages to some extent as long as it was trained in related languages. section: ablation experiments in this section, we explore different variants of our approach and study the impact on the performance for all our evaluation tasks. we report average results across all languages. for xnli, we also report the accuracy on english. subsection: encoder depth table [reference] reports the performance on the different tasks for encoders with one, three or five layers. we were not able to achieve good convergence with deeper models. it can be seen that all tasks benefit from deeper models, in particular xnli and tatoeba, suggesting that a single layer bilstm has not enough capacity to encode so many languages. subsection: multitask learning multitask learning has been shown to be helpful to learn english sentence embeddings. the most important task in this approach is arguably nli, so we explored adding an additional nli objective to our system with different weighting schemes. as shown in table [reference], the nli objective leads to a better performance on the english nli test set, but this comes at the cost of a worse cross-lingual transfer performance in xnli and tatoeba. the effect in bucc is negligible. subsection: number of training languages so as to better understand how our architecture scales to a large amount of languages, we train a separate model on a subset of 18 evaluation languages, and compare it to our main model trained on 93 languages. we replaced the tatoeba corpus with the wmt 2014 test set to evaluate the multilingual similarity error rate. this covers english, czech, french, german and spanish, so results between both models are directly comparable. as shown in table [reference], the full model equals or outperforms the one covering the evaluation languages only for all tasks but mldoc. this suggests that the joint training also yields to overall better representations. section: conclusions in this paper, we propose an architecture to learn multilingual sentence embeddings for 93 languages. we use a single language-agnostic bilstm encoder for all languages, which is trained on publicly available parallel corpora and applied to different downstream tasks without any fine-tuning. our model sets a new state-of-the-art for most languages in zero-shot cross-lingual natural language inference (xnli), cross-lingual document classification (mldoc), and bitext mining (bucc). we also introduce a new test set of cross-lingual similarity search in 122 languages, and show that our approach is competitive even for low-resource languages. to the best of our knowledge, this is the first successful exploration of massively multilingual sentence representations. in the future, we would like to explore alternative architectures for the encoder. in particular, we plan to replace our bilstm with the transformer, which has been shown to work better in different settings vaswani2017attention, devlin:2018:arxiv_bert. moreover, we would like to explore possible strategies to exploit monolingual training data in addition to parallel corpora, such as using pre-trained word embeddings, backtranslation sennrich2016improving, edunov2018understanding, or other ideas from unsupervised machine translation, lample:2018:emnlp_unsupmt. finally, we would like to replace our language-specific tokenization and bpe segmentation with a language agnostic approach similar to sentencepiece. the model and code used in this paper will be freely available in the framework of the laser toolkit. bibliography: references appendix: training data our training data consists of the combination of the following publicly available parallel corpora: europarl provides high-quality translations for 21 european languages. the size varies from 400k to 2 m sentence pairs, in function of the date the respective country joined the european union. united nations: more than 11 million sentences in the six official languages of the united nations. we only use the first two million sentences in arabic, russian and chinese. opensubtitles2018: a collection of translations of movie subtitles in 57 languages. the corpus size varies from few thousand sentences (e.g. armenian or kazakh) to more than 50 million (e.g. spanish or romanian). we keep at most 2 million entries for each language pair. global voices: a parallel corpus of news stories from the global voices website (38 languages). this is a rather small corpus with less than 100k sentence in most of the languages. tanzil: a collection of quran translations in 42 languages. the style and vocabulary is very different from news texts. the average size is 135k sentences. tatoeba: a community supported collection of english sentences and translations into more than 300 languages. we use this corpus to extract a separate test set of up to 1, 000 sentences for many languages (see section [reference] and [reference]). for languages with more than 1, 000 entries, we use the remaining ones for training. using all these corpora would provide parallel data for more than hundred languages. however, we finally only kept 93 different languages to train the multilingual sentence embeddings. in particular, we discarded several constructed languages with little practical use (klingon, kotava, lojban, toki pona and volap\u00fck). appendix: xnli results for all language combinations table [reference] reports the accuracies of our system on the xnli test set when the premises and hypothesis are in a different language (e.g. premise in russian and hypothesis in thai). the numbers in the diagonal correspond to the main results reported in table [reference]. we observe that our approach seems to handle the combination of different languages very well. we do not have evidence that very distant languages perform considerably worse. it rather seems that the combined performance is mostly bounded by the accuracy of the language which performs worst when used alone. as an example, greek-russian achieves very similar results than bulgarian-russian, two slavic languages. combing french with chinese, two totally different languages, is only 1.5 points worse than french/ spanish, two very close languages. appendix: tatoeba dataset tatoeba is an open collection of english sentences and high quality translations into more than three hundred languages. the number of available translations is updated every saturday. we downloaded the snapshot on november 19th 2018 and performed the following processing: removal of sentences that contain\"@\" or\" http\". this is motivated by the fact that emails and web addresses are not language specific. removal of sentences with less than three words (before tokenization). these are usually sentences with limited semantic information. removal of sentences that appear multiple times, either in the source or the target. after filtering, we created test sets of up to 1, 000 aligned sentences with english. this amount of texts is available for 78 languages. limiting the number of sentences to 500, we increase the coverage to 101 languages, and even 141 languages with 100 parallel sentences. it should be stressed that, in general, the english sentences are not the same for the different languages. this implies that the error rates are not necessarily comparable between the languages. appendix: tatoeba: result analysis we provide here some analysis on the results given in tables [reference] and [reference]. we have 48 languages with an error rate below 10% and 55 with less than 20%, respectively (english included). the languages with less than 20% error belong to 20 different families and use 12 different scripts. it is nice to find six languages in this list for which we have only small amounts of bitexts (less than 400k), namely esperanto, galician, hindi, interlingua, malayam and marathi. the two constructed languages probably benefit from their inspiration by other european languages. overall, we observe low similarity error rates on the indo-aryan languages, namely hindi, bengali, marathi and urdu. the performance on berber languages (\" ber\" and\" kab\") is remarkable, although we have less than 100 thousand sentences to train them. this is a typical example of languages which are spoken by several millions of people, but for which the amount of written resources is very limited. it is quite unlikely that we would be able to train a good sentence embedding with language specific corpora only. this clearly shows the benefit of joint training on many languages. fifteen languages have similarity error rates of more than 50%. four of them are low-resource languages with their own script and which are alone in their family: amharic, armenian, khmer and georgian. this makes it difficult to benefit from joint training. on the other hand, one can also argue that is surprising that a language like khmer performs much better than random (99.9% error rate) with only 625 training examples. khmer probably benefits of the fact that he have trained our model on other languages of the region which have influenced khmer, namely thai and vietnamese. there are also several turkic languages (kazakh, tatar, uighur and uzbek) and celtic languages (breton and cornish) with high error rates. we hope to improve their performance in the future. appendix: tatoeba: results for unseen languages we extend our tatoeba experiments to 29 languages without any training data (see table [reference]). many of them are recognized minority languages spoken in specific regions, e.g. asturian, faroese, frisian, kashubian, north moluccan malay, piemontese, swabian or sorbian. all share some similarities, at various degrees, with other major languages, but also differ by their own grammar or specific vocabulary. this enables our encoder to perform reasonably well. we can probably assume that these are mainly spoken languages with limited resources in written form. the six languages which perform worst are mongolian, welsh, xhosa pampangan, yiddish and gaelic. we include these results here as baseline for future research. premise training [- 1pt] corpus [- 2pt] size tatoeba [- 1pt] test set [- 2pt] size",
        "pred_templates": [
            {
                "Material": [
                    [
                        "xnli dataset"
                    ],
                    [
                        "mldoc"
                    ],
                    [
                        "mldoc dataset"
                    ],
                    [
                        "bucc"
                    ],
                    [
                        "tatoeba corpus"
                    ],
                    [
                        "tatoeba corpus"
                    ],
                    [
                        "english multinli"
                    ],
                    [
                        "english xnli development corpus"
                    ],
                    [
                        "english nli classifier"
                    ],
                    [
                        "english training data"
                    ],
                    [
                        "english sentences"
                    ]
                ],
                "Method": [
                    [
                        "multilingual sentence embeddings"
                    ],
                    [
                        "embeddings"
                    ],
                    [
                        "language agnostic bilstm"
                    ]
                ],
                "Metric": [
                    [
                        "error rate"
                    ]
                ],
                "Task": [
                    [
                        "zero shot cross lingual transfer"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "bucc dataset",
                        "english",
                        "bucc",
                        "english training data",
                        "english multinli",
                        "english data",
                        "french",
                        "english-chinese test",
                        "english sentences"
                    ]
                ],
                "Method": [
                    [
                        "sentence embeddings",
                        "cross-lingual word embeddings",
                        "sentence embedding",
                        "multilingual sentence embedding",
                        "multilingual encoder",
                        "english sentence embeddings"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "bitext mining"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "mldoc dataset",
                        "mldoc",
                        "spanish"
                    ]
                ],
                "Method": [
                    [
                        "sentence embeddings",
                        "cross-lingual word embeddings",
                        "sentence embedding",
                        "multilingual sentence embedding",
                        "multilingual encoder",
                        "english sentence embeddings"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy",
                        "accuracies"
                    ]
                ],
                "Task": [
                    [
                        "cross-lingual document classification",
                        "classification",
                        "cross-lingual classification"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "xnli dataset",
                        "xnli",
                        "xnli corpus",
                        "english development set"
                    ]
                ],
                "Method": [
                    [
                        "bilstm encoder",
                        "stacked bilstm",
                        "x-bilstm",
                        "single layer bilstm",
                        "bilstm"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy",
                        "accuracies"
                    ]
                ],
                "Task": [
                    [
                        "cross-lingual natural language inference",
                        "inference"
                    ]
                ]
            }
        ]
    },
    "175f74a09241b6cb5101a2a09978095720db7d5f-20": {
        "doctext": "document: image super-resolution via dual-state recurrent networks advances in image super-resolution (sr) have recently benefited significantly from rapid developments in deep neural networks. inspired by these recent discoveries, we note that many state-of-the-art deep sr architectures can be reformulated as a single-state recurrent neural network (rnn) with finite unfoldings. in this paper, we explore new structures for sr based on this compact rnn view, leading us to a dual-state design, the dual-state recurrent network (dsrn). compared to its single-state counterparts that operate at a fixed spatial resolution, dsrn exploits both low-resolution (lr) and high-resolution (hr) signals jointly. recurrent signals are exchanged between these states in both directions (both lr to hr and hr to lr) via delayed feedback. extensive quantitative and qualitative evaluations on benchmark datasets and on a recent challenge demonstrate that the proposed dsrn performs favorably against state-of-the-art algorithms in terms of both memory consumption and predictive accuracy. section: introduction in the problem of single-image super-resolution (sr), the aim is to recover a high-resolution (hr) image from a single low-resolution (lr) image. in recent years, sr performance has been significantly improved due to rapid developments in deep neural networks (dnns). specifically, convolutional neural networks (cnns) and residual learning have been widely applied in much recent sr work. in these approaches, two principles have been consistently observed. the first is that increasing the depth of a cnn model improves sr performance; a deeper model with more parameters can represent a more complex mapping from lr to hr images. in addition, increasing network depth enlarges the size of receptive fields, providing more contextual information that can be exploited to reconstruct missing hr components. the second principle is that adding residual connections (globally, locally or jointly) prevents the problems of vanishing and exploding gradients, facilitating the training of deep models. while these recent models have demonstrated promising results, there are also drawbacks. one major issue is that increasing the depth of models by adding new layers introduces more parameters, and thus raises the likelihood of model overfitting. at the same time, larger models demand more storage space, which is a hurdle to deployment in resource-constrained environments (e.g. mobile systems). to resolve this issue, the deep recursive residual network (drrn) inspired by the deeply-recursive convolutional network (drcn) shares weights across different residual units and achieves state-of-the-art performance with a small number of parameters. separate efforts in neural architectural design have recently shown that commonly-used deep structures can be represented more compactly using recurrent neural networks (rnns). specifically, liao and poggio demonstrated that a weight-sharing residual neural network (resnet) is equivalent to a shallow rnn. inspired by their findings, we first explore the connections between the neural architectures of existing sr algorithms and their compact rnn formulations. we note that previous sr models with recursive computation and weight sharing, including drrn and drcn, work at a single spatial resolution (bicubic interpolation is first applied to upscale lr images to a desired spatial resolution). this enables their model structures to be represented as a unified single-state rnn. thus, both drrn and drcn can be viewed as a finite unfolding in time of the same rnn structure, but with different transition functions. this is illustrated in figure [reference], and will be discussed in detail in section [reference]. it is worth mentioning that we follow the terminology used in, where a ''state'' can be considered as corresponding to a ''layer'' in the normal rnn setting. based on this compact rnn view of state-of-the-art sr models, in this paper we explore new structures to extend the frontier of sr. the first approach in improving a conventional rnn model is generally to make it multi-layer. we apply this experience in designing the sr architecture in our compact rnn view by adding an additional state, rendering our model a dual-state recurrent network (dsrn), where the two states operate at different spatial resolutions. specifically, the bottom state captures information at lr, while the top state operates in the hr regime. as with a conventional two-layer stacked rnn, there is a connection from the bottom to the top state via deconvolutional operations. this provides information flow from lr to hr at every single unrolling time. in addition, to allow information flow from previously predicted hr features to lr features, we incorporate a delayed feedback mechanism from the top (hr) state to the bottom one. the overall structure of the proposed dsrn is shown in figure [reference], which not only utilizes parameters efficiently but also allows both lr and hr signals to contribute jointly to learning the mappings. to demonstrate the effectiveness of the proposed method, we compare dsrn with other recent image sr approaches on four common benchmarks as well as on the div2 k dataset from the\" new trends in image restoration and enhancement workshop and challenge on image super-resolution (ntire sr 2017)\". extensive experimental results validate that dsrn delivers higher parameter efficiency, low memory consumption and high restoration accuracy. section: related work single image sr has been widely studied in the past few decades and has an extensive literature. in recent years, due to the fast development of deep learning, significant progress has been made in this field. dong et al. first exploited a fully convolutional neural network, termed srcnn, to predict the nonlinear lr-hr mapping. it demonstrated superior performance to many other example-based learning paradigms, such as nearest neighbor, sparse representation, neighborhood embedding, random forest, etc. although all layers of a srcnn are trained jointly in an end-to-end fashion, conceptually the network is split into three stages: patch representation, non-linear mapping, and reconstruction. much of the later work follows a similar network design with more complicated building blocks or advanced optimization techniques. wang et al. proposed a sparse coding network (scn) that encodes a sparse representation prior for image sr and can be trained end-to-end, demonstrating the benefit of domain expertise in sparse coding for image sr. both external and self examples were utilized to synthesize the hr prediction via a neural network in. inspired by the success of very deep models on imagenet challenges, kim et al. proposed a very deep cnn, vdsr, which stacks 20 convolutional layers with kernels. both residual learning and adjustable gradient clipping are used to prevent vanishing and exploding gradients. however, as the model gets deeper, the number of parameters increases. to control the size of the model, drcn introduces 16 recursive layers, each with the same structure and shared parameters. moreover, drcn makes use of skip connections and recursive supervision to mitigate the difficulty of training. tai et al. discovered that many residual sr learning algorithms are based on either global residual learning or local residual learning, which are insufficient for very deep models. instead, they proposed the drrn that applies both global and local learning while remaining parameter efficient via recursive learning. more recently, tong et al. proposed making use of densely connected networks (densenet) instead of resnet as the building block for image sr. they demonstrated that the densenet structure is better at combining features at different levels, which boosts sr performance. apart from deep models working on bicubic upscaled input images, shi et al. used a compact network model to conduct convolutions on lr images directly and learned upscaling filters in the last layer, which considerably reduces the computation cost. similarly, dong et al. adopted deconvolution layers to accelerate srcnn in combination with smaller filter sizes and more convolution layers. however, these networks are relatively small and have difficulty capturing complicated mappings owing to limited network capacity. the laplacian pyramid super-resolution network (lapsrn) works on lr images directly and progressively predicts sub-band residuals on various scales. lim et al. proposed the enhanced deep super-resolution (edsr) network and a multi-scale variant, which learns different scaled mapping functions in parallel via weight sharing. it is noteworthy that most sr algorithms minimize the mean squared reconstruction error (i.e. via loss). they often suffer from regression-to-the-mean due to the ill-posed nature of single image sr, resulting in blurry predictions and poor subjective scores. to overcome this drawback, generative adversarial networks have been used along with perceptual loss for sr. subjective evaluation by mean-opinion-score showed huge improvement over other regression-based methods. our work is also strongly related to and built upon the idea of viewing a resnet as an unrolled rnn. it was first proposed in, which aids understanding of a family of deep structures from the perspective of rnns. later, chen et al. unified several different residual functions to provide a better understanding of the design of dnns with high learning capacity. recently, the equivalence to rnns has been further extended to densenet. based on this finding, dual path networks were proposed and showed superior performance to densenet and resnet in a varity of applications. section: single-state recurrent networks in this section, we first revisit the discovery that a resnet with shared weights can be reformulated as a recurrent system. then, based on this view, we unite the recent development of sr models with such rnn reformulations to show drcn and drrn are structurally equivalent to an unrolled single-state rnn. to establish the equivalence, we adopt the commonly used definition of a rnn, which is characterized by a set of states and transition functions among the states. a rnn often consists of the input state, output state, and the recurrent states. depending on the number recurrent states, we describe rnns as ''single-state'' (i.e. one recurrent state) or ''dual-state'' (i.e. two recurrent states). an illustration of a single-state rnn is shown in figure [reference] (a). the input, output, and recurrent states are represented as, and respectively. the arrow link indicates the state transition function. the square on the directed cycle indicates that the recurrent function travels one time step forward during the unfolding. interested readers are referred to for detailed information on this general formulation of a rnn. based on figure [reference] (a), we unfold along the temporal direction to a fixed length. the unfolded graph is shown in figure [reference] (b), and the dynamics of a single-state rnn can be characterized by: where the upper script indicates the-th unrolling. the parameters of,, and are often time-independent, which means these parameters are reused at every unfolding step. this allows us to unify resnet, drcn, and drrn as unrolled networks with the same recurrent structure but with the different realizations of and different rules of parameter sharing. resnet: we consider a resnet in its simplest form without any down-sampling or up-sampling operations. in other words, both of the spatial dimensions and feature dimensions remain the same across all intermediate layers. to render figure [reference] (b) equivalent to a resnet with residual blocks, one possible technique is to make: be the input image or a function of., and. thus, the state transition becomes. the recurrent function be the same as a conventional residual block, which contains two convolutional layers with skip connections as shown in figure [reference] (c). differences in color indicate different sets of parameters. the prediction state be calculated only at the time as the final output. it is worth mentioning that the only difference between an unrolled rnn following the above definitions and a conventional resnet is that the parameters in need to be reused among all residual blocks. drcn: to realize the drcn expressible by the same single-state rnn, we define and in the same way as for the resnet. since drcn recursively applies only a single convolutional layer to the input feature map 16 times, with the parameters of the layer reused across the whole network, we could use a single convolutional layer to express. the graph is illustrated in figure [reference] (d). moreover, unlike the resnet where the output is predicted only at the end of unfolding, drcn utilizes recursive supervision, which generates an output at every unfolding. the final hr prediction of drcn is the weighted sum of the outputs at every unfolding. drrn: the recurrent structure of drrn differs only slightly from a resnet. in a resnet, the skip connection comes from the previous residual block, whereas in a drrn the skip connection always comes from the first unrolled state. figure [reference] (e) shows the equivalent recurrent function for a drrn with one recursive block (i.e.) using the definition in the original paper. section: dual-state recurrent networks drawing on the connections between state-of-the-art sr models and rnns, we have investigated new compact rnn architectures for image sr. specifically, we propose a dual-state design, which adopts two recurrent states enable use of features from both lr and hr spaces. the rnn view of our dsrn is shown in figure [reference] (a) and is introduced as follows. dual-state design: unlike single-state models working at the same spatial resolution, dsrn incorporates information from both the lr and hr spaces. specifically, and in figure [reference] (a) indicate the lr state and hr state, respectively. four colored arrows indicate the transition functions between these two states. the blue (), orange () and yellow () links exist in a conventional two-layer rnn, providing information flow from lr to lr, hr to hr, and lr to hr, respectively. to further enable two-way information flows between and, we add the green link, which is inspired by the delayed feedback mechanism of traditional multi-layer rnns. here, it introduces a delayed hr to lr connection. the overall dynamics of our dsrn is given as: figure [reference] (b) demonstrates the same concept via an unfolded graph, where the top row represents hr state while the bottom one is lr. this design choice encourages feature specialization for different resolutions and information sharing across different resolutions. transition functions: our model is characterized by six transition functions.,,, and as illustrated in figure [reference] (b). specifically, we use the standard residual block for both self-transitions. a single convolutional layer is used for the down-sampling transition and a single transposed convolutional (or deconvolutional) layer is used for the up-sampling transition. the strides in both inter-state layers are set to be the same as the sr upscaling factor. unfolding details: similarly to unfolding a single-state rnn to obtain a resnet, for image sr, we let have no contribution to calculating the state transition. in other words, for any choice of (e.g. choose). furthermore, we set as the output of two convolutional layers with skip connections, which takes the lr input image and transform it into a desired feature space. in addition, is set to zero. finally, we use deep supervision for the hr prediction, as discussed below. deep supervision: the unrolled dsrn is capable of making a prediction at every time step. denote as a prediction at the unfolding, where is characterized by a single convolutional layer. then, instead of taking the prediction only at the final unfolding, we average all the predictions as thus, every unrolled layer directly connects to the loss layer to facilitate the training of such a very deep network. moreover, the model predicts the residual image and minimizes the following mean square error where is the group-truth image in hr and is the residual map between the ground truth and bicubic upsampled lr image. section: experiments in this section, we first provide implementation details, including both model hyper-parameters and training data augmentation. then we analyze a number of design choices and their contributions to final performance. finally, we compare dsrn to other state-of-the-art methods on several benchmark datasets. subsection: datasets to evaluate the proposed dsrn algorithm, we train our model using 91 images proposed in and test on the following datasets: set5, set14, b100 and urban100. the training data is augmented in a similar way to previous methods, which includes 1) random flipping along the vertical or horizontal axis; 2) random rotation by 90, 180 or 270; and 3) random scaling by a factor from [0.5, 0.6, 0.7, 0.8, 0.9, 1]. tensorflow is used for our full data processing pipeline; the lr training images are generated by the built-in bicubic down-sampling function. we additionally test our algorithm on the div2 k dataset of the ntire sr 2017 challenge, where we use the provided training and validation sets with all of the aforementioned data augmentations except random scaling. subsection: implementation details we use our model to super-resolve only the luminance channel of images, and use bicubic interpolation to upscale the other two color channels, following. we train independent models for each scale (2, 3, and 4) with 64 filters on the first input convolutional layer and 128 filters in the rest of the network. all layers use convolution filters. due to our dual-state design, the feature maps of and in each time step have the same spatial dimensions as the lr and hr images, respectively. we zero-pad the boundaries of feature maps to ensure the spatial size of each feature map is the same as the input size after the convolution is applied. all the weights in the network are initialized with a uniform distribution using the method proposed in. we use standard stochastic gradient descent (sgd) with momentum 0.95 as our optimizer to minimize the mse loss function in equation ([reference]). we search for the best initial learning rate from and reduce it by a factor of 10 three times during the entire training process. this learning rate annealing is driven by observing that the loss on the validation set stops decreasing. gradient clipping at is adopted during training to prevent the gradient explosion. we sample image patches with a size of and use a mini-batch size of to train our network. we observe that the recursion defined in equation ([reference]) may lead to an exponential increase in the scale of feature values, especially when is large. in, the authors proposed the use of unshared batch normalization at every unfolding time to resolve this issue. batch normalization is not used in our network; we found that normalizing the scale with two scalar parameters was sufficient. specifically, we use one unshared prelu activation for each recurrent state after every unrolling step. all other layers have ordinary relu as the activation function. ours others.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24.24 subsection: model analysis in this section, we analyze our proposed model in the following respects: unrolling length: the unrolling length changes the maximum effective depth of the unrolled network. in particular, for a dsrn with times unrolling, the maximum number of convolution layers between input and output of the network is. the multiplier comes from the two layers in a residual block, while the extra 4 is from the auxiliary input and output layers. however, the number of model parameters remains independent of the length of unrolling. essentially, controls the trade-off between model capacity and computation cost. we study the influence of by training the model with different unrolling lengths. the empirical results are shown in figure [reference]. the test performance increases when the number of unfolding steps increases, but the benefit seems to diminish after. unless otherwise mentioned, we use for all our models. it is worth mentioning that we also experimented with stochastic depth by randomly sampling during training, but we observed no improvement in validation accuracy. parameter sharing: we empirically find parameter sharing to be crucial for training a deep recursive model. as shown in table [reference], the same model with untied weights performs much more poorly than its weight-sharing counterpart. specifically, we observe around 0.2db performance drop across all three upscaling scales when changing from shared weights to untied weights. we speculate that the model with untied weights suffers a larger risk of model over-fitting and much slower training convergence, both of which diminish the model's restoration accuracy. dual-state and delayed feedback: we compare our dsrn with two baselines under the same unrolling time steps to understand how each module of our model contributes to the final performance: 1) a single-state rnn unrolled resnet; and 2) a dual-state rnn without delayed feedback connections. the quantitative comparison on the ntire sr 2017 challenge is shown in table [reference]. comparing the single-state baseline and the dsrn without feedback, it is clear that considering information from both lr and hr spaces as two separated states provides performance gains. in addition, comparing our models with and without feedback, we realize that incorporating such an information flow from hr space back to lr space consistently improves performance on all three different scales. in all, both the dual-state and delayed feedback designs are beneficial to our model. state visualization since dsrn has independent scaling parameters on each unrolled state, the model implicitly learns a weighted-average of all the unrolled states for the final prediction. empirically we observe that this strategy performs better than output from the last state only. to demonstrate how the network aggregates different unrolled states, we show feature response maps at different unrolling steps in figure [reference], demonstrating that the network distributes slightly different features to each unrolled state. subsection: comparison with the state-of-the-art we provide results of evaluation of our model on several public benchmark datasets in table [reference], with three commonly-used evaluation metrics: peak signal-to-noise ratio (psnr), structural similarity (ssim) and the information fidelity criterion (ifc). specifically, we perform a comprehensive comparison between our method and 10 other existing sr algorithms, including both deep learning and non-deep-learning based methods. note that many recent deep learning based competitors, including vdsr, lapsrn and drrn, use 291 training samples with the additional 200 from the training set of berkeley segmentation dataset, while our model was trained on only the 91 images. still, our dsrn method achieves competitive performance across all datasets and scales. it achieves particularly strong performance in the and settings. in addition, we report quantitative evaluations on the recently developed div2 k dataset and comparisons with top-ranking algorithms in table [reference]. our method achieves competitive performance with the best algorithm, edsr+, and outperforms all the other algorithms by a large margin, which demonstrates the effectiveness of our proposed dual-state recurrent structure. to further analyze the proposed dsrn against other state-of-the-art sr approaches in a qualitative manner, in figure [reference] we present several visual examples of super-resolved images on set14 with upscaling among different sr approaches. for these competing methods, we use sr results publicly released by the authors. as shown in figure [reference], our method can construct sharp and detailed structures and is less prone to generating spurious artifacts. furthermore, the proposed dsrn benefits from inherent parameter sharing and therefore obtains higher parameter efficiency compared to other methods. in figure [reference], we illustrate the parameters-to-psnr relationship of our model and several state-of-the-art methods, including srcnn, vdsr, drcn, drrn and red30. our method represents a favorable trade-off between model size and sr performance, and has modest inference time. the dsrn takes 0.4s on the x4 task with a 288x288 output image size, on an nvidia titan x gpu. section: conclusion in this work, we have provided a unique formulation that expresses many state-of-the-art sr models as a finite unfolding of a single-state rnn with various recurrent functions. based on this, we extend existing methods by considering a dual-state design; the two hidden states of our proposed dsrn operate at different spatial resolutions. one captures the lr information while the other one targets the hr domains. to ensure two-way communication between states, we integrate a delayed feedback mechanism. thus, the predicted features from both lr and hr states can be exploited jointly for final predictions. extensive experiments on benchmark datasets have demonstrated that the proposed dsrn performs favorably against state-of-the-art sr models in terms of both efficiency and accuracy. for the future work, we will explore use of our proposed dsrn to capture temporal dependencies for video sr. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "set5"
                    ],
                    [
                        "set5 set14"
                    ],
                    [
                        "set14"
                    ],
                    [
                        "set14 b100"
                    ],
                    [
                        "b100"
                    ],
                    [
                        "b100 and urban100"
                    ],
                    [
                        "urban100"
                    ],
                    [
                        "berkeley segmentation dataset"
                    ],
                    [
                        "set14"
                    ]
                ],
                "Method": [
                    [
                        "dsrn"
                    ],
                    [
                        "sparse coding network"
                    ],
                    [
                        "laplacian pyramid super resolution network"
                    ],
                    [
                        "enhanced deep super resolution"
                    ],
                    [
                        "enhanced deep super resolution edsr network"
                    ]
                ],
                "Metric": [
                    [
                        "predictive accuracy"
                    ],
                    [
                        "peak signal to noise ratio"
                    ],
                    [
                        "psnr"
                    ],
                    [
                        "psnr structural similarity"
                    ],
                    [
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "image super resolution"
                    ],
                    [
                        "super resolution"
                    ],
                    [
                        "sr"
                    ],
                    [
                        "sr"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "b100"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "peak signal-to-noise ratio",
                        "psnr",
                        "psnr relationship"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "b100"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "structural similarity",
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set14"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "peak signal-to-noise ratio",
                        "psnr",
                        "psnr relationship"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set14"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "structural similarity",
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set5"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "peak signal-to-noise ratio",
                        "psnr",
                        "psnr relationship"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set5"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "structural similarity",
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "urban100"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "peak signal-to-noise ratio",
                        "psnr",
                        "psnr relationship"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "urban100"
                    ]
                ],
                "Method": [
                    [
                        "dual-state recurrent networks",
                        "dual-state recurrent network",
                        "dsrn",
                        "unrolled single-state rnn",
                        "dual-state rnn without delayed feedback connections",
                        "dual-state recurrent structure"
                    ]
                ],
                "Metric": [
                    [
                        "structural similarity",
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "sr",
                        "single-image super-resolution",
                        "single image sr"
                    ]
                ]
            }
        ]
    },
    "1778e32c18bd611169e64c1805a51abff341ca53-21": {
        "doctext": "document: natural language inference over interaction space natural language inference (nli) task requires an agent to determine the logical relationship between a natural language premise and a natural language hypothesis. we introduce interactive inference network (iin), a novel class of neural network architectures that is able to achieve high-level understanding of the sentence pair by hierarchically extracting semantic features from interaction space. we show that an interaction tensor (attention weight) contains semantic information to solve natural language inference, and a denser interaction tensor contains richer semantic information. one instance of such architecture, densely interactive inference network (diin), demonstrates the state-of-the-art performance on large scale nli copora and large-scale nli alike corpus. it's noteworthy that diin achieve a greater than 20% error reduction on the challenging multi-genre nli (multinli;) dataset with respect to the strongest published system. section: introduction natural language inference (nli also known as recognizing textual entiailment, or rte) task requires one to determine whether the logical relationship between two sentences is among entailment (if the premise is true, then the hypothesis must be true), contradiction (if the premise is true, then the hypothesis must be false) and neutral (neither entailment nor contradiction). nli is known as a fundamental and yet challenging task for natural language understanding, not only because it requires one to identify the language pattern, but also to understand certain common sense knowledge. in table [reference], three samples from multinli corpus show solving the task requires one to handle the full complexity of lexical and compositional semantics. the previous work on nli (or rte) has extensively researched on conventional approaches. recent progress on nli is enabled by the availability of 570k human annotated dataset and the advancement of representation learning technique. among the core representation learning techniques, attention mechanism is broadly applied in many nlu tasks since its introduction: machine translation, abstractive summarization, reading comprehension, dialog system, etc. as described by,\" an attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. the output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key\". attention mechanism is known for its alignment between representations, focusing one part of representation over another, and modeling the dependency regardless of sequence length. observing attention's powerful capability, we hypothesize that the attention weight can assist with machine to understanding the text. a regular attention weight, the core component of the attention mechanism, encodes the cross-sentence word relationship into a alignment matrix. however, a multi-head attention weight can encode such interaction into multiple alignment matrices, which shows a more powerful alignment. in this work, we push the multi-head attention to a extreme by building a word-by-word dimension-wise alignment tensor which we call interaction tensor. the interaction tensor encodes the high-order alignment relationship between sentences pair. our experiments demonstrate that by capturing the rich semantic features in the interaction tensor, we are able to solve natural language inference task well, especially in cases with paraphrase, antonyms and overlapping words. we dub the general framework as interactive inference network (iin). to the best of our knowledge, it is the first attempt to solve natural language inference task in the interaction space. we further explore one instance of interactive inference network, densely interactive inference network (diin), which achieves new state-of-the-art performance on both snli and multinli copora. to test the generality of the architecture, we interpret the paraphrase identification task as natural language inference task where matching as entailment, not-matching as neutral. we test the model on quora question pair dataset, which contains over 400k real world question pair, and achieves new state-of-the-art performance. we introduce the related work in section 2, and discuss the general framework of iin along with a specific instance that enjoys state-of-the-art performance on multiple datasets in section 3. we describe experiments and analysis in section 4. finally, we conclude and discuss future work in section 5. section: related work the early exploration on nli mainly rely on conventional methods and small scale datasets. the availability of snli dataset with 570k human annotated sentence pairs has enabled a good deal of progress on natural language understanding. the essential representation learning techniques for nlu such as attention, memory and the use of parse structure are studied on the snli which serves as an important benchmark for sentence understanding. the models trained on nli task can be divided into two categories: (i) sentence encoding-based model which aims to find vector representation for each sentence and classifies the relation by using the concatenation of two vector representation along with their absolute element-wise difference and element-wise product. (ii) joint feature models which use the cross sentence feature or attention from one sentence to another. after neural attention mechanism is successfully applied on the machine translation task, such technique has became widely used in both natural language process and computer vision domains. many variants of attention technique such as hard-attention, self-attention, multi-hop attention, bidirectional attention and multi-head attention are also introduced to tackle more complicated tasks. before this work, neural attention mechanism is mainly used to make alignment, focusing on specific part of the representation. in this work, we want to show that attention weight contains rich semantic information required for understanding the logical relationship between sentence pair. though rnn or lstm are very good for variable length sequence modeling, using convolutional neural network in nlu tasks is very desirable because of its parallelism in computation. convolutional structure has been successfully applied in various domain such as machine translation, sentence classification, text matching and sentiment analysis, etc. the convolution structure is also applied on different level of granularity such as byte, character, word and sentences levels. section: model subsection: interactive inference network the interactive inference network (iin) is a hierarchical multi-stage process and consists of five components. each of the components is compatible with different type of implementations. potentially all exiting approaches in machine learning, such as decision tree, support vector machine and neural network approach, can be transfer to replace certain component in this architecture. we focus on neural network approaches below. figure [reference] provides a visual illustration of interactive inference network. embedding layer converts each word or phrase to a vector representation and construct the representation matrix for sentences. in embedding layer, a model can map tokens to vectors with the pre-trained word representation such as glove, word2vec and fasttext. it can also utilize the pre-processing tool, e.g. named entity recognizer, part-of-speech recognizer, lexical parser and coreference identifier etc., to incorporate more lexical and syntactical information into the feature vector. encoding layer encodes the representations by incorporating the context information or enriching the representation with desirable features for future use. for instance, a model can adopt bidirectional recurrent neural network to model the temporal interaction on both direction, recursive neural network (also known as treernn) to model the compositionality and the recursive structure of language, or self-attention to model the long-term dependency on sentence. different components of encoder can be combined to obtain a better sentence matrix representation. interaction layer creates an word-by-word interaction tensor by both premise and hypothesis representation matrix. the interaction can be modeled in different ways. a common approach is to compute the cosine similarity or dot product between each pair of feature vector. on the other hand, a high-order interaction tensor can be constructed with the outer product between two matrix representations. feature extraction layer adopts feature extractor to extract the semantic feature from interaction tensor. the convolutional feature extractors, such as alexnet, vgg, inception, resnet and densenet, proven work well on image recognition are completely compatible under such architecture. unlike the work who employs 1-d sliding window, our cnn architecture allows 2-d kernel to extract semantic interaction feature from the word-by-word interaction between n-gram pair. sequential or tree-like feature extractors are also applicable in the feature extraction layer. output layer decodes the acquired features to give prediction. under the setting of nli, the output layer predicts the confidence on each class. subsection: densely interactive inference network here we introduce densely interactive inference network (diin), which is a relatively simple instantiation of iin but produces state-of-the-art performance on multiple datasets. paragraph: embedding layer: for diin, we use the concatenation of word embedding, character feature and syntactical features. the word embedding is obtained by mapping token to high dimensional vector space by pre-trained word vector (840b glove). the word embedding is updated during training. as in, we filter character embedding with 1d convolution kernel. the character convolutional feature maps are then max pooled over time dimension for each token to obtain a vector. the character features supplies extra information for some out-of-vocabulary (oov) words. syntactical features include one-hot part-of-speech (pos) tagging feature and binary exact match (em) feature. the em value is activated if there are tokens with same stem or lemma in the other sentence as the corresponding token. the em feature is simple while found useful as in reading comprehension task. in analysis section, we study how em feature helps text understanding. now we have premise representation and hypothesis representation, where refers to the sequence length of premise, refers to the sequence length of hypothesis and means the dimension of both representation. the 1-d convolutional neural network and character features weights share the same set of parameters between premise and hypothesis. paragraph: encoding layer: in the encoding layer, the premise representation and the hypothesis representation are passed through a two-layer highway network, thus having and for new premise representation and new hypothesis representation. these new representation are then passed to self-attention layer to take into account the word order and context information. take premise as example, we model self-attention by where is a weighted summation of. we choose, where is a trainable weight, is element-wise multiplication, [;] is vector concatenation across row, and the implicit multiplication is matrix multiplication. then both and are fed into a semantic composite fuse gate (fuse gate in short), which acts as a skip connection. the fuse gate is implemented as where,, and, are trainable weights, is sigmoid nonlinear operation. we do the same operation on hypothesis representation, thus having. the weights of intra-attention and fuse gate for premise and hypothesis are not shared, but the difference between the weights of are penalized. the penalization aims to ensure the parallel structure learns the similar functionality but is aware of the subtle semantic difference between premise and hypothesis. paragraph: interaction layer: the interaction layer models the interaction between premise encoded representation and hypothesis encoded representation as follows: where is the-th row vector of, and is the-th row vector of. though there are many implementations of interaction, we find very useful. paragraph: feature extraction layer: we adopt densenet as convolutional feature extractor in diin. though our experiments show resnet works well in the architecture, we choose densenet because it is effective in saving parameters. one interesting observation with resnet is that if we remove the skip connection in residual structure, the model does not converge at all. we found batch normalization delays convergence without contributing to accuracy, therefore we does not use it in our case. a relu activation function is applied after all convolution unless otherwise noted. once we have the interaction tensor, we use a convolution with kernel to scale down the tensor in a ratio,, without following relu. if the input channel is then the output channel is. then the generated feature map is feed into three sets of dense block and transition block pair. the densenet block contains n layers of convolution layer with growth rate of g. the transition layer has a convolution layer with kernel for scaling down purpose, followed by a max pooling layer with stride. the transition scale down ratio in transition layer is. paragraph: output layer: diin uses a linear layer to classify final flattened feature representation to three classes. section: experiments in this section, we present the evaluation of our model. we first perform quantitative evaluation, comparing our model with other competitive models. we then conduct some qualitative analyses to understand how diin achieve the high level understanding through interaction. subsection: data here we introduce three datasets we evaluate our model on. the evaluation metric for all dataset is accuracy. paragraph: snli stanford natural language inference (snli;) has 570k human annotated sentence pairs. the premise data is draw from the captions of the flickr30k corpus, and the hypothesis data is manually composed. the labels provided in are\" entailment\",\" neutral',\" contradiction\" and\" -\".\" -\" shows that annotators can not reach consensus with each other, thus removed during training and testing as in other works. we use the same data split as in. paragraph: multinli multi-genre nli corpus (multinli;) has 433k sentence pairs, whose collection process and task detail are modeled closely to snli. the premise data is collected from maximally broad range of genre of american english such as written non-fiction genres (slate, oup, government, verbatim, travel), spoken genres (telephone, face-to-face), less formal written genres (fiction, letters) and a specialized one for 9/ 11. half of these selected genres appear in training set while the rest are not, creating in-domain (matched) and cross-domain (mismatched) development/ test sets. we use the same data split as provided by. since test set labels are not provided, the test performance is obtained through submission on kaggle.com. each team is limited to two submissions per day. paragraph: quora question pair quora question pair dataset contains over 400k real world question pair selected from quora.com. a binary annotation which stands for match (duplicate) or not match (not duplicate) is provided for each question pair. in our case, duplicate question pair can be interpreted as entailment relation and not duplicate as neutral. we use the same split ratio as mentioned in. subsection: experiments setting we implement our algorithm with tensorflow framework. an adadelta optimizer with as 0.95 and as is used to optimize all the trainable weights. the initial learning rate is set to 0.5 and batch size to 70. when the model does not improve best in-domain performance for 30, 000 steps, an sgd optimizer with learning rate of is used to help model to find a better local optimum. dropout layers are applied before all linear layers and after word-embedding layer. we use an exponential decayed keep rate during training, where the initial keep rate is 1.0 and the decay rate is 0.977 for every 10, 000 step. we initialize our word embeddings with pre-trained 300d glove 840b vectors while the out-of-vocabulary word are randomly initialized with uniform distribution. the character embeddings are randomly initialized with 100d. we crop or pad each token to have 16 characters. the 1d convolution kernel size for character embedding is 5. all weights are constraint by l2 regularization, and the l2 regularization at step is calculated as follows: where determines the maximum l2 regularization ratio, and determines at which step the maximum l2 regularization ratio would be applied on the l2 regularization. we choose as and as 100, 000. the ratio of l2 penalty between the difference of two encoder weights is set to. for a dense block in feature extraction layer, the number of layer is set to and growth rate g is set to. the first scale down ratio in feature extraction layer is set to and transitional scale down ratio is set to. the sequence length is set as a hard cutoff on all experiments: 48 for multinli, 32 for snli and 24 for quora question pair dataset. during the experiments on multinli, we use 15% of data from snli as in. we select the parameter by the best run of development accuracy. our ensembling approach considers the majority vote of the predictions given by multiple runs of the same model under different random parameter initialization. subsection: experiment on multinli we compare our result with all other published systems in table [reference]. besides esim, the state-of-the-art model on snli, all other models appear at repeval 2017 workshop. repeval 2017 workshop requires all submitted model to be sentence encoding-based model therefore alignment between sentences and memory module are not eligible for competition. all models except ours share one common feature that they use lstm as a essential building block as encoder. our approach, without using any recurrent structure, achieves the new state-of-the-art performance of 80.0%, exceeding current state-of-the-art performance by more than 5%. unlike the observation from, we find the out-of-domain test performance is consistently lower than in-domain test performance. selecting parameters from the best in-domain development accuracy partially contributes to this result. subsection: experiment on snli in table [reference], we compare our model to other model performance on snli. experiments (2-7) are sentence encoding based model. provides a bilstm baseline. adopts two layer gru encoder with pre-trained\" skip-thoughts\" vectors. to capture sentence-level semantics, use tree-based cnn and propose a stack-augmented parser-interpreter neural network (spinn) which incorporates parsing information in a sequential manner. uses intra-attention on top of bilstm to generate sentence representation, and proposes an memory augmented neural network to encode the sentence. the next group of model, experiments (8-18), uses cross sentence feature. aligns each sentence word-by-word with attention on top of lstms. enforces cross sentence attention word-by-word matching with the proprosed mlstm model. proposes long short-term memory-network (lstmn) with deep attention fusion that links the current word to previous word stored in memory. decomposes the task into sub-problems and conquer them respectively. proposes neural tree indexer, a full n-ary tree whose subtrees can be overlapped. re-read lstm proposed by considers the attention vector of one sentence as the inner-state of lstm for another sentence. propose a sequential model that infers locally, and a ensemble with tree-like inference module that further improves performance. we show our model, diin, achieves state-of-the-art performance on the competitive leaderboard. subsection: experiment on quora question pair dataset in this subsection, we evaluate the effectiveness of our model for paraphrase identification as natural language inference task. other than our baselines, we compare with and. bimpm models different perspective of matching between sentence pair on both direction, then aggregates matching vector with lstm. decatt\u2062word and decatt\u2062char uses automatically collected in-domain paraphrase data to noisy pretrain-gram word embedding and-gram subword embedding correspondingly on decomposable attention model proposed by. in table [reference], our experiment shows diin has better performance than all other models and an ensemble score is higher than the former best result for more than 1 percent. subsection: analysis paragraph: ablation study we conduct a ablation study on our base model to examine the effectiveness of each component. we study our model on multinli dataset and we use matched validation score as the standard for model selection. the result is shown in table [reference]. we studies how em feature contributes to the system. after removing the exact match binary feature, we find the performance degrade to 78.2 on matched score on development set and 78.0 on mismatched score. as observed in reading comprehension task, the simple exact match feature does help the model to better understand the sentences. in the experiment 3, we remove the convolutional feature extractor and then model is structured as a sentence-encoding based model. the sentence representation matrix is max-pooled over time to obtain a feature vector. once we have the feature vector for premise and for hypothesis, we use as final feature vector to classify the relationship. we obtain 73.2 for matched score and 73.6 on mismatched data. the result is competitive among other sentence-encoding based model. we further study how encoding layer contribute in enriching the feature space in interaction tensor. if we remove encoding layer completely, then we'll obtain a 73.5 for matched score and 73.2 for mismatched score. the result demonstrate the feature extraction layer have powerful capability to capture the semantic feature. in experiment 5, we remove both self-attention and fuse gate, thus retaining only highway network. the result improves to 77.7 and 77.3 respectively on matched and mismatched development set. however, in experiment 6, when we only remove fuse gate, to our surprise, the performance degrade to 73.5 for matched score and 73.8 for mismatched. on the other hand, if we use the addition of the representation after highway network and the representation after self-attention as skip connection as in experiment 7, the performance increase to 77.3 and 76.3. the comparison indicates self-attention layer makes the training harder to converge while a skip connection could ease the gradient flow for both highway layer and self-attention layer. by comparing the base model and the model the in experiment 6, we show that the fuse gate not only well serves as a skip connection, but also makes good decision upon which information the fuse for both representation. to show that dense interaction tensor contains more semantic information, we replace the dense interaction tensor with dot product similarity matrix between the encoded representation of premise and hypothesis. the result shows that the dot product similarity matrix has an inferior capacity of semantic information. another dimensionality study is provided in supplementary material. in experiment 9, we share the encoding layer weight, and the result decrease from the baseline. the result shows that the two set of encoding weights learn the subtle difference between premise and hypothesis. paragraph: error analysis to analyze the model prediction, we use annotated subset of development set provided by that consists of 1, 000 examples each tagged with zero or more following tags: conditional: whether the sentence contains a conditional. word overlap: whether both sentences share more than 70% of their tokens. negation: whether a negation shows up in either sentence. anto: whether two sentences contain antonym pair. long sentence: whether premise or hypothesis is longer than 30 or 16 tokens respectively. tense difference: whether any verb in two sentences uses different tense. active/ passive: whether there is an active-to-passive (or vice versa) transformation from the premise to the hypothesis. paraphrase: whether the two sentences are close paraphrases quantity/ time reasoning: whether understanding the pair requires quantity or time reasoning. coref: whether the hypothesis contains a pronoun or referring expression that needs to be resolved using the premise. quantifier: whether either sentence contains one of the following quantifier: much, enough, more, most, less, least, no, none, some, any, many, few, several, almost, nearly. modal: whether one of the following modal verbs appears in either sentence: can, could, may, might, must, will, would, should. belief: whether one of the following belief verbs appear in either sentence: know, believe, understand, doubt, think, suppose, recognize, forget, remember, imagine, mean, agree, disagree, deny, promise. for more detailed descriptions, please resort to. the result is shown in table [reference]. we find diin is consistently better on sentence pair with word overlap, anto, long sentence, paraphrase and belief tags by a large margin. during investigation, we hypothesize exact match feature helps the model to better understand paraphrase, therefore we study the result from second ablation ablation study where exact match feature is not used. surprisingly, the model without exact model feature does not work worse on paraphrase, instead, the accuracy on anto drops about 10%. diin is also work well on long sentence, partially because the receptive field is large enough to cover all tokens. paragraph: visualization we also visualize the hidden representation from interaction tensor and the feature map from first dense block in figure [reference]. we pick a sentence pair whose premise is\" south carolina has no referendum right, so the supreme court canceled the vote and upheld the ban.\" and hypothesis is\" south carolina has a referendum right, so the supreme court was powerless over the state.\". the upper row of figures are sampled from hidden representation of interaction tensor. we observe the values of neurons are highly correlated row-wise and column-wise in the interaction tensor and different channel of hidden representation shows different aspect of interaction. though in certain channel same words,\" referendum\", or phrases,\" supreme court\", cause activation, different word or phrase pair, such as\" ban\" and\" powerless over\", also cause activation in other activation. it shows the model's strong capacity of understanding text in different perspective. the lower row of figure [reference] shows the feature map from first dense block. after being convolved from the interaction tensor and previous feature map, new feature maps shows activation in different position, demonstrating different semantic features are found. the first figure in the lower row has similar pattern as normal attention weight whereas others has no obvious pattern. different channels of feature maps indicate different kinds of semantic feature. section: conclusion and future work we show the interaction tensor (or attention weight) contains semantic information to understand the natural language. we introduce interactive inference network, a novel class of architecture that allows the model to solve nli or nli alike tasks via extracting semantic feature from interaction tensor end-to-end. one instance of such architecture, densely interactive inference network (diin), achieves state-of-the-art performance on multiple datasets. by ablating each component in diin and changing the dimensionality, we show the effectiveness of each component in diin. though we have the initial exploration of natural language inference in interaction space, the full potential is not yet clear. we will keep exploring the potential of interaction space. incorporating common-sense knowledge from external resources such as knowledge base to leverage the capacity of the mode is another research goal of ours. subsubsection: acknowledgments we thank yuchen lu, chang huang and kai yu for their sincere and insightful advice. bibliography: references appendix: supplementary material paragraph: dimensionality and parameter number study to study the influence of the model dimension which is also the channel number of interaction tensor, we design experiments to find out whether dimension has influence on performance. we also present the parameter count of these models. the dimensionality is 448 where 300 comes from word embedding, 100 comes from char feature, 47 comes from part of speech tagging and 1 comes from the binary exact match feature. since highway network sets the output dimensionality default as that in input, we design a variant to highway network so that different output size could be obtained. the variant of highway layer is designed as follows: where is the-th vector of input matrix, is the-th vector of output matrix,,, and,, are trainable weights. the result shows that higher dimension number have better performance when the dimension number is lower certain threshold, however, when the number of dimensionality is greater than the threshold, larger number of parameter and higher dimensionality does n't contribute to performance. in the case of snli, due to its simplicity in language pattern, 250d would be suffice to obtain a good performance. on the other hand, it requires 350d to achieve a competitive performance on multinli. we fail to reproduce our best performance with the new structure on multinli. it shows that the additional layer on highway network does n't helps convergence.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "large scale nli alike corpus"
                    ],
                    [
                        "real world question pair"
                    ],
                    [
                        "snli"
                    ],
                    [
                        "stanford"
                    ],
                    [
                        "snli"
                    ],
                    [
                        "flickr30k corpus"
                    ]
                ],
                "Method": [
                    [
                        "iin"
                    ],
                    [
                        "interaction tensor"
                    ],
                    [
                        "diin"
                    ],
                    [
                        "interactive inference network"
                    ],
                    [
                        "iin"
                    ],
                    [
                        "densely interactive inference network"
                    ],
                    [
                        "diin"
                    ],
                    [
                        "iin"
                    ],
                    [
                        "stack augmented parser interpreter neural network"
                    ],
                    [
                        "spinn"
                    ]
                ],
                "Metric": [
                    [
                        "error reduction"
                    ]
                ],
                "Task": [
                    [
                        "natural language inference"
                    ],
                    [
                        "inference"
                    ],
                    [
                        "natural language inference"
                    ],
                    [
                        "nli"
                    ],
                    [
                        "nli task"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "quora question pair dataset",
                        "quora question pair"
                    ]
                ],
                "Method": [
                    [
                        "densely interactive inference network",
                        "diin"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy",
                        "development accuracy",
                        "in-domain development accuracy"
                    ]
                ],
                "Task": [
                    [
                        "paraphrase identification task",
                        "paraphrase identification",
                        "paraphrase"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "snli",
                        "snli dataset",
                        "stanford natural language inference"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": [
                    [
                        "natural language inference",
                        "nli"
                    ]
                ]
            }
        ]
    },
    "178275dbdcfa267e41a9d5efe386ee5874c6d23f-22": {
        "doctext": "document: fraternal dropout recurrent neural networks (rnns) form an important class of architectures among neural networks useful for language modeling and sequential prediction. however, optimizing rnns is known to be harder compared to feed-forward neural networks. a number of techniques have been proposed in literature to address this problem. in this paper we propose a simple technique called fraternal dropout that takes advantage of dropout to achieve this goal. specifically, we propose to train two identical copies of an rnn (that share parameters) with different dropout masks while minimizing the difference between their (pre-softmax) predictions. in this way our regularization encourages the representations of rnns to be invariant to dropout mask, thus being robust. we show that our regularization term is upper bounded by the expectation-linear dropout objective which has been shown to address the gap due to the difference between the train and inference phases of dropout. we evaluate our model and achieve state-of-the-art results in sequence modeling tasks on two benchmark datasets- penn treebank and wikitext-2. we also show that our approach leads to performance improvement by a significant margin in image captioning (microsoft coco) and semi-supervised (cifar-10) tasks. section: introduction recurrent neural networks (rnns) like long short-term memory (lstm;) networks and gated recurrent unit (gru;) are popular architectures for sequence modeling tasks like language generation, translation, speech synthesis, and machine comprehension. however, they are harder to optimize compared to feed-forward networks due to challenges like variable length input sequences, repeated application of the same transition operator at each time step, and largely-dense embedding matrix that depends on the vocabulary size. due to these optimization challenges in rnns, the application of batch normalization and its variants (layer normalization, recurrent batch normalization, recurrent normalization propagation) have not been as successful as their counterparts in feed-forward networks, although they do considerably provide performance gains. similarly, naive application of dropout has been shown to be ineffective in rnns. therefore, regularization techniques for rnns is an active area of research. to address these challenges, proposed to apply dropout only to the non-recurrent connections in multi-layer rnns. variational dropout () uses the same dropout mask throughout a sequence during training. dropconnect applies the dropout operation on the weight matrices. zoneout (), in a similar spirit with dropout, randomly chooses to use the previous time step hidden state instead of using the current one. similarly as a substitute for batch normalization, layer normalization normalizes the hidden units within each sample to have zero mean and unit standard deviation. recurrent batch normalization applies batch normalization but with unshared mini-batch statistics for each time step. and on the other hand show that activity regularization (ar) and temporal activation regularization (tar) are also effective methods for regularizing lstms. another more recent way of regularizing rnns, that is similar in spirit to the approach we take, involves minimizing the difference between the hidden states of the original and the auxiliary network. in this paper we propose a simple regularization based on dropout that we call fraternal dropout, where we minimize an equally weighted sum of prediction losses from two identical copies of the same lstm with different dropout masks, and add as a regularization the difference between the predictions (pre-softmax) of the two networks. we analytically show that our regularization objective is equivalent to minimizing the variance in predictions from different i.i.d. dropout masks; thus encouraging the predictions to be invariant to dropout masks. we also discuss how our regularization is related to expectation linear dropout,-model and activity regularization, and empirically show that our method provides non-trivial gains over these related methods which we explain furthermore in our ablation study (section [reference]). section: fraternal dropout dropout is a powerful regularization for neural networks. it is usually more effective on densely connected layers because they suffer more from overfitting compared with convolution layers where the parameters are shared. for this reason dropout is an important regularization for rnns. however, dropout has a gap between its training and inference phase since the latter phase assumes linear activations to correct for the factor by which the expected value of each activation would be different. in addition, the prediction of models with dropout generally vary with different dropout mask. however, the desirable property in such cases would be to have final predictions be invariant to dropout masks. as such, the idea behind fraternal dropout is to train a neural network model in a way that encourages the variance in predictions under different dropout masks to be as small as possible. specifically, consider we have an rnn model denoted by that takes as input, where denotes the model parameters. let be the prediction of the model for input sample at time, for dropout mask and current input, where is a function of and the hidden states corresponding to the previous time steps. similarly, let be the corresponding time step loss value for the overall input-target sample pair. then in fraternal dropout, we simultaneously feed-forward the input sample through two identical copies of the rnn that share the same parameters but with different dropout masks and at each time step. this yields two loss values at each time step given by, and. then the overall loss function of fraternal dropout is given by, where is the regularization coefficient, is the dimensions of and is the fraternal dropout regularization given by, we use monte carlo sampling to approximate where and are the same as the one used to calculate values. hence, the additional computation is negligible. we note that the regularization term of our objective is equivalent to minimizing the variance in the prediction function with different dropout masks as shown below (proof in the appendix). theorem:. let sit and sjt be i.i.d. dropout masks and\u2208\u2062pt (zt, sit;\u03b8) rm be the prediction function as described above. then, note that a generalization of our approach would be to minimize the difference between the predictions of the two networks with different data/ model augmentations. however, in this paper we focus on using different dropout masks and experiment mainly with rnns. section: related work subsection: relation to expectation linear dropout (eld) analytically showed that the expected error (over samples) between a model's expected prediction over all dropout masks, and the prediction using the average mask, is upper bounded. based on this result, they propose to explicitly minimize the difference (we have adapted their regularization to our notations), where is the dropout mask. however, due to feasibility consideration, they instead propose to use the following regularization in practice, specifically, this is achieved by feed-forwarding the input twice through the network, with and without dropout mask, and minimizing the main network loss (with dropout) along with the regularization term specified above (but without back-propagating the gradients through the network without dropout). the goal of is to minimize the network loss along with the expected difference between the prediction from individual dropout mask and the prediction from the expected dropout mask. we note that our regularization objective is upper bounded by the expectation-linear dropout regularization as shown below (proof in the appendix). theorem:.. this result shows that minimizing the eld objective indirectly minimizes our regularization term. finally as indicated above, they apply the target loss only on the network with dropout. in fact, in our own ablation studies (see section [reference]) we find that back-propagating target loss through the network (without dropout) makes optimizing the model harder. however, in our setting, simultaneously back-propagating target loss through both networks yields both performance gain as well as convergence gain. we believe convergence is faster for our regularization because network weights are more likely to get target based updates from back-propagation in our case. this is especially true for weight dropout since in this case dropped weights do not get updated in the training iteration. subsection: relation to-model propose-model with the goal of improving performance on classification tasks in the semi-supervised setting. they propose a model similar to ours (considering the equivalent deep feed-forward version of our model) except they apply target loss only on one of the networks and use time-dependent weighting function (while we use constant). the intuition in their case is to leverage unlabeled data by using them to minimize the difference in prediction between the two copies of the network with different dropout masks. further, they also test their model in the supervised setting but fail to explain the improvements they obtain by using this regularization. we note that in our case we analytically show that minimizing our regularizer (also used in-model) is equivalent to minimizing the variance in the model predictions (remark [reference]). furthermore, we also show the relation of our regularizer to expectation linear dropout (proposition [reference]). in section [reference], we study the effects of target based loss on both networks, which is not used in the-model. we find that applying target loss on both the networks leads to significantly faster convergence. finally, we bring to attention that temporal embedding (another model proposed by, claimed to be a better version of-model for semi-supervised, learning) is intractable in natural language processing applications because storing averaged predictions over all of the time steps would be memory exhaustive (since predictions are usually huge-tens of thousands values). on a final note, we argue that in the supervised case, using a time-dependent weighting function instead of a constant value is not needed. since the ground truth labels are known, we have not observed the problem mentioned by, that the network gets stuck in a degenerate solution when is too large in earlier epochs of training. we note that it is much easier to search for an optimal constant value, which is true in our case, as opposed to tuning the time-dependent function. similarity to-model makes our method related to other semi-supervised works, mainly and. since semi-supervised learning is not a primary focus of this paper, we refer to for more details. we note that the idea of adding a penalty encouraging the representation to be similar for two different masks was previously implemented by the authors of a multi-prediction deep boltzmann machines. nevertheless, the idea is not discussed in their paper. another way to address the gap between the train and evaluation mode of dropout is to perform monte carlo sampling of masks and average the predictions during evaluation, and this has been used for feed-forward networks. we find that this technique does not work well for rnns. the details of these experiments can be found in the appendix. section: experiments subsection: language models in the case of language modeling we test our model on two benchmark datasets- penn tree-bank (ptb) dataset and wikitext-2 (wt2) dataset. we use preprocessing as specified by (for ptb corpus) and moses tokenizer (for the wt2 dataset). for both datasets we use the awd-lstm 3-layer architecture described in which we call the baseline model. the number of parameters in the model used for ptb is 24 million as compared to 34 million in the case of wt2 because wt2 has a larger vocabulary size for which we use a larger embedding matrix. apart from those differences, the architectures are identical. when we use fraternal dropout, we simply add our regularization on top of this baseline model. word level penn treebank (ptb). influenced by, our goal here is to make sure that fraternal dropout outperforms existing methods not simply because of extensive hyper-parameter grid search but rather due to its regularization effects. hence, in our experiments we leave a vast majority of hyper-parameters used in the baseline model unchanged i.e. embedding and hidden states sizes, gradient clipping value, weight decay and the values used for all dropout layers (dropout on the word vectors, the output between lstm layers, the output of the final lstm, and embedding dropout). however, a few changes are necessary: the coefficients for ar and tar needed to be altered because fraternal dropout also affects rnns activation (as explained in subsection [reference])- we did not run grid search to obtain the best values but simply deactivated ar and tar regularizers; since fraternal dropout needs twice as much memory, batch size is halved so the model needs approximately the same amount of memory and hence fits on the same gpu. the final change in hyper-parameters is to alter the non-monotone interval used in non-monotonically triggered averaged sgd (nt-asgd) optimizer. we run a grid search on and obtain very similar results for the largest values (40, 50 and 60) in the candidate set. hence, our model is trained longer using ordinary sgd optimizer as compared to the baseline model. we evaluate our model using the perplexity metric and compare the results that we obtain against the existing state-of-the-art results. the results are reported in table [reference]. our approach achieves the state-of-the-art performance compared with existing benchmarks. to confirm that the gains are robust to initialization, we run ten experiments for the baseline model with different seeds (without fine-tuning) for ptb dataset to compute confidence intervals. the average best validation perplexity is with the minimum value equals. the same for test perplexity is and, respectively. our score (validation and test perplexity) beats ordinal dropout minimum values. we also perform experiments using fraternal dropout with a grid search on all the hyper-parameters and find that it leads to further improvements in performance. the details of this experiment can be found in section [reference]. word level wikitext-2 (wt2). in the case of wikitext-2 language modeling task, we outperform the current state-of-the-art using the perplexity metric by a significant margin. due to the lack of computational power, we run a single training procedure for fraternal dropout on wt2 dataset because it is larger than ptb. in this experiment, we use the best hyper-parameters found for ptb dataset (, non-monotone interval and halved batch size; the rest of the hyper-parameters are the same as described in for wt2). the final results are presented in table [reference]. subsection: image captioning we also apply fraternal dropout on an image captioning task. we use the well-known show and tell model as a baseline. we emphasize that in the image captioning task, the image encoder and sentence decoder architectures are usually learned together. since we want to focus on the benefits of using fraternal dropout in rnns we use frozen pretrained resnet-101 model as our image encoder. it means that our results are not directly comparable with other state-of-the-art methods, however we report results for the original methods so readers can see that our baseline performs well. the final results are presented in table [reference]. we argue that in this task smaller values are optimal because the image captioning encoder is given all information in the beginning and hence the variance of consecutive predictions is smaller that in unconditioned natural language processing tasks. fraternal dropout may benefits here mainly due to averaging gradients for different mask and hence updating weights more frequently. section: ablation studies in this section, the goal is to study existing methods closely related to ours- expectation linear dropout,-model and activity regularization. all of our experiments for ablation studies, which apply a single layer lstm, use the same hyper-parameters and model architecture as. subsection: expectation-linear dropout (eld) the relation with expectation-linear dropout has been discussed in section [reference]. here we perform experiments to study the difference in performance when using the eld regularization versus our regularization (fd). in addition to eld, we also study a modification (eldm) of eld which applies target loss to both copies of lstms in eld similar to fd (notice in their case they only have dropout on one lstm). finally we also evaluate a baseline model without any of these regularizations. the learning dynamics curves are shown in figure [reference]. our regularization performs better in terms of convergence compared with other methods. in terms of generalization, we find that fd is similar to eld, but baseline and eldm are much worse. interestingly, looking at the train and validation curves together, eldm seems to be suffering from optimization problems. subsection:-model since-model is similar to our algorithm (even though it is designed for semi-supervised learning in feed-forward networks), we study the difference in performance with-model both qualitatively and quantitatively to establish the advantage of our approach. first, we run both single layer lstm and 3-layer awd-lstm on ptb task to check how their model compares with ours in the case of language modeling. the results are shown in figure [reference] and [reference]. we find that our model converges significantly faster than-model. we believe this happens because we back-propagate the target loss through both networks (in contrast to-model) that leads to weights getting updated using target-based gradients more often. even though we designed our algorithm specifically to address problems in rnns, to have a fair comparison, we compare with-model on a semi-supervised task which is their goal. specifically, we use the cifar-10 dataset that consists of images from 10 classes. following the usual splits used in semi-supervised learning literature, we use 4 thousand labeled and 41 thousand unlabeled samples for training, 5 thousand labeled samples for validation and 10 thousand labeled samples for test set. we use the original resnet-56 architecture. we run grid search on, dropout rates in and leave the rest of the hyper-parameters unchanged. we additionally check importance of using unlabeled data. the results are reported in table [reference]. we find that our algorithm performs at par with-model. when unlabeled data is not used, fraternal dropout provides slightly better results as compared to traditional dropout. subsection: activity regularization and temporal activity regularization analysis the authors of study the importance of activity regularization (ar) and temporal activity regularization (tar) in lstms given as, where is the lstm's output activation at time step (hence depends on both current input and the model parameters). notice that ar and tar regularizations are applied on the output of the lstm, while our regularization is applied on the pre-softmax output of the lstm. however, since our regularization can be decomposed as and encapsulates an term along with the dot product term, we perform experiments to confirm that the gains in our approach is not due to the regularization alone. a similar argument goes for the tar objective. we run a grid search on,, which include the hyper-parameters mentioned in. for our regularization, we use. furthermore, we also compare with a regularization (pr) that regularizes to further rule-out any gains only from regularization. based on this grid search, we pick the best model on the validation set for all the regularizations, and additionally report a baseline model without any of these four mentioned regularizations. the learning dynamics is shown in figure [reference]. our regularization performs better both in terms of convergence and generalization compared with other methods. average hidden state activation is reduced when any of the regularizer described is applied (see figure [reference]). subsection: improvements using fine-tuning we confirm that models trained with fraternal dropout benefit from the nt-asgd fine-tuning step (as also used in). however, this is a very time-consuming practice and since different hyper-parameters may be used in this additional part of the learning procedure, the probability of obtaining better results due to the extensive grid search is higher. hence, in our experiments we use the same fine-tuning procedure as implemented in the official repository (even fraternal dropout was not used). we present the importance of fine-tuning in table [reference]. subsection: fraternal dropout and expectation linear dropout comparison we perform extensive grid search for the baseline model from subsection [reference] (an awd-lstm 3-layer architecture) trained with either fraternal dropout or expectation linear dropout regularizations, to further contrast the performance of these two methods. the experiments are run without fine-tuning on the ptb dataset. in each run, all five dropout rates are randomly altered (they are set to their original value, as in, multiplied by a value drawn from the uniform distribution on the interval) and the rest of the hyper-parameters are drawn as shown in table [reference]. as in subsection [reference], ar and tar regularizers are deactivated. together we run more than 400 experiments. the results are presented in table [reference]. both fd and eld perform better than the baseline model that instead uses ar and tar regularizers. hence, we confirm our previous finding (see subsection [reference]) that both fd and eld are better. however, as found previously for smaller model in subsection [reference], the convergence of fd is faster than that of eld. additionally, fraternal dropout is more robust to different hyper-parameters choice (more runs performing better than the baseline and better average for top performing runs). section: conclusion in this paper we propose a simple regularization method for rnns called fraternal dropout that acts as a regularization by reducing the variance in model predictions across different dropout masks. we show that our model achieves state-of-the-art results on benchmark language modeling tasks along with faster convergence. we also analytically study the relationship between our regularization and expectation linear dropout. we perform a number of ablation studies to evaluate our model from different aspects and carefully compare it with related methods both qualitatively and quantitatively. section: acknowledgements the authors would like to acknowledge the support of the following agencies for research funding and computing support: nserc, cifar, and ivado. we would like to thank rosemary nan ke and philippe lacaille for their thoughts and comments throughout the project. we would also like to thank stanis\u0142aw jastrz\u0119bski and evan racah for useful discussions. bibliography: references appendix: appendix subsection: monte carlo evaluation a well known way to address the gap between the train and evaluation mode of dropout is to perform monte carlo sampling of masks and average the predictions during evaluation (mc-eval), and this has been used for feed-forward networks. since fraternal dropout addresses the same problem, we would like to clarify that it is not straight-forward and feasible to apply mc-eval for rnns. in feed-forward networks, we average the output prediction scores from different masks. however, in the case rnns (for next step predictions), there is more than one way to perform such evaluation, but each one is problematic. they are as follows: 1. online averaging consider that we first make the prediction at time step 1 using different masks by averaging the prediction score. then we use this output to feed as input to the time step 2, then use different masks at time step 2 to generate the output at time step 2, and so on. but in order to do so, because of the way rnns work, we also need to feed the previous time hidden state to time step 2. one way would be to average the hidden states over different masks at time step 1. but the hidden space can in general be highly nonlinear, and it is not clear if averaging in this space is a good strategy. this approach is not justified. besides, this strategy as a whole is extremely time consuming because we would need to sequentially make predictions with multiple masks at each time step. 2. sequence averaging let's consider that we use a different mask each time we want to generate a sequence, and then we average the prediction scores, and compute the argmax (at each time step) to get the actual generated sequence. in this case, notice it is not guaranteed that the predicted word at time step due to averaging the predictions would lead to the next word (generated by the same process) if we were to feed the time step output as input to the time step. for example, with different dropout masks, if the probability of time step outputs are: i 40%), he (30%), she (30%), and the probability of the 2nd time step outputs are: am (30%), is (60%), was (10%). then the averaged prediction score followed by argmax will result in the prediction ''i is'', but this would be incorrect. a similar concern applies for output predictions varying in temporal length. hence, this approach can not be used to generate a sequence (it has to be done by by sampling a mask and generating a single sequence). however, this approach may be used to estimate the probability assigned by the model to a given sequence. nonetheless, we run experiments on the ptb dataset using mc-eval (the results are summarized in table [reference]). we start with a simple comparison that compares fraternal dropout with the averaged mask and the awd-lstm 3-layer baseline with a single fixed mask that we call mc1. the mc1 model performs much worse than fraternal dropout. hence, it would be hard to use mc1 model in practice because a single sample is inaccurate. we also check mc-eval for a larger number of models (mc50) (50 models were used since we were not able to fit more models simultaneously on a single gpu). the final results for mc50 are worse than the baseline which uses the averaged mask. for comparison, we also evaluate mc10. note that no fine-tuning is used for the above experiments. subsection: reasons for focusing on rnns the fraternal dropout method is general and may be applied in feed-forward architectures (as shown in subsection [reference] for cifar-10 semisupervised example). however, we believe that it is more powerful in the case of rnns because: variance in prediction accumulates among time steps in rnns and since we share parameters for all time steps, one may use the same value at each step. in feed-forward networks the layers usually do not share parameters and hence one may want to use different values for different layers (which may be hard to tune). the simple way to alleviate this problem is to apply the regularization term on the pre-softmax predictions only (as shown in the paper) or use the same value for all layers. however, we believe that it may limit possible gains. the best performing rnn architectures (state-of-the-art) usually use some kind of dropout (embedding dropout, word dropout, weight dropout etc.), very often with high dropout rates (even larger than 50% for input word embedding in nlp tasks). however, this is not true for feed-forward networks. for instance, resnet architectures very often do not use dropout at all (probably because batch normalization is often better to use). it can be seen in the paper (subsection [reference], semisupervised cifar-10 task) that when unlabeled data is not used the regular dropout hurts performance and using fraternal dropout seems to improve just a little. on a final note, the monte carlo sampling (a well known method that adresses the gap betweem the train and evaluation mode of dropout) can not be easily applied for rnns and fraternal dropout may be seen as an alternative. to conclude, we believe that when the use of dropout benefits in a given architecture, applying fraternal dropout should improve performance even more. as mentioned before, in image recognition tasks, one may experiment with something what we would temporarily dub fraternal augmentation (even though dropout is not used, one can use random data augmentation such as random crop or random flip). hence, one may force a given neural network to have the same predictions for different augmentations. subsection: proofs theorem:. let sit and sjt be i.i.d. dropout masks and\u2208\u2062pt (zt, sit;\u03b8) rm be the prediction function as described above. then, proof: proof. for simplicity of notation, we omit the time index.\u220e theorem:.. proof: proof. let, then then using jensen's inequality,\u220e",
        "pred_templates": [
            {
                "Material": [
                    [
                        "penn treebank"
                    ],
                    [
                        "wikitext-2"
                    ],
                    [
                        "microsoft coco"
                    ],
                    [
                        "cifar-10"
                    ],
                    [
                        "penn tree bank"
                    ],
                    [
                        "ptb dataset"
                    ],
                    [
                        "wikitext-2 wt2 dataset"
                    ],
                    [
                        "wt2 dataset"
                    ]
                ],
                "Method": [
                    [
                        "fraternal dropout"
                    ],
                    [
                        "fraternal dropout recurrent neural networks"
                    ]
                ],
                "Metric": [
                    [
                        "expectation linear dropout"
                    ]
                ],
                "Task": [
                    [
                        "language modeling"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "penn treebank",
                        "penn tree-bank (ptb) dataset",
                        "ptb"
                    ]
                ],
                "Method": [
                    [
                        "fraternal dropout",
                        "dropout",
                        "tar",
                        "lstm",
                        "fraternal dropout regularization",
                        "dropout layers",
                        "eld",
                        "fraternal dropout method"
                    ]
                ],
                "Metric": [
                    [
                        "perplexity metric"
                    ]
                ],
                "Task": [
                    [
                        "language modeling",
                        "wikitext-2 language modeling task",
                        "language modeling tasks"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "penn treebank",
                        "penn tree-bank (ptb) dataset",
                        "ptb"
                    ]
                ],
                "Method": [
                    [
                        "fraternal dropout",
                        "dropout",
                        "tar",
                        "lstm",
                        "fraternal dropout regularization",
                        "dropout layers",
                        "eld",
                        "fraternal dropout method"
                    ]
                ],
                "Metric": [
                    [
                        "train and evaluation mode",
                        "average best validation perplexity",
                        "validation and test perplexity",
                        "train and validation curves",
                        "train and evaluation mode of dropout"
                    ]
                ],
                "Task": [
                    [
                        "language modeling",
                        "wikitext-2 language modeling task",
                        "language modeling tasks"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "wikitext-2",
                        "wikitext-2 (wt2) dataset"
                    ]
                ],
                "Method": [
                    [
                        "fraternal dropout",
                        "dropout",
                        "tar",
                        "lstm",
                        "fraternal dropout regularization",
                        "dropout layers",
                        "eld",
                        "fraternal dropout method"
                    ]
                ],
                "Metric": [
                    [
                        "perplexity metric"
                    ]
                ],
                "Task": [
                    [
                        "language modeling",
                        "wikitext-2 language modeling task",
                        "language modeling tasks"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "wikitext-2",
                        "wikitext-2 (wt2) dataset"
                    ]
                ],
                "Method": [
                    [
                        "fraternal dropout",
                        "dropout",
                        "tar",
                        "lstm",
                        "fraternal dropout regularization",
                        "dropout layers",
                        "eld",
                        "fraternal dropout method"
                    ]
                ],
                "Metric": [
                    [
                        "train and evaluation mode",
                        "average best validation perplexity",
                        "validation and test perplexity",
                        "train and validation curves",
                        "train and evaluation mode of dropout"
                    ]
                ],
                "Task": [
                    [
                        "language modeling",
                        "wikitext-2 language modeling task",
                        "language modeling tasks"
                    ]
                ]
            }
        ]
    },
    "178631e0f0e624b1607c7a7a2507ed30d4e83a42-23": {
        "doctext": "document: speech recognition with deep recurrent neural networks recurrent neural networks (rnns) are a powerful model for sequential data. end-to-end training methods such as connectionist temporal classification make it possible to train rnns for sequence labelling problems where the input-output alignment is unknown. the combination of these methods with the long short-term memory rnn architecture has proved particularly fruitful, delivering state-of-the-art results in cursive handwriting recognition. however rnn performance in speech recognition has so far been disappointing, with better results returned by deep feedforward networks. this paper investigates deep recurrent neural networks, which combine the multiple levels of representation that have proved so effective in deep networks with the flexible use of long range context that empowers rnns. when trained end-to-end with suitable regularisation, we find that deep long short-term memory rnns achieve a test set error of 17.7% on the timit phoneme recognition benchmark, which to our knowledge is the best recorded score. alexgraves, abdel -, universityoftoronto recurrent neural networks, deep neural networks, speech recognition section: introduction neural networks have a long history in speech recognition, usually in combination with hidden markov models. they have gained attention in recent years with the dramatic improvements in acoustic modelling yielded by deep feedforward networks. given that speech is an inherently dynamic process, it seems natural to consider recurrent neural networks (rnns) as an alternative model. hmm-rnn systems have also seen a recent revival, but do not currently perform as well as deep networks. instead of combining rnns with hmms, it is possible to train rnns 'end-to-end' for speech recognition. this approach exploits the larger state-space and richer dynamics of rnns compared to hmms, and avoids the problem of using potentially incorrect alignments as training targets. the combination of long short-term memory, an rnn architecture with an improved memory, with end-to-end training has proved especially effective for cursive handwriting recognition. however it has so far made little impact on speech recognition. rnns are inherently deep in time, since their hidden state is a function of all previous hidden states. the question that inspired this paper was whether rnns could also benefit from depth in space; that is from stacking multiple recurrent hidden layers on top of each other, just as feedforward layers are stacked in conventional deep networks. to answer this question we introduce deep long short-term memory rnns and assess their potential for speech recognition. we also present an enhancement to a recently introduced end-to-end learning method that jointly trains two separate rnns as acoustic and linguistic models. sections [reference] and [reference] describe the network architectures and training methods, sec: experiments provides experimental results and concluding remarks are given in sec: conclusion. section: recurrent neural networks given an input sequence, a standard recurrent neural network (rnn) computes the hidden vector sequence and output vector sequence by iterating the following equations from to: where the terms denote weight matrices (e.g. is the input-hidden weight matrix), the terms denote bias vectors (e.g. is hidden bias vector) and is the hidden layer function. is usually an elementwise application of a sigmoid function. however we have found that the long short-term memory (lstm) architecture, which uses purpose-built memory cells to store information, is better at finding and exploiting long range context. fig: lstm illustrates a single lstm memory cell. for the version of lstm used in this paper is implemented by the following composite function: where is the logistic sigmoid function, and,, and are respectively the input gate, forget gate, output gate and cell activation vectors, all of which are the same size as the hidden vector. the weight matrices from the cell to gate vectors (e.g.) are diagonal, so element in each gate vector only receives input from element of the cell vector. one shortcoming of conventional rnns is that they are only able to make use of previous context. in speech recognition, where whole utterances are transcribed at once, there is no reason not to exploit future context as well. bidirectional rnns (brnns) do this by processing the data in both directions with two separate hidden layers, which are then fed forwards to the same output layer. as illustrated in fig: brnn, a brnn computes the forward hidden sequence, the backward hidden sequence and the output sequence by iterating the backward layer from to, the forward layer from to and then updating the output layer: combing brnns with lstm gives bidirectional lstm, which can access long-range context in both input directions. a crucial element of the recent success of hybrid hmm-neural network systems is the use of deep architectures, which are able to build up progressively higher level representations of acoustic data. deep rnns can be created by stacking multiple rnn hidden layers on top of each other, with the output sequence of one layer forming the input sequence for the next. assuming the same hidden layer function is used for all layers in the stack, the hidden vector sequences are iteratively computed from to and to: where we define. the network outputs are deep bidirectional rnns can be implemented by replacing each hidden sequence with the forward and backward sequences and, and ensuring that every hidden layer receives input from both the forward and backward layers at the level below. if lstm is used for the hidden layers we get deep bidirectional lstm, the main architecture used in this paper. as far as we are aware this is the first time deep lstm has been applied to speech recognition, and we find that it yields a dramatic improvement over single-layer lstm. section: network training we focus on end-to-end training, where rnns learn to map directly from acoustic to phonetic sequences. one advantage of this approach is that it removes the need for a predefined (and error-prone) alignment to create the training targets. the first step is to to use the network outputs to parameterise a differentiable distribution over all possible phonetic output sequences given an acoustic input sequence. the log-probability of the target output sequence can then be differentiated with respect to the network weights using backpropagation through time, and the whole system can be optimised with gradient descent. we now describe two ways to define the output distribution and hence train the network. we refer throughout to the length of as, the length of as, and the number of possible phonemes as. subsection: connectionist temporal classification the first method, known as connectionist temporal classification (ctc), uses a softmax layer to define a separate output distribution at every step along the input sequence. this distribution covers the phonemes plus an extra blank symbol which represents a non-output (the softmax layer is therefore size). intuitively the network decides whether to emit any label, or no label, at every timestep. taken together these decisions define a distribution over alignments between the input and target sequences. ctc then uses a forward-backward algorithm to sum over all possible alignments and determine the normalised probability of the target sequence given the input sequence. similar procedures have been used elsewhere in speech and handwriting recognition to integrate out over possible segmentations; however ctc differs in that it ignores segmentation altogether and sums over single-timestep label decisions instead. rnns trained with ctc are generally bidirectional, to ensure that every depends on the entire input sequence, and not just the inputs up to. in this work we focus on deep bidirectional networks, with defined as follows: where is the element of the length unnormalised output vector, and is the number of bidirectional levels. subsection: rnn transducer ctc defines a distribution over phoneme sequences that depends only on the acoustic input sequence. it is therefore an acoustic-only model. a recent augmentation, known as an rnn transducer combines a ctc-like network with a separate rnn that predicts each phoneme given the previous ones, thereby yielding a jointly trained acoustic and language model. joint lm-acoustic training has proved beneficial in the past for speech recognition. whereas ctc determines an output distribution at every input timestep, an rnn transducer determines a separate distribution for every combination of input timestep and output timestep. as with ctc, each distribution covers the phonemes plus. intuitively the network 'decides' what to output depending both on where it is in the input sequence and the outputs it has already emitted. for a length target sequence, the complete set of decisions jointly determines a distribution over all possible alignments between and, which can then be integrated out with a forward-backward algorithm to determine. in the original formulation was defined by taking an 'acoustic' distribution from the ctc network, a 'linguistic' distribution from the prediction network, then multiplying the two together and renormalising. an improvement introduced in this paper is to instead feed the hidden activations of both networks into a separate feedforward output network, whose outputs are then normalised with a softmax function to yield. this allows a richer set of possibilities for combining linguistic and acoustic information, and appears to lead to better generalisation. in particular we have found that the number of deletion errors encountered during decoding is reduced. denote by and the uppermost forward and backward hidden sequences of the ctc network, and by the hidden sequence of the prediction network. at each the output network is implemented by feeding and to a linear layer to generate the vector, then feeding and to a hidden layer to yield, and finally feeding to a size softmax layer to determine: where is the element of the length unnormalised output vector. for simplicity we constrained all non-output layers to be the same size (; however they could be varied independently. rnn transducers can be trained from random initial weights. however they appear to work better when initialised with the weights of a pretrained ctc network and a pretrained next-step prediction network (so that only the output network starts from random weights). the output layers (and all associated weights) used by the networks during pretraining are removed during retraining. in this work we pretrain the prediction network on the phonetic transcriptions of the audio training data; however for large-scale applications it would make more sense to pretrain on a separate text corpus. subsection: decoding rnn transducers can be decoded with beam search to yield an n-best list of candidate transcriptions. in the past ctc networks have been decoded using either a form of best-first decoding known as prefix search, or by simply taking the most active output at every timestep. in this work however we exploit the same beam search as the transducer, with the modification that the output label probabilities do not depend on the previous outputs (so). we find beam search both faster and more effective than prefix search for ctc. note the n-best list from the transducer was originally sorted by the length normalised log-probabilty; in the current work we dispense with the normalisation (which only helps when there are many more deletions than insertions) and sort by. subsection: regularisation regularisation is vital for good performance with rnns, as their flexibility makes them prone to overfitting. two regularisers were used in this paper: early stopping and weight noise (the addition of gaussian noise to the network weights during training). weight noise was added once per training sequence, rather than at every timestep. weight noise tends to 'simplify' neural networks, in the sense of reducing the amount of information required to transmit the parameters, which improves generalisation. section: experiments phoneme recognition experiments were performed on the timit corpus. the standard 462 speaker set with all sa records removed was used for training, and a separate development set of 50 speakers was used for early stopping. results are reported for the 24-speaker core test set. the audio data was encoded using a fourier-transform-based filter-bank with 40 coefficients (plus energy) distributed on a mel-scale, together with their first and second temporal derivatives. each input vector was therefore size 123. the data were normalised so that every element of the input vectors had zero mean and unit variance over the training set. all 61 phoneme labels were used during training and decoding (so), then mapped to 39 classes for scoring. note that all experiments were run only once, so the variance due to random weight initialisation and weight noise is unknown. as shown in tab: timit, nine rnns were evaluated, varying along three main dimensions: the training method used (ctc, transducer or pretrained transducer), the number of hidden levels (1-5), and the number of lstm cells in each hidden layer. bidirectional lstm was used for all networks except ctc-3l-500h-tanh, which had units instead of lstm cells, and ctc-3l-421h-uni where the lstm layers were unidirectional. all networks were trained using stochastic gradient descent, with learning rate, momentum and random initial weights drawn uniformly from. all networks except ctc-3l-500h-tanh and pretrans-3l-250h were first trained with no noise and then, starting from the point of highest log-probability on the development set, retrained with gaussian weight noise () until the point of lowest phoneme error rate on the development set. pretrans-3l-250h was initialised with the weights of ctc-3l-250h, along with the weights of a phoneme prediction network (which also had a hidden layer of 250 lstm cells), both of which were trained without noise, retrained with noise, and stopped at the point of highest log-probability. pretrans-3l-250h was trained from this point with noise added. ctc-3l-500h-tanh was entirely trained without weight noise because it failed to learn with noise added. beam search decoding was used for all networks, with a beam width of 100. the advantage of deep networks is immediately obvious, with the error rate for ctc dropping from 23.9% to 18.4% as the number of hidden levels increases from one to five. the four networks ctc-3l-500h-tanh, ctc-1l-622h, ctc-3l-421h-uni and ctc-3l-250h all had approximately the same number of weights, but give radically different results. the three main conclusions we can draw from this are (a) lstm works much better than for this task, (b) bidirectional lstm has a slight advantage over unidirectional lstmand (c) depth is more important than layer size (which supports previous findings for deep networks). although the advantage of the transducer is slight when the weights are randomly initialised, it becomes more substantial when pretraining is used. section: conclusions and future work we have shown that the combination of deep, bidirectional long short-term memory rnns with end-to-end training and weight noise gives state-of-the-art results in phoneme recognition on the timit database. an obvious next step is to extend the system to large vocabulary speech recognition. another interesting direction would be to combine frequency-domain convolutional neural networks with deep lstm. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "timit phoneme recognition"
                    ],
                    [
                        "timit phoneme recognition benchmark"
                    ],
                    [
                        "timit corpus"
                    ]
                ],
                "Method": [
                    [
                        "long short term memory"
                    ]
                ],
                "Metric": [
                    [
                        "error"
                    ],
                    [
                        "phoneme error rate"
                    ]
                ],
                "Task": [
                    [
                        "speech recognition"
                    ],
                    [
                        "recognition"
                    ],
                    [
                        "cursive handwriting recognition"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "timit corpus",
                        "timit",
                        "timit database"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "test set error",
                        "deletion errors",
                        "error rate"
                    ]
                ],
                "Task": [
                    [
                        "speech recognition",
                        "speech",
                        "phoneme recognition"
                    ]
                ]
            }
        ]
    },
    "18168aea48a22f6fe2fe407c0ff70083cba225a7-24": {
        "doctext": "document: image restoration using very deep convolutional encoder-decoder networks with symmetric skip connections in this paper, we propose a very deep fully convolutional encoding-decoding framework for image restoration such as denoising and super-resolution. the network is composed of multiple layers of convolution and de-convolution operators, learning end-to-end mappings from corrupted images to the original ones. the convolutional layers act as the feature extractor, which capture the abstraction of image contents while eliminating noises/ corruptions. de-convolutional layers are then used to recover the image details. we propose to symmetrically link convolutional and de-convolutional layers with skip-layer connections, with which the training converges much faster and attains a higher-quality local optimum. first, the skip connections allow the signal to be back-propagated to bottom layers directly, and thus tackles the problem of gradient vanishing, making training deep networks easier and achieving restoration performance gains consequently. second, these skip connections pass image details from convolutional layers to de-convolutional layers, which is beneficial in recovering the original image. significantly, with the large capacity, we can handle different levels of noises using a single model. experimental results show that our network achieves better performance than all previously reported state-of-the-art methods../ figs/ section: introduction the task of image restoration is to recover an clean image from its corrupted observation, which is known to be an ill-posed inverse problem. by accommodating different types of corruption distributions, the same mathematical model applies to problems such as image denoising and super-resolution. recently, deep neural networks (dnns) have shown their superior performance in image processing and computer vision tasks, ranging from high-level recognition, semantic segmentation to low-level denoising, super-resolution, deblur, inpainting and recovering raw images from compressed images. despite the progress that dnns achieve, there still are some problems. for example, can a deeper network in general achieve better performance; can we design a single model to handle different levels of corruption. observing recent superior performance of dnns on image processing tasks, we propose a convolutional neural network (cnn)- based framework for image restoration. we observe that in order to obtain good restoration performance, it is beneficial to train a very deep model. meanwhile, we show that it is possible to achieve good performance with a single network when processing multiple different levels of corruptions due to the benefits of large-capacity networks. specifically, the proposed framework learns end-to-end fully convolutional mappings from corrupted images to the clean ones. the network is composed of multiple layers of convolution and de-convolution operators. as deeper networks tend to be more difficult to train, we propose to symmetrically link convolutional and de-convolutional layers with skip-layer connections, with which the training converges much faster and attains a higher-quality local optimum. our main contributions are briefly outlined as follows: 1) a very deep network architecture, which consists of a chain of symmetric convolutional and deconvolutional layers, for image restoration is proposed in this paper. the convolutional layers act as the feature extractor which encode the primary components of image contents while eliminating the corruption. the deconvolutional layers then decode the image abstraction to recover the image content details. 2) we propose to add skip connections between corresponding convolutional and de-convolutional layers. these skip connections help to back-propagate the gradients to bottom layers and pass image details to the top layers, making training of the end-to-end mapping more easier and effective, and thus achieve performance improvement while the network going deeper. 3) relying on the large capacity and fitting ability of our very deep network, we propose to handle different level of noises/ corruption using a single model. to our knowledge, this is the first approach that achieves good accuracy for processing different levels of noises with a single model. 4) experimental results demonstrate the advantages of our network over other recent state-of-the-art methods on image denoising and super-resolution, setting new records on these topics. related work extensive work has been done on image restoration in the literature. see detail reviews in a survey. traditional methods such as total variation, bm3d algorithm and dictionary learning based methods have shown very good performance on image restoration topics such as image denoising and super-resolution. since image restoration is in general an ill-posed problem, the use of regularization has been proved to be essential. an active (and probably more promising) category for image restoration is the dnn based methods. stacked denoising auto-encoder is one of the most well-known dnn models which can be used for image restoration. xie et al. combined sparse coding and dnn pre-trained with denoising auto-encoder for low-level vision tasks such as image denoising and inpainting. other neural networks based methods such as multi-layer perceptron and cnn for image denoising, as well as dnn for image or video super-resolution and compression artifacts reduction have been actively studied in these years. burger et al. presented a patch-based algorithm learned with a plain multi-layer perceptron. they also concluded that with large networks, large training data, neural networks can achieve state-of-the-art image denoising performance. jain and seung proposed fully convolutional cnn for denoising. they found that cnn provide comparable or even superior performance to wavelet and markov random field (mrf) methods. cui et al. employed non-local self-similarity (nlss) search on the input image in multi-scale, and then used collaborative local auto-encoder for super-resolution in a layer by layer fashion. dong et al. proposed to directly learn an end-to-end mapping between the low/ high-resolution images. wang et al. argued that domain expertise represented by the conventional sparse coding can be combined to achieve further improved results. in general, dnn-based methods learn restoration parameters directly from data, which tends to been more effective in real-world image restoration applications. an advantage of dnn methods is that these methods are purely data driven and no assumption about the noise distributions are made. section: very deep red-net for image restoration the proposed framework mainly contains a chain of convolutional layers and symmetric deconvolutional layers, as shown in figure [reference]. we term our method ''red-net''\u2014very deep residual encoder-decoder networks. subsection: architecture the framework is fully convolutional and deconvolutional. rectification layers are added after each convolution and deconvolution. the convolutional layers act as feature extractor, which preserve the primary components of objects in the image and meanwhile eliminating the corruptions. the deconvolutional layers are then combined to recover the details of image contents. the output of the deconvolutional layers is the ''clean'' version of the input image. moreover, skip connections are also added from a convolutional layer to its corresponding mirrored deconvolutional layer. the passed convolutional feature maps are summed to the deconvolutional feature maps element-wise, and passed to the next layer after rectification. for low-level image restoration problems, we use neither pooling nor unpooling in the network as usually pooling discards useful image details that are essential for these tasks. motivated by the vgg model, the kernel size for convolution and deconvolution is set to, which has shown excellent image recognition performance. it is worth mentioning that the size of input image can be arbitrary since our network is essentially a pixel-wise prediction. the input and output of the network are images of the same size, where, and are width, height and number of channels. in this paper, we use although it is straightforward to apply to images with. we found that using 64 feature maps for convolutional and deconvolutional layers achieves satisfactory results, although more feature maps leads to slightly better performance. deriving from the above architecture, we propose two networks, which are 20-layer and 30-layer respectively. subsubsection: deconvolution decoder architectures combining layers of convolution and deconvolution have been proposed for semantic segmentation lately. in contrast to convolutional layers, in which multiple input activations within a filter window are fused to output a single activation, deconvolutional layers associate a single input activation with multiple outputs. one can simply replace deconvolution with convolution, which results in a architecture that is very similar to recently proposed very deep fully convolutional neural networks. however, there exist essential differences between a fully convolution model and our model. in the fully convolution case, the noise is eliminated step by step, i.e., the noise level is reduced after each layer. during this process, the details of the image content may be lost. nevertheless, in our network, convolution preserves the primary image content. then deconvolution is used to compensate the details. we compare the 5-layer and 10-layer fully convolutional network with our network (combining convolution and deconvolution, but without skip connection). for fully convolutional networks, we use padding and up-sample the input to make the input and output the same size. for our network, the first 5 layers are convolutional and the second 5 layers are deconvolutional. all the other parameters for training are the same, i.e., trained with sgd and learning rate of, noise level. in terms of psnr, using deconvolution works better than the fully convolutional counterpart. we see that, the fully convolutional network reduces noise layer by layer, and our network preserve primary image contents by convolution and recover some details by using deconvolution. detailed results are in the supplementary materials. subsubsection: skip connections an intuitive question is that, is deconvolution able to recover image details from the image abstraction only? we find that in shallow networks with only a few layers of convolution, deconvolution is able to recover the details. however, when the network goes deeper or using operations such as max pooling, deconvolution does not work so well, possibly because too much details are already lost in the convolution. the second question is that, when our network goes deeper, does it achieve performance gain? we observe that deeper networks often suffer from gradients vanishing and become hard to train\u2014 a problem that is well addressed in the literature. to address the above two problems, inspired by highway networks and deep residual networks, we add skip connections between two corresponding convolutional and deconvolutional layers as shown in figure [reference]. a building block is shown in figure [reference]. there are two reasons for using such connections. first, when the network goes deeper, as mentioned above, image details can be lost, making deconvolution weaker in recovering them. however, the feature maps passed by skip connections carry much image detail, which helps deconvolution to recover a better clean image. second, the skip connections also achieve benefits on back-propagating the gradient to bottom layer, which makes training deeper network much easier as observed in and. note that our skip layer connections are very different from the ones proposed in and, where the only concern is on the optimization side. in our case, we want to pass information of the convolutional feature maps to the corresponding deconvolutional layers. instead of directly learning the mappings from input to the output, we would like the network to fit the residual of the problem, which is denoted as. such a learning strategy is applied to inner blocks of the encoding-decoding network to make training more effective. skip connections are passed every two convolutional layers to their mirrored deconvolutional layers. other configurations are possible and our experiments show that this configuration already works very well. using such shortcuts makes the network easier to be trained and gains restoration performance via increasing network depth. the very deep highway networks are essentially feed-forward long short-term memory (lstms) with forget gates; and the cnn layers of deep residual network are feed-forward lstms without gates. note that our deep residual networks are in general not in the format of standard feed-forward lstms. subsection: discussions training with symmetric skip connections as mentioned above, using skip connections mainly has two benefits: (1) passing image detail forwardly, which helps recovering clean images and (2) passing gradient backwardly, which helps finding better local minimum. we design experiments to show these observations. we first compare two networks trained for denoising noises of. in the first network, we use 5 layers of convolution with stride 3. the input size of training data is, which results in a vector after 5 layers of convolution. then deconvolution is used to recover the input. the second network uses the same settings as the first one, except for adding skip connections. the results are show in figure [reference] (a). we can observe that it is hard for deconvolution to recover details from only a vector encoding the abstraction of the input, which shows that the ability on recovering image details for deconvolution is limited. however, if we use skip connections, the network can still recover the input, because details are passed to topper layers in the network. we also train five networks to show that using skip connections help to back-propagate gradient in training to better fit the end-to-end mapping, as shown in figure [reference] (b). the five networks are: 10, 20 and 30 layer networks without skip connections, and 20, 30 layer networks with skip connections. as we can see, the training loss increases when the network going deeper without shortcuts (similar phenomenon is also observed in), but we obtain smaller loss when using skip connections. comparison with deep residual networks [] one may use different types of skip connections in our network, a straightforward alternate is that in. in, the skip connections are added to divide the network into sequential blocks. a benefit of our model is that our skip connections have element-wise correspondence, which can be very important in pixel-wise prediction problems. we carry out experiments to compare the two types of skip connections. here the block size indicates the span of the connections. the results are shown in figure [reference] (c). we can observe that our connections often converge to a better optimum, demonstrating that element-wise correspondence can be important. dealing with different levels of noises/ corruption an important question is, can we handle different levels of corruption with a single model. almost all existing methods need to train different models for different levels of corruption and estimate the corruption level at first. we use a trained model in, to denoise different levels of noises with being 10, 30, 50 and 70. the obtained average psnr on the 14 images are 29.95db, 27.81db, 18.62db and 14.84db, respectively. the results show that the parameters trained on a single noise level can not handle different levels of noises well. therefore, in this paper, we aim to train a single model for recovering different levels of corruption, which are different noise levels in the task of image denoising and different scaling parameters in image super-resolution. the large capacity of the network is the key to this success. subsection: training learning the end-to-end mapping from corrupted images to clean ones needs to estimate the weights represented by the convolutional and deconvolutional kernels. this is achieved by minimizing the euclidean loss between the outputs of the network and the clean image. in specific, given a collection of training sample pairs, where is a corrupted image and is the clean version as the groundtruth. we minimize the following mean squared error (mse): we implement and train our network using caffe. in practice, we find that using adam with learning rate for training converges faster than traditional stochastic gradient descent (sgd). the base learning rate for all layers are the same, different from, in which a smaller learning rate is set for the last layer. this trick is not necessary in our network. as general settings in the literature, we use gray-scale image for denoising and the luminance channel for super-resolution in this paper. 300 images from the berkeley segmentation dataset (bsd) are used to generate the training set. for each image, patches of size are sampled as ground truth. for denoising, we add additive gaussian noise to the patches multiple times to generate a large training set (about 0.5 m). for super-resolution, we first down-sample a patch and then up-sample it to its original size, obtaining a low-resolution version as the input of the network. subsection: testing although trained on local patches, our network can perform denoising and super-resolution on images of arbitrary size. given a testing image, one can simply go forward through the network, which is able to obtain a better performance than existing methods. to achieve more smooth results, we propose to process a corrupted image on multiple orientations. different from segmentation, the filter kernels in our network only eliminate the corruptions, which is not sensitive to the orientation of image contents. therefore, we can rotate and mirror flip the kernels and perform forward multiple times, and then average the output to get a more smooth image. we see that this can lead to slightly better denoising and super-resolution performance. section: experiments in this section, we provide evaluation of denoising and super-resolution performance of our models against a few existing state-of-the-art methods. denoising experiments are performed on two datasets: 14 common benchmark images and the bsd200 dataset. we test additive gaussian noises with zero mean and standard deviation 10, 30, 50 and 70 respectively. bm3d, ncsr, epll, pclr, pdpd and wmmn are compared with our method. for super-resolution, we compare our network with srcnn, nbsrf, cscn, csc, tse and arfl+ on three dataset: set5, set14 and bsd100. the scaling parameter are tested with 2, 3 and 4. peak signal-to-noise ratio (psnr) and structural similarity (ssim) index are calculated for evaluation. for our method, which is denoted as red-net, we implement three versions: red10 contains 5 convolutional and deconvolutional layers without shortcuts, red20 contains 10 convolutional and deconvolutional layers with shortcuts, and red30 contains 15 convolutional and deconvolutional layers with shortcuts. subsection: image denoising evaluation on the 14 images table [reference] presents the psnr and ssim results of 10, 30, 50, and 70. we can make some observations from the results. first of all, the 10 layer convolutional and deconvolutional network has already achieved better results than the state-of-the-art methods, which demonstrates that combining convolution and deconvolution for denoising works well, even without any skip connections. moreover, when the network goes deeper, the skip connections proposed in this paper help to achieve even better denoising performance, which exceeds the existing best method wnnm by 0.32db, 0.43db, 0.49db and 0.51db on noise levels of being 10, 30, 50 and 70 respectively. while wnnm is only slightly better than the second best existing method pclr by 0.01db, 0.06db, 0.03db and 0.01db respectively, which shows the large improvement of our model. last, we can observe that the more complex the noise is, the more improvement our model achieves than other methods. similar observations can be made on the evaluation of ssim. evaluation on bsd200 for testing efficiency, we convert the images to gray-scale and resize them to smaller ones on bsd-200. then all the methods are run on these images to get average psnr and ssim results of 10, 30, 50, and 70, as shown in table [reference]. for existing methods, their denoising performance does not differ much, while our model achieves 0.38db, 0.47db, 0.49db and 0.42db higher of psnr over wnnm. subsection: image super-resolution the evaluation on set5 is shown in table [reference]. our 10-layer network outperforms the compared methods already, and we achieve better performance with deeper networks. the 30-layer network exceeds the second best method cscn for 0.52db, 0.56db and 0.47db on scale 2, 3 and 4 respectively. the evaluation on set14 is shown in table [reference]. the improvement on set14 in not as significant as that on set5, but we can still observe that the 30 layer network achieves higher psnr than the second best cscn for 0.23db, 0.06db and 0.1db. the results on bsd100, as shown in table [reference], is similar than that on set5. the second best method is still cscn, the performance of which is not as good as our 10 layer network. our deeper network obtains much more performance gain than the others. subsection: evaluation with a single model to construct the training set, we extract image patches with different noise levels and scaling parameters for denoising and super-resolution. then a 30-layer network is trained for the two tasks respectively. the evaluation results are shown in table [reference] and table [reference]. although training with different levels of corruption, we can observe that the performance of our network only slightly degrades comparing to the case in which using separate models for denoising and super-resolution. this may be due the fact that the network has to fit much more complex mappings. except that cscn works slightly better on super-resolution with scales 3 and 4, our network still beats the existing methods, showing that our network works much better in image denoising and super-resolution even using only one single model to deal with complex corruption. section: conclusions in this paper we have proposed a deep encoding and decoding framework for image restoration. convolution and deconvolution are combined, modeling the restoration problem by extracting primary image content and recovering details. more importantly, we propose to use skip connections, which helps on recovering clean images and tackles the optimization difficulty caused by gradient vanishing, and thus obtains performance gains when the network goes deeper. experimental results and our analysis show that our network achieves better performance than state-of-the-art methods on image denoising and super-resolution. x.-j. mao's contribution was made when visiting the university of adelaide. this work was in part supported by arc future fellowship (ft120100969). correspondence should be addressed to c. shen. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "berkeley segmentation dataset"
                    ],
                    [
                        "set14"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "image restoration"
                    ],
                    [
                        "restoration"
                    ],
                    [
                        "denoising"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "berkeley segmentation dataset",
                        "bsd",
                        "bsd100"
                    ]
                ],
                "Method": [
                    [
                        "red30"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "peak signal-to-noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "super-resolution",
                        "image super-resolution"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "berkeley segmentation dataset",
                        "bsd",
                        "bsd100"
                    ]
                ],
                "Method": [
                    [
                        "red30"
                    ]
                ],
                "Metric": [
                    [
                        "structural similarity",
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "super-resolution",
                        "image super-resolution"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set5"
                    ]
                ],
                "Method": [
                    [
                        "red30"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "peak signal-to-noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "super-resolution",
                        "image super-resolution"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set5"
                    ]
                ],
                "Method": [
                    [
                        "red30"
                    ]
                ],
                "Metric": [
                    [
                        "structural similarity",
                        "ssim"
                    ]
                ],
                "Task": [
                    [
                        "super-resolution",
                        "image super-resolution"
                    ]
                ]
            }
        ]
    },
    "193089d56758ab88391d846edd08d359b1f9a863-25": {
        "doctext": "document: a discriminatively learned cnn embedding for person re-identification in this paper, we revisit two popular convolutional neural networks (cnn) in person re-identification (re-id), i.e., verification and identification models. the two models have their respective advantages and limitations due to different loss functions. in this paper, we shed light on how to combine the two models to learn more discriminative pedestrian descriptors. specifically, we propose a siamese network that simultaneously computes the identification loss and verification loss. given a pair of training images, the network predicts the identities of the two input images and whether they belong to the same identity. our network learns a discriminative embedding and a similarity measurement at the same time, thus making full usage of the re-id annotations. our method can be easily applied on different pre-trained networks. albeit simple, the learned embedding improves the state-of-the-art performance on two public person re-id benchmarks. further, we show our architecture can also be applied in image retrieval. large-scale person re-identification, convolutional neural networks. section: introduction person re-identification (re-id) is usually viewed as an image retrieval problem, which matches pedestrians from different cameras. given a person-of-interest (query), person re-id determines whether the person has been observed by another camera. recent progress in this area has been due to two factors: 1) the availability of the large-scale pedestrian datasets. the datasets contain the general visual variance of pedestrian and provide a comprehensive evaluation. 2) the learned embedding of pedestrian using a convolutional neural network (cnn). recently, the convolutional neural network (cnn) has shown potential for learning state-of-the-art feature embeddings or deep metrics. as shown in fig. [reference], there are two major types of cnn structures, i.e., verification models and identification models. the two models are different in terms of input, feature extraction and loss function for training. our motivation is to combine the strengths of the two models and learn a more discriminative pedestrian embedding. verification models take a pair of images as input and determine whether they belong to the same person or not. a number of previous works treat person re-id as a binary-class classification task or a similarity regression task. given a label, the verification network forces two images of the same person to be mapped to nearby points in the feature space. if the images are of different people, the points are far apart. however, the major problem in the verification models is that they only use weak re-id labels, and do not take all the annotated information into consideration. therefore, the verification network lacks the consideration of the relationship between the image pairs and other images in the dataset. in the attempt to take full advantages of the re-id labels, identification models which treat person re-identification as a multi-class recognition task, are employed for feature learning. they directly learn the non-linear functions from an input image to the person id and the cross-entropy loss is used following the final layer. during testing, the feature is extracted from a fully connected layer and then normalized. the similarity of two images is thus computed by the euclidean distance between their normalized cnn embeddings. the major drawback of the identification model is that the training objective is different from the testing procedure, i.e., it does not account for the similarity measurement between image pairs, which can be problematic during the pedestrian retrieval process. the above-mentioned observations demonstrate that the two types of models have complementary advantages and limitations as shown in table [reference]. motivated by these properties, this work proposes to combine the strengths of the two networks and leverage their complementary nature to improve the discriminative ability of the learned embeddings. the proposed model is a siamese network that predicts person identities and similarity scores at the same time. compared to previous networks, we take full advantages of the annotated data in terms of pair-wise similarity and image identities. during testing, the final convolutional activations are extracted for euclidepdfan distance based pedestrian retrieval. to summarize, our contributions are: we propose a siamese network that has two losses: identification loss and verification loss. this network simultaneously learns a discriminative cnn embedding and a similarity metric, thus improving pedestrian retrieval accuracy. we report competitive accuracy compared to the state-of-art methods on two large-scale person re-id datasets (market1501 and cuhk03) and one instance retrieval dataset (oxford5k). the paper is organized as follows. we first review some related works in section [reference]. in section [reference], we describe how we combine the two losses and define the cnn structure. the implementation details are provided. in section [reference], we present the experimental results on two large-scale person re-identification datasets and one instance retrieval dataset. we conclude this paper in section [reference]. section: related work in this section we describe previous works relevant to the approach discussed in this paper. they are mainly based on verification models or identification models. subsection: verification models in 1993, bromley et al. first used verification models to deep metric learning in signature verification. verification models usually take a pair of images as input and output a similarity score by calculating the cosine distance between low-dimensional features, which can be penalized by the contrastive loss. recently researchers have begun to apply verification models to person re-identification with a focus on data augmentation and image matching. yi et al. split a pedestrian image into three horizontal parts and train three part-cnns to extract features. the similarity of two images is computed by the cosine distance of their features. similarly, cheng et al. split the convolutional map into four parts and fuse the part features with the global features. li et al. add a patch-matching layer that multiplies the activation of two images in different horizontal stripes. they use it to find similar locations and treat similarity regression as binary-class penalized by softmax loss. later, ahmed et al. improve the verification model by adding a different matching layer that compares the activation of two images in neighboring pixels. besides, wu et al. use smaller filters and a deeper network to extract features. varior et al. combine cnn with some gate functions, similar to long-short-term memory (lstm) in spirit, which aims to adaptively focus on the similar parts of input image pairs. but it is limited by the computational inefficiency because the query image has to pair with every gallery image to pass through the network. moreover, ding et al. use triplet samples for training the network which considers the images from the same people and the different people at the same time. subsection: identification models recent datasets such as cuhk03 and market1501 provide large-scale training sets, which make it possible to train a deeper classification model without over-fitting. every identity has 9.6 training images on average in cuhk03 and has 17.2 images in market1501. cnn can learn discriminative embeddings by itself without part-matching. zheng et al. directly use a conventional fine-tuning approach on market1501, prw and mars and outperform many recent results. wu et al. combine cnn embeddings with the hand-crafted features in the fc layer. besides, xiao et al. jointly train a classification model using multiple datasets and propose a new dropout function to deal with the hundreds of classes. in, xiao et al. train a classification model similar to the faster-rcnn method and automatically predict the location of the candidate pedestrian from the whole image, which alleviates the pedestrian detection errors. subsection: verification-identification models in face recognition, the\" deepid networks\" train the network with the verification and identification losses, which is similar to our network. in, sun et al. jointly train face identification and verification. then more verification supervision is added into the model and a deeper network is used. our method is different from their models in the following aspects. first, in face recognition, the training dataset contains 202, 599 face images of 10, 177 identities while the current largest person re-i d training dataset contains 12, 936 images of 751 identities. deepid networks apply contrastive loss to the verification problem, wile our model uses the cross-entropy loss. we find that the contrastive loss leads to over-fitting when the number of images is limited. in the experiment, we show the proposed method learns more robust person representative and outperforms using contrastive loss. second, dropout can not be applied on the embedding before the contrastive loss, which introduces zero values at random locations. on the contrary, we can add dropout regularization on the embedding in the proposed model. third, the deepid networks are trained from scratch, while our model benefits from the networks pretrained on imagenet. finally, we evaluate our method on the tasks of person re-id and instance retrieval, providing more insights in the verification-classification models. section: proposed method subsection: preview fig. [reference] (a) and fig. [reference] (b) illustrate the relational graph built by verification and identification models. in a sample batch of size, red edges represent the positive pairs (the same person) and blue edges represent the negative pairs (different persons). the dotted edges denote implicit relationships built by the identification loss and the solid edges denote explicit relationships built by the verification loss. in verification models, there are several operations between the two inputs. the explicit relationship between data is built by the pair-wise comparison, such as part matching or contrastive loss. for example, contrastive loss directly calculates the euclidean distance between two embeddings. in identification models, the input is independent to each other. but there is implicit relationship between the learned embeddings built by the cross-entropy loss. the cross-entropy loss can be formulated as. is the weight of the linear function. are the embeddings of the two images from the same class. to maximize,, the network converges when and have similar vector direction with. in, similar observation and visualization are shown. so the learned embeddings are eventually close for images within the same class and far away for images in the different classes. the relationship is implicitly built between and bridged by the weight. due to the usage of the weak labels, verification models take limited relationships into consideration. on the other hand, classification models do not explicitly consider similarity measurements. fig. [reference] (c) illustrates how our model works in a batch. we benefit from simultaneously considering the verification and identification losses. the proposed model thus combines the strength of the two models (see table [reference]). subsection: overall network our network is basically a convolutional siamese network that combines the verification and identification losses. fig. [reference] briefly illustrates the architecture of the proposed network. given an input pair of images resized to, the proposed network simultaneously predicts the ids of the two images and the similarity score. the network consists of two imagenet pre-trained cnn models, three additional convolutional layers, one square layer and three losses. it is supervised by the identification label and the verification label. the pre-trained cnn model can be caffenet, vgg16 or resnet-50, from which we have removed the final fully-connected (fc) layer. the re-id performance of the three models is comprehensively evaluated in section [reference]. here, we do not provide detailed descriptions of the architecture of the cnn models and only take caffenet as an example in the following subsections. the three optimization objectives include two identification losses and one verification loss. we use the final convolutional activations as the discriminative descriptor for person re-id, which is directly supervised by three objectives. subsection: identification loss there are two caffenets in our architecture. they share weights and predict the two identity labels of the input image pair simultaneously. in order to fine-tune the network on a new dataset, we replace the final fully-connected layer (1, 000-dim) of the pre-trained cnn model with a convolutional layer. the number of the training identities in market-1501 is 751. so this convolutional layer has kernels of size connected to the output of caffenet and then we add a softmax unit to normalize the output. the size of the result tensor is. the rectified linear unit (relu) is not added after this convolution. similar to conventional multi-class recognition approaches, we use the cross-entropy loss for identity prediction, which is here denotes the convolutional operation. is a tensor, is the target class and denotes the parameters of the added convolutional layer. is the predicted probability, is the target probability. for all except. subsection: verification loss while some previous works contain a matching function in the intermediate layers, our work directly compares the high-level features for similarity estimation. the high-level feature from the fine-tuned cnn has shown a discriminative ability and it is more compact than the activations in the intermediate layers. so in our model, the pedestrian descriptor in the identification model are directly supervised by the verification loss. as shown in fig. [reference], we introduce a non-parametric layer called square layer to compare the high-level features. it takes two tensors as inputs and outputs one tensor after subtracting and squaring element-wisely. the square layer is denoted as, where are the 4, 096-dim embeddings and is the output tensor of the square layer. we then add a convolutional layer and the softmax output function to embed the resulting tensor to a 2-dim vector (,) which represents the predicted probability of the two input images belonging to the same identity. the convolutional layer takes as input and filters it with kernels of size. the relu is not added after this convolution. we treat pedestrian verification as a binary classification problem and use the cross-entropy loss that is similar to the one in the identification loss, which is here are the two tensors of size. is the target class (same/ different), denotes the parameters of the added convolutional layer and is the predicted probability. if the image pair depicts the same person,; otherwise,. departing from, we do not use the contrastive loss. on the one hand, the contrastive loss, as a regression loss, forces the same-class embeddings to be as close as possible. it may make the model over-fitting because the number of training of each identity is limited in person re-id. on the other hand, dropout, which introduces zero values at random locations, can not be applied on the embedding before the contrastive loss. but the cross-entropy loss in our model can work with dropout to regularize the model. in section [reference], we show that the result using contrastive loss is 4.39% and 6.55% lower than the one using the cross-entropy loss on rank-1 accuracy and map respectively. subsection: identification vs. verification the proposed network is trained to minimize the three cross-entropy losses jointly. to figure out which objective contributes more, we train the identification model and verification model separately. following the learning rate setting in section [reference], we train the models until convergence. we also train the network with the two losses jointly until two objectives both converge. as the quantitative results shown in table [reference], the fine-tuned cnn model with two kinds of losses outperforms the one trained individually. this result has been confirmed on the three different network structures. further, we visualize the intermediate feature maps that are trained using resnet-50 as the pretrained model and try to find the differences between identification loss and verification loss. we select three test images in the market1501. one image is considered to be well detected and the other two images are not well aligned. given one image as input, we get its activation in the intermediate layer\" res4fx\", the size of which is. we visualize the sum of several activation maps. as shown in fig. [reference], the identification and the verification networks exhibit different activation patterns to the pedestrian. we find that if we use only one kind of loss, the network tends to find one discriminative part. the proposed model takes advantages of both networks, so the new activation map is mostly a union of the two individual maps. this also illustrates the complementary nature of the two baseline networks. the proposed model makes more neurons activated. moreover, as shown in fig. [reference] we visualize the embedding by plot them to the 2-dimension map. in regard to fig. [reference], we find the network usually has strong attention on the center part of the human (usually clothes) and it also illustrates the color of the clothes is the major clue for the person re-identification. subsection: training and optimization input preparation. we resize all the training images to. the mean image computed from all the training images is subtracted from all the images. during training, all the images are randomly cropped to for caffenet and mirrored horizontally. for resnet-50 and vgg16, we randomly crop images to. we shuffle the dataset and use a random order of the images. then we sample another image from the same/ different class to compose a positive/ negative pair. the initial ratio between negative pairs and positive pairs is to alleviate the prediction bias and we multiple it by a factor of every epoch until it reaches, since the number of positive pairs is so limited that the network risks over-fitting. training. we use the matconvnet package for training and testing the embedding with caffenet, vgg16 and resnet-50, respectively. the maximum number of training epochs is set to 75 for resnet-50, 65 for vgg16net and 155 for caffenet. the batch size (in image pairs) is set to 128 for caffenet, 48 for vgg16 and resnet-50. the learning rate is initialized as 0.001 and then set to 0.0001 for the final 5 epochs. we adopt the mini-batch stochastic gradient descent (sgd) to update the parameters of the network. there are three objectives in our network. therefore, we first compute all the gradients produced by every objectives respectively and add the weighted gradients together to update the network. we assign a weight of 1 to the gradient produced by the verification loss and 0.5 for the two gradients produced by two identification losses. moreover, we insert the dropout function before the final convolutional layer. testing. we adopt an efficient method to extract features as well as the activation in the intermediate layer. because two caffenet share weights, our model has nearly the same memory consumption with the pretrained model. so we extract features by only activating one fine-tuned model. given a image, we feed forward the image to one caffenet in our network and obtain a 4, 096-dim pedestrian descriptor. once the descriptors for the gallery sets are obtained, they are stored offline. given a query image, its descriptor is extracted online. we sort the cosine distance between the query and all the gallery features to obtain the final ranking result. note that the cosine distance is equivalent to euclidean distance when the feature is l2-normalized. section: experiments we mainly verify the proposed model on two large-scale datasets market1501 and cuhk03. we report the results trained by three network structures. besides, we also report the result on market1501+ 500k dataset. meanwhile, the proposed architecture is also applied on the image retrieval task. we modify our model and test it on a popular image retrieval dataset, i.e., oxford buildings. the performance is comparable to the state of the art. subsection: dataset market1501 contains 32, 668 annotated bounding boxes of 1, 501 identities. images of each identity are captured by at most six cameras. according to the dataset setting, the training set contains 12, 936 cropped images of 751 identities and testing set contains 19, 732 cropped images of 750 identities and distractors. they are directly detected by the deformable part model (dpm) instead of using hand-drawn bboxes, which is closer to the realistic setting. for each query, we aim to retrieve the ground truth images from the 19, 732 candidate images. the searching pool (gallery) is important to person re-identification. in the realistic setting, the scale of the gallery is usually large. the distractor dataset of market1501 provides extra 500, 000 bboxes, consisting of false alarms on the background as well as the persons not belonging to any of the original 1, 501 identities. when testing, we add the 500k images to the original gallery, which makes the retrieval more difficult. cuhk03 dataset contains 14, 097 cropped images of 1, 467 identities collected in the cuhk campus. each identity is observed by two camera views and has 4.8 images in average for each view. the author provides two kinds of bounding boxes. we evaluate our model on the bounding boxes detected by dpm, which is closer to the realistic setting. following the setting of the dataset, the dataset is partitioned into a training set of 1, 367 persons and a testing set of 100 persons. the experiment is repeated with 20 random splits. both the single-shot and multiple-shot results will be reported. oxford5k buildings consists of 5062 images collected from the internet and corresponding to particular oxford landmarks. some images have complex structures and may contain other buildings. the images corresponding to 11 oxford landmarks are manually annotated and a set of 55 queries for 11 different landmarks are provided. this benchmark contains many high-resolution images and the mean image size of this dataset is. we use the rank-1 accuracy and mean average precision (map) for performance evaluation on market1501 (+ 100k) and cuhk03, while on oxford, we use map. subsection: person re-i d evaluation comparison with the cnn baseline. we train the baseline networks according the conventional fine-tuning method. the baseline networks are pretrained on imagenet and fine-tuned to predict the person identities. as shown in tab. [reference], we obtain 50.89%, 65.02% and 73.69% rank-1 accuracy by caffenet, vgg16 and resnet-50, respectively on market1501. note that using the baseline alone exceeds many previous works. our model further improves these baselines on market1501. the improvement can be observed on three network architectures. to be specific, we obtain 11.25%, 5.14% and 5.82% improvement, respectively, using caffenet, vgg16 and resnet-50 on market1501. similarly, we observe 35.8%, 49.1% and 71.5% baseline rank-1 accuracy on cuhk03 in single-shot setting. as show in tab. [reference], these baseline results exceed some previous works as well. we further get 14.0%, 22.7% and 11.9% improvement on the baseline by our method. these results show that our method can work with different networks and improve their results. it indicates that the proposed model helps the network to learn more discriminative features. cross-entropy vs. contrastive loss. we replace the cross-entropy loss with the contrastive loss as used in\" deepid network\". however, we find a 4.39% and 6.55% drop in rank-1 and map. the resnet-50 model using the contrastive loss has 75.12% rank-1 accuracy and 53.32% map. we speculate that the contrastive loss tends to over-fit on the re-id dataset because no regularization is added to the verification. cross-entropy loss designed in our model can work with the dropout function and avoid the over-fitting. comparison with the state of the art. as shown in table [reference], we compare our method with other state-of-the-art algorithms in terms of mean average precision (map) and rank-1 accuracy on market1501. we report the single-query as well as multiple-query evaluation results. our model (caffenet) achieves 62.14% rank-1 accuracy and 39.61% map, which is comparable to the state of the art 65.88% rank-1 accuracy and 39.55% map. our model using resnet-50 produces the best performance 79.51% in rank-1 accuracy and 59.87% in map, which outperforms other state-of-the-art algorithms. for cuhk03, we evaluate our method in the single-shot setting as shown in tab. [reference]. there is only one right image in the searching pool. in the evaluation, we randomly select 100 images from 100 identities under the other camera as gallery. the proposed model yields 83.4% rank-1 and 86.4% map and outperforms the state-of-the-art performance. as shown in tab. [reference], we also report the results in the multi-shot setting, which uses all the images from the other camera as gallery and the number of the gallery images is about 500. we think this setting is much closer to image retrieval and alleviate the unstable effect caused by the random searching pool under single-shot settings. fig. [reference] presents some re-id samples on cuhk03 dataset. the images in the first column are the query images. the retrieval images are sorted according to the similarity scores from left to right. most ground-truth candidate images are correctly retrieved. although the model retrieves some incorrect candidates on the third row, we find it is a reasonable prediction since the man with red hat and blue coat is similar to the query. the proposed model yields 88.3% rank-1 and 85.0% map and also outperforms the state-of-the-art performance in the multi-shot setting. results between camera pairs. cuhk03 only contains two camera views. so this experiment is evaluated on market1501 since it contains six different cameras. we provide the re-identification results between all camera pairs in fig. [reference]. although camera-6 is a low-resolution camera and captures distinct background with the other hd cameras, the re-id accuracy between camera 6 and the others is relatively high. we also compute the cross-camera average map and average rank-1 accuracy: 48.42% and 54.42% respectively. comparing to the previous reported results, i.e., 10.51% and 13.72% in, our method largely improves the performance and observes a smaller standard deviation between cameras. it suggests that the discriminatively learned embedding works under different viewpoints. further, fig. [reference] shows the barnes-hut t-sne visualization on the learned embeddings of our model. by the clustering algorithm, the persons wearing the similar-color clothes are quit clustered together and are apart from other persons. the learned pedestrian descriptor pay more attention to the color and it is robust to some illusion and viewpoint variations. in realistic setting, we think color provides the most important information to figure out the person. large-scale experiments. the market1501 dataset also provides an additional distractor set with 500k images to enlarge the gallery. in general, more candidate images may confuse the image retrieval. the re-id performance of our model (resnet) on the large-scale dataset is presented in tab. [reference]. as the searching pool gets larger, the accuracy drops. with the gallery size of, we still achieve 68.26% rank1 accuracy and 45.24% map. a relative drop 24.4% from 59.87% to 45.24% on map is observed, compared to a relative drop 37.88% from 13.94% to 8.66% in our previous work. besides, we also compare our result with the performance of the resnet baseline. as shown in fig. [reference], it is interesting that the re-id precision of our model decreases more quickly comparing to the baseline model. we speculate that the market1501 training set is relatively small in covering the pedestrian variations encountered in a much larger test set. in fact, the 500k dataset was collected in a different time (the same location) with the market1501 dataset, so the transfer effect is large enough that the learned embedding is inferior to the baseline on the scale of 500 k images. in the future, we will look into this interesting problem and design more robust descriptors for the transfer dataset. subsection: instance retrieval we apply the identification-verification model to the generic image retrieval task. oxford5k is a testing dataset containing buildings in the oxford university. we train the network on another scene dataset proposed in, which comprises of a number of buildings without overlapping with the oxford5k. similarly, the model is trained to not only tell which building the image depicts but also determine whether the two input images are from the same architecture. the training data is high-resolution. in order to obtain more information from the high-resolution building images, we modify the final pooling layer of our model to a mac layer, which outputs the maximum value over the whole activation map. this layer helps us to handle large images without resizing them to a fixed size and output a fixed-dimension feature to retrieve the images. during training, the input image is randomly cropped to from and mirrored horizontally. during testing, we keep the original size of the images that are not cropped or resized and extract the feature. in table [reference], many previous works are based on caffenet or vgg16. for fair comparison, we report the baseline results and the results of our model based on these two network structures, respectively. our model which uses caffenet as pretrained model outperforms the state of the art. meanwhile, the model using vgg16 is comparable to the state-of-the-arts methods. the proposed method show a 6.0% and 6.6% improvement over the baseline networks caffenet and vgg16, respectively. we visualize some retrieval results in fig. [reference]. the images in the first column are the query images. the retrieval images are sorted according to the similarity scores from left to right. the main difficulty in the image retrieval is various object sizes in the image. in the first row, we use the roof (part of the building) to retrieve the images and the top five images are correct candidate images. the other retrieval samples also show our model is robust to the scale variations. section: conclusion in this work, we propose a siamese network that simultaneously considers the identification loss and the verification loss. the proposed model learns a discriminative embedding and a similarity measurement at the same time. it outperforms the state of the art on two popular person re-id benchmarks and shows potential ability to apply on the generic instance retrieval task. future work includes exploring more novel applications of the proposed method, such as car recognition and fine-grained classification. besides, we will investigate how to learn a robust descriptor to further improve the performance of the person re-identification on large-scale testing set. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "market1501"
                    ],
                    [
                        "oxford5k"
                    ],
                    [
                        "market1501"
                    ],
                    [
                        "market1501"
                    ],
                    [
                        "market1501 dataset"
                    ]
                ],
                "Method": [
                    [
                        "discriminatively learned cnn"
                    ],
                    [
                        "cnn"
                    ],
                    [
                        "cnn embedding"
                    ],
                    [
                        "embedding"
                    ]
                ],
                "Metric": [
                    [
                        "mean average precision"
                    ],
                    [
                        "map"
                    ],
                    [
                        "mean average precision"
                    ]
                ],
                "Task": [
                    [
                        "person re identification"
                    ],
                    [
                        "re identification"
                    ],
                    [
                        "identification"
                    ],
                    [
                        "re id"
                    ],
                    [
                        "verification"
                    ],
                    [
                        "verification"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "market1501"
                    ]
                ],
                "Method": [
                    [
                        "discriminatively learned cnn embedding"
                    ]
                ],
                "Metric": [
                    [
                        "map",
                        "mean average precision"
                    ]
                ],
                "Task": [
                    [
                        "person re-identification",
                        "re-id",
                        "identification loss",
                        "identification",
                        "person re-i d evaluation",
                        "re-identification"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "market1501"
                    ]
                ],
                "Method": [
                    [
                        "discriminatively learned cnn embedding"
                    ]
                ],
                "Metric": [
                    [
                        "rank-1 accuracy",
                        "rank-1",
                        "rank1 accuracy"
                    ]
                ],
                "Task": [
                    [
                        "person re-identification",
                        "re-id",
                        "identification loss",
                        "identification",
                        "person re-i d evaluation",
                        "re-identification"
                    ]
                ]
            }
        ]
    },
    "193b518bc3025804c6d587c74cbc154d91478417-26": {
        "doctext": "document: learning to adapt structured output space for semantic segmentation convolutional neural network-based approaches for semantic segmentation rely on supervision with pixel-level ground truth, but may not generalize well to unseen image domains. as the labeling process is tedious and labor intensive, developing algorithms that can adapt source ground truth labels to the target domain is of great interest. in this paper, we propose an adversarial learning method for domain adaptation in the context of semantic segmentation. considering semantic segmentations as structured outputs that contain spatial similarities between the source and target domains, we adopt adversarial learning in the output space. to further enhance the adapted model, we construct a multi-level adversarial network to effectively perform output space domain adaptation at different feature levels. extensive experiments and ablation study are conducted under various domain adaptation settings, including synthetic-to-real and cross-city scenarios. we show that the proposed method performs favorably against the state-of-the-art methods in terms of accuracy and visual quality. section: introduction semantic segmentation aims to assign each pixel a semantic label, e.g., person, car, road or tree, in an image. recently, methods based on convolutional neural networks (cnns) have achieved significant progress in semantic segmentation with applications for autonomous driving and image editing. the crux of cnn-based approaches is to annotate a large number of images that cover possible scene variations. however, this trained model may not generalize well to unseen images, especially when there is a domain gap between the training (source) and test (target) images. for instance, the distribution of appearance for objects and scenes may vary in different cities, and even weather and lighting conditions can change significantly in the same city. in such cases, relying only on the supervised model that requires re-annotating per-pixel ground truths in different scenarios would entail prohibitively high labor cost. to address this issue, knowledge transfer or domain adaptation techniques have been proposed to close the gap between source and target domains, where annotations are not available in the target domain. for image classification, one effective approach is to align features across two domains such that the adapted features can generalize to both domains. similar efforts have been made for semantic segmentation via adversarial learning in the feature space. however, different from the image classification task, feature adaptation for semantic segmentation may suffer from the complexity of high-dimensional features that needs to encode diverse visual cues, including appearance, shape and context. this motivates us to develop an effective method for adapting pixel-level prediction tasks rather than using feature adaptation. in semantic segmentation, we note that the output space contains rich information, both spatially and locally. for instance, even if images from two domains are very different in appearance, their segmentation outputs share a significant amount of similarities, e.g., spatial layout and local context (see figure [reference]). based on this observation, we address the pixel-level domain adaptation problem in the output (segmentation) space. in this paper, we propose an end-to-end cnn-based domain adaptation algorithm for semantic segmentation. our formulation is based on adversarial learning in the output space, where the intuition is to directly make the predicted label distributions close to each other across source and target domains. based on the generative adversarial network (gan), the proposed model consists of two parts: 1) a segmentation model to predict output results, and 2) a discriminator to distinguish whether the input is from the source or target segmentation output. with an adversarial loss, the proposed segmentation model aims to fool the discriminator, with the goal of generating similar distributions in the output space for either source or target images. the proposed method also adapts features as the errors are back-propagated to the feature level from the output labels. however, one concern is that lower-level features may not be adapted well as they are far away from the high-level output labels. to address this issue, we develop a multi-level strategy by incorporating adversarial learning at different feature levels of the segmentation model. for instance, we can use both conv5 and conv4 features to predict segmentation results in the output space. then two discriminators can be connected to each of the predicted output for multi-level adversarial learning. we perform one-stage end-to-end training for the segmentation model and discriminators jointly, without using any prior knowledge of the data in the target domain. in the testing phase, we can simply discard discriminators and use the adapted segmentation model on target images, with no extra computational requirements. due to the high labor cost of annotating segmentation ground truth, there has been great interest in large-scale synthetic datasets with annotations, e.g., gta5 and synthia. as a result, one critical setting is to adapt the model trained on synthetic data to real-world datasets, such as cityscapes. we follow this setting and conduct extensive experiments to validate the proposed domain adaptation method. first, we use a strong baseline model that is able to generalize to different domains. we note that a strong baseline facilitates real-world applications and can evaluate the limitation of the proposed adaptation approach. based on this baseline model, we show comparisons using adversarial adaptation in the feature and output spaces. furthermore, we show that the multi-level adversarial learning improves the results over single-level adaptation. in addition to the synthetic-to-real setting, we show experimental results on the cross-city dataset, where annotations are provided in one city (source), while testing the model on another unseen city (target). overall, our method performs favorably against state-of-the-art algorithms on numerous benchmark datasets under different settings. the contributions of this work are as follows. first, we propose a domain adaptation method for pixel-level semantic segmentation via adversarial learning. second, we demonstrate that adaptation in the output (segmentation) space can effectively align scene layout and local context between source and target images. third, a multi-level adversarial learning scheme is developed to adapt features at different levels of the segmentation model, which leads to improved performance. section: related work semantic segmentation. state-of-the-art semantic segmentation methods are mainly based on the recent advances of deep neural networks. as proposed by long, one can transform a classification cnn (e.g., alexnet, vgg, or resnet) to a fully-convolutional network (fcn) for semantic segmentation. numerous methods have since been developed to improve this model by utilizing context information or enlarging receptive fields. to train these advanced networks, a substantial amount of dense pixel annotations must be collected in order to match the model capacity of deep cnns. as a result, weakly and semi-supervised approaches are proposed in recent years to reduce the heavy labeling cost of collecting segmentation ground truths. however, in most real-world applications, it is difficult to obtain weak annotations and the trained model may not generalize well to unseen image domains. another approach to tackle the annotation problem is to construct synthetic datasets based on rendering, e.g., gta5 and synthia. while the data collection is less costly since the pixel-level annotation can be done with a partially automated process, these datasets are usually used in conjunction with real-world datasets for joint learning to improve the performance. however, when training solely on the synthetic dataset, the model does not generalize well to real-world data, mainly due to the large domain shift between synthetic images and real-world images, i.e., appearance differences are still significant with current rendering techniques. although synthesizing more realistic images can decrease the domain shift, it is necessary to use domain adaptation to narrow the performance gap. domain adaptation. domain adaptation methods for image classification have been developed to address the domain-shift problem between the source and target domains. numerous methods are developed based on cnn classifiers due to performance gain. the main insight behind these approaches is to tackle the problem by aligning the feature distribution between source and target images. ganin propose the domain-adversarial neural network (dann) to transfer the feature distribution. a number of variants have since been proposed with different loss functions or classifiers. recently, the pixelda method addresses domain adaptation for image classification by transferring the source images to target domain, thereby obtaining a simulated training set for target images. we note that domain adaptation for pixel-level prediction tasks have not been explored widely. hoffman introduce the task of domain adaptation on semantic segmentation by applying adversarial learning (i.e., dann) in a fully-convolutional way on feature representations and additional category constraints similar to the constrained cnn. other methods focus on adapting synthetic-to-real or cross-city images by adopting class-wise adversarial learning or label transfer. similar to the pixelda method, one concurrent work, cycada uses the cyclegan and transfers source domain images to the target domain with pixel alignment, thus generating extra training data combined with feature space adversarial learning. although feature space adaptation has been successfully applied to image classification, pixel-level tasks such as semantic segmentation remains challenging based on feature adaptation-based approaches. in this paper, we use the property that pixel-level predictions are structured outputs that contain information spatially and locally, to propose an efficient domain adaptation algorithm through adversarial learning in the output space. section: algorithmic overview subsection: overview of the proposed model our domain adaptation algorithm consists of two modules: a segmentation network and the discriminator, where indicates the level of a discriminator in the multi-level adversarial learning. two sets of images from source and target domains are denoted as and. we first forward the source image (with annotations) to the segmentation network for optimizing. then we predict the segmentation softmax output for the target image (without annotations). since our goal is to make segmentation predictions of source and target images (i.e., and) close to each other, we use these two predictions as the input to the discriminator to distinguish whether the input is from the source or target domain. with an adversarial loss on the target prediction, the network propagates gradients from to, which would encourage to generate similar segmentation distributions in the target domain to the source prediction. figure [reference] shows the overview of the proposed algorithm. subsection: objective function for domain adaptation with the proposed network, we formulate the adaptation task containing two loss functions from both modules: where is the cross-entropy loss using ground truth annotations in the source domain, and is the adversarial loss that adapts predicted segmentations of target images to the distribution of source predictions (see section [reference]). in ([reference]), is the weight used to balance the two losses. section: output space adaptation different from image classification based on features that describe the global visual information of the image, high-dimensional features learned for semantic segmentation encodes complex representations. as a result, adaptation in the feature space may not be the best choice for semantic segmentation. on the other hand, although segmentation outputs are in the low-dimensional space, they contain rich information, e.g., scene layout and context. our intuition is that no matter images are from the source or target domain, their segmentations should share strong similarities, spatially and locally. thus, we utilize this property to adapt low-dimensional softmax outputs of segmentation predictions via an adversarial learning scheme. subsection: single-level adversarial learning discriminator training. before introducing how to adapt the segmentation network via adversarial learning, we first describe the training objective for the discriminator. given the segmentation softmax output, where is the number of categories, we forward to a fully-convolutional discriminator using a cross-entropy loss for the two classes (i.e., source and target). the loss can be written as: where if the sample is drawn from the target domain, and for the sample from the source domain. segmentation network training. first, we define the segmentation loss in ([reference]) as the cross-entropy loss for images from the source domain: where is the ground truth annotations for source images and is the segmentation output. second, for images in the target domain, we forward them to and obtain the prediction. to make the distribution of closer to, we use an adversarial loss in ([reference]) as: this loss is designed to train the segmentation network and fool the discriminator by maximizing the probability of the target prediction being considered as the source prediction. subsection: multi-level adversarial learning although performing adversarial learning in the output space directly adapts predictions, low-level features may not be adapted well as they are far away from the output. similar to the deep supervision method that uses auxiliary loss for semantic segmentation, we incorporate additional adversarial module in the low-level feature space to enhance the adaptation. the training objective for the segmentation network can be extended from ([reference]) as: where indicates the level used for predicting the segmentation output. we note that, the segmentation output is still predicted in each feature space, before passing through individual discriminators for adversarial learning. hence, and remain in the same form as in ([reference]) and ([reference]), respectively. based on ([reference]), we optimize the following min-max criterion: the ultimate goal is to minimize the segmentation loss in for source images, while maximizing the probability of target predictions being considered as source predictions. road sidewalk building wall fence pole light sign veg terrain sky person rider car truck bus train mbike bike section: network architecture and training discriminator. for the discriminator, we use an architecture similar to but utilize all fully-convolutional layers to retain the spatial information. the network consists of 5 convolution layers with kernel and stride of 2, where the channel number is {64, 128, 256, 512, 1}, respectively. except for the last layer, each convolution layer is followed by a leaky relu parameterized by. an up-sampling layer is added to the last convolution layer for re-scaling the output to the size of the input. we do not use any batch-normalization layers as we jointly train the discriminator with the segmentation network using a small batch size. segmentation network. it is essential to build upon a good baseline model to achieve high-quality segmentation results. we adopt the deeplab-v2 framework with resnet-101 model pre-trained on imagenet as our segmentation baseline network. however, we do not use the multi-scale fusion strategy due to the memory issue. similar to the recent work on semantic segmentation, we remove the last classification layer and modify the stride of the last two convolution layers from 2 to 1, making the resolution of the output feature maps effectively times the input image size. to enlarge the receptive field, we apply dilated convolution layers in conv4 and conv5 layers with a stride of 2 and 4, respectively. after the last layer, we use the atrous spatial pyramid pooling (aspp) as the final classifier. finally, we apply an up-sampling layer along with the softmax output to match the size of the input image. based on this architecture, our segmentation model achieves 65.1% mean intersection-over-union (iou) when trained on the cityscapes training set and tested on the cityscapes validation set. multi-level adaptation model. we construct the above-mentioned discriminator and segmentation network as our single-level adaptation model. for the multi-level structure, we extract feature maps from the conv4 layer and add an aspp module as the auxiliary classifier. similarly, a discriminator with the same architecture is added for adversarial learning. figure [reference] shows the proposed multi-level adaptation model. in this paper, we use two levels due to the balance of its efficiency and accuracy. network training. to train the proposed single/ multi-level adaptation model, we find that jointly training the segmentation network and discriminators in one stage is effective. in each training batch, we first forward the source image to optimize the segmentation network for in ([reference]) and generate the output. for the target image, we obtain the segmentation output, and pass it along with to the discriminator for optimizing in ([reference]). in addition, we compute the adversarial loss in ([reference]) for the target prediction. for the multi-level training objective in ([reference]), we simply repeat the same procedure for each adaptation module. we implement our network using the pytorch toolbox on a single titan x gpu with 12 gb memory. to train the segmentation network, we use the stochastic gradient descent (sgd) optimizer with nesterov acceleration where the momentum is 0.9 and the weight decay is. the initial learning rate is set as and is decreased using the polynomial decay with power of 0.9 as mentioned in. for training the discriminator, we use the adam optimizer with the learning rate as and the same polynomial decay as the segmentation network. the momentum is set as 0.9 and 0.99. section: experimental results in this section, we present experimental results to validate the proposed domain adaptation method for semantic segmentation under different settings. first, we show evaluations of the model trained on synthetic datasets (i.e., gta5 and synthia) and test the adapted model on real-world images from the cityscapes dataset. extensive experiments including comparisons to the state-of-the-art methods and ablation study are also conducted, e.g., adaptation in the feature/ output spaces and single/ multi-level adversarial learning. second, we carry out experiments on the cross-city dataset, where the model is trained on one city and adapted to another city without using annotations. in all the experiments, the iou metric is used. the code and model are available at. subsection: gta5 the gta5 dataset consists of images with the resolution of synthesized from the video game based on the city of los angeles. the ground truth annotations are compatible with the cityscapes dataset that contains 19 categories. following, we use the full set of gta5 and adapt the model to the cityscapes training set with 2975 images. during testing, we evaluate on the cityscapes validation set with 500 images. overall results. we present adaptation results in table [reference] with comparisons to the state-of-the-art domain adaptation methods. for these approaches, the baseline model is trained using vgg-based architectures. to fairly evaluate our method, we first use the same baseline architecture (vgg-16) and train our model with the proposed single-level adaptation module. table [reference] shows that our method performs favorably against the other algorithms. while these methods all have feature adaptation modules, our results show that adapting the model in the output space achieves better performance. we note that cycada has a pixel adaptation module by transforming source domain images to the target domain and hence obtains additional training samples. although this strategy achieves a similar performance as ours, one can always apply pixel transformation combined with our output space adaptation to improve the results. on the other hand, we argue that utilizing a stronger baseline model is critical for understanding the importance of different adaptation components as well as for enhancing the performance to enable real-world applications. thus, we use the resnet-101 based network introduced in section [reference] and train the proposed adaptation model. table [reference] shows the baseline results only trained on source images without adaptation, with comparisons to our adapted models under different settings, including feature adaptation and single/ multi-level adversarial learning in the output space. figure [reference] presents some example results for adapted segmentation. we note that for small objects such as poles and traffic signs, they are harder to adapt since they easily get merged with background classes. in addition, another factor to evaluate the adaptation performance is to measure how much gap is narrowed between the adaptation model and the fully-supervised model. hence, we train the model using annotated ground truths in the cityscapes dataset as the oracle results. table [reference] shows the gap under different baseline models. we observe that, although the oracle result does not differ a lot between vgg-16 and resnet-101 based models, the gap is larger for the vgg one. it suggests us that to narrow the gap, using a deeper model with larger capacity is more practical. parameter analysis. during optimizing the segmentation network, it is essential to balance the weight between segmentation and adversarial losses. we first consider the single-level case in ([reference]) and conduct experiments to observe the impact of changing. table [reference] shows that a smaller may not facilitate the training process significantly, while a larger may propagate incorrect gradients to the network. we empirically choose as 0.001 in the single-level setting. feature level v.s. output space adaptation. in the single-level setting in ([reference]), we compare results by using feature-level or output space adaptation via adversarial learning. for feature-level adaptation, we adopt a similar strategy as used in and train our model accordingly. table [reference] shows that the proposed adaptation method in the output space performs better than the one in the feature level. in addition, table [reference] shows that adaptation in the feature space is more sensitive to, which causes the training process more difficult, while output space adaptation allows for a wider range of. one reason is that as feature adaptation is performed in the high-dimensional space, the problem for the discriminator becomes easier. thus, such an adapted model can not effectively match distributions between source and target domains via adversarial learning. single-level v.s. multi-level adversarial learning. we have shown the merits of adopting adversarial learning in the output space. in addition, we present the results of using multi-level adversarial learning in table [reference]. here, we utilize an additional adversarial module (see figure [reference]) and jointly optimize ([reference]) for two levels. to properly balance and, we use the same weight as in the single-level setting for the high-level output space (i.e.,= 1 and= 0.001). since the low-level output carries less information to predict the segmentation, we use smaller weights for both the segmentation and adversarial loss (i.e.,= 0.1 and= 0.0002). evaluation results show that our multi-level adversarial adaptation further improves the segmentation accuracy. more results and analysis are presented in the supplementary material. road sidewalk building light sign veg sky person rider car bus mbike bike subsection: synthia to adapt from the synthia to cityscapes datasets, we use the synthia-rand-cityscapes set as the source domain which contains 9400 images compatible with the cityscapes annotated classes. similar to, we evaluate images on the cityscapes validation set with 13 classes. for the weight in ([reference]) and ([reference]), we use the same ones as in the case of gta5 dataset. table [reference] shows evaluation results of the proposed algorithm against the state-of-the-art methods that use feature adaptation. similar to the experiments with the gta5 dataset, we first utilize the same vgg-based model and train our single-level adaptation model for fair comparisons. the experimental results suggest that adapting the model in the output space performs better. second, we compare results using different components of the proposed method with the resnet based model. we show that the multi-level adaptation module improves the results over the baseline, feature space adaptation and single-level adaptation models. in addition, we present comparisons of mean iou gap between adapted and oracle results in table [reference]. our method achieves the smallest gap and is the only one that can minimize the gap below 30%. road sidewalk building light sign veg sky person rider car bus mbike bike subsection: cross-city dataset in addition to the synthetic-to-real adaptation for a larger domain gap, we conduct experiment on the cross-city dataset with smaller domain gaps between cities. the dataset contains four different cities: rio, rome, tokyo and taipei, in which each city has 3200 images without annotations and 100 images with pixel-level ground truths for 13 classes. similar to, we use the cityscapes training set as the source domain and adapt it to each target city using 3200 images, while 100 annotated images are used for evaluation. since a smaller domain gap results in smaller output differences, we use smaller weights for the adversarial loss (i.e.,) when training our models, while the weights for segmentation remain the same as previous experiments. we show our results in table [reference] with comparisons to and our baseline models under different settings. again, our final multi-level model achieves consistent improvement for different cities, which demonstrates the advantages of the proposed adaptation method in the output space. note that the state-of-the-art method uses a different baseline model, and we present it as a reference to analyze how much the proposed algorithm can improve. section: concluding remarks in this paper, we exploit the fact that segmentations are structured outputs and share many similarities between source and target domains. we tackle the domain adaptation problem for semantic segmentation via adversarial learning in the output space. to further enhance the adapted model, we construct a multi-level adversarial network to effectively perform output space domain adaptation at different feature levels. experimental results show that the proposed method performs favorably against numerous baseline models and the state-of-the-art algorithms. we hope that our proposed method can be a generic adaptation model for a wide range of pixel-level prediction tasks. acknowledgments. w.-c. hung is supported in part by the nsf career grant# 1149783, gifts from adobe and nvidia. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "synthia"
                    ],
                    [
                        "synthia"
                    ],
                    [
                        "cross city dataset"
                    ],
                    [
                        "cityscapes validation set"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "semantic segmentation"
                    ],
                    [
                        "segmentation"
                    ],
                    [
                        "pixel level semantic segmentation"
                    ],
                    [
                        "high quality segmentation"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "single-level adaptation model",
                        "multi-level adaptation model",
                        "single"
                    ]
                ],
                "Metric": [
                    [
                        "mean intersection-over-union",
                        "iou"
                    ]
                ],
                "Task": [
                    [
                        "synthetic-to-real",
                        "synthetic-to-real setting",
                        "synthetic-to-real adaptation"
                    ]
                ]
            }
        ]
    },
    "1d0dcb458aa4d30b51f7c74b159be687f39120a0-27": {
        "doctext": "document: pose-driven deep convolutional model for person re-identification feature extraction and matching are two crucial components in person re-identification (reid). the large pose deformations and the complex view variations exhibited by the captured person images significantly increase the difficulty of learning and matching of the features from person images. to overcome these difficulties, in this work we propose a pose-driven deep convolutional (pdc) model to learn improved feature extraction and matching models from end to end. our deep architecture explicitly leverages the human part cues to alleviate the pose variations and learn robust feature representations from both the global image and different local parts. to match the features from global human body and local body parts, a pose driven feature weighting sub-network is further designed to learn adaptive feature fusions. extensive experimental analyses and results on three popular datasets demonstrate significant performance improvements of our model over all published state-of-the-art methods. section: introduction person re-identification (reid) is an important component in a video surveillance system. here person reid refers to the process of identifying a probe person from a gallery captured by different cameras, and is generally deployed in the following scenario: given a probe image or video sequence containing a specific person under a certain camera, querying the images, locations, and time stamps of this person from other cameras. despite decades of studies, the person reid problem is still far from being solved. this is mainly because of challenging situations like complex view variations and large pose deformations on the captured person images. most of traditional works try to address these challenges with the following two approaches: (1) representing the visual appearance of a person using customized local invariant features extracted from images or (2) learning a discriminative distance metric to reduce the distance among features of images containing the same person. because the human poses and viewpoints are uncontrollable in real scenarios, hand-coded features may be not robust enough to pose and viewpoint variations. distance metric is computed for each pair of cameras, making distance metric learning based person reid suffers from the computational complexity. in recent years, deep learning has demonstrated strong model capabilities and obtains very promising performances in many computer vision tasks. meanwhile, the release of person reid datasets like cuhk 03, market-1501, and mars, both of which contain many annotated person images, makes training deep models for person reid feasible. therefore, many researchers attempt to leverage deep models in person reid. most of these methods first learn a pedestrian feature and then compute euclidean distance to measure the similarity between two samples. more specifically, existing deep learning based person reid approaches can be summarized into two categories: 1) use softmax loss with person id labels to learn a global representation, and 2) first learn local representations using predefined rigid body parts, then fuse the local and global representations to depict person images. deep learning based methods have demonstrated significant performance improvements over the traditional methods. although these approaches have achieved remarkable results on mainstream person reid datasets, most of them do not consider pose variation of human body. because pose variations may significantly change the appearance of a person, considering the human pose cues is potential to help person re-identification. although there are several methods that segment the person images according to the predefined configuration, such simple segmentation can not capture the pose cues effectively. some recent works attempt to use pose estimation algorithms to predict human pose and then train deep models for person reid. however, they use manually cropped human body parts and their models are not trained from end to end. therefore, the potential of pose information to boost the reid performance has not been fully explored. to better alleviate the challenges from pose variations, we propose a pose-driven deep convolutional (pdc) model for person reid. the proposed pdc model learns the global representation depicting the whole body and local representations depicting body parts simultaneously. the global representation is learned using the softmax loss with person id labels on the whole input image. for the learning of local representations, a novel feature embedding sub-net (fen) is proposed to learn and readjust human parts so that parts are affine transformed and re-located at more reasonable regions which can be easily recognizable through two different cameras. in feature embedding sub-net, each body part region is first automatically cropped. the cropped part regions are hence transformed by a pose transformation network (ptn) to eliminate the pose variations. the local representations are hence learned on the transformed regions. we further propose a feature weighting sub-net (fwn) to learn the weights of global representations and local representations on different parts. therefore, more reasonable feature fusion is conducted to facilitate feature similarity measurement. some more detailed descriptions to our local representation generation are illustrated in fig. [reference]. our method first locates the key body joints from the input image,, illustrated in fig. [reference] (c). from the detected joints, six body parts are extracted,, shown in fig. [reference] (d). as shown in fig. [reference] (e), those parts are extracted and normalized into fixed sizes and orientations. finally, they are fed into the pose transformation network (ptn) to further eliminate the pose variations. with the normalized and transformed part regions,, fig. [reference] (f), local representations are learned by training the deep neural network. different parts commonly convey different levels of discriminative cues to identify the person. we thus further learn weights for representations on different parts with a sub-network. most of current deep learning based person reid works do not consider the human pose cues and the weights of representation on different parts. this paper proposes a novel deep architecture that transforms body parts into normalized and homologous feature representations to better overcome the pose variations. moreover, a sub-network is proposed to automatically learn weights for different parts to facilitate feature similarity measurement. both the representation and weighting are learned jointly from end to end. since pose estimation is not the focus of this paper, the used pose estimation algorithm,, fully convolutional networks (fcn) based pose estimation method is simple and trained independently. once the fcn is trained, it is incorporated in our framework, which is hence trained in an end-to-end manner,, using images as inputs and person id labels as outputs. experimental results on three popular datasets show that our algorithm significantly outperforms many state-of-the-art ones. section: related work traditional algorithms perform person re-identification through two ways: (a) acquiring robust local features visually representing a person's appearance and then encoding them; (b) closing the gap between a person's different features by learning a discriminative distance metric. some recent works have started to apply deep learning in person reid and achieved promising performance. in the following, we briefly review recent deep learning based person reid methods. deep learning is commonly used to either learn a person's representation or the distance metric. when handling a pair of person images, existing deep learning methods usually learn feature representations of each person by using a deep matching function from convolutional features or from the fully connected (fc) features. apart from deep metric learning methods, some algorithms first learn image representations directly with the triplet loss or the siamese contrastive loss, then utilize euclidean distance for comparison. wang use a joint learning framework to unify single-image representation and cross-image representation using a doublet or triplet cnn. shi propose a moderate positive mining method to use deep distance metric learning for person reid. another novel method learns deep attributes feature for reid with semi-supervised learning. xiao train one network with several person reid datasets using a domain guided dropout algorithm. predefined rigid body parts are also used by many deep learning based methods for the purpose of learning local pedestrian features. different from these algorithms, our work and the ones in use more accurate human pose estimation algorithms to acquire human pose features. however, due to the limited accuracy of pose estimation algorithms as well as reasons like occlusion and lighting change, pose estimation might be not accurate enough. moreover, different parts convey different levels of discriminative cues. therefore, we normalize the part regions to get more robust feature representation using feature embedding sub-net (fen) and propose a feature weighting sub-net (fwn) to learn the weight for each part feature. in this way, the part with high discriminative power can be identified and emphasized. this also makes our work different from existing ones, which do not consider the inaccuracy of human poses estimation and weighting on different parts features. section: pose-driven deep reid model in this section, we describe the overall framework of the proposed approach, where we mainly introduce the feature embedding sub-net (fen) and the feature weighting sub-net (fwn). details about the training and test procedures of the proposed approach will also be presented. subsection: framework fig. [reference] shows the framework of our proposed deep reid model. it can be seen that the global image and part images are simultaneously considered during each round of training. given a training sample, we use an human pose estimation algorithm to acquire the locations of human pose joints. these pose joints are combined into different human body parts. the part regions are first transformed using our feature embedding sub-net (fen) and then are combined to form a new modified part image containing the normalized body parts. the global image and the new modified part image are then fed into our cnn together. the two images share the same weights for the first several layers, then have their own network weights in the subsequent layers. at last, we use feature weighting sub-net (fwn) to learn the weights of part features before fusing them with the global features for final softmax loss computation. considering that pedestrian images form different datasets have different sizes, it is not appropriate to directly use the cnn models pre-trained on the imagenet dataset. we thus modify and design a network based on the googlenet, as shown in the table [reference]. layers from data to inception (4e) in table [reference] corresponds to the blue cnn block in fig. [reference], cnng and cnnp are inception (5a) and inception (5b), respectively. the green conv matches the subsequent 1 1 convolution. the loss layers are not shown in table [reference]. the batch normalization layers are inserted before every relu layer to accelerate the convergence. we employ a convolutional layer and a global average pooling layer (gap) at the end of network to let our network can fit different sizes of input images. in this work, we fix input image size as 512 256. subsection: feature embedding sub-net the feature embedding sub-net (fen) is divided into four steps, including locating the joint, generating the original part images, ptn, and outputting the final modified part images. with a given person image, fen first locates the 14 joints of human body using human pose estimation algorithm. fig. [reference] (c) shows an example of the 14 joints of human body. according to number, the 14 joints are {}. then we propose six rectangles to cover six different parts of human body, including the head region, the upper body, two arms and two legs. for each human joint, we calculate a response feature map. the horizontal and vertical dimensions of the feature maps are denoted by and, respectively. with the feature maps, the fourteen body joints, can be located by finding the center of mass with the feature values: where in eq. [reference] are the coordinates of joints, and is the value of pixels in response feature maps. different from, we do not use complex pose estimation networks as the pre-trained network. instead, we use a standard fcn trained on the lsp dataset and mpii human pose dataset. in the second step, the fen uses the 14 human joints to further locate six sub-regions (head, upper body, left arm, right arm, left leg, and right leg) as human parts. these parts are normalized through cropping, rotating, and resizing to fixed size and orientation. as shown in fig. [reference] (d), the 14 located body joints are assigned to six rectangles indicating six parts. the head part, the upper body part, the left arm part, the right arm part, the left leg part, and the right leg part, respectively. for each body part set, the corresponding sub-region bounding box can be obtained based on the location coordinates of all body joints in each part set: an example of the extracted six body sub-regions are visualized in fig. [reference] (d). as shown in fig. [reference] (e), these body sub-regions are normalized through cropping, rotating, and resizing to fixed sizes and orientations. all body parts are rotated to fixed vertical direction. arms and legs are resized to 256 64, upper body is resized to 256 128 and head is resized to 128 128. those resized and rotated parts are combined to form the body part image. because 6 body parts have different sizes, black area is unavoidable in body part image. simply resizing and rotation can not overcome the complex pose variations, especially if the pose estimations are inaccurate. we thus design a ptn modified from spatial transformer networks (stn) to learn the angles required for rotating the five body parts. stn is a spatial transformer module which can be inserted to a neural network to provide spatial transformation capabilities. it thus is potential to adjust the localizations and angles of parts. a stn is a small net which allows for end-to-end training with standard back-propagation, therefore, the introduction of stn does n't substantially increase the complexity of training procedure. the stn consist of three components: localisation network, parameterised sampling grid, and differentiable image sampling. the localisation network takes the input feature map and outputs the parameters of the transformation. for our net, we choose affine transformation so our transformation parameter is 6-dimensional. the parameterized sampling grid computes each output pixel and the differentiable image sampling component produces the sampled output image. for more details about stn, please refer to. as discussed above, we use a 6-dimensional parameter to complete affine transformation: where the are the scale and rotation parameters, while the are the translation parameters. the in eq. [reference] are the target coordinates of the output image and the are the source coordinates of the input image. usually the stn computes one affine transform for the whole image, considering a pedestrian's different parts have various orientations and sizes from each other, stn is not applicable to a part image. inspired by stn, we design a pose transformer network (ptn) which computes the affine transformation for each part in part image individually and combines 6 transformed parts together. similar to stn, our ptn is also a small net and does n't substantially increase the complexity of our training procedure. as a consequence, ptn has potential to perform better than stn for person images. fig. [reference] shows the detailed structure of ptn. considering a pedestrian's head seldom has a large rotation angle, we do n't insert a ptn net for the pedestrian's head part. therefore, we totally have 5 independent ptn, namely,,,,. each ptn can generate a 6-dimensional transformation parameter and use to adjust pedestrian's part, we can get modified body part. by combining the five transformed parts and a head part together, we obtain the modified part image. subsection: feature weighting sub-net the generated part features are combined with the global feature to generate a robust feature representation for precise person re-identification. as the poses generated by the pose detector might be affected by factors like occlusions, pose changes, etc. then inaccurate part detection results could be obtained. examples are shown in fig. [reference]. therefore, the part features could be not reliable enough. this happens frequently in real applications with unconstrained video gathering environment. simply fusing global feature and the part feature may introduces noises. this motivates us to introduce feature weighting sub-net (fwn) to seek a more optimal feature fusion. fwn is consisted with a weight layer and a nonlinear transformation, which decides the importance of each dimension in the part feature vector. considering that a single linear weight layer might cause excessive response on some specific dimensions of the part vector, we add a nonlinear function to equalize the response of part feature vector, and the fused feature representation is where the and the are the global and part feature vectors. the and in eq. [reference] are the weight and bias vectors which have the same dimensions with. the means the hadamard product of two vectors, and the means concatenation of two vectors together. the imposes the hyperbolic tangent nonlinearity. is our final person feature generated by and. to allow back-propagation of the loss through the fwn, we give the gradient formula: where,,,,, and are the dimensions of and. subsection: reid feature extraction the global feature and body-part features are learned by training the pose-driven deep convolutional model. these two types of features are then fused under a unified framework for multi-class person identification. pdc extracts the global feature maps from the global body-based representation and learns a 1024-dimensional feature embedding. similarly, a 1024-dimension feature is acquired from the modified part image after the fen. the global body feature and the local body part features are compensated into a 2048-dimensional feature as the final representation. after being weighted by fwn, the final representation is used for person reid with euclidean distance. section: experiment subsection: datasets we select three widely used person reid datasets as our evaluation protocols, including the cuhk 03, market 1501, and viper. note that, because the amount of images in viper is not enough for training a deep model, we combine the training sets of viper, cuhk 03 and market 1501 together to train the model for viper. cuhk 03: this dataset is made up of 14, 096 images of 1, 467 different persons taken by six campus cameras. each person only appears in two views. this dataset provides two types of annotations, including manually labelled pedestrian bounding boxes and bounding boxes automatically detected by the deformable-part-model (dpm) detector. we denote the two corresponding subsets as labeled dataset and detected dataset, respectively. the dataset also provides 20 test sets, each includes 100 identities. we select the first set and use 100 identities for testing and the rest 1, 367 identities for training. we report the averaged performance after repeating the experiments for 20 times. market 1501: this dataset is made up of 32, 368 pedestrian images taken by six manually configured cameras. it has 1, 501 different persons in it. on average, there are 3.6 images for each person captured from each angle. the images can be classified into two types,, cropped images and images of pedestrians automatically detected by the dpm. because market 1501 has provided the training set and testing set, we use images in the training set for training our pdc network and follow the protocol to report the reid performance. viper: this dataset is made up of 632 person images captured from two views. each pair of images depicting a person are collected by different cameras with varying viewpoints and illumination conditions. because the amount of images in viper is not enough to train the deep model, we also perform data augmentation with similar methods in existing deep learning based person reid works. for each training image, we generate 5 augmented images around the image center by performing random 2d transformations. finally, we combine the augmented training images of viper, training images of cuhk 03 and market 1501 together, as the final training set. subsection: implementation details the pedestrian representations are learned through multi-class classification cnn. we use the full body and body parts to learn the representations with softmax loss, respectively. we report rank1, rank5, rank10 and rank20 accuracy of cumulative match curve (cmc) on the three datasets to evaluate the reid performance. as for market-1051, mean average precision (map) is also reported as an additional criterion to evaluate the performance. our model is trained and fine-tuned on caffe. stochastic gradient descent (sgd) is used to optimize our model. images for training are randomly divided into several batches, each of which includes 16 images. the initial learning rate is set as 0.01, and is gradually lowered after each iterations. it should be noted that, the learning rate in part localization network is only 0.1% of that in feature learning network. for each dataset, we train a model on its corresponding training set as the pretrained body-based model. for the overall network training, the network is initialized using pretrained body-based model. then, we adopt the same training strategy as described above. we implement our approach with gtx titan x gpu, intel i7 cpu, and 128 gb memory. all images are resized to. the mean value is subtracted from each channel (b, g, and r) for training the network. the images of each dataset are randomized in the process of training stage. subsection: evaluation of individual components we evaluate five variants of our approach to verify the validity of individual components in our pdc,, components like feature embedding sub-net (fen) and feature weighting sub-net (fwn). comparisons on three datasets are summarized in table [reference]. in the table,\" global only\" means we train our deep model without using any part information.\" global+ part\" denotes cnn trained through two streams without fen and fwn. based on\" global+ part\", considering fen is denoted as\" global+ part+ fen\". similarly,\" global+ part+ fwn\" means considering fwn. in addition,\" part only\" denotes only using part features. pdc considers all of these components. from the experimental results, it can be observed that, fusing global features and part features achieves better performance than only using one of them. compared with\" global only\", considering extra part cues,,\" global+ part\", largely improves the reid performance and achieves the rank1 accuracy of 85.07% and 76.33% on cuhk 03 labeled and detected datasets, respectively. moreover, using fen and fwn further boosts the rank1 identification rate. this shows that training our model using ptn and weight layer gets more competitive performance on three datasets. the above experiments shows that each of the components in our method is helpful for improving the performance. by considering all of these components, pdc exhibits the best performance. subsection: comparison with related works cuhk 03: for the cuhk 03 dataset, we compare our pdc with some recent methods, including distance metric learning methods: mlapg, lomo+ xqda, bow+ hs, warca, ldns, feature extraction method: gog and deep learning based methods: idla, personnet, dgdropout, si+ ci, gate s-cnn, lstm s-cnn, edm, pie and spindle. we conduct experiments on both the detected dataset and the labeled dataset. experimental results are presented in table [reference] and table [reference]. experimental results show that our approach outperforms all distance metric learning methods by a large margin. it can be seen that pie, spindle and our pdc which all use the human pose cues achieve better performance than the other methods. this shows the advantages of considering extra pose cues in person reid. it is also clear that, our pdc achieves the rank1 accuracy of 78.29 and 88.70 on detected and labeled datasets, respectively. this leads to 11.19 and 0.20 performance gains over the reported performance of pie and spindle, respectively. market 1501: on market 1501, the compared works that learn distance metrics for person reid include lomo+ xqda, bow+ kissme, warca, ldns, tma and hvil. compared works based on deep learning are personnet, gate s-cnn, lstm s-cnn, pie and spindle. dgdropout does not report performance on market1501. so we implemented dgdroput and show experimental results in table [reference]. it is clear that our method outperforms these compared works by a large margin. specifically, pdc achieves rank1 accuracy of 84.14%, and map of 63.41% using the single query mode. they are higher than the rank1 accuracy and map of pie, which performs best among the compared works. this is because our pdc not only learns pose invariant features with fen but also learns better fusion strategy with fwn to emphasize the more discriminative features. viper: we also evaluate our method by comparing it with several existing methods on viper. the compared methods include distance metric learning ones: mlapg, lomo+ xqda, bow, warca and ldns, and deep learning based ones: idla, dgdropout, si+ ci, gate s-cnn, lstm s-cnn, mtl-lorae and spindle. from the results shown in table [reference], our pdc achieves the rank1 accuracy of 51.27%. this outperforms most of compared methods except spindle which also considers the human pose cues. we assume the reason might be because, spindle involves more training sets to learn the model for viper. therefore, the training set of spindle is larger than ours,, the combination of market 1501, cuhk03 and viper. for the other two datasets, our pdc achieves better performance than spindle. subsection: evaluation of feature weighting sub-net to test the effectiveness of feature weighting sub-net (fwn), we verify the performance of five variants of fwn, which are denoted as,= {0, 1, 2, 3, 4}, where is the number of weight layers in fwn with nonlinear transformation. for example, means we cascade two weight layers with nonlinear transformation, means we only have one weight layer without nonlinear transformation. the experimental results are shown in table [reference]. as we can see that one weight layer with nonlinear transformation gets the best performance on the three datasets. the reid performance starts to drop as we increase of the number of weight layers, despite more computations are being brought in. it also can be observed that, using one layer with nonlinear transformation gets better performance than one layer without nonlinear transformation,,. this means adding one nonlinear transformation after a weight layer learns more reliable weights for feature fusion and matching. based on the above observations, we adopt as our final model in this paper. examples of features before and after fwn are shown fig. [reference]. section: conclusions this paper presents a pose-driven deep convolutional model for the person reid. the proposed deep architecture explicitly leverages the human part cues to learn effective feature representations and adaptive similarity measurements. for the feature representations, both global human body and local body parts are transformed to a normalized and homologous state for better feature embedding. for similarity measurements, weights of feature representations from human body and different body parts are learned to adaptively chase a more discriminative feature fusion. experimental results on three benchmark datasets demonstrate the superiority of the proposed model over current state-of-the-art methods. acknowledgments this work is partly supported by national science foundation of china under grant no. 61572050, 91538111, 61620106009, 61429201, 61672519, and the national 1000 youth talents plan. dr. qi tian is supported by aro grant w911nf-15-1-0290 and faculty research gift awards by nec laboratories of america and blippar. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "cuhk"
                    ],
                    [
                        "lsp dataset"
                    ],
                    [
                        "mpii human pose dataset"
                    ],
                    [
                        "cuhk 03 this dataset"
                    ]
                ],
                "Method": [
                    [
                        "pose driven deep convolutional model"
                    ],
                    [
                        "pose driven deep convolutional pdc"
                    ],
                    [
                        "ptn"
                    ]
                ],
                "Metric": [
                    [
                        "rank1 accuracy"
                    ],
                    [
                        "rank1 accuracy"
                    ]
                ],
                "Task": [
                    [
                        "person re identification"
                    ],
                    [
                        "reid"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "market-1501",
                        "market 1501",
                        "market-1051",
                        "market1501"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "computational complexity",
                        "mean average precision",
                        "map",
                        "map of pie"
                    ]
                ],
                "Task": [
                    [
                        "person re-identification",
                        "reid",
                        "person reid works",
                        "multi-class person identification"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "market-1501",
                        "market 1501",
                        "market-1051",
                        "market1501"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "rank1",
                        "rank1 identification rate"
                    ]
                ],
                "Task": [
                    [
                        "person re-identification",
                        "reid",
                        "person reid works",
                        "multi-class person identification"
                    ]
                ]
            }
        ]
    },
    "1f08598381af9146d0fd9a61b30d0e51a7331689-28": {
        "doctext": "document: distributed prioritized experience replay we propose a distributed architecture for deep reinforcement learning at scale, that enables agents to learn effectively from orders of magnitude more data than previously possible. the algorithm decouples acting from learning: the actors interact with their own instances of the environment by selecting actions according to a shared neural network, and accumulate the resulting experience in a shared experience replay memory; the learner replays samples of experience and updates the neural network. the architecture relies on prioritized experience replay to focus only on the most significant data generated by the actors. our architecture substantially improves the state of the art on the arcade learning environment, achieving better final performance in a fraction of the wall-clock training time. section: introduction a broad trend in deep learning is that combining more computation with more powerful models dblp: journals/ corr/ kaisergsvpju17 and larger datasets imagenet_cvpr09 yields more impressive results. it is reasonable to hope that a similar principle holds for deep reinforcement learning. there are a growing number of examples to justify this optimism: effective use of greater computational resources has been a critical factor in the success of such algorithms as gorila gorila, a3c a3c, gpu advantage actor critic ga3c, distributed ppo heess: dppo and alphago alphago. deep learning frameworks such as tensorflow tensorflow support distributed training, making large scale machine learning systems easier to implement and deploy. despite this, much current research in deep reinforcement learning concerns itself with improving performance within the computational budget of a single machine, and the question of how to best harness more resources is comparatively underexplored. in this paper we describe an approach to scaling up deep reinforcement learning by generating more data and selecting from it in a prioritized fashion prioritized-replay. standard approaches to distributed training of neural networks focus on parallelizing the computation of gradients, to more rapidly optimize the parameters. in contrast, we distribute the generation and selection of experience data, and find that this alone suffices to improve results. this is complementary to distributing gradient computation, and the two approaches can be combined, but in this work we focus purely on data-generation. we use this distributed architecture to scale up variants of deep q-networks (dqn) and deep deterministic policy gradient (ddpg), and we evaluate these on the arcade learning environment benchmark bellemare2013arcade, and on a range of continuous control tasks. our architecture achieves a new state of the art performance on atari games, using a fraction of the wall-clock time compared to the previous state of the art, and without per-game hyperparameter tuning. we empirically investigate the scalability of our framework, analysing how prioritization affects performance as we increase the number of data-generating workers. our experiments include an analysis of factors such as the replay capacity, the recency of the experience, and the use of different data-generating policies for different workers. finally, we discuss implications for deep reinforcement learning agents that may apply beyond our distributed framework. section: background paragraph: distributed stochastic gradient descent distributed stochastic gradient descent is widely used in supervised learning to speed up training of deep neural networks, by parallelizing the computation of the gradients used to update their parameters. the resulting parameter updates may be applied synchronously krizhevsky2014one or asynchronously. both approaches have proven effective and are an increasingly standard part of the deep learning toolbox. inspired by this, applied distributed asynchronous parameter updates and distributed data generation to deep reinforcement learning. asynchronous parameter updates and parallel data generation have also been successfully used within a single-machine, in a multi-threaded rather than a distributed context a3c. gpu asynchronous actor-critic [ga3c;][] ga3c and parallel advantage actor-critic [paac;][] paac adapt this approach to make efficient use of gpus. paragraph: distributed importance sampling a complementary family of techniques for speeding up training is based on variance reduction by means of importance sampling [cf.][] hastings1970monte. this has been shown to be useful in the context of neural networks hinton2007-vs. sampling non-uniformly from a dataset and weighting updates according to the sampling probability in order to counteract the bias thereby introduced can increase the speed of convergence by reducing the variance of the gradients. one way of doing this is to select samples with probability proportional to the norm of the corresponding gradients. in supervised learning, this approach has been successfully extended to the distributed setting alain2015variance. an alternative is to rank samples according to their latest known loss value and make the sampling probability a function of the rank rather than of the loss itself loshchilov2015online. paragraph: prioritized experience replay experience replay experience-replay has long been used in reinforcement learning to improve data efficiency. it is particularly useful when training neural network function approximators with stochastic gradient descent algorithms, as in neural fitted q-iteration nfq and deep q-learning dqn. experience replay may also help to prevent overfitting by allowing the agent to learn from data generated by previous versions of the policy. prioritized experience replay prioritized-replay extends classic prioritized sweeping ideas prioritized-sweeping to work with deep neural network function approximators. the approach is strongly related to the importance sampling techniques discussed in the previous section, but using a more general class of biased sampling procedures that focus learning on the most 'surprising' experiences. biased sampling can be particularly helpful in reinforcement learning, since the reward signal may be sparse and the data distribution depends on the agent's policy. as a result, prioritized experience replay is used in many agents, such as prioritized dueling dqn dueling, unreal unreal, dqfd dqfd, and rainbow rainbow. in an ablation study conducted to investigate the relative importance of several algorithmic ingredients rainbow, prioritization was found to be the most important ingredient contributing to the agent's performance. section: our contribution: distributed prioritized experience replay in this paper we extend prioritized experience replay to the distributed setting and show that this is a highly scalable approach to deep reinforcement learning. we introduce a few key modifications that enable this scalability, and we refer to our approach as ape-x. as in gorila gorila, we decompose the standard deep reinforcement learning algorithm into two parts, which run concurrently with no high-level synchronization. the first part consists of stepping through an environment, evaluating a policy implemented as a deep neural network, and storing the observed data in a replay memory. we refer to this as acting. the second part consists of sampling batches of data from the memory to update the policy parameters. we term this learning. [width= trim=0pt 400pt 0pt 0pt, clip] images/ apex_architecture.pdf [t!] actor {algorithmic} [1] t agent in environment instance, storing experiences. call to obtain latest network parameters. initial state from environment. to t an action using the current policy. the action in the environment. data to local buffer. a background thread, periodically send data to replay. buffered data (e.g. batch of multi-step transitions). priorities for experience (e.g. absolute td error). call to add experience to replay memory. latest network parameters. [t!] learner {algorithmic} [1] network using batches sampled from memory. to t the parameters t times. a prioritized batch of transitions (in a background thread). learning rule; e.g. double q-learning or ddpg priorities for experience, (e.g. absolute td error). call to update priorities. old experience from replay memory. in principle, both acting and learning may be distributed across multiple workers. in our experiments, hundreds of actors run on cpus to generate data, and a single learner running on a gpu samples the most useful experiences (figure [reference]). pseudocode for the actors and learners is shown in algorithms [reference] and [reference]. updated network parameters are periodically communicated to the actors from the learner. in contrast to gorila, we use a shared, centralized replay memory, and instead of sampling uniformly, we prioritize, to sample the most useful data more often. since priorities are shared, high priority data discovered by any actor can benefit the whole system. priorities can be defined in various ways, depending on the learning algorithm; two instances are described in the next sections. in prioritized dqn prioritized-replay priorities for new transitions were initialized to the maximum priority seen so far, and only updated once they were sampled. this does not scale well: due to the large number of actors in our architecture, waiting for the learner to update priorities would result in a myopic focus on the most recent data, which has maximum priority by construction. instead, we take advantage of the computation the actors in ape-x are already doing to evaluate their local copies of the policy, by making them also compute suitable priorities for new transitions online. this ensures that data entering the replay has more accurate priorities, at no extra cost. sharing experiences has certain advantages compared to sharing gradients. low latency communication is not as important as in distributed sgd, because experience data becomes outdated less rapidly than gradients, provided the learning algorithm is robust to off-policy data. across the system, we take advantage of this by batching all communications with the centralized replay, increasing the efficiency and throughput at the cost of some latency. with this approach it is even possible for actors and learners to run in different data-centers without limiting performance. finally, by learning off-policy [cf.][] suttonbarto:1998, suttonbarto:2017, we can further take advantage of ape-x's ability to combine data from many distributed actors, by giving the different actors different exploration policies, broadening the diversity of the experience they jointly encounter. as we will see in the results, this can be sufficient to make progress on difficult exploration problems. subsection: ape-x dqn the general framework we have described may be combined with different learning algorithms. first, we combined it with a variant of dqn dqn with some of the components of rainbow rainbow. more specifically, we used double q-learning doubleq, deepdoubleqlearning with multi-step bootstrap targets [cf.][] sutton:1988, suttonbarto:1998, suttonbarto:2017, a3c as the learning algorithm, and a dueling network architecture dueling as the function approximator. this results in computing for all elements in the batch the loss with where is a time index for an experience sampled from the replay starting with state and action, and denotes parameters of the target network dqn, a slow moving copy of the online parameters. multi-step returns are truncated if the episode ends in fewer than steps. in principle, q-learning variants are off-policy methods, so we are free to choose the policies we use to generate data. however, in practice, the choice of behaviour policy does affect both exploration and the quality of function approximation. furthermore, we are using a multi-step return with no off-policy correction, which in theory could adversely affect the value estimation. nonetheless, in ape-x dqn, each actor executes a different policy, and this allows experience to be generated from a variety of strategies, relying on the prioritization mechanism to pick out the most effective experiences. in our experiments, the actors use-greedy policies with different values of. low policies allow exploring deeper in the environment, while high policies prevent over-specialization. subsection: ape-x dpg to test the generality of the framework we also combined it with a continuous-action policy gradient system based on ddpg ddpg, an implementation of deterministic policy gradients also similar to older methods adhdp, acd, and tested it on continuous control tasks from the deepmind control suite tassa2018suite. the ape-x dpg setup is similar to ape-x dqn, but the actor's policy is now represented explicitly by a separate policy network, in addition to the q-network. the two networks are optimized separately, by minimizing different losses on the sampled experience. we denote the policy and q-network parameters by and respectively, and adopt the same convention as above to denote target networks. the q-network outputs an action-value estimate for a given state, and multi-dimensional action. it is updated using temporal-difference learning with a multi-step bootstrap target. the q-network loss can be written as, where the policy network outputs an action. the policy parameters are updated using policy gradient ascent on the estimated q-value, using gradient\u2014 note that this depends on the policy parameters only through the action that is input to the critic network. further details of the ape-x dpg algorithm are available in the appendix. section: experiments subsection: atari [width=] images/ [width=] images/ in our first set of experiments we evaluate ape-x dqn on atari, and show state of the art results on this standard reinforcement learning benchmark. we use 360 actor machines (each using one cpu core) to feed data into the replay memory as fast as they can generate it; approximately 139 frames per second (fps) each, for a total of 50 k fps, which corresponds to 12.5 k transitions (because of a fixed action repeat of 4). the actors batch experience data locally before sending it to the replay: up to 100 transitions may be buffered at a time, which are then sent asynchronously in batches of. the learner asynchronously prefetches up to 16 batches of 512 transitions, and computes updates for 19 such batches each second, meaning that gradients are computed for 9.7 k transitions per second on average. to reduce memory and bandwidth requirements, observation data is compressed using a png codec when sent and when stored in the replay. the learner decompresses data as it prefetches it, in parallel with computing and applying gradients. the learner also asynchronously handles any requests for parameters from actors. actors copy the network parameters from the learner every 400 frames (2.8 seconds). each actor executes an-greedy policy where with,. each is held constant throughout training. the episode length is limited to 50000 frames during training. the capacity of the shared experience replay memory is soft-limited to 2 million transitions: adding new data is always permitted, to not slow down the actors, but every 100 learning steps any excess data above this capacity threshold is removed en masse, in fifo order. the median actual size of the memory is 2035050. data is sampled according to proportional prioritization, with a priority exponent of 0.6 and an importance sampling exponent set to 0.4. in figure [reference], on the left, we compare the median human normalized score across all 57 games to several baselines: dqn, prioritized dqn, distributional dqn distributional, rainbow, and gorila. in all cases the performance is measured at the end of training under the no-op starts testing regime dqn. on the right, we show initial learning curves (taken from the greediest actor) for a selection of 6 games (full learning curves for all games are in the appendix). given that ape-x can harness substantially more computation than most baselines, one might expect it to train faster. figure [reference] shows that this was indeed the case. perhaps more surprisingly, our agent achieved a substantially higher final performance. in table [reference] we compare the median human-normalized performance of ape-x dqn on the atari benchmark to corresponding metrics as reported for other baseline agents in their respective publications. whenever available we report results both for no-op starts and for human starts. the human-starts regime gorila corresponds to a more challenging generalization test, as the agent is initialized from random starts drawn from games played by human experts. ape-x's performance is higher than the performance of any of the baselines according to both metrics. subsection: continuous control in a second set of experiments we evaluated ape-x dpg on four continuous control tasks. in the manipulator domain the agent must learn to bring a ball to a specified location. in the humanoid domain the agent must learn to control a humanoid body to solve three distinct tasks of increasing complexity: standing, walking and running. since here we learn from features, rather than from pixels, the observation space is much smaller than it is in the atari domain. we therefore use small, fully-connected networks (details in the appendix). with 64 actors on this domain, we obtain 14 k total fps (the same number of transitions per second; here we do not use action repeats). we process 86 batches of 256 transitions per second, or 22 k transitions processed per second. figure [reference] shows that ape-x dpg achieved very good performance on all four tasks. the figure shows the performance of ape-x dpg for different numbers of actors: as the number of actors increases our agent becomes increasingly effective at solving these problems rapidly and reliably, outperforming a standard ddpg baseline trained for over 10 times longer. a parallel paper d4pg builds on this work by combining ape-x dpg with distributional value functions, and the resulting algorithm is successfully applied to further continuous control tasks. [width=0.8clip] images/ section: analysis [width=0.85trim=0pt 0 0pt 40pt, clip] images/ in this section we describe additional ape-x dqn experiments on atari that helped improve our understanding of the framework, and we investigate the contribution of different components. first, we investigated how the performance scales with the number of actors. we trained our agent with different numbers of actors (8, 16, 32, 64, 128 and 256) for 35 hours on a subset of 6 atari games. in all experiments we kept the size of the shared experience replay memory fixed at 1 million transitions. figure [reference] shows that the performance consistently improved as the number of actors increased. the appendix contains learning curves for additional games, and a comparison of the scalability of the algorithm with and without prioritized replay. it is perhaps surprising that performance improved so substantially purely by increasing the number of actors, without changing the rate at which the network parameters are updated, the structure of the network, or the update rule. we hypothesize that the proposed architecture helps with a common deep reinforcement learning failure mode, in which the policy discovered is a local optimum in the parameter space, but not a global one, e.g., due to insufficient exploration. using a large number of actors with varying amounts of exploration helps to discover promising new courses of action, and prioritized replay ensures that when this happens, the learning algorithm focuses its efforts on this important information. next, we investigated varying the capacity of the replay memory (see figure [reference]). we used a setup with 256 actors, for a median of 37 k total environment frames per second (approximately 9 k transitions). with such a large number of actors, the contents of the memory is replaced much faster than in most dqn-like agents. we observed a small benefit to using a larger replay capacity. we hypothesize this is due to the value of keeping some high priority experiences around for longer and replaying them. as above, a single learner machine trained the network with median 19 batches per second, each of 512 transitions, for a median of 9.7 k transitions processed per second. [width= trim=0pt 0 0pt 40pt, clip] images/ finally, we ran additional experiments to disentangle potential effects of two confounding factors in our scalability analysis: recency of the experience data in the replay memory, and diversity of the data-generating policies. the full description of these experiments is confined to the appendix; to summarize, neither factor alone is sufficient to explain the performance we see. we therefore conclude that the results are due substantially to the positive effects of gathering more experience data; namely better exploration of the environment and better avoidance of overfitting. section: conclusion we have designed, implemented, and analyzed a distributed framework for prioritized replay in deep reinforcement learning. this architecture achieved state of the art results in a wide range of discrete and continuous tasks, both in terms of wall-clock learning speed and final performance. in this paper we focused on applying the ape-x framework to dqn and dpg, but it could also be combined with any other off-policy reinforcement learning update. for methods that use temporally extended sequences [e.g.,] [] a3c, acer, the ape-x framework may be adapted to prioritize sequences of past experiences instead of individual transitions. ape-x is designed for regimes in which it is possible to generate large quantities of data in parallel. this includes simulated environments but also a variety of real-world applications, such as robotic arm farms, self-driving cars, online recommender systems, or other multi-user systems in which data is generated by many instances of the same environment [c.f.][] concurrent-rl. in applications where data is costly to obtain, our approach will not be directly applicable. with powerful function approximators, overfitting is an issue: generating more training data is the simplest way of addressing it, but may also provide guidance towards data-efficient solutions. many deep reinforcement learning algorithms are fundamentally limited by their ability to explore effectively in large domains. ape-x uses a naive yet effective mechanism to address this issue: generating a diverse set of experiences and then identifying and learning from the most useful events. the success of this approach suggests that simple and direct approaches to exploration may be feasible, even for synchronous agents. our architecture illustrates that distributed systems are now practical both for research and, potentially, large-scale applications of deep reinforcement learning. we hope that the algorithms, architecture, and analysis we have presented will help to accelerate future efforts in this direction. subsubsection: acknowledgments we would like to acknowledge the contributions of our colleagues at deepmind, whose input and support has been vital to the success of this work. thanks in particular to tom schaul, joseph modayil, sriram srinivasan, georg ostrovski, josh abramson, todd hester, jean-baptiste lespiau, alban rrustemi and dan belov. bibliography: references appendix: recency of experience [width=] images/ apex_iclr_virtual_actors [width=] images/ in our main experiments we do not change the size of the replay memory in proportion to the number of actors, so by changing the number of actors we also increased the rate at which the contents of the replay memory is replaced. this means that in the experiments with more actors, transitions in the replay memory are more recent: they are generated by following policies whose parameters are closer to version of the parameters being optimized by the learner, and in this sense they are more on-policy. could this alone be sufficient to explain the improved performance? if so, we might be able to recover the results without needing a large number of actor machines. to test this, we constructed an experiment wherein we replicate the rate at which the contents of the replay memory is replaced in the 256-actor experiments, but instead of actually using 256 actors, we use 32 actors but add each transition they generate to the replay memory 8 times over. in this setup, the contents of the replay memory is similarly generated by policies with a recent version of the network parameters: the only difference is that the data is not as diverse as in the 256-actor case. we observe (see figure [reference]) that this does not recover the same performance, and therefore conclude that the recency of the experience alone is not sufficient to explain the performance of our method. indeed, we see that adding the same data multiple times can sometimes harm performance, since although it increases recency this comes at the expense of diversity. note: in principle, duplicating the added data in this fashion has a similar effect to reducing the capacity of the replay memory, and indeed, our results with a smaller replay memory in figure [reference] do corroborate the finding. however, we test also by duplicating the data primarily in order to exclude any effects arising from the implementation. in particular, in contrast to simply reducing the replay capacity, duplicating each data point means that the computational demands on the replay server in these runs are the same as when we use the corresponding number of real actors. appendix: varying the data-generating policies another factor that could conceivably contribute to the scalability of our algorithm is the fact that each actor has a different. to determine the extent to which this impacts upon the performance, we ran an experiment (see figure [reference]) with some simple variations on the mechanism we use to choose the policies that generate the data we train on. the first alternative we tested is to choose a small fixed set of 6 values for, instead of the full range that we typically use. in this test, we use prioritized replay as normal, and we find that the results with the full range of are overall slightly better. however, it is not essential for achieving good results within our distributed framework. appendix: atari: additional details the frames received from the environment are preprocessed on the actor side with the standard transformations introduced by dqn. this includes greyscaling, frame stacking, repeating actions 4 times, and clipping rewards to. the learner waits for at least 50000 transitions to be accumulated in the replay before starting learning. we use a centered rmsprop optimizer with a learning rate of 0.00025/ 4, decay of 0.95, epsilon of 1.5e-7, and no momentum to minimize the multi-step loss (with). gradient norms are clipped to 40. the target network used in the loss calculation is copied from the online network every 2500 training batches. we use the same network as in the dueling ddqn agent. appendix: continuous control: additional details the critic network has a layer with 400 units, followed by a tanh activation, followed by another layer of 300 units. the actor network has a layer with 300 units, followed by a tanh activation, followed by another layer of 200 units. the gradient used to update the actor network is clipped to, element-wise. training uses the adam optimizer () with learning rate of. the target network used in the loss calculation is copied from the online network every 100 training batches. replay sampling priorities are set according to the absolute td error as given by the critic, and are sampled by the learner using proportional prioritized sampling (see appendix [reference]) with priority exponent. to maintain a fixed replay capacity of, transitions are periodically evicted using proportional prioritized sampling, with priority exponent. this is a different strategy for removing data than in the atari experiments, which simply removed the oldest data first-it remains to be seen which is superior. unlike the original dpg algorithm which applies autocorrelated noise sampled from a ornstein-uhlenbeck process (), we apply exploration noise to each action sampled from a normal distribution with. evaluation is performed using the noiseless deterministic policy. hyperparameters are otherwise as per dqn. benchmarking was performed in two continuous control domains ((a) humanoid and (b) manipulator, see figure [reference]) implemented in the mujoco physics simulator (). humanoid is a humanoid walker with action, state and observation dimensionalities, and respectively. three humanoid tasks were considered: walk (reward for exceeding a minimum velocity), run (reward proportional to movement speed) and stand (reward proportional to standing height). manipulator is a 2-dimensional planar arm with, and, which receives reward for catching a randomly-initialized moving ball..5 [width=.6]./ images/ humanoid.png.5 [width=.6]./ images/ manipulator.png appendix: tuning on atari, we performed some limited tuning of the learning rate and batch size: we found that larger batch sizes contribute significantly to performance, when using many actors. we tried batch sizes from {32, 128, 256, 512, 1024}, seeing clear benefits up to 512. we attempted increasing the learning rate to 0.00025 with the larger batch sizes but this destabilized training on some games. we also tried a lower learning rate of 0.00025/ 8, but this did not reliably improve results. likewise for continuous control, we experimented with batch sizes {32, 128, 256, 512, 1024} and learning rates from to. we also experimented with the prioritization exponents from to, with results proving essentially consistent within the range [0.3, 0.7] (beyond 0.7, training would sometimes become unstable and diverge). for the experiments with many actors, we set the period for updating network parameters on the actors to be high enough that the learner was not overloaded with requests, and we set the number of transitions that are locally accumulated on each actor to be high enough that the replay server would not be overloaded with network traffic, but we did not otherwise tune those parameters and have not observed them to have significant impact on the learning dynamics. appendix: implementation the following section makes explicit some of the more practical details that may be of interest to anyone wishing to implement a similar system. paragraph: data storage the algorithm is implemented using tensorflow tensorflow. replay data is kept in a distributed in-memory key-value store implemented using custom tensorflow ops, similar to the lookup ops available in core tensorflow. the ops allow adding, reading, and removing batches of tensor data efficiently. paragraph: sampling data we also implemented ops for efficiently maintaining and sampling from a prioritized distribution over the keys, using the algorithm for proportional prioritization described in. the probability of sampling a transition is where is the priority of the transition with key. the exponent controls the amount of prioritization, and when uniform sampling is recovered. the proportional variant sets priority where is the td error for transition. whenever a batch of data is added to or removed from the store, or is processed by the learner, this distribution is correspondingly updated, recording any change to the set of valid keys and the priorities associated with them. a background thread on the learner fetches batches of sampled data from the remote replay and decompresses it using the learner's cpu, in parallel with the gradients being computed on the gpu. the fetched data is buffered in a tensorflow queue, so that the gpu always has data available to train on. paragraph: adding data in order to efficiently construct-step transition data, each actor maintains a circular buffer of capacity containing tuples, where is the current size of the buffer. with each step, the new data is appended and the accumulated per-step discounts and partial returns for all entries in the buffer are updated. if the buffer has reached its capacity,, then its first element may be combined with the latest state and value estimates to produce a valid-step transition (with accompanying q-values). however, instead of being directly added to the remote replay memory on each step, the constructed transitions are first stored in a local tensorflow queue, in order to reduce the number of requests to the replay server. the queue is periodically flushed, at which stage the absolute-step td-errors (and thus the initial priorities) for the queued transitions are computed in batch, using the buffered q-values to avoid recomputation. the q-value estimates from which the initial priorities are derived are therefore based on the actor's copy of the network parameters at the time the corresponding state was obtained from the environment, rather than the latest version on the learner. these q-values need not be stored after this, since the learner does not require them, although they can be helpful for debugging. a unique key is assigned to each transition, which records which actor and environment step it came from, and the dequeued transition tuples are stored in the remote replay memory. as mentioned in the previous section, the remote sampling distribution is immediately updated with the newly added keys and the corresponding initial priorities computed by the actor. note that, since we store both the start and the end state with each transition, we are storing some data twice: this costs more ram, but simplifies the code. paragraph: contention it is important that the replay server be able to handle all requests in a timely fashion, in order to avoid slowing down the whole system. possible bottlenecks include cpu, network bandwidth, and any locks protecting the shared data. in our experiments we found cpu to be the main bottleneck, but this was resolved by ensuring all requests and responses use sufficiently large batches. nonetheless, it is advisable to consider all of these potential performance concerns when designing such systems. paragraph: asynchronicity in our framework, since acting and learning proceed with no synchronization, and performance depends on both, it can be misleading to consider performance with reference to only one of these. for example, the results after a given total number of environment frames have been experienced are highly dependent on the number of updates the learner has performed in that time. for this reason it is important to monitor and report the speeds of all parts of the system and to consider them when analyzing results. paragraph: failure tolerance in distributed systems with many workers, it is inevitable that interruptions or failures will occur, either due to occasional hardware issues or because shared resources are needed by higher priority jobs. all stateful parts of the system therefore must periodically save their work and be able to resume where they left off when restarted. in our system, actors may be interrupted at any time and this will not prevent continued learning, albeit with a temporarily reduced rate of new data entering the replay memory. if the replay server is interrupted, the data it contains is discarded, and upon resuming, the memory is refilled quickly by the actors. in this event, to avoid overfitting, the learner will pause training briefly, until the minimum amount of data has once again been accumulated. if the learner is interrupted, progress will stall until it resumes. [width=0.99] images/ [width=0.99] images/ [height=4cm] images/ [width=0.95] images/ apex_iclr_num_actors",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "distributed prioritized experience"
                    ],
                    [
                        "distributed prioritized experience replay"
                    ]
                ],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "dqn",
                        "ape-x"
                    ]
                ],
                "Metric": [
                    [
                        "human normalized score",
                        "median human-normalized performance"
                    ]
                ],
                "Task": [
                    [
                        "atari games",
                        "atari"
                    ]
                ]
            }
        ]
    },
    "2138a7127429d67746ec78de46d6820fee0e548e-29": {
        "doctext": "document: graph2seq: graph to sequence learning with attention-based neural networks the celebrated sequence to sequence learning (seq2seq) technique and its numerous variants achieve excellent performance on many tasks. however, many machine learning tasks have inputs naturally represented as graphs; existing seq2seq models face a significant challenge in achieving accurate conversion from graph form to the appropriate sequence. to address this challenge, we introduce a novel general end-to-end graph-to-sequence neural encoder-decoder model that maps an input graph to a sequence of vectors and uses an attention-based lstm method to decode the target sequence from these vectors. our method first generates the node and graph embeddings using an improved graph-based neural network with a novel aggregation strategy to incorporate edge direction information in the node embeddings. we further introduce an attention mechanism that aligns node embeddings and the decoding sequence to better cope with large graphs. experimental results on babi, shortest path, and natural language generation tasks demonstrate that our model achieves state-of-the-art performance and significantly outperforms existing graph neural networks, seq2seq, and tree2seq models; using the proposed bi-directional node embedding aggregation strategy, the model can converge rapidly to the optimal performance. section: introduction the celebrated sequence to sequence learning (seq2seq) technique and its numerous variants achieve excellent performance on many tasks such as neural machine translation bahdanau2014neural, gehring2017convolutional, natural language generation (nlg) dblp: conf/ acl/ songpzwg17 and speech recognition zhang2017very. most of the proposed seq2seq models can be viewed as a family of encoder-decoders dblp: conf/ nips/ sutskevervl14, cho2014learning, bahdanau2014neural, where an encoder reads and encodes a source input in the form of sequences into a continuous vector representation of fixed dimension, and a decoder takes the encoded vectors and outputs a target sequence. many other enhancements including bidirectional recurrent neural networks (bi-rnn) schuster1997bidirectional or bidirectional long short-term memory networks (bi-lstm) graves2005framewise as encoder, and attention mechanism bahdanau2014neural, luong2015effective, have been proposed to further improve its practical performance for general or domain-specific applications. despite their flexibility and expressive power, a significant limitation with the seq2seq models is that they can only be applied to problems whose inputs are represented as sequences. however, the sequences are probably the simplest structured data, and many important problems are best expressed with a more complex structure such as graphs that have more capacity to encode complicated pair-wise relationships in the data. for example, one task in nlg applications is to translate a graph-structured semantic representation such as abstract meaning representation to a text expressing its meaning banarescu2013abstract. in addition, path planning for a mobile robot hu2004knowledge and path finding for question answering in babi task li2015gated can also be cast as graph-to-sequence problems. on the other hand, even if the raw inputs are originally expressed in a sequence form, it can still benefit from the enhanced inputs with additional information (to formulate graph inputs). for example, for semantic parsing tasks (text-to-amr or text-to-sql), they have been shown better performance by augmenting the original sentence sequences with other structural information such as dependency parsing trees pust2015parsing. intuitively, the ideal solution for graph-to-sequence tasks is to build a more powerful encoder which is able to learn the input representation regardless of its inherent structure. to cope with graph-to-sequence problems, a simple and straightforward approach is to directly convert more complex structured graph data into sequences iyer2016summarizing, gomez2016automatic, liu2017retrosynthetic, and apply sequence models to the resulting sequences. however, the seq2seq model often fails to perform as well as hoped on these problems, in part because it inevitably suffers significant information loss due to the conversion of complex structured data into a sequence, especially when the input data is naturally represented as graphs. recently, a line of research efforts have been devoted to incorporate additional information by extracting syntactic information such as the phrase structure of a source sentence (tree2seq) eriguchi2016tree, by utilizing attention mechanisms for input sets (set2seq) vinyals2015order, and by encoding sentences recursively as trees socher2010learning, tai2015improved. although these methods achieve promising results on certain classes of problems, most of the presented techniques largely depend on the underlying application and may not be able to generalize to a broad class of problems in a general way. to address this issue, we propose graph2seq, a novel general attention-based neural network model for graph-to-sequence learning. the graph2seq model follows the conventional encoder-decoder approach with two main components, a graph encoder and a sequence decoder. the proposed graph encoder aims to learn expressive node embeddings and then to reassemble them into the corresponding graph embeddings. to this end, inspired by a recent graph representation learning method hamilton2017inductive, we propose an inductive graph-based neural network to learn node embeddings from node attributes through aggregation of neighborhood information for directed and undirected graphs, which explores two distinct aggregators on each node to yield two representations that are concatenated to form the final node embedding. in addition, we further design an attention-based rnn sequence decoder that takes the graph embedding as its initial hidden state and outputs a target prediction by learning to align and translate jointly based on the context vectors associated with the corresponding nodes and all previous predictions. our code and data are available at. graph2seq is simple yet general and is highly extensible where its two building blocks, graph encoder and sequence decoder, can be replaced by other models such as graph convolutional (attention) networks kipf2016semi, velickovic2017graph or their extensions schlichtkrull2017modeling, and lstm hochreiter1997long. we highlight three main contributions of this paper as follows: we propose a novel general attention-based neural networks model to elegantly address graph-to-sequence learning problems that learns a mapping between graph-structured inputs to sequence outputs, which current seq2seq and tree2seq may be inadequate to handle. we propose a novel graph encoder to learn a bi-directional node embeddings for directed and undirected graphs with node attributes by employing various aggregation strategies, and to learn graph-level embedding by exploiting two different graph embedding techniques. equally importantly, we present an attention mechanism to learn the alignments between nodes and sequence elements to better cope with large graphs. experimental results show that our model achieves state-of-the-art performance on three recently introduced graph-to-sequence tasks and significantly outperforms existing graph neural networks, seq2seq, and tree2seq models. section: related work our model draws inspiration from the research fields of graph representation learning, neural networks on graphs, and neural encoder-decoder models. graph representation learning. graph representation learning has been proven extremely useful for a broad range of the graph-based analysis and prediction tasks, goyal2017graph. the main goal for graph representation learning is to learn a mapping that embeds nodes as points in a low-dimensional vector space. these representation learning approaches can be roughly categorized into two classes including matrix factorization-based algorithms and random-walk based methods. a line of research learn the embeddings of graph nodes through matrix factorization roweis2000nonlinear, belkin2002laplacian, ahmed2013distributed, cao2015grarep, ou2016asymmetric. these methods directly train embeddings for individual nodes of training and testing data jointly and thus inherently transductive. another family of work is the use of random walk-based methods to learn low-dimensional embeddings of nodes by exploring neighborhood information for a single large-scale graph duran2017leanring, hamilton2017inductive, tang2015line, grover2016node2vec, perozzi2014deepwalk, velickovic2017graph. graphsage hamilton2017inductive is such a technique that learns node embeddings through aggregation from a node local neighborhood using node attributes or degrees for inductive learning, which has better capability to generate node embeddings for previously unseen data. our graph encoder is an extension to graphsage with two major distinctions. first, we non-trivially generalize it to cope with both directed and undirected graphs by splitting original node into forward nodes (a node directs to) and backward nodes (direct to a node) according to edge direction and applying two distinct aggregation functions to these types of nodes. second, we exploit two different schemes (pooling-based and supernode-based) to reassemble the learned node embeddings to generate graph embedding, which is not studied in graphsage. we show the advantages of our graph encoder over graphsage in our experiments. neural networks on graphs. over the past few years, there has been a surge of approaches that seek to learn the representations of graph nodes, or entire (sub) graphs, based on graph neural networks (gnn) that extend well-known network architectures including rnn and cnn to graph data gori2005new, scarselli2009graph, li2015gated, bruna2013spectral, duvenaud2015convolutional, niepert2016learning,, yang2016revisiting, kipf2016semi, chen2018fastgcn. a line of research is the neural networks that operate on graphs as a form of rnn gori2005new, scarselli2009graph, and recently extended by li et al. li2015gated by introducing modern practices of rnn (using of gru updates) in the original gnn framework. another important stream of work that has recently drawn fast increasing interest is graph convolutional networks (gcn) built on spectral graph theory, introduced by and then extended by with fast localized convolution. most of these approaches can not scale to large graphs, which is improved by using a localized first-order approximation of spectral graph convolution kipf2016semi and further equipping with important sampling for deriving a fast gcn chen2018fastgcn. the closely relevant work to our graph encoder is gcn kipf2016semi, which is designed for semi-supervised learning in transductive setting that requires full graph laplacian to be given during training and is typically applicable to a single large undirected graph. an extension of gcn can be shown to be mathematically related to one variant of our graph encoder on undirected graphs. we compare the difference between our graph encoder and gcn in our experiments. another relevant work is gated graph sequence neural networks (ggs-nns) li2015gated. although it is also designed for outputting a sequence, it is essentially a prediction model that learns to predict a sequence embedded in graph while our approach is a generative model that learns a mapping between graph inputs and sequence outputs. a good analogy that can be drawn between our proposed graph2seq and ggs-nns is the relationship between convolutional seq2seq and rnn. neural encoder-decoder models. one of the most successful encoder-decoder architectures is the sequence to sequence learning dblp: conf/ nips/ sutskevervl14, cho2014learning, bahdanau2014neural, luong2015effective, gehring2017convolutional, which are originally proposed for machine translation. recently, the classical seq2seq model and its variants have been applied to several applications in which these models can perform mappings from objects to sequences, including mapping from an image to a sentence vinyals2015show, models for computation map from problem statements of a python program to their solutions (the answers to the program) zaremba2014learning, the traveling salesman problem for the set of points vinyals2015pointer and deep generative model for molecules generation from existing known molecules in drug discovery. it is easy to see that the objects that are mapped to sequences in the listed examples are often naturally represented in graphs rather than sequences. recently, many research efforts and the key contributions have been made to address the limitations of seq2seq when dealing with more complex data, that leverage external information using specialized neural models attached to underlying targeted applications, including tree2seq eriguchi2016tree, set2seq vinyals2015order, recursive neural networks socher2010learning, and tree-structured lstm tai2015improved. due to more recent advances in graph representations and graph convolutional networks, a number of research has investigated to utilize various gnn to improve the performance over the seq2seq models in the domains of machine translation and graph generation bastings2017graph, beck2018graph, simonovsky2018graphvae, li2018learning. there are several distinctions between these work and ours. first, our model is the first general-purpose encoder-decoder model for graph-to-sequence learning that is applicable to different applications while the aforementioned research has to utilize domain-specific information. second, we design our own graph embedding techniques for our graph decoder while most of other work directly apply existing gnn to their problems. section: graph-to-sequence model as shown in figure [reference], our graph-to-sequence model includes a graph encoder, a sequence decoder, and a node attention mechanism. following the conventional encoder-decoder architecture, the graph encoder first generates node embeddings, and then constructs graph embeddings based on the learned node embeddings. finally, the sequence decoder takes both the graph embeddings and node embeddings as input and employs attention over the node embeddings whilst generating sequences. in this section, we first introduce the node-embedding generation algorithm which derives the bi-directional node embeddings by aggregating information from both forward and backward neighborhoods of a node in a graph. upon these node embeddings, we propose two methods for generating graph embeddings capturing the whole-graph information. subsection: node embedding generation inspired by, we design a new inductive node embedding algorithm that generates bi-directional node embeddings by aggregating information from a node local forward and backward neighborhood within hops for both directed and undirected graphs. in order to make it more clear, we take the embedding generation process for node as an example to explain our node embedding generation algorithm: we first transform node's text attribute to a feature vector, av, by looking up the embedding matrix w. note that for some tasks where's text attribute may be a word sequence, one neural network layer, such as an lstm layer, could be additionally used to generate av. we categorize the neighbors of into forward neighbors,, and backward neighbors,, according to the edge direction. in particular, returns the nodes that directs to and returns the nodes that direct to; we aggregate the forward representations of's forward neighbors {h\u22a2u-k1,} into a single vector, h\u2062n\u22a2 (v) k, where is the iteration index. in our experiments, we find that the aggregator choice,, may heavily affect the overall performance and we will discuss it later. notice that at iteration, this aggregator only uses the representations generated at. the initial forward representation of each node is its feature vector calculated in step (1); we concatenate's current forward representation, h\u22a2v-k1, with the newly generated neighborhood vector, h\u2062n\u22a2 (v) k. this concatenated vector is fed into a fully connected layer with nonlinear activation function, which updates the forward representation of, h\u22a2vk, to be used at the next iteration; we update the backward representation of, h\u22a3vk, using the similar procedure as introduced in step (3) and (4) except that operating on the backward representations instead of the forward representations; we repeat steps (3) (5) times, and the concatenation of the final forward and backward representation is used as the final bi-directional representation of. since the neighbor information from different hops may have different impact on the node embedding, we learn a distinct aggregator at each iteration. aggregator architectures. since a node neighbors have no natural ordering, the aggregator function should be invariant to permutations of its inputs, ensuring that our neural network model can be trained and applied to arbitrarily ordered node-neighborhood feature sets. in practice, we examined the following three aggregator functions: mean aggregator: this aggregator function takes the element-wise mean of the vectors in {h\u22a2u-k1,} and {h\u22a3u-k1,}. lstm aggregator: similar to hamilton2017inductive, we also examined a more complex aggregator based on an long short term memory (lstm) architecture. note that lstms are not inherently symmetric since they process their inputs sequentially. we use lstms to operate on unordered sets by simply applying them to a single random permutation of the node neighbors. pooling aggregator: in this aggregator, each neighbor's vector is fed through a fully-connected neural network, and an element-wise max-pooling operation is applied: where max denotes the element-wise max operator, and is a nonlinear activation function. by applying max-pooling, the model can capture different information across the neighborhood set. subsection: graph embedding generation most existing works of graph convolution neural networks focus more on node embeddings rather than graph embeddings since their focus is on the node-wise classification task. however, graph embeddings that convey the entire graph information are essential to the downstream decoder. in this work, we introduce two approaches (i.e., pooling-based and node-based) to generate these graph embeddings from the node embeddings. pooling-based graph embedding. in this approach, we investigated three pooling techniques: max-pooling, min-pooling and average-pooling. in our experiments, we fed the node embeddings to a fully-connected neural network and applied each pooling method element-wise. we found no significant performance difference across the three different pooling approaches; we thus adopt the max-pooling method as our default pooling approach. node-based graph embedding. in this approach, we add one super node,, into the input graph, and all other nodes in the graph direct to. we use the aforementioned node embedding generation algorithm to generate the embedding of by aggregating the embeddings of the neighbor nodes. the embedding of that captures the information of all nodes is regarded as the graph embedding. subsection: attention based decoder the sequence decoder is a recurrent neural network (rnn) that predicts the next token, given all the previous words, the rnn hidden state for time, and a context vector that directs attention to the encoder side. in particular, the context vector depends on a set of node representations (,\u2026,) which the graph encoder maps the input graph to. each node representation contains information about the whole graph with a strong focus on the parts surrounding the-th node of the input graph. the context vector is computed as a weighted sum of these node representations and the weight of each node representation is computed by: where is an which scores how well the input node around position and the output at position match. the score is based on the rnn hidden state and the-th node representation of the input graph. we parameterize the alignment model as a feed-forward neural network which is jointly trained with other components of the proposed system. our model is jointly trained to maximize the conditional log-probability of the correct description given a source graph. in the inference phase, we use the beam search to generate a sequence with the beam size= 5. section: experiments we conduct experiments to demonstrate the effectiveness and efficiency of the proposed method. following the experimental settings in li2015gated, we firstly compare its performance with classical lstm, ggs-nn, and gcn based methods on two selected tasks including babi task 19 and the shortest path task. we then compare graph2seq against other seq2seq based methods on a real-world application-natural language generation task. note that the parameters of all baselines are set based on performance on the development set. experimental settings. our proposed model is trained using the adam optimizer dblp: journals/ corr/ kingmab14, with mini-batch size 30. the learning rate is set to 0.001. we apply the dropout strategy dblp: journals/ jmlr/ srivastavahkss14 with a ratio of 0.5 at the decoder layer to avoid overfitting. gradients are clipped when their norm is bigger than 20. for the graph encoder, the default hop size is set to 6, the size of node initial feature vector is set to 40, the non-linearity function is relu dblp: journals/ jmlr/ glorotbb11, the parameters of aggregators are randomly initialized. the decoder has 1 layer and hidden state size is 80. since graph2seq with mean aggregator and pooling-based graph embeddings generally performs better than other configurations (we defer this discussion to sec. [reference]), we use this setting as our default model in the following sections. subsection: babi task 19 setup. the babi artificial intelligence (ai) tasks dblp: journals/ corr/ westonbcm15 are designed to test reasoning capabilities that an ai system possesses. among these tasks, task 19 (path finding) is arguably the most challenging task (see, e.g., dblp: conf/ nips/ sukhbaatarswf15 which reports an accuracy of less than 20% for all methods that do not use strong supervision). we apply the transformation procedure introduced in li2015gated to transform the description as a graph as shown in figure [reference]. the left part shows an instance of babi task 19: given a set of sentences describing the relative geographical positions for a pair of objects and, we aim to find the geographical path between and. the question is then treated as finding the shortest path between two nodes, and, which represent and in the graph. to tackle this problem with graph2seq, we annotate with text attribute start and with text attribute end. for other nodes, we assign their ids in the graph as their text attributes. it is worth noting that, in our model, the start and end tokens are node features whose vector representations are first randomly initialized and then learned by the model later. in contrast, in ggs-nn, the vector representations of staring and end nodes are set as one-hot vectors, which is specially designed for the shortest path task. to aggregate the edge information into the node embedding, for each edge, we additionally add a node representing this edge into the graph and assign the edge's text as its text attribute. we generate 1000 training examples, 1000 development examples and 1000 test examples where each example is a graph-path pair. we use a standard lstm model hochreiter1997long and ggs-nn li2015gated as our baselines. since gcn kipf2016semi itself can not output a sequence, we also create a baseline that combines gcn with our sequence decoder. figurepath finding example. results. from table [reference], we can see that the lstm model fails on this task while our model makes perfect predictions, which underlines the importance of the use of graph encoder to directly encode a graph instead of using sequence model on the converted inputs from a graph. comparing to ggs-nn that uses carefully designed initial embeddings for different types of nodes such as start and end, our model uses a purely end-to-end approach which generates the initial node feature vectors based on random initialization of the embeddings for words in text attributes. however, we still significantly outperform ggs-nn, demonstrating the expressive power of our graph encoder that considers information flows in both forward and backward directions. we observe similar results when comparing our whole graph2seq model to gcn with our decoder, which mainly because the current form of gcn kipf2016semi is designed for undirected graph and thus may have information loss when converting directed graph to undirected one as suggested in kipf2016semi. subsection: shortest path task setup. we further evaluate our model on the shortest path (sp) task whose goal is to find the shortest directed path between two nodes in a graph, introduced in li2015gated. for this task, we created datasets by generating random graphs, and choosing pairs random nodes a and b which are connected by a unique shortest directed path. since we can control the size of generated graphs, we can easily test the performance changes of each model when increasing the size of graphs as well. two such datasets, sp-s and sp-l, were created, containing s mall (node size=5) and l arge graphs (node size=100), respectively. we restricted the length of the generated shortest paths for sp-s to be at least 2 and at least 4 for sp-l. for each dataset, we used 1000 training examples and 1000 development examples for parameter tuning, and evaluated on 1000 test examples. we choose the same baselines as introduced in the previous section. results. table [reference] shows that the lstm model still fails on both of these two datasets. our graph2seq model achieves comparable performance with ggs-nn that both models could achieve 100% accuracy on the sp-s dataset while achieves much better on larger graphs on the sp-l dataset. this is because our graph encoder is more expressive in learning the graph structural information with our dual-direction aggregators, which is the key to maintaining good performance when the graph size grows larger, while the performance of ggs-nn significantly degrades due to hardness of capturing the long-range dependence in a graph with large size. compared to gcn, it achieves better performance than ggs-nn but still much lower than our graph2seq, in part because of both the poor effectiveness of graph encoder and incapability of handling with directed graph. subsection: natural language generation task setup. we finally evaluate our model on a real-world application-natural language generation (nlg) task where we translate a structured semantic representation\u2014 in this case a structured query language (sql) query\u2014 to a natural language description expressing its meaning. as indicated in dblp: journals/ is/ spiliopoulouh92, the structure of sql query is essentially a graph. thus we naturally cast this task as an application of the graph-to-sequence model which takes a graph representing the semantic structure as input and outputs a sequence. figure [reference] illustrates the process of translation of an sql query to a corresponding natural language description via our graph2seq model. we use the bleu-4 score to evaluate our model on the wikisql dataset zhongseq2sql2017, a corpus of 87, 726 hand-annotated instances of natural language questions, sql queries, and sql tables. wikisql was created as the benchmark dataset for the table-based question answering task (for which the state-of-the-art performance is 82.6% execution accuracy yu2018typesql); here we reverse the use of the dataset, treating the sql query as the input and having the goal of generating the correct english question. these wikisql sql queries are split into training, development and test sets, which contain 61297 queries, 9145 queries and 17284 queries, respectively. since the sql-to-text task can be cast as\" machine translation\" type of problems, we implemented several baselines to address this task. the first one is an attention-based sequence-to-sequence (seq2seq) model proposed by bahdanau2014neural; the second one additionally introduces the copy mechanism in the decoder side gu2016incorporating; the third one is a tree-to-sequence (tree2seq) model proposed by eriguchi2016tree as our baseline; the fourth one is to combine a gcn kipf2016semi with our pge graph embeddings with our sequence decoder; the fifth one is to combine a ggs-nn li2015gated with our sequence decoder. to apply these baselines, we convert an sql query to a sequence or a tree using some templates which we discuss in detail in the appendix. results. from table [reference], we can see that our graph2seq model performs significantly better than the seq2seq, tree2seq, and graph2seq baselines. this result is expected since the structure of sql query is essentially a graph despite its expressions in sequence and a graph encoder is able to capture much more information directly in graph. among all graph2seq models, our graph2seq model performed best, in part due to a more effective graph encoder. tree2seq achieves better performance compared to seq2seq since its tree-based encoder explicitly takes the syntactic structure of a sql query into consideration. two variants of the graph2seq models can substantially outperform tree2seq, which demonstrates that a general graph to sequence model that is independent of different structural information in complex data is very useful. interestingly, we also observe that graph2seq-pge (pooling-based graph embedding) performs better than graph2seq-nge (node-based graph embedding). one potential reason is that the node-based graph embedding method artificially added a super node in graph which changes the original graph topology and brings unnecessary noise into the graph. figurea running example of the nlg task. subsection: impacts of aggregator, hop size and attention mechanism on garph2seq model setup. we now investigate the impact of the aggregator and the hop size on the graph2seq model. following the previous sp task, we further create three synthetic datasets: i) sdp\u2062dag whose graphs are directed acyclic graphs (dags); ii) sdp\u2062dcg whose graphs are directed cyclic graphs (dcgs) that always contain cycles; iii) sdp\u2062seq whose graphs are essentially sequential lines. for each dataset, we randomly generated 10000 graphs with the graph size 100 and split them as 8000/ 1000/ 1000 for the training/ development/ test set. for each graph, we generated an sdp query by choosing two random nodes with the constraints that there should be a unique shortest path connecting these two nodes, and that its length should be at least 4. we create six variants of the graph2seq model coupling with different aggregation strategies in the node embedding generation. the first three (graph2seq-ma,-la,-pa) use the m ean a ggregator, l stm a ggregator and p ooling a ggregator to aggregate node neighbor information, respectively. unlike these three models that aggregate the information of both forward and backward nodes, the other two models (graph2seq-ma-f,-ma-b) only consider one-way information aggregating the information from the forward nodes or the information from the backward nodes with the mean aggregator, respectively. we use the path accuracy to evaluate these models. the hop size is set to 10. impacts of the aggregator. table [reference] shows that on the sdp dataset, both graph2seq-ma and graph2seq-pa achieve the best performance. on more complicated structured data, such as sdp and sdp, graph2seq-ma (our default model) also performs better than other variants. we can also see that graph2seq-ma performs better than graph2seq-ma-f and graph2seq-ma-b on sdp and sdp since it captures more information from both directions to learn better node embeddings. however, graph2seq-ma-f and graph2seq-ma-b achieve comparable performance to graph2seq-ma on sdp. this is because in almost 95% of the graphs, 90% of the nodes could reach each other by traversing the graph for a given hop size, which dramatically restores its information loss. figuretest results on sdp. impact of hop size. to study the impact of the hop size, we create a sdp dataset, sdp and results are shown in figure [reference]. we see that the performance of all variants of graph2seq converges to its optimal performance when increasing the number of hop size. specifically, graph2seq-ma achieves significantly better performance than its counterparts considering only one direction propagation, especially when the hop size is small. as the hop size increases, the performance differences diminish. this is the desired property since graph2seq-ma can use much smaller hop size (about the half) to achieve the same performance of graph2seq-ma-f or graph2seq-ma-b with a larger size. this is particularly useful for large graphs where increasing hop size may need considerable computing resources and long run-time. we also compare graph2seq with gcn, where the hop size means the number of layers in the settings of gcn. surprisingly, even graph2seq-ma-f or graph2seq-ma-b can significantly outperform gcn with the same hope size despite its rough equivalence between these two architectures. it again illustrates the importance of the methods that could take into account both directed and undirected graphs. for additional experimental results on the impact of hop size for graphs of different sizes, please refer to the table 4 in appendix c. impact of attention mechanism. to investigate the impact of attention mechanism to the graph2seq model, we still evaluate our model on sdp, sdp and sdp datasets but without considering the attention strategy. as shown in table 4, we find that the attention strategy significantly improves the performance of all variants of graph2seq by at least 14.9%. this result is expected since for larger graphs it is more difficult for the encoder to compress all necessary information into a fixed-length vector; as intended, applying the attention mechanism in decoding enabled our proposed graph2seq model to successfully handle large graphs. section: conclusion in this paper, we study the graph-to-sequence problem, introducing a new general and flexible graph2seq model that follows the encoder-decoder architecture. we showed that, using our proposed bi-directional node embedding aggregation strategy, the graph encoder could successfully learn representations for three representative classes of directed graph, i.e., directed acyclic graphs, directed cyclic graphs and sequence-styled graphs. experimental results on three tasks demonstrate that our model significantly outperforms existing graph neural networks, seq2seq, and tree2seq baselines on both synthetic and real application datasets. we also showed that introducing an attention mechanism over node representation into the decoding substantially enhances the ability of our model to produce correct target sequences from large graphs. since much symbolic data is represented as graphs and many tasks express their desired outputs as sequences, we expect graph2seq to be broadly applicable to unify symbolic ai and beyond. bibliography: references appendix: pseudo-code of the graph-to-sequence algorithm [h] node embedding generation algorithm {algorithmic} [1] graph\u2062g (v, e); node initial feature vector av,\u2208\u2200vv; hops k; weight matrices wk,\u2208\u2200k{1,\u2026, k}; non-linearity\u03c3; aggregator functions aggregatek\u22a2, aggregatek\u22a3,\u2208\u2200k{1,\u2026, k}; neighborhood functions n\u22a2, n\u22a3 vector representations zv for all\u2208vv\u2190 av,\u2208\u2200vv\u2190 av,\u2208\u2200vv\u2190 aggregatek\u22a2 ({h\u22a2u-k1,\u2208\u2200u\u2062n\u22a2 (v)})\u2190\u03c3 (w\u22c5k concat (h\u22a2v-k1, h\u2062n\u22a2 (v) k)) h\u2062n\u22a3 (v) k\u2190 aggregatek\u22a3 ({h\u22a3u-k1,\u2208\u2200u\u2062n\u22a3 (v)})\u2190\u03c3 (w\u22c5k concat (h\u22a3v-k1, h\u2062n\u22a3 (v) k))\u2190 concat (h\u22a2vk, h\u22a3vk),\u2208\u2200vv algorithm [reference] describes the embedding generation process where the entire graph and initial feature vectors for all nodes av,, are provided as input. here denotes the current hop in the outer loop. the h\u22a2vk denotes node's forward representation which aggregates the information of nodes in. similarly, the h\u22a3vk denotes node's backward representation which is generated by aggregating the information of nodes in. each step in the outer loop of algorithm [reference] proceeds as follows. first, each node in a graph aggregates the forward representations of the nodes in its immediate neighborhood, {h\u22a2u-k1,}, into a single vector, h\u2062n\u22a2 (v) k (line 5). note that this aggregation step depends on the representations generated at the previous iteration of the outer loop,, and the forward representations are defined as the input node feature vector. after aggregating the neighboring feature vectors, we concatenate the node current forward representation, h\u22a2v-k1, with the aggregated neighborhood vector, h\u2062n\u22a2 (v) k. then this concatenated vector is fed through a fully connected layer with nonlinear activation function, which updates the forward representation of the current node to be used at the next step of the algorithm (line 6). we apply similar process to generate the backward representations of the nodes (line 7, 8). finally, the representation of each node zv is the concatenation of the forward representation (i.e., h\u22a2vk) and the backward representation (i.e., h\u22a3vk) at the last iteration. appendix: structured representation of the sql query to apply graph2seq, seq2seq and tree2seq models on the natural language generation task, we need to convert the sql query to a graph, sequence and tree, respectively. in this section, we describe these representations of the sql query. subsection: sequence representation we apply a simple template to construct the sql query sequence:\" select+ aggregation function>+ split symbol+ selected column>+ where+ condition0>+ split symbol+ condition1>+\u2026\". subsection: tree representation we apply the sql parser tool to convert an sql query to a tree which is illustrated in figure [reference]. specifically, the root of this tree has two child nodes, namely select list and where clause. the child nodes of select list node are the selected columns in the sql query. the where clause node has all occurred logical operators in the sql query as its children. the children of a logical operator node are the columns on which this operator works. subsection: graph representation we use the following method to transform the sql query to a graph: select clause. for the select clause such as\" select company\", we first create a node assigned with text attribute select. this select node connects with column nodes whose text attributes are the selected column names such as company. for the sql queries that contain aggregation functions such as count or max, we add one aggregation node which is connected with the column node\u2014 their text attributes are the aggregation function names. where clause. the where clause usually contains more than one condition. for each condition, we use the same process as for the select clause to create nodes. for example, in figure [reference], we create node assets and for the first condition, the node sales and for the second condition. we then integrate the constraint nodes that have the same text attribute (e.g., in figure [reference]). for a logical operator such as and, or and not, we create a node that connects with all column nodes that the operator works on (e.g., and in figure [reference]). these logical operator nodes then connect with select node. appendix: more results on the impact of hop size in algorithm [reference], we can see that there are three key factors in the node embedding generation. the first factor is the aggregator choice which determines how information from neighborhood nodes is combined. the other two are the hop size () and the neighborhood function (,), which together determine which neighbor nodes should be aggregated to generate each node embedding. to study the impact of the hop size in our model, we create two sdp datasets, sdp and sdp, where each graph has 100 nodes or 1000 nodes, respectively. both of these two datasets contain 8000 training examples, 1000 dev examples and 1000 test examples. we evaluated three models, graph2seq-ma-f, graph2seq-ma-b and graph2seq-ma, on these two datasets; results are listed in table [reference]. we see that graph2seq-ma-f and graph2seq-ma-b could show significant performance improvements with increasing the hop size. specifically, on the sdp dataset, graph2seq-ma-f and graph2seq-ma-b achieve their best performance when the hop size reaches 7; further increases do not improve the overall performance. a similar situation is also observed on the sdp dataset; performance converges at the hop size of 85. interestingly, the average diameters of the graphs in the two datasets are 6.8 and 80.2, respectively, suggesting that the ideal hop size for best graph2seq-ma-f performance should be the graph diameter. this should not be surprising; if the hop size equals the graph diameter, each node is guaranteed to aggregate the information of all reachable nodes on the graph within its embedding. note that in the experiments on sdp, in the (\u00bf 10) hop, we always use the aggregator in the 10-th hop, because introducing too many aggregators (i.e., parameters) may make the model over-fitting. like graph2seq-ma-f, graph2seq-ma also benefited from increasing the hop size. however, on both datasets, graph2seq-ma could reach peak performance at a smaller hop size than graph2seq-ma-f. for example, on the sdp dataset, graph2seq-ma achieves 99.2% accuracy once the hop size is greater than 4 while graph2seq-ma-f requires a hop size greater than 7 to achieve comparable accuracy; similar observations hold for the sdp dataset. moreover, we can see that the minimum required hop size that graph2seq-ma could achieve its best performance is approximately the average radii (c.f. diameter) of the graphs, which are 3.4 and 40.1, respectively. recall that the main difference between graph2seq-ma and graph2seq-ma-f (or graph2seq-ma-b) lies in whether the system aggregates information propagated from backward nodes; the performance difference indicates that by incorporating forward and backward nodes' information, it is possible for the model to achieve the best performance by traversing less of the graph. this is useful in practice, especially for large graphs where increasing hop size may consume considerable computing resources and run-time. table [reference] also makes clear the utility of the attention strategy; the performance of both graph2seq-ma-f and graph2seq-ma decreases by at least 9.8% on sdp and 14.9% on sdp. this result is expected, since for larger graphs it is more difficult for the encoder to compress all necessary information into a fixed-length vector; as intended, applying the attention mechanism in decoding enabled our proposed graph2seq model to handle large graphs successfully. as shown in algorithm [reference], the neighborhood function takes a given node as input and returns its directly connected neighbor nodes, which are then fed to the node embedding generator. intuitively, to obtain a better representation of a node, this function should return all its neighbor nodes in the graph. however, this may result in high training times on large graphs. to address this, hamilton2017inductive proposes a sampling method which randomly selects a fixed number of neighbor nodes from which to aggregate information at each hop. we use this sampling method to manage the neighbor node size at each aggregation step.",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "graph2seq"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "wikisql dataset",
                        "wikisql"
                    ]
                ],
                "Method": [
                    [
                        "graph2seq-pge"
                    ]
                ],
                "Metric": [
                    [
                        "bleu-4 score"
                    ]
                ],
                "Task": [
                    [
                        "sql-to-text task"
                    ]
                ]
            }
        ]
    },
    "21a1654b856cf0c64e60e58258669b374cb05539-30": {
        "doctext": "document: you only look once: unified, real-time object detection we present yolo, a new approach to object detection. prior work on object detection repurposes classifiers to perform detection. instead, we frame object detection as a regression problem to spatially separated bounding boxes and associated class probabilities. a single neural network predicts bounding boxes and class probabilities directly from full images in one evaluation. since the whole detection pipeline is a single network, it can be optimized end-to-end directly on detection performance. our unified architecture is extremely fast. our base yolo model processes images in real-time at 45 frames per second. a smaller version of the network, fast yolo, processes an astounding 155 frames per second while still achieving double the map of other real-time detectors. compared to state-of-the-art detection systems, yolo makes more localization errors but is less likely to predict false positives on background. finally, yolo learns very general representations of objects. it outperforms other detection methods, including dpm and r-cnn, when generalizing from natural images to other domains like artwork. section: introduction humans glance at an image and instantly know what objects are in the image, where they are, and how they interact. the human visual system is fast and accurate, allowing us to perform complex tasks like driving with little conscious thought. fast, accurate algorithms for object detection would allow computers to drive cars without specialized sensors, enable assistive devices to convey real-time scene information to human users, and unlock the potential for general purpose, responsive robotic systems. current detection systems repurpose classifiers to perform detection. to detect an object, these systems take a classifier for that object and evaluate it at various locations and scales in a test image. systems like deformable parts models (dpm) use a sliding window approach where the classifier is run at evenly spaced locations over the entire image. more recent approaches like r-cnn use region proposal methods to first generate potential bounding boxes in an image and then run a classifier on these proposed boxes. after classification, post-processing is used to refine the bounding boxes, eliminate duplicate detections, and rescore the boxes based on other objects in the scene. these complex pipelines are slow and hard to optimize because each individual component must be trained separately. we reframe object detection as a single regression problem, straight from image pixels to bounding box coordinates and class probabilities. using our system, you only look once (yolo) at an image to predict what objects are present and where they are. yolo is refreshingly simple: see figure [reference]. a single convolutional network simultaneously predicts multiple bounding boxes and class probabilities for those boxes. yolo trains on full images and directly optimizes detection performance. this unified model has several benefits over traditional methods of object detection. first, yolo is extremely fast. since we frame detection as a regression problem we do n't need a complex pipeline. we simply run our neural network on a new image at test time to predict detections. our base network runs at 45 frames per second with no batch processing on a titan x gpu and a fast version runs at more than 150 fps. this means we can process streaming video in real-time with less than 25 milliseconds of latency. furthermore, yolo achieves more than twice the mean average precision of other real-time systems. for a demo of our system running in real-time on a webcam please see our project webpage:. second, yolo reasons globally about the image when making predictions. unlike sliding window and region proposal-based techniques, yolo sees the entire image during training and test time so it implicitly encodes contextual information about classes as well as their appearance. fast r-cnn, a top detection method, mistakes background patches in an image for objects because it ca n't see the larger context. yolo makes less than half the number of background errors compared to fast r-cnn. third, yolo learns generalizable representations of objects. when trained on natural images and tested on artwork, yolo outperforms top detection methods like dpm and r-cnn by a wide margin. since yolo is highly generalizable it is less likely to break down when applied to new domains or unexpected inputs. yolo still lags behind state-of-the-art detection systems in accuracy. while it can quickly identify objects in images it struggles to precisely localize some objects, especially small ones. we examine these tradeoffs further in our experiments. all of our training and testing code is open source. a variety of pretrained models are also available to download. section: unified detection we unify the separate components of object detection into a single neural network. our network uses features from the entire image to predict each bounding box. it also predicts all bounding boxes across all classes for an image simultaneously. this means our network reasons globally about the full image and all the objects in the image. the yolo design enables end-to-end training and real-time speeds while maintaining high average precision. our system divides the input image into an grid. if the center of an object falls into a grid cell, that grid cell is responsible for detecting that object. each grid cell predicts bounding boxes and confidence scores for those boxes. these confidence scores reflect how confident the model is that the box contains an object and also how accurate it thinks the box is that it predicts. formally we define confidence as. if no object exists in that cell, the confidence scores should be zero. otherwise we want the confidence score to equal the intersection over union (iou) between the predicted box and the ground truth. each bounding box consists of 5 predictions:,,,, and confidence. the coordinates represent the center of the box relative to the bounds of the grid cell. the width and height are predicted relative to the whole image. finally the confidence prediction represents the iou between the predicted box and any ground truth box. each grid cell also predicts conditional class probabilities,. these probabilities are conditioned on the grid cell containing an object. we only predict one set of class probabilities per grid cell, regardless of the number of boxes. at test time we multiply the conditional class probabilities and the individual box confidence predictions, which gives us class-specific confidence scores for each box. these scores encode both the probability of that class appearing in the box and how well the predicted box fits the object. for evaluating yolo on pascal voc, we use,. pascal voc has 20 labelled classes so. our final prediction is a tensor. subsection: network design we implement this model as a convolutional neural network and evaluate it on the pascal voc detection dataset. the initial convolutional layers of the network extract features from the image while the fully connected layers predict the output probabilities and coordinates. our network architecture is inspired by the googlenet model for image classification. our network has 24 convolutional layers followed by 2 fully connected layers. instead of the inception modules used by googlenet, we simply use reduction layers followed by convolutional layers, similar to lin et al. the full network is shown in figure [reference]. we also train a fast version of yolo designed to push the boundaries of fast object detection. fast yolo uses a neural network with fewer convolutional layers (9 instead of 24) and fewer filters in those layers. other than the size of the network, all training and testing parameters are the same between yolo and fast yolo. the final output of our network is the tensor of predictions. subsection: training we pretrain our convolutional layers on the imagenet 1000-class competition dataset. for pretraining we use the first 20 convolutional layers from figure [reference] followed by a average-pooling layer and a fully connected layer. we train this network for approximately a week and achieve a single crop top-5 accuracy of 88% on the imagenet 2012 validation set, comparable to the googlenet models in caffe's model zoo. we use the darknet framework for all training and inference. we then convert the model to perform detection. ren et al. show that adding both convolutional and connected layers to pretrained networks can improve performance. following their example, we add four convolutional layers and two fully connected layers with randomly initialized weights. detection often requires fine-grained visual information so we increase the input resolution of the network from to. our final layer predicts both class probabilities and bounding box coordinates. we normalize the bounding box width and height by the image width and height so that they fall between 0 and 1. we parametrize the bounding box and coordinates to be offsets of a particular grid cell location so they are also bounded between 0 and 1. we use a linear activation function for the final layer and all other layers use the following leaky rectified linear activation: we optimize for sum-squared error in the output of our model. we use sum-squared error because it is easy to optimize, however it does not perfectly align with our goal of maximizing average precision. it weights localization error equally with classification error which may not be ideal. also, in every image many grid cells do not contain any object. this pushes the\" confidence\" scores of those cells towards zero, often overpowering the gradient from cells that do contain objects. this can lead to model instability, causing training to diverge early on. to remedy this, we increase the loss from bounding box coordinate predictions and decrease the loss from confidence predictions for boxes that do n't contain objects. we use two parameters, and to accomplish this. we set and. sum-squared error also equally weights errors in large boxes and small boxes. our error metric should reflect that small deviations in large boxes matter less than in small boxes. to partially address this we predict the square root of the bounding box width and height instead of the width and height directly. yolo predicts multiple bounding boxes per grid cell. at training time we only want one bounding box predictor to be responsible for each object. we assign one predictor to be\" responsible\" for predicting an object based on which prediction has the highest current iou with the ground truth. this leads to specialization between the bounding box predictors. each predictor gets better at predicting certain sizes, aspect ratios, or classes of object, improving overall recall. during training we optimize the following, multi-part loss function: where denotes if object appears in cell and denotes that the th bounding box predictor in cell is\" responsible\" for that prediction. note that the loss function only penalizes classification error if an object is present in that grid cell (hence the conditional class probability discussed earlier). it also only penalizes bounding box coordinate error if that predictor is\" responsible\" for the ground truth box (i.e. has the highest iou of any predictor in that grid cell). we train the network for about 135 epochs on the training and validation data sets from pascal voc 2007 and 2012. when testing on 2012 we also include the voc 2007 test data for training. throughout training we use a batch size of 64, a momentum of and a decay of. our learning rate schedule is as follows: for the first epochs we slowly raise the learning rate from to. if we start at a high learning rate our model often diverges due to unstable gradients. we continue training with for 75 epochs, then for 30 epochs, and finally for 30 epochs. to avoid overfitting we use dropout and extensive data augmentation. a dropout layer with rate=.5 after the first connected layer prevents co-adaptation between layers. for data augmentation we introduce random scaling and translations of up to 20% of the original image size. we also randomly adjust the exposure and saturation of the image by up to a factor of in the hsv color space. subsection: inference just like in training, predicting detections for a test image only requires one network evaluation. on pascal voc the network predicts 98 bounding boxes per image and class probabilities for each box. yolo is extremely fast at test time since it only requires a single network evaluation, unlike classifier-based methods. the grid design enforces spatial diversity in the bounding box predictions. often it is clear which grid cell an object falls in to and the network only predicts one box for each object. however, some large objects or objects near the border of multiple cells can be well localized by multiple cells. non-maximal suppression can be used to fix these multiple detections. while not critical to performance as it is for r-cnn or dpm, non-maximal suppression adds 2-3% in map. subsection: limitations of yolo yolo imposes strong spatial constraints on bounding box predictions since each grid cell only predicts two boxes and can only have one class. this spatial constraint limits the number of nearby objects that our model can predict. our model struggles with small objects that appear in groups, such as flocks of birds. since our model learns to predict bounding boxes from data, it struggles to generalize to objects in new or unusual aspect ratios or configurations. our model also uses relatively coarse features for predicting bounding boxes since our architecture has multiple downsampling layers from the input image. finally, while we train on a loss function that approximates detection performance, our loss function treats errors the same in small bounding boxes versus large bounding boxes. a small error in a large box is generally benign but a small error in a small box has a much greater effect on iou. our main source of error is incorrect localizations. section: comparison to other detection systems object detection is a core problem in computer vision. detection pipelines generally start by extracting a set of robust features from input images (haar, sift, hog, convolutional features). then, classifiers or localizers are used to identify objects in the feature space. these classifiers or localizers are run either in sliding window fashion over the whole image or on some subset of regions in the image. we compare the yolo detection system to several top detection frameworks, highlighting key similarities and differences. deformable parts models. deformable parts models (dpm) use a sliding window approach to object detection. dpm uses a disjoint pipeline to extract static features, classify regions, predict bounding boxes for high scoring regions, etc. our system replaces all of these disparate parts with a single convolutional neural network. the network performs feature extraction, bounding box prediction, non-maximal suppression, and contextual reasoning all concurrently. instead of static features, the network trains the features in-line and optimizes them for the detection task. our unified architecture leads to a faster, more accurate model than dpm. r-cnn. r-cnn and its variants use region proposals instead of sliding windows to find objects in images. selective search generates potential bounding boxes, a convolutional network extracts features, an svm scores the boxes, a linear model adjusts the bounding boxes, and non-max suppression eliminates duplicate detections. each stage of this complex pipeline must be precisely tuned independently and the resulting system is very slow, taking more than 40 seconds per image at test time. yolo shares some similarities with r-cnn. each grid cell proposes potential bounding boxes and scores those boxes using convolutional features. however, our system puts spatial constraints on the grid cell proposals which helps mitigate multiple detections of the same object. our system also proposes far fewer bounding boxes, only 98 per image compared to about 2000 from selective search. finally, our system combines these individual components into a single, jointly optimized model. other fast detectors fast and faster r-cnn focus on speeding up the r-cnn framework by sharing computation and using neural networks to propose regions instead of selective search. while they offer speed and accuracy improvements over r-cnn, both still fall short of real-time performance. many research efforts focus on speeding up the dpm pipeline. they speed up hog computation, use cascades, and push computation to gpus. however, only 30hz dpm actually runs in real-time. instead of trying to optimize individual components of a large detection pipeline, yolo throws out the pipeline entirely and is fast by design. detectors for single classes like faces or people can be highly optimized since they have to deal with much less variation. yolo is a general purpose detector that learns to detect a variety of objects simultaneously. deep multibox. unlike r-cnn, szegedy et al. train a convolutional neural network to predict regions of interest instead of using selective search. multibox can also perform single object detection by replacing the confidence prediction with a single class prediction. however, multibox can not perform general object detection and is still just a piece in a larger detection pipeline, requiring further image patch classification. both yolo and multibox use a convolutional network to predict bounding boxes in an image but yolo is a complete detection system. overfeat. sermanet et al. train a convolutional neural network to perform localization and adapt that localizer to perform detection. overfeat efficiently performs sliding window detection but it is still a disjoint system. overfeat optimizes for localization, not detection performance. like dpm, the localizer only sees local information when making a prediction. overfeat can not reason about global context and thus requires significant post-processing to produce coherent detections. multigrasp. our work is similar in design to work on grasp detection by redmon et al. our grid approach to bounding box prediction is based on the multigrasp system for regression to grasps. however, grasp detection is a much simpler task than object detection. multigrasp only needs to predict a single graspable region for an image containing one object. it does n't have to estimate the size, location, or boundaries of the object or predict it's class, only find a region suitable for grasping. yolo predicts both bounding boxes and class probabilities for multiple objects of multiple classes in an image. section: experiments first we compare yolo with other real-time detection systems on pascal voc 2007. to understand the differences between yolo and r-cnn variants we explore the errors on voc 2007 made by yolo and fast r-cnn, one of the highest performing versions of r-cnn. based on the different error profiles we show that yolo can be used to rescore fast r-cnn detections and reduce the errors from background false positives, giving a significant performance boost. we also present voc 2012 results and compare map to current state-of-the-art methods. finally, we show that yolo generalizes to new domains better than other detectors on two artwork datasets. subsection: comparison to other real-time systems many research efforts in object detection focus on making standard detection pipelines fast. however, only sadeghi et al. actually produce a detection system that runs in real-time (30 frames per second or better). we compare yolo to their gpu implementation of dpm which runs either at 30hz or 100hz. while the other efforts do n't reach the real-time milestone we also compare their relative map and speed to examine the accuracy-performance tradeoffs available in object detection systems. fast yolo is the fastest object detection method on pascal; as far as we know, it is the fastest extant object detector. with map, it is more than twice as accurate as prior work on real-time detection. yolo pushes map to while still maintaining real-time performance. we also train yolo using vgg-16. this model is more accurate but also significantly slower than yolo. it is useful for comparison to other detection systems that rely on vgg-16 but since it is slower than real-time the rest of the paper focuses on our faster models. fastest dpm effectively speeds up dpm without sacrificing much map but it still misses real-time performance by a factor of 2. it also is limited by dpm's relatively low accuracy on detection compared to neural network approaches. r-cnn minus r replaces selective search with static bounding box proposals. while it is much faster than r-cnn, it still falls short of real-time and takes a significant accuracy hit from not having good proposals. fast r-cnn speeds up the classification stage of r-cnn but it still relies on selective search which can take around 2 seconds per image to generate bounding box proposals. thus it has high map but at fps it is still far from real-time. the recent faster r-cnn replaces selective search with a neural network to propose bounding boxes, similar to szegedy et al. in our tests, their most accurate model achieves 7 fps while a smaller, less accurate one runs at 18 fps. the vgg-16 version of faster r-cnn is 10 map higher but is also 6 times slower than yolo. the zeiler-fergus faster r-cnn is only 2.5 times slower than yolo but is also less accurate. subsection: voc 2007 error analysis to further examine the differences between yolo and state-of-the-art detectors, we look at a detailed breakdown of results on voc 2007. we compare yolo to fast r-cnn since fast r-cnn is one of the highest performing detectors on pascal and it's detections are publicly available. we use the methodology and tools of hoiem et al. for each category at test time we look at the top n predictions for that category. each prediction is either correct or it is classified based on the type of error: correct: correct class and localization: correct class, similar: class is similar, other: class is wrong, background: for any object figure [reference] shows the breakdown of each error type averaged across all 20 classes. yolo struggles to localize objects correctly. localization errors account for more of yolo's errors than all other sources combined. fast r-cnn makes much fewer localization errors but far more background errors. 13.6% of it's top detections are false positives that do n't contain any objects. fast r-cnn is almost 3x more likely to predict background detections than yolo. subsection: combining fast r-cnn and yolo yolo makes far fewer background mistakes than fast r-cnn. by using yolo to eliminate background detections from fast r-cnn we get a significant boost in performance. for every bounding box that r-cnn predicts we check to see if yolo predicts a similar box. if it does, we give that prediction a boost based on the probability predicted by yolo and the overlap between the two boxes. the best fast r-cnn model achieves a map of 71.8% on the voc 2007 test set. when combined with yolo, its map increases by 3.2% to 75.0%. we also tried combining the top fast r-cnn model with several other versions of fast r-cnn. those ensembles produced small increases in map between.3 and.6%, see table [reference] for details. the boost from yolo is not simply a byproduct of model ensembling since there is little benefit from combining different versions of fast r-cnn. rather, it is precisely because yolo makes different kinds of mistakes at test time that it is so effective at boosting fast r-cnn's performance. unfortunately, this combination does n't benefit from the speed of yolo since we run each model seperately and then combine the results. however, since yolo is so fast it does n't add any significant computational time compared to fast r-cnn. subsection: voc 2012 results on the voc 2012 test set, yolo scores 57.9% map. this is lower than the current state of the art, closer to the original r-cnn using vgg-16, see table [reference]. our system struggles with small objects compared to its closest competitors. on categories like bottle, sheep, and tv/ monitor yolo scores 8-10% lower than r-cnn or feature edit. however, on other categories like cat and train yolo achieves higher performance. our combined fast r-cnn+ yolo model is one of the highest performing detection methods. fast r-cnn gets a 2.3% improvement from the combination with yolo, boosting it 5 spots up on the public leaderboard. subsection: generalizability: person detection in artwork [b].45 [b].55 academic datasets for object detection draw the training and testing data from the same distribution. in real-world applications it is hard to predict all possible use cases and the test data can diverge from what the system has seen before. we compare yolo to other detection systems on the picasso dataset and the people-art dataset, two datasets for testing person detection on artwork. figure [reference] shows comparative performance between yolo and other detection methods. for reference, we give voc 2007 detection ap on person where all models are trained only on voc 2007 data. on picasso models are trained on voc 2012 while on people-art they are trained on voc 2010. r-cnn has high ap on voc 2007. however, r-cnn drops off considerably when applied to artwork. r-cnn uses selective search for bounding box proposals which is tuned for natural images. the classifier step in r-cnn only sees small regions and needs good proposals. dpm maintains its ap well when applied to artwork. prior work theorizes that dpm performs well because it has strong spatial models of the shape and layout of objects. though dpm does n't degrade as much as r-cnn, it starts from a lower ap. yolo has good performance on voc 2007 and its ap degrades less than other methods when applied to artwork. like dpm, yolo models the size and shape of objects, as well as relationships between objects and where objects commonly appear. artwork and natural images are very different on a pixel level but they are similar in terms of the size and shape of objects, thus yolo can still predict good bounding boxes and detections. section: real-time detection in the wild yolo is a fast, accurate object detector, making it ideal for computer vision applications. we connect yolo to a webcam and verify that it maintains real-time performance, including the time to fetch images from the camera and display the detections. the resulting system is interactive and engaging. while yolo processes images individually, when attached to a webcam it functions like a tracking system, detecting objects as they move around and change in appearance. a demo of the system and the source code can be found on our project website:. section: conclusion we introduce yolo, a unified model for object detection. our model is simple to construct and can be trained directly on full images. unlike classifier-based approaches, yolo is trained on a loss function that directly corresponds to detection performance and the entire model is trained jointly. fast yolo is the fastest general-purpose object detector in the literature and yolo pushes the state-of-the-art in real-time object detection. yolo also generalizes well to new domains making it ideal for applications that rely on fast, robust object detection. acknowledgements: this work is partially supported by onr n00014-13-1-0720, nsf iis-1338054, and the allen distinguished investigator award. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "pascal voc detection dataset"
                    ],
                    [
                        "imagenet 2012 validation set"
                    ],
                    [
                        "voc 2012 test set"
                    ],
                    [
                        "picasso dataset"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": [
                    [
                        "real time object detection"
                    ],
                    [
                        "object detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "detection pipeline"
                    ],
                    [
                        "detection systems"
                    ],
                    [
                        "detection task"
                    ],
                    [
                        "detections"
                    ],
                    [
                        "real time object detection"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "pascal voc",
                        "voc 2007 test data",
                        "voc 2007",
                        "pascal",
                        "voc 2007 test set",
                        "voc 2007 data"
                    ]
                ],
                "Method": [
                    [
                        "yolo"
                    ]
                ],
                "Metric": [
                    [
                        "fps"
                    ]
                ],
                "Task": [
                    [
                        "real-time object detection",
                        "real-time detection",
                        "real-time detection in the wild"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "pascal voc",
                        "voc 2007 test data",
                        "voc 2007",
                        "pascal",
                        "voc 2007 test set",
                        "voc 2007 data"
                    ]
                ],
                "Method": [
                    [
                        "yolo"
                    ]
                ],
                "Metric": [
                    [
                        "mean average precision",
                        "maximizing average precision",
                        "map"
                    ]
                ],
                "Task": [
                    [
                        "object detection",
                        "detection",
                        "frame detection",
                        "detection task",
                        "detection pipeline",
                        "grasp detection",
                        "person detection"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "pascal voc",
                        "voc 2007 test data",
                        "voc 2007",
                        "pascal",
                        "voc 2007 test set",
                        "voc 2007 data"
                    ]
                ],
                "Method": [
                    [
                        "yolo"
                    ]
                ],
                "Metric": [
                    [
                        "mean average precision",
                        "maximizing average precision",
                        "map"
                    ]
                ],
                "Task": [
                    [
                        "real-time object detection",
                        "real-time detection",
                        "real-time detection in the wild"
                    ]
                ]
            }
        ]
    },
    "232b43584b2236669c0a53702ad89ab10c3886ea-31": {
        "doctext": "in this work, we build on recent advances in distributional reinforcement learning to give a generally applicable, flexible, and state-of-the-art distributional variant of dqn. we achieve this by using quantile regression to approximate the full quantile function for the state-action return distribution. by reparameterizing a distribution over the sample space, this yields an implicitly defined return distribution and gives rise to a large class of risk-sensitive policies. we demonstrate improved performance on the 57 atari 2600 games in the ale, and use our algorithm's implicitly defined distributions to study the effects of risk-sensitive policies in atari games. section: introduction distributional reinforcement learning focuses on the intrinsic randomness of returns within the reinforcement learning (rl) framework. as the agent interacts with the environment, irreducible randomness seeps in through the stochasticity of these interactions, the approximations in the agent's representation, and even the inherently chaotic nature of physical interaction. distributional rl aims to model the distribution over returns, whose mean is the traditional value function, and to use these distributions to evaluate and optimize a policy. any distributional rl algorithm is characterized by two aspects: the parameterization of the return distribution, and the distance metric or loss function being optimized. together, these choices control assumptions about the random returns and how approximations will be traded off. categorical dqn [c51] c51 combines a categorical distribution and the cross-entropy loss with the cram\u00e9r-minimizing projection. for this, it assumes returns are bounded in a known range and trades off mean-preservation at the cost of overestimating variance. c51 outperformed all previous improvements to dqn on a set of 57 atari 2600 games in the arcade learning environment, which we refer to as the atari-57 benchmark. subsequently, several papers have built upon this successful combination to achieve significant improvements to the state-of-the-art in atari-57, and challenging continuous control tasks. these algorithms are restricted to assigning probabilities to an a priori fixed, discrete set of possible returns. dabney2017qr propose an alternate pair of choices, parameterizing the distribution by a uniform mixture of diracs whose locations are adjusted using quantile regression. their algorithm, qr-dqn, while restricted to a discrete set of quantiles, automatically adapts return quantiles to minimize the wasserstein distance between the bellman updated and current return distributions. this flexibility allows qr-dqn to significantly improve on c51's atari-57 performance. in this paper, we extend the approach of dabney2017qr, from learning a discrete set of quantiles to learning the full quantile function, a continuous map from probabilities to returns. when combined with a base distribution, such as, this forms an implicit distribution capable of approximating any distribution over returns given sufficient network capacity. our approach, implicit quantile networks (iqn), is best viewed as a simple distributional generalization of the dqn algorithm, and provides several benefits over qr-dqn. first, the approximation error for the distribution is no longer controlled by the number of quantiles output by the network, but by the size of the network itself, and the amount of training. second, iqn can be used with as few, or as many, samples per update as desired, providing improved data efficiency with increasing number of samples per training update. third, the implicit representation of the return distribution allows us to expand the class of policies to more fully take advantage of the learned distribution. specifically, by taking the base distribution to be non-uniform, we expand the class of policies to-greedy policies on arbitrary distortion risk measures. we begin by reviewing distributional reinforcement learning, related work, and introducing the concepts surrounding risk-sensitive rl. in subsequent sections, we introduce our proposed algorithm, iqn, and present a series of experiments using the atari-57 benchmark, investigating the robustness and performance of iqn. despite being a simple distributional extension to dqn, and forgoing any other improvements, iqn significantly outperforms qr-dqn and nearly matches the performance of rainbow, which combines many orthogonal advances. in fact, in human-starts as well as in the hardest atari games (where current rl agents still underperform human players) iqn improves over rainbow. section: background/ related work we consider the standard rl setting, in which the interaction of an agent and an environment is modeled as a markov decision process, where and denote the state and action spaces, the (state-and action-dependent) reward function, the transition kernel, and a discount factor. a policy maps a state to a distribution over actions. for an agent following policy, the discounted sum of future rewards is denoted by the random variable, where,,, and. the action-value function is defined as, and can be characterized by the bellman equation the objective in rl is to find an optimal policy, which maximizes, i.e. for all and all. one approach is to find the unique fixed point of the bellman optimality operator: to this end, q-learning iteratively improves an estimate,, of the optimal action-value function,, by repeatedly applying the bellman update: the action-value function can be approximated by a parameterized function (e.g. a neural network), and trained by minimizing the squared temporal difference (td) error, over samples observed while following an-greedy policy over. this policy acts greedily with respect to with probability and uniformly at random otherwise. dqn uses a convolutional neural network to parameterize and the q-learning algorithm to achieve human-level play on the atari-57 benchmark. subsection: distributional rl in distributional rl, the distribution over returns (the law of) is considered instead of the scalar value function that is its expectation. this change in perspective has yielded new insights into the dynamics of rl, and been a useful tool for analysis. empirically, distributional rl algorithms show improved sample complexity and final performance, as well as increased robustness to hyperparameter variation. an analogous distributional bellman equation of the form can be derived, where denotes that two random variables and have equal probability laws, and the random variables and are distributed according to and, respectively. morimura10parametric defined the distributional bellman operator explicitly in terms of conditional probabilities, parameterized by the mean and scale of a gaussian or laplace distribution, and minimized the kullback-leibler (kl) divergence between the bellman target and the current estimated return distribution. however, the distributional bellman operator is not a contraction in the kl. as with the scalar setting, a distributional bellman optimality operator can be defined by with distributed according to. while the distributional bellman operator for policy evaluation is a contraction in the-wasserstein distance, this no longer holds for the control case. convergence to the optimal policy can still be established, but requires a more involved argument. c51 parameterize the return distribution as a categorical distribution over a fixed set of equidistant points and minimize the kl divergence to the projected distributional bellman target. their algorithm, c51, outperformed previous dqn variants on the atari-57 benchmark. subsequently, hessel2018rainbow combined c51 with enhancements such as prioritized experience replay,-step updates, and the dueling architecture, leading to the rainbow agent, current state-of-the-art in atari-57. the categorical parameterization, using the projected kl loss, has also been used in recent work to improve the critic of a policy gradient algorithm, d4pg, achieving significantly improved robustness and state-of-the-art performance across a variety of continuous control tasks. subsection:-wasserstein metric the-wasserstein metric, for, plays a key role in recent results in distributional rl. it has also been a topic of increasing interest in generative modeling, because unlike the kl divergence, the wasserstein metric inherently trades off approximate solutions with likelihoods. the-wasserstein distance is the metric on inverse cumulative distribution functions (c.d.f.), also known as quantile functions. for random variables and with quantile functions and, respectively, the-wasserstein distance is given by the class of optimal transport metrics express distances between distributions in terms of the minimal cost for transporting mass to make the two distributions identical. this cost is given in terms of some metric,, on the underlying space. the-wasserstein metric corresponds to. we are particularly interested in the wasserstein metrics due to the predominant use of spaces in mean-value reinforcement learning. subsection: quantile regression for distributional rl c51 showed that the distributional bellman operator is a contraction in the-wasserstein metric, but as the proposed algorithm did not itself minimize the wasserstein metric, this left a theory-practice gap for distributional rl. recently, this gap was closed, in both directions. first and most relevant to this work, dabney2017qr proposed the use of quantile regression for distributional rl and showed that by choosing the quantile targets suitably the resulting projected distributional bellman operator is a contraction in the-wasserstein metric. concurrently, rowland2018analysis showed the original class of categorical algorithms are a contraction in the cram\u00e9r distance, the metric on cumulative distribution functions. by estimating the quantile function at precisely chosen points, qr-dqn minimizes the wasserstein distance to the distributional bellman target. this estimation uses quantile regression, which has been shown to converge to the true quantile function value when minimized using stochastic approximation. in qr-dqn, the random return is approximated by a uniform mixture of diracs, with each assigned a fixed quantile target, for, where. these quantile estimates are trained using the huber1964robust quantile regression loss, with threshold, on the pairwise td-errors at the time of this writing, qr-dqn achieves the best performance on atari-57, human-normalized mean and median, of all agents that do not combine distributional rl, prioritized replay, and-step updates. subsection: risk in reinforcement learning distributional rl algorithms have been theoretically justified for the wasserstein and cram\u00e9r metrics, and learning the distribution over returns, in and of itself, empirically results in significant improvements to data efficiency, final performance, and stability. however, in each of these recent works the policy used was based entirely on the mean of the return distribution, just as in standard reinforcement learning. a natural question arises: can we expand the class of policies using information provided by the distribution over returns (i.e. to the class of risk-sensitive policies)? furthermore, when would this larger policy class be beneficial? here, 'risk' refers to the uncertainty over possible outcomes, and risk-sensitive policies are those which depend upon more than the mean of the outcomes. at this point, it is important to highlight the difference between intrinsic uncertainty, captured by the distribution over returns, and parametric uncertainty, the uncertainty over the value estimate typically associated with bayesian approaches such as psrl and kalman td. distributional rl seeks to capture the former, which classic approaches to risk are built upon. expected utility theory states that if a decision policy is consistent with a particular set of four axioms regarding its choices then the decision policy behaves as though it is maximizing the expected value of some utility function, this is perhaps the most pervasive notion of risk-sensitivity. a policy maximizing a linear utility function is called risk-neutral, whereas concave or convex utility functions give rise to risk-averse or risk-seeking policies, respectively. many previous studies on risk-sensitive rl adopt the utility function approach. a crucial axiom of expected utility is independence: given random variables, and, such that (preferred over), any mixture between and is preferred to the same mixture between and. stated in terms of the cumulative probability functions,. this axiom in particular has troubled many researchers because it is consistently violated by human behavior. the allais paradox is a frequently used example of a decision problem where people violate the independence axiom of expected utility theory. however, as yaari1987dual showed, this axiom can be replaced by one in terms of convex combinations of outcome values, instead of mixtures of distributions. specifically, if as before, then for any and random variable,. this leads to an alternate, dual, theory of choice than that of expected utility. under these axioms the decision policy behaves as though it is maximizing a distorted expectation, for some continuous monotonic function: such a function is known as a distortion risk measure, as it distorts the cumulative probabilities of the random variable. that is, we have two fundamentally equivalent approaches to risk-sensitivity. either, we choose a utility function and follow the expectation of this utility. or, we choose a reweighting of the distribution and compute expectation under this distortion measure. indeed, yaari1987dual further showed that these two functions are inverses of each other. the choice between them amounts to a choice over whether the behavior should be invariant to mixing with random events or to convex combinations of outcomes. distortion risk measures include, as special cases, cumulative probability weighting used in cumulative prospect theory, conditional value at risk, and many other methods. recently majumdar2017should argued for the use of distortion risk measures in robotics. section: implicit quantile networks we now introduce the implicit quantile network (iqn), a deterministic parametric function trained to reparameterize samples from a base distribution, e.g., to the respective quantile values of a target distribution. iqn provides an effective way to learn an implicit representation of the return distribution, yielding a powerful function approximator for a new dqn-like agent. let be the quantile function at for the random variable. for notational simplicity we write, thus for the resulting state-action return distribution sample is. we propose to model the state-action quantile function as a mapping from state-actions and samples from some base distribution, typically, to, viewed as samples from the implicitly defined return distribution. let be a distortion risk measure, with identity corresponding to risk-neutrality. then, the distorted expectation of under is given by notice that the distorted expectation is equal to the expected value of weighted by, that is,. the immediate implication of this is that for any, there exists a sampling distribution for such that the mean of is equal to the distorted expectation of under, that is, any distorted expectation can be represented as a weighted sum over the quantiles. denote by the risk-sensitive greedy policy for two samples, and policy, the sampled temporal difference (td) error at step is then, the iqn loss function is given by where and denote the respective number of iid samples used to estimate the loss. a corresponding sample-based risk-sensitive policy is obtained by approximating in equation [reference] by samples of: implicit quantile networks differ from the approach of dabney2017qr in two ways. first, instead of approximating the quantile function at fixed values of we approximate it with for some differentiable functions,, and. if we ignore the distributional interpretation for a moment and view each as a separate action-value function, this highlights that implicit quantile networks are a type of universal value function approximator (uvfa). there may be additional benefits to implicit quantile networks beyond the obvious increase in representational fidelity. as with uvfas, we might hope that training over many different's (goals in the case of the uvfa) leads to better generalization between values and improved sample complexity than attempting to train each separately. second,,, and are sampled from continuous, independent, distributions. besides, we also explore risk-sentive policies, with non-linear. the independent sampling of each, results in the sample td errors being decorrelated, and the estimated action-values go from being the true mean of a mixture of diracs to a sample mean of the implicit distribution defined by reparameterizing the sampling distribution via the learned quantile function. subsection: implementation consider the neural network structure used by the dqn agent. let be the function computed by the convolutional layers and the subsequent fully-connected layers mapping to the estimated action-values, such that. for our network we use the same functions and as in dqn, but include an additional function computing an embedding for the sample point. we combine these to form the approximation, where denotes the element-wise (hadamard) product. as the network for is not particularly deep, we use the multiplicative form,, to force interaction between the convolutional features and the sample embedding. alternative functional forms, e.g. concatenation or a 'residual' function, are conceivable, and can be parameterized in different ways. to investigate these, we compared performance across a number of architectural variants on six atari 2600 games (asterix, assault, breakout, ms. pacman, qbert, space invaders). full results are given in the appendix. despite minor variation in performance, we found the general approach to be robust to the various choices. based upon the results we used the following function in our later experiments, for embedding dimension: after settling on a network architecture, we study the effect of the number of samples, and, used in the estimate terms of equation [reference]. we hypothesized that, the number of samples of, would affect the sample complexity of iqn, with larger values leading to faster learning, and that with one would potentially approach the performance of dqn. this would support the hypothesis that the improved performance of many distributional rl algorithms rests on their effect as auxiliary loss functions, which would vanish in the case of. furthermore, we believed that, the number of samples of, would affect the variance of the gradient estimates much like a mini-batch size hyperparameter. our prediction was that would have the greatest effect on variance of the long-term performance of the agent. we used the same set of six games as before, with our chosen architecture, and varied. in figure [reference] we report the average human-normalized scores on the six games for each configuration. figure [reference] (left) shows the average performance over the first ten million frames, while (right) shows the average performance over the last ten million (from 190 m to 200 m). as expected, we found that has a dramatic effect on early performance, shown by the continual improvement in score as the value increases. additionally, we observed that affected performance very differently than expected: it had a strong effect on early performance, but minimal impact on long-term performance past. overall, while using more samples for both distributions is generally favorable, appears to be sufficient to achieve the majority of improvements offered by iqn for long-term performance, with variation past this point largely insignificant. to our surprise we found that even for, which is comparable to dqn in the number of loss components, the longer term performance is still quite strong (dqn). in an informal evaluation, we did not find iqn to be sensitive to, the number of samples used for the policy, and have fixed it at for all experiments. section: risk-sensitive reinforcement learning in this section, we explore the effects of varying the distortion risk measure,, away from identity. this only affects the policy,, used both in equation [reference] and for acting in the environment. as we have argued, evaluating under different distortion risk measures is equivalent to changing the sampling distribution for, allowing us to achieve various forms of risk-sensitive policies. we focus on a handful of sampling distributions and their corresponding distortion measures. the first one is the cumulative probability weighting parameterization proposed in cumulative prospect theory: in particular, we use the parameter value found by wu1996curvature to most closely match human subjects. this choice is interesting as, unlike the others we consider, it is neither globally convex nor concave. for small values of it is locally concave and for larger values of it becomes locally convex. recall that concavity corresponds to risk-averse and convexity to risk-seeking policies. second, we consider the distortion risk measure proposed by wang2000class, where and are taken to be the standard normal cumulative distribution function and its inverse: for, this produces risk-averse policies and we include it due to its simple interpretation and ability to switch between risk-averse and risk-seeking distortions. third, we consider a simple power formula for risk-averse () or risk-seeking () policies: finally, we consider conditional value-at-risk (cvar): cvar has been widely studied in and out of reinforcement learning. its implementation as a modification to the sampling distribution of is particularly simple, as it changes to. another interesting sampling distribution, not included in our experiments, is denoted and corresponds to sampled by averaging samples from. in figure [reference] (right) we give an example of a distribution (neutral) and how each of these distortion measures affects the implied distribution due to changing the sampling distribution of. and reduce the impact of the tails of the distribution, while and heavily shift the distribution mass towards the tails, creating a risk-averse or risk-seeking preference. additionally, while cvar entirely ignores all values corresponding to, gives these non-zero, but vanishingly small, probability. by using these sampling distributions we can induce various risk-sensitive policies in iqn. we evaluate these on the same set of six atari 2600 games previously used. our algorithm simply changes the policy to maximize the distorted expectations instead of the usual sample mean. figure [reference] (left) shows our results in this experiment, with average scores reported under the usual, risk-neutral, evaluation criterion. intuitively, we expected to see a qualitative effect from risk-sensitive training, e.g. strengthened exploration from a risk-seeking objective. although we did see qualitative differences, these did not always match our expectations. for two of the games, asterix and assault, there is a very significant advantage to the risk-averse policies. although tends to perform almost identically to the standard risk-neutral policy, and the risk-seeking performs as well or worse than risk-neutral, we find that both risk-averse policies improve performance over standard iqn. however, we also observe that the more risk-averse of the two,, suffers some loss in performance on two other games (qbert and space invaders). additionally, we note that the risk-seeking policy significantly underperforms the risk-neutral policy on three of the six games. it remains an open question as to exactly why we see improved performance for risk-averse policies. there are many possible explanations for this phenomenon, e.g. that risk-aversion encodes a heuristic to stay alive longer, which in many games is correlated with increased rewards. section: full atari-57 results finally, we evaluate iqn on the full atari-57 benchmark, comparing with the state-of-the-art performance of rainbow, a distributional rl agent that combines several advances in deep rl, the closely related algorithm qr-dqn, prioritized experience replay dqn, and the original dqn agent. note that in this section we use the risk-neutral variant of the iqn, that is, the policy of the iqn agent is the regular-greedy policy with respect to the mean of the state-action return distribution. it is important to remember that rainbow builds upon the distributional rl algorithm c51, but also includes prioritized experience replay, double dqn, dueling network architecture, noisy networks, and multi-step updates. in particular, besides the distributional update,-step updates and prioritized experience replay were found to have significant impact on the performance of rainbow. our other competitive baseline is qr-dqn, which is currently state-of-the-art for agents that do not combine distributional updates,-step updates, and prioritized replay. thus, between qr-dqn and the much more complex rainbow we compare to the two most closely related, and best performing, agents in published work. in particular, we would expect that iqn would benefit from the additional enhancements in rainbow, just as rainbow improved significantly over c51. figure [reference] shows the mean (left) and median (right) human-normalized scores during training over the atari-57 benchmark. iqn dramatically improves over qr-dqn, which itself improves on many previously published results. at 100 million frames iqn has reached the same level of performance as qr-dqn at 200 million frames. table [reference] gives a comparison between the same methods in terms of their best, human-normalized, scores per game under the 30 random no-op start condition. these are averages over the given number of seeds. additionally, using human-starts, iqn achieves median human-normalized score, whereas rainbow reaches, see table [reference]. finally, we took a closer look at the games in which each algorithm continues to underperform humans, and computed, on average, how far below human-level they perform. we refer to this value as the human-gapthanks to joseph modayil for proposing this metric. metric and give results in table [reference]. interestingly, c51 outperforms qr-dqn in this metric, and iqn outperforms all others. this shows that the remaining gap between rainbow and iqn is entirely from games on which both algorithms are already super-human. the games where the most progress in rl is needed happen to be the games where iqn shows the greatest improvement over qr-dqn and rainbow. section: discussion and conclusions we have proposed a generalization of recent work based around using quantile regression to learn the distribution over returns of the current policy. our generalization leads to a simple change to the dqn agent to enable distributional rl, the natural integration of risk-sensitive policies, and significantly improved performance over existing methods. the iqn algorithm provides, for the first time, a fully integrated distributional rl agent without prior assumptions on the parameterization of the return distribution. iqn can be trained with as little as a single sample from each state-action value distribution, or as many as computational limits allow to improve the algorithm's data efficiency. furthermore, iqn allows us to expand the class of control policies to a large class of risk-sensitive policies connected to distortion risk measures. finally, we show substantial gains on the atari-57 benchmark over qr-dqn, and even halving the distance between qr-dqn and rainbow. despite the significant empirical successes in this paper there are many areas in need of additional theoretical analysis. we highlight a few particularly relevant open questions we were unable to address in the present work. first, sample-based convergence results have been recently shown for a class of categorical distributional rl algorithms. could existing sample-based rl convergence results be extended to the qr-based algorithms? second, can the contraction mapping results for a fixed grid of quantiles given by dabney2017qr be extended to the more general class of approximate quantile functions studied in this work? finally, and particularly salient to our experiments with distortion risk measures, theoretical guarantees for risk-sensitive rl have been building over recent years, but have been largely limited to special cases and restricted classes of risk-sensitive policies. can the convergence of the distribution of returns under the bellman operator be leveraged to show convergence to a fixed-point in distorted expectations? in particular, can the control results of c51 be expanded to cover some class of risk-sensitive policies? there remain many intriguing directions for future research into distributional rl, even on purely empirical fronts. hessel2018rainbow recently showed that distributional rl agents can be significantly improved, when combined with other techniques. creating a rainbow-iqn agent could yield even greater improvements on atari-57. we also recall the surprisingly rich return distributions found by barthmaron2018d4pg, and hypothesize that the continuous control setting may be a particularly fruitful area for the application of distributional rl in general, and iqn in particular. bibliography: references section: appendix subsection: architecture and hyperparameters we considered multiple architectural variants for parameterizing an iqn. all of these build on the q-network of a regular dqn, which can be seen as the composition of a convolutional stack and an mlp, and extend it by an embedding of the sample point,, and a merging function, resulting in the function for the embedding, we considered a number of variants: a learned linear embedding, a learned mlp embedding with a single hidden layer of size, and a learned linear function of cosine basis functions of the form. each of those was followed by either a relu or sigmoid nonlinearity. for the merging function, the simplest choice would be a simple vector concatenation of and. note however, that the mlp which takes in the output of and outputs the action-value quantiles, only has a single hidden layer in the dqn network. therefore, to force a sufficiently early interaction between the two representations, we also considered a multiplicative function, where denotes the element-wise (hadamard) product of two vectors, as well as a 'residual' function. early experiments showed that a simple linear embedding of was insufficient to achieve good performance, and the residual version of did n't show any marked difference to the multiplicative variant, so we do not include results for these here. for the other configurations, figure [reference] shows pairwise comparisons between 1) a cosine basis function embedding and a completely learned mlp embedding, 2) an embedding size (hidden layer size or number of cosine basis elements) 32 and 64, 3) relu and sigmoid nonlinearity following the embedding, and 4) concatenation and a multiplicative interaction between and. each comparison 'violin plot' can be understood as a marginalization over the other variants of the architecture, with the human-normalized performance at the end of training, averaged across six atari 2600 games, on the y-axis. each white dot corresponds to a configuration (each represented by two seeds), the black dots show the position of our preferred configuration. the width of the colored regions corresponds to a kernel density estimate of the number of configurations at each performance level. our final choice is a multiplicative interaction with a linear function of a cosine embedding, with and a relu nonlinearity (see equation [reference]), as this configuration yielded the highest performance consistently over multiple seeds. also noteworthy is the overall robustness of the approach to these variations: most of the configurations consistently outperform the qr-dqn baseline shown as a grey horizontal line for comparison. we give pseudo-code for the iqn loss in algorithm [reference]. all other hyperparameters for this agent correspond to the ones used by dabney2017qr. in particular, the bellman target is computed using a target network. notice that iqn will generally be more computationally expensive per-sample than qr-dqn. however, in practice iqn requires many fewer samples per update than qr-dqn so that the actual running times are comparable. [ht] implicit quantile network loss and functions,# compute greedy next action# sample quantile thresholds# compute distributional temporal differences# compute huber quantile loss subsection: evaluation the human-normalized scores reported in this paper are given by the formula where, and are the per-game raw scores (undiscounted returns) for the given agent, a reference human player, and random agent baseline. the 'human-gap' metric referred to at the end of section [reference] builds on the human-normalized score, but emphasizes the remaining improvement for the agent to reach super-human performance. it is given by, with a value of corresponding to random play, and a value of corresponding to super-human level of performance. to avoid degeneracies in the case of, the quantity is being clipped above at.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "atari 2600 games"
                    ],
                    [
                        "atari games"
                    ],
                    [
                        "atari 2600 games"
                    ],
                    [
                        "asterix"
                    ],
                    [
                        "atari-57 benchmark"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "assault"
                    ]
                ],
                "Method": [
                    [
                        "implicit quantile networks",
                        "distributional generalization of the dqn algorithm",
                        "iqn",
                        "distributional bellman equation",
                        "implicit quantile network",
                        "state-action quantile function",
                        "iqn loss"
                    ]
                ],
                "Metric": [
                    [
                        "human-normalized scores",
                        "human-normalized, scores",
                        "human-normalized score"
                    ]
                ],
                "Task": [
                    [
                        "atari games",
                        "atari-57"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "asterix"
                    ]
                ],
                "Method": [
                    [
                        "implicit quantile networks",
                        "distributional generalization of the dqn algorithm",
                        "iqn",
                        "distributional bellman equation",
                        "implicit quantile network",
                        "state-action quantile function",
                        "iqn loss"
                    ]
                ],
                "Metric": [
                    [
                        "human-normalized scores",
                        "human-normalized, scores",
                        "human-normalized score"
                    ]
                ],
                "Task": [
                    [
                        "atari games",
                        "atari-57"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "breakout"
                    ]
                ],
                "Method": [
                    [
                        "implicit quantile networks",
                        "distributional generalization of the dqn algorithm",
                        "iqn",
                        "distributional bellman equation",
                        "implicit quantile network",
                        "state-action quantile function",
                        "iqn loss"
                    ]
                ],
                "Metric": [
                    [
                        "human-normalized scores",
                        "human-normalized, scores",
                        "human-normalized score"
                    ]
                ],
                "Task": [
                    [
                        "atari games",
                        "atari-57"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "atari 2600 games",
                        "atari games"
                    ]
                ],
                "Method": [
                    [
                        "implicit quantile networks",
                        "distributional generalization of the dqn algorithm",
                        "iqn",
                        "distributional bellman equation",
                        "implicit quantile network",
                        "state-action quantile function",
                        "iqn loss"
                    ]
                ],
                "Metric": [
                    [
                        "human-normalized scores",
                        "human-normalized, scores",
                        "human-normalized score"
                    ]
                ],
                "Task": [
                    [
                        "atari games",
                        "atari-57"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "qbert"
                    ]
                ],
                "Method": [
                    [
                        "implicit quantile networks",
                        "distributional generalization of the dqn algorithm",
                        "iqn",
                        "distributional bellman equation",
                        "implicit quantile network",
                        "state-action quantile function",
                        "iqn loss"
                    ]
                ],
                "Metric": [
                    [
                        "human-normalized scores",
                        "human-normalized, scores",
                        "human-normalized score"
                    ]
                ],
                "Task": [
                    [
                        "atari games",
                        "atari-57"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "space invaders"
                    ]
                ],
                "Method": [
                    [
                        "implicit quantile networks",
                        "distributional generalization of the dqn algorithm",
                        "iqn",
                        "distributional bellman equation",
                        "implicit quantile network",
                        "state-action quantile function",
                        "iqn loss"
                    ]
                ],
                "Metric": [
                    [
                        "human-normalized scores",
                        "human-normalized, scores",
                        "human-normalized score"
                    ]
                ],
                "Task": [
                    [
                        "atari games",
                        "atari-57"
                    ]
                ]
            }
        ]
    },
    "23d2d3a6ffebfecaa8930307fdcf451c147757c8-32": {
        "doctext": "document: seqgan: sequence generative adversarial nets with policy gradient as a new way of training generative models, generative adversarial net (gan) that uses a discriminative model to guide the training of the generative model has enjoyed considerable success in generating real-valued data. however, it has limitations when the goal is for generating sequences of discrete tokens. a major reason lies in that the discrete outputs from the generative model make it difficult to pass the gradient update from the discriminative model to the generative model. also, the discriminative model can only assess a complete sequence, while for a partially generated sequence, it is non-trivial to balance its current score and the future one once the entire sequence has been generated. in this paper, we propose a sequence generation framework, called seqgan, to solve the problems. modeling the data generator as a stochastic policy in reinforcement learning (rl), seqgan bypasses the generator differentiation problem by directly performing gradient policy update. the rl reward signal comes from the gan discriminator judged on a complete sequence, and is passed back to the intermediate state-action steps using monte carlo search. extensive experiments on synthetic data and real-world tasks demonstrate significant improvements over strong baselines. section: introduction generating sequential synthetic data that mimics the real one is an important problem in unsupervised learning. recently, recurrent neural networks (rnns) with long short-term memory (lstm) cells have shown excellent performance ranging from natural language generation to handwriting generation. the most common approach to training an rnn is to maximize the log predictive likelihood of each true token in the training sequence given the previous observed tokens. however, as argued in, the maximum likelihood approaches suffer from so-called exposure bias in the inference stage: the model generates a sequence iteratively and predicts next token conditioned on its previously predicted ones that may be never observed in the training data. such a discrepancy between training and inference can incur accumulatively along with the sequence and will become prominent as the length of sequence increases. to address this problem, proposed a training strategy called scheduled sampling (ss), where the generative model is partially fed with its own synthetic data as prefix (observed tokens) rather than the true data when deciding the next token in the training stage. nevertheless, showed that ss is an inconsistent training strategy and fails to address the problem fundamentally. another possible solution of the training/ inference discrepancy problem is to build the loss function on the entire generated sequence instead of each transition. for instance, in the application of machine translation, a task specific sequence score/ loss, bilingual evaluation understudy (bleu), can be adopted to guide the sequence generation. however, in many other practical applications, such as poem generation and chatbot, a task specific loss may not be directly available to score a generated sequence accurately. general adversarial net (gan) proposed by is a promising framework for alleviating the above problem. specifically, in gan a discriminative net learns to distinguish whether a given data instance is real or not, and a generative net learns to confuse by generating high quality data. this approach has been successful and been mostly applied in computer vision tasks of generating samples of natural images. unfortunately, applying gan to generating sequences has two problems. firstly, gan is designed for generating real-valued, continuous data but has difficulties in directly generating sequences of discrete tokens, such as texts. the reason is that in gans, the generator starts with random sampling first and then a determistic transform, govermented by the model parameters. as such, the gradient of the loss from w.r.t. the outputs by is used to guide the generative model (paramters) to slightly change the generated value to make it more realistic. if the generated data is based on discrete tokens, the\" slight change\" guidance from the discriminative net makes little sense because there is probably no corresponding token for such slight change in the limited dictionary space. secondly, gan can only give the score/ loss for an entire sequence when it has been generated; for a partially generated sequence, it is non-trivial to balance how good as it is now and the future score as the entire sequence. in this paper, to address the above two issues, we follow and consider the sequence generation procedure as a sequential decision making process. the generative model is treated as an agent of reinforcement learning (rl); the state is the generated tokens so far and the action is the next token to be generated. unlike the work in that requires a task-specific sequence score, such as bleu in machine translation, to give the reward, we employ a discriminator to evaluate the sequence and feedback the evaluation to guide the learning of the generative model. to solve the problem that the gradient can not pass back to the generative model when the output is discrete, we regard the generative model as a stochastic parametrized policy. in our policy gradient, we employ monte carlo (mc) search to approximate the state-action value. we directly train the policy (generative model) via policy gradient, which naturally avoids the differentiation difficulty for discrete data in a conventional gan. extensive experiments based on synthetic and real data are conducted to investigate the efficacy and properties of the proposed seqgan. in our synthetic data environment, seqgan significantly outperforms the maximum likelihood methods, scheduled sampling and pg-bleu. in three real-world tasks, i.e. poem generation, speech language generation and music generation, seqgan significantly outperforms the compared baselines in various metrics including human expert judgement. section: related work deep generative models have recently drawn significant attention, and the ability of learning over large (unlabeled) data endows them with more potential and vitality. first proposed to use the contrastive divergence algorithm to efficiently training deep belief nets (dbn). proposed denoising autoencoder (dae) that learns the data distribution in a supervised learning fashion. both dbn and dae learn a low dimensional representation (encoding) for each data instance and generate it from a decoding network. recently, variational autoencoder (vae) that combines deep learning with statistical inference intended to represent a data instance in a latent hidden space, while still utilizing (deep) neural networks for non-linear mapping. the inference is done via variational methods. all these generative models are trained by maximizing (the lower bound of) training data likelihood, which, as mentioned by, suffers from the difficulty of approximating intractable probabilistic computations. proposed an alternative training methodology to generative models, i.e. gans, where the training procedure is a minimax game between a generative model and a discriminative model. this framework bypasses the difficulty of maximum likelihood learning and has gained striking successes in natural image generation. however, little progress has been made in applying gans to sequence discrete data generation problems, e.g. natural language generation. this is due to the generator network in gan is designed to be able to adjust the output continuously, which does not work on discrete data generation. on the other hand, a lot of efforts have been made to generate structured sequences. recurrent neural networks can be trained to produce sequences of tokens in many applications such as machine translation. the most popular way of training rnns is to maximize the likelihood of each token in the training data whereas pointed out that the discrepancy between training and generating makes the maximum likelihood estimation suboptimal and proposed scheduled sampling strategy (ss). later theorized that the objective function underneath ss is improper and explained the reason why gans tend to generate natural-looking samples in theory. consequently, the gans have great potential but are not practically feasible to discrete probabilistic models currently. as pointed out by, the sequence data generation can be formulated as a sequential decision making process, which can be potentially be solved by reinforcement learning techniques. modeling the sequence generator as a policy of picking the next token, policy gradient methods can be adopted to optimize the generator once there is an (implicit) reward function to guide the policy. for most practical sequence generation tasks, e.g. machine translation, the reward signal is meaningful only for the entire sequence, for instance in the game of go, the reward signal is only set at the end of the game. in those cases, state-action evaluation methods such as monte carlo (tree) search have been adopted. by contract, our proposed seqgan extends gans with the rl-based generator to solve the sequence generation problem, where a reward signal is provided by the discriminator at the end of each episode via monte carlo approach, and the generator picks the action and learns the policy using estimated overall rewards. section: sequence generative adversarial nets the sequence generation problem is denoted as follows. given a dataset of real-world structured sequences, train a-parameterized generative model to produce a sequence, where is the vocabulary of candidate tokens. we interpret this problem based on reinforcement learning. in timestep, the state is the current produced tokens and the action is the next token to select. thus the policy model is stochastic, whereas the state transition is deterministic after an action has been chosen, i.e. for the next state if the current state and the action; for other next states,. additionally, we also train a-parameterized discriminative model to provide a guidance for improving generator. is a probability indicating how likely a sequence is from real sequence data or not. as illustrated in figure [reference], the discriminative model is trained by providing positive examples from the real sequence data and negative examples from the synthetic sequences generated from the generative model. at the same time, the generative model is updated by employing a policy gradient and mc search on the basis of the expected end reward received from the discriminative model. the reward is estimated by the likelihood that it would fool the discriminative model. the specific formulation is given in the next subsection. subsection: seqgan via policy gradient following, when there is no intermediate reward, the objective of the generator model (policy) is to generate a sequence from the start state to maximize its expected end reward: where is the reward for a complete sequence. note that the reward is from the discriminator, which we will discuss later. is the action-value function of a sequence, i.e. the expected accumulative reward starting from state, taking action, and then following policy. the rational of the objective function for a sequence is that starting from a given initial state, the goal of the generator is to generate a sequence which would make the discriminator consider it is real. the next question is how to estimate the action-value function. in this paper, we use the reinforce algorithm and consider the estimated probability of being real by the discriminator as the reward. formally, we have: however, the discriminator only provides a reward value for a finished sequence. since we actually care about the long-term reward, at every timestep, we should not only consider the fitness of previous tokens (prefix) but also the resulted future outcome. this is similar to playing the games such as go or chess where players sometimes would give up the immediate interests for the long-term victory. thus, to evaluate the action-value for an intermediate state, we apply monte carlo search with a roll-out policy to sample the unknown last tokens. we represent an-time monte carlo search as where and is sampled based on the roll-out policy and the current state. in our experiment, is set the same as the generator, but one can use a simplified version if the speed is the priority. to reduce the variance and get more accurate assessment of the action value, we run the roll-out policy starting from current state till the end of the sequence for times to get a batch of output samples. thus, we have: where, we see that when no intermediate reward, the function is iteratively defined as the next-state value starting from state and rolling out to the end. a benefit of using the discriminator as a reward function is that it can be dynamically updated to further improve the generative model iteratively. once we have a set of more realistic generated sequences, we shall re-train the discriminator model as follows: each time when a new discriminator model has been obtained, we are ready to update the generator. the proposed policy based method relies upon optimizing a parametrized policy to directly maximize the long-term reward. following, the gradient of the objective function w.r.t. the generator's parameters can be derived as the above form is due to the deterministic state transition and zero intermediate rewards. the detailed derivation is provided in the appendix. using likelihood ratios, we build an unbiased estimation for eq. ([reference]) (on one episode): where is the observed intermediate state sampled from. since the expectation can be approximated by sampling methods, we then update the generator's parameters as: where denotes the corresponding learning rate at-th step. also the advanced gradient algorithms such as adam and rmsprop can be adopted here. in summary, algorithm [reference] shows full details of the proposed seqgan. at the beginning of the training, we use the maximum likelihood estimation (mle) to pre-train on training set. we found the supervised signal from the pre-trained discriminator is informative to help adjust the generator efficiently. after the pre-training, the generator and discriminator are trained alternatively. as the generator gets progressed via training on g-steps updates, the discriminator needs to be re-trained periodically to keeps a good pace with the generator. when training the discriminator, positive examples are from the given dataset, whereas negative examples are generated from our generator. in order to keep the balance, the number of negative examples we generate for each d-step is the same as the positive examples. and to reduce the variability of the estimation, we use different sets of negative samples combined with positive ones, which is similar to bootstrapping. [t] sequence generative adversarial nets [1] generator policy g\u03b8; roll-out policy g\u03b2; discriminator d\u03d5; a sequence dataset= s{x:1 t} initialize g\u03b8, d\u03d5 with random weights\u03b8,\u03d5. g\u03b8 using mle on s negative samples using g\u03b8 for training d\u03d5 d\u03d5 via minimizing the cross entropy a sequence y:1t= (y1,\u2026, yt)\u223cg\u03b8 in:1 t q (a= yt;s= y:1-t1) by eq. () generator parameters via policy gradient eq. () current g\u03b8 to generate negative examples and combine with given positive examples s discriminator d\u03d5 for k epochs by eq. () converges subsection: the generative model for sequences we use recurrent neural networks (rnns) as the generative model. an rnn maps the input embedding representations of the sequence into a sequence of hidden states by using the update function recursively. moreover, a softmax output layer maps the hidden states into the output token distribution where the parameters are a bias vector and a weight matrix. to deal with the common vanishing and exploding gradient problem of the backpropagation through time, we leverage the long short-term memory (lstm) cells to implement the update function in eq. ([reference]). it is worth noticing that most of the rnn variants, such as the gated recurrent unit (gru) and soft attention mechanism, can be used as a generator in seqgan. subsection: the discriminative model for sequences deep discriminative models such as deep neural network (dnn), convolutional neural network (cnn) and recurrent convolutional neural network (rcnn) have shown a high performance in complicated sequence classification tasks. in this paper, we choose the cnn as our discriminator as cnn has recently been shown of great effectiveness in text (token sequence) classification. most discriminative models can only perform classification well for an entire sequence rather than the unfinished one. in this paper, we also focus on the situation where the discriminator predicts the probability that a finished sequence is real. we first represent an input sequence as: where is the-dimensional token embedding and is the concatenation operator to build the matrix. then a kernel applies a convolutional operation to a window size of words to produce a new feature map: where operator is the summation of elementwise production, is a bias term and is a non-linear function. we can use various numbers of kernels with different window sizes to extract different features. finally we apply a max-over-time pooling operation over the feature maps. to enhance the performance, we also add the highway architecture based on the pooled feature maps. finally, a fully connected layer with sigmoid activation is used to output the probability that the input sequence is real. the optimization target is to minimize the cross entropy between the ground truth label and the predicted probability as formulated in eq. ([reference]). detailed implementations of the generative and discriminative models are provided in the appendix. section: synthetic data experiments to test the efficacy and add our understanding of seqgan, we conduct a simulated test with synthetic data. to simulate the real-world structured sequences, we consider a language model to capture the dependency of the tokens. we use a randomly initialized lstm as the true model, aka, the oracle, to generate the real data distribution for the following experiments. subsection: evaluation metric the benefit of having such oracle is that firstly, it provides the training dataset and secondly evaluates the exact performance of the generative models, which will not be possible with real data. we know that mle is trying to minimize the cross-entropy between the true data distribution and our approximation, i.e.. however, the most accurate way of evaluating generative models is that we draw some samples from it and let human observers review them based on their prior knowledge. we assume that the human observer has learned an accurate model of the natural distribution. then in order to increase the chance of passing turing test, we actually need to minimize the exact opposite average negative log-likelihood, with the role of and exchanged. in our synthetic data experiments, we can consider the oracle to be the human observer for real-world problems, thus a perfect evaluation metric should be where and denote our generative model and the oracle respectively. at the test stage, we use to generate 100, 000 sequence samples and calculate for each sample by and their average score. also significance tests are performed to compare the statistical properties of the generation performance between the baselines and seqgan. subsection: training setting to set up the synthetic data experiments, we first initialize the parameters of an lstm network following the normal distribution as the oracle describing the real data distribution. then we use it to generate 10, 000 sequences of length 20 as the training set for the generative models. in seqgan algorithm, the training set for the discriminator is comprised by the generated examples with the label 0 and the instances from with the label 1. for different tasks, one should design specific structure for the convolutional layer and in our synthetic data experiments, the kernel size is from 1 to and the number of each kernel size is between 100 to 200. dropout and l2 regularization are used to avoid over-fitting. four generative models are compared with seqgan. the first model is a random token generation. the second one is the mle trained lstm. the third one is scheduled sampling. the fourth one is the policy gradient with bleu (pg-bleu). in the scheduled sampling, the training process gradually changes from a fully guided scheme feeding the true previous tokens into lstm, towards a less guided scheme which mostly feeds the lstm with its generated tokens. a curriculum rate is used to control the probability of replacing the true tokens with the generated ones. to get a good and stable performance, we decrease by 0.002 for every training epoch. in the pg-bleu algorithm, we use bleu, a metric measuring the similarity between a generated sequence and references (training data), to score the finished samples from monte carlo search. subsection: results the performance of generating sequences from the compared policies is provided in table [reference]. since the evaluation metric is fundamentally instructive, we can see the impact of seqgan, which outperforms other baselines significantly. a significance t-test on the score distribution of the generated sequences from the compared models is also performed, which demonstrates the significant improvement of seqgan over all compared models. the learning curves shown in figure [reference] illustrate the superiority of seqgan explicitly. after about 150 training epochs, both the maximum likelihood estimation and the schedule sampling methods converge to a relatively high score, whereas seqgan can improve the limit of the generator with the same structure as the baselines significantly. this indicates the prospect of applying adversarial training strategies to discrete sequence generative models to breakthrough the limitations of mle. additionally, seqgan outperforms pg-bleu, which means the discriminative signal in gan is more general and effective than a predefined score (e.g. bleu) to guide the generative policy to capture the underlying distribution of the sequence data. subsection: discussion in our synthetic data experiments, we find that the stability of seqgan depends on the training strategy. more specifically, the g-steps, d-steps and parameters in algorithm [reference] have a large effect on the convergence and performance of seqgan. figure [reference] shows the effect of these parameters. in figure [reference], the g-steps is much larger than the d-steps and epoch number, which means we train the generator for many times until we update the discriminator. this strategy leads to a fast convergence but as the generator improves quickly, the discriminator can not get fully trained and thus will provide a misleading signal gradually. in figure [reference], with more discriminator training epochs, the unstable training process is alleviated. in figure [reference], we train the generator for only one epoch and then before the discriminator gets fooled, we update it immediately based on the more realistic negative examples. in such a case, seqgan learns stably. the d-steps in all three training strategies described above is set to 1, which means we only generate one set of negative examples with the same number as the given dataset, and then train the discriminator on it for various epochs. but actually we can utilize the potentially unlimited number of negative examples to improve the discriminator. this trick can be considered as a type of bootstrapping, where we combine the fixed positive examples with different negative examples to obtain multiple training sets. figure [reference] shows this technique can improve the overall performance with good stability, since the discriminator is shown more negative examples and each time the positive examples are emphasized, which will lead to a more comprehensive guidance for training generator. this is in line with the theorem in. when analyzing the convergence of generative adversarial nets, an important assumption is that the discriminator is allowed to reach its optimum given. only if the discriminator is capable of differentiating real data from unnatural data consistently, the supervised signal from it can be meaningful and the whole adversarial training process can be stable and effective. section: real-world scenarios to complement the previous experiments, we also test seqgan on several real-world tasks, i.e. poem composition, speech language generation and music generation. subsection: text generation for text generation scenarios, we apply the proposed seqgan to generate chinese poems and barack obama political speeches. in the poem composition task, we use a corpus of 16, 394 chinese quatrains, each containing four lines of twenty characters in total. to focus on a fully automatic solution and stay general, we did not use any prior knowledge of special structure rules in chinese poems such as specific phonological rules. in the obama political speech generation task, we use a corpus, which is a collection of 11, 092 paragraphs from obama's political speeches. we use bleu score as an evaluation metric to measure the similarity degree between the generated texts and the human-created texts. bleu is originally designed to automatically judge the machine translation quality. the key point is to compare the similarity between the results created by machine and the references provided by human. specifically, for poem evaluation, we set n-gram to be 2 (bleu-2) since most words (dependency) in classical chinese poems consist of one or two characters and for the similar reason, we use bleu-3 and bleu-4 to evaluate obama speech generation performance. in our work, we use the whole test set as the references instead of trying to find some references for the following line given the previous line. the reason is in generation tasks we only provide some positive examples and then let the model catch the patterns of them and generate new ones. in addition to bleu, we also choose poem generation as a case for human judgement since a poem is a creative text construction and human evaluation is ideal. specifically, we mix the 20 real poems and 20 each generated from seqgan and mle. then 70 experts on chinese poems are invited to judge whether each of the 60 poem is created by human or machines. once regarded to be real, it gets+ 1 score, otherwise 0. finally, the average score for each algorithm is calculated. the experiment results are shown in tables [reference] and [reference], from which we can see the significant advantage of seqgan over the mle in text generation. particularly, for poem composition, seqgan performs comparably to real human data. subsection: music generation for music composition, we use nottingham dataset as our training data, which is a collection of 695 music of folk tunes in midi file format. we study the solo track of each music. in our work, we use 88 numbers to represent 88 pitches, which correspond to the 88 keys on the piano. with the pitch sampling for every 0.4s, we transform the midi files into sequences of numbers from 1 to 88 with the length 32. to model the fitness of the discrete piano key patterns, bleu is used as the evaluation metric. to model the fitness of the continuous pitch data patterns, the mean squared error (mse) is used for evaluation. from table [reference], we see that seqgan outperforms the mle significantly in both metrics in the music generation task. section: conclusion in this paper, we proposed a sequence generation method, seqgan, to effectively train generative adversarial nets for structured sequences generation via policy gradient. to our best knowledge, this is the first work extending gans to generate sequences of discrete tokens. in our synthetic data experiments, we used an oracle evaluation mechanism to explicitly illustrate the superiority of seqgan over strong baselines. for three real-world scenarios, i.e., poems, speech language and music generation, seqgan showed excellent performance on generating the creative sequences. we also performed a set of experiments to investigate the robustness and stability of training seqgan. for future work, we plan to build monte carlo tree search and value network to improve action decision making for large scale data and in the case of longer-term planning. section: acknowledgments we sincerely thank tianxing he for many helpful discussions and comments on the manuscript. bibliography: references appendix: appendix in section 1, we present the step-by-step derivation of eq. (6) in the paper. in section 2, the detailed realization of the generative model and the discriminative model is discussed, including the model parameter settings. in section 3, an interesting ablation study is provided, which is a supplementary to the discussions of the synthetic data experiments. subsection: proof for eq. (6) for readability, we provide the detailed derivation of eq. (6) here by following. as mentioned in sequence generative adversarial nets section, the state transition is deterministic after an action has been chosen, i.e. for the next state if the current state and the action; for other next states,. in addition, the intermediate reward is 0. we re-write the action value and state value as follows: for the start state, the value is calculated as which is the objective function to maximize in eq. (1) of the paper. then we can obtain the gradient of the objective function, defined in eq. (1), w.r.t. the generator's parameters: which is the result in eq. (6) of the paper. subsection: model implementations in this section, we present a full version of the discussed generative model and discriminative model in our paper submission. subsubsection: the generative model for sequences we use recurrent neural networks (rnns) as the generative model. an rnn maps the input embedding representations of the sequence into a sequence of hidden states by using the update function recursively. moreover, a softmax output layer maps the hidden states into the output token distribution where the parameters are a bias vector and a weight matrix. the vanishing and exploding gradient problem in backpropagation through time (bptt) issues a challenge of learning long-term dependencies to recurrent neural network. to address such problems, gated rnns have been designed based on the basic idea of creating paths through time that have derivatives that neither vanish nor explode. among various gated rnns, we choose the long short-term memory (lstm) to be our generative networks with the update equations: where is the vector concatenation and is the elementwise product. for simplicity, we use the standard lstm as the generator, while it is worth noticing that most of the rnn variants, such as the gated recurrent unit (gru) and soft attention mechanism, can be used as a generator in seqgan. the standard way of training an rnn is the maximum likelihood estimation (mle), which involves minimizing the negative log-likelihood for a generated sequence given input. however, when applying mle to generative models, there is a discrepancy between training and generating, which motivates our work. subsubsection: the discriminative model for sequences deep discriminative models such as deep neural network (dnn), convolutional neural network (cnn) and recurrent convolutional neural network (rcnn) have shown a high performance in complicated sequence classification tasks. in this paper, we choose the cnn as our discriminator as cnn has recently been shown of great effectiveness in text (token sequence) classification. as far as we know, except for some specific tasks, most discriminative models can only perform classification well for a whole sequence rather than the unfinished one. in case of some specific tasks, one may design a classifier to provide intermediate reward signal to enhance the performance of our framework. but to make it more general, we focus on the situation where discriminator can only provide final reward, i.e., the probability that a finished sequence was real. we first represent an input sequence as: where is the-dimensional token embedding and is the vertical concatenation operator to build the matrix. then a kernel applies a convolutional operation to a window size of words to produce a new feature map: where operator is the summation of elementwise production, is a bias term and is a non-linear function. we can use various numbers of kernels with different window sizes to extract different features. specifically, a kernel with window size applied to the concatenated embeddings of input sequence will produce a feature map finally we apply a max-over-time pooling operation over the feature map and pass all pooled features from different kernels to a fully connected softmax layer to get the probability that a given sequence is real. we perform an empirical experiment to choose the kernel window sizes and numbers as shown in table [reference]. for different tasks, one should design specific structures for the discriminator. to enhance the performance, we also add the highway architecture before the final fully connected layer: where, and are highway layer weights, denotes an affine transform followed by a non-linear activation function such as a rectified linear unit (relu) and is the\" transform gate\" with the same dimensionality as and. finally, we apply a sigmoid transformation to get the probability that a given sequence is real: where and is the output layer weight and bias. when optimizing discriminative models, supervised training is applied to minimize the cross entropy, which is widely used as the objective function for classification and prediction tasks: where is the ground truth label of the input sequence and is the predicted probability from the discriminative models. subsection: more ablation study in the discussion subsection of synthetic data experiments section of our paper, we discussed the ablation study of three hyperparameters of seqgan, i.e., g-steps, d-steps and epoch number. here we provide another ablation study which is instructive for the better training of seqgan. as described in our paper, we start the adversarial training process after the convergence of mle supervised pre-training. here we further conduct experiments to investigate the performance of seqgan when the supervised pre-training is insufficient. as shown in figure [reference], if we pre-train the generative model with conventional mle methods for only 20 epochs, which is far from convergence, then the adversarial training process improves the generator quite slowly and unstably. the reason is that in seqgan, the discriminative model provides reward guidance when training the generator and if the generator acts almost randomly, the discriminator will identify the generated sequence to be unreal with high confidence and almost every action the generator takes receives a low (unified) reward, which does not guide the generator towards a good improvement direction, resulting in an ineffective training procedure. this indicates that in order to apply adversarial training strategies to sequence generative models, a sufficient pre-training is necessary.",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "seqgan"
                    ],
                    [
                        "seqgan sequence generative adversarial nets"
                    ],
                    [
                        "gan"
                    ]
                ],
                "Metric": [
                    [
                        "mean squared error"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "chinese poems",
                        "chinese quatrains",
                        "poem"
                    ]
                ],
                "Method": [
                    [
                        "seqgan",
                        "sequence generative adversarial nets",
                        "sequence generation framework",
                        "sequence generation procedure",
                        "sequence generation method"
                    ]
                ],
                "Metric": [
                    [
                        "bleu-2"
                    ]
                ],
                "Task": [
                    [
                        "handwriting generation",
                        "sequence generation",
                        "poem generation",
                        "music generation",
                        "natural image generation",
                        "discrete data generation",
                        "sequence data generation",
                        "sequence generation tasks",
                        "go",
                        "generator",
                        "i.e. poem composition",
                        "text generation",
                        "text generation scenarios",
                        "obama speech generation",
                        "generation tasks",
                        "music generation task",
                        "poems",
                        "speech language",
                        "generating"
                    ]
                ]
            },
            {
                "Material": [],
                "Method": [
                    [
                        "seqgan",
                        "sequence generative adversarial nets",
                        "sequence generation framework",
                        "sequence generation procedure",
                        "sequence generation method"
                    ]
                ],
                "Metric": [
                    [
                        "bleu-3"
                    ]
                ],
                "Task": [
                    [
                        "handwriting generation",
                        "sequence generation",
                        "poem generation",
                        "music generation",
                        "natural image generation",
                        "discrete data generation",
                        "sequence data generation",
                        "sequence generation tasks",
                        "go",
                        "generator",
                        "i.e. poem composition",
                        "text generation",
                        "text generation scenarios",
                        "obama speech generation",
                        "generation tasks",
                        "music generation task",
                        "poems",
                        "speech language",
                        "generating"
                    ]
                ]
            },
            {
                "Material": [],
                "Method": [
                    [
                        "seqgan",
                        "sequence generative adversarial nets",
                        "sequence generation framework",
                        "sequence generation procedure",
                        "sequence generation method"
                    ]
                ],
                "Metric": [
                    [
                        "bleu-4"
                    ]
                ],
                "Task": [
                    [
                        "handwriting generation",
                        "sequence generation",
                        "poem generation",
                        "music generation",
                        "natural image generation",
                        "discrete data generation",
                        "sequence data generation",
                        "sequence generation tasks",
                        "go",
                        "generator",
                        "i.e. poem composition",
                        "text generation",
                        "text generation scenarios",
                        "obama speech generation",
                        "generation tasks",
                        "music generation task",
                        "poems",
                        "speech language",
                        "generating"
                    ]
                ]
            }
        ]
    },
    "24730424236724d3f798dec02901e7a1f1c4710e-33": {
        "doctext": "joint maximum purity forest with application to image super-resolution section: abstract-in this paper, we propose a novel random-forest scheme, namely joint maximum purity forest (jmpf), for classification, clustering, and regression tasks. in the jmpf scheme, the original feature space is transformed into a compactly pre-clustered feature space, via a trained rotation matrix. the rotation matrix is obtained through an iterative quantization process, where the input data belonging to different classes are clustered to the respective vertices of the new feature space with maximum purity. in the new feature space, orthogonal hyperplanes, which are employed at the split-nodes of decision trees in random forests, can tackle the clustering problems effectively. we evaluated our proposed method on public benchmark datasets for regression and classification tasks, and experiments showed that jmpf remarkably outperforms other state-of-the-art random-forest-based approaches. furthermore, we applied jmpf to image super-resolution, because the transformed, compact features are more discriminative to the clustering-regression scheme. experiment results on several public benchmark datasets also showed that the jmpf-based image super-resolution scheme is consistently superior to recent state-of-the-art image super-resolution algorithms. section: from achieving the optimal hyperplanes as svm does (i.e., there is no orthogonal constraint in svm) in some original feature space, as shown in fig. 1 (a). in this paper, we aim to solve this orthogonalconstraint limitation. with the fixed orthogonal hyperplanes, we propose to rotate the feature space, this is equivalent to rotating the hyperplanes, in such a way that global maximum purity on the clustered data can be achieved, as illustrated in fig. 2. this strategy can achieve a joint maximum purity for all the split-nodes when training a random forest. image super-resolution can be performed based on clustering/ classification, according to the recent emerging clustering-regression stream [reference][reference][reference], and the jmpf scheme can achieve remarkable performance on both the classification and regression tasks. therefore, jmpf is applied to single-image super-resolution in this paper. in our algorithm, principal component analysis (pca) is applied to the features for dimensionality reduction. the projected feature space is then rotated to a compact, preclustered feature space via a learned rotation matrix. finally, for all the split-nodes trained for a random forest, their thresholds are directly set to the inherent zero-center orthogonal hyperplanes in the rotated feature space to meet the maximum-purity criterion. experiment results show that jmpf can achieve more accurate clustering/ classification performance on random forests, and applying jmpf to image super-resolution can achieve superior quality, compared to state-of-the-art methods. having introduced the main idea of our proposed algorithm, the remainder of this paper is organized as follows. in section ii, we will describe our proposed scheme, the joint maximum purity forest scheme, and present in detail how to compute the rotation matrix via clustering data into the feature-space vertices. section iii will evaluate our proposed method and compare its performance with recent state-of-the-art random-forest-based approaches on regression and classification tasks. in section iv, we will validate the performance of jmpf scheme on single-image super-resolution. conclusions are given in section v. section: ii. joint maximum purity forest scheme section: ii.1 random forest and our insights a random forest is an ensemble of binary decision trees ():\u2192\u211d, where (= 1, 2,\u2026,) is the index of the trees,\u2208\u211d is the m-dimension feature space, and\u211d= [0, 1] represents the space of class probability distributions over the label space= {1,...,}. as shown in fig. 1 (b), the vertical dotted line forms a hyperplane,= 0, chosen in the first split-node for separating training samples, and the horizontal dotted line is the hyperplane,= 0, for the second split-node to cluster all the feature data assigned to this node. this results in separating the three data samples (red, green and blue) into three leaf-nodes. it can be seen from fig. 1 (b) that, for each split-node, the optimal hyperplane with more generalization capability is the one which can achieve maximum purity in clustering samples into two groups. for example, the vertical dotted line is the first optimal hyperplane because it clusters all the red training samples into the right node, while all the blue and green samples are clustered into the left node. furthermore, the left margin and the right margin are equal. although there is no guarantee that optimal hyperplanes can be determined for all the split-nodes in a random forest, approximated optimal hyperplanes can be obtained through a random bagging strategy. the training of a whole random forest is to train all of its decision trees, by choosing the candidate features and thresholds for each of the split-nodes, where the feature dimensions and thresholds are determined using a random bagging strategy. in the prediction stage, each decision tree returns a class probability (|) for a given query sample\u2208\u211d, and the final class label y* is then obtained via averaging, as follows:*= arg max\u2211 (|). the splitting function for a split-node is denoted as (;\u03b8), where is a sample and\u03b8 is typically parameterized by two values: (i) a feature dimension\u03b8\u00ee{1,...,}, and (ii) a threshold\u03b8\u00ee\u211d. the splitting function is defined as follows: where the outcome defines to which child node the sample is routed, and 0 and 1 are the two labels for the left and right child nodes, respectively. each node chooses the best splitting function\u03b8* out of a randomly sampled set {\u03b8} by optimizing the following function: where and are the sets of samples that are routed to the left and the right child nodes, and|| represents the number of samples in the set. during the training of a random forest, the decision trees are provided with a random subset of the training data (i.e. bagging), and are trained independently of each other. therefore, the decision trees are working as independent experts. taking random-forest-based classification as an example, training a single decision tree involves recursively splitting each node, such that the training data in each newly created child node is clustered according to their corresponding class labels, so the purity at each node is increasing along a tree. each tree is grown until a stopping criterion is reached (e.g. the number of samples in a node is less than a threshold or the tree depth reaches a maximum value) and the class probability distributions are estimated in the leaf-nodes. after fulfilling one of these criteria, a density model () in the leaf-node is estimated by all samples falling into this leaf-node for predicting the target value in the testing stage. a simple way to estimate the probability distribution () is averaging all the samples in the leaf-node, while there are also variant methods, such as fitting a gaussian distribution or kernel density estimation, ridge regression [reference][reference][reference], and so on. () is the local score for a set of samples (is either or), which normally is calculated using entropy as in eqn. (4), but it can be replaced by variance [reference][reference][reference] or the gini index [reference]. where k is the number of classes, and (|) is the probability for class, given the set. for the regression problem, the differential entropy: over continuous outputs can be employed, where (|) denotes the conditional probability of a target variable given the input sample. assuming (.,.) to be a gaussian distribution and having only a finite set of samples, the differential entropy can be written in closed form as where det (\u03c3) is the determinant of the estimated covariance matrix of the target variables in. for training each decision tree in a random forest, the goal on each split-node is to maximize the information gain (ig) by reducing the entropy after splitting. ig is defined as follows: since each decision tree is a binary tree and each step is to split a current node (a parent set) into two children nodes (and sets), ig can be described as follows: where\u210b is the optimal hyperplane of the split-node, and eqn. (8) is the target function of each splitnode when training each decision tree of a random forest. as we can see from fig. 1 (b), all the optimal hyperplanes from split-nodes are achieved independently and locally. since each optimal hyperplane is obtained from a subset of feature-dimension candidates with the randomly bagging strategy, there is no guarantee of obtaining a global optimum with respect to all the hyperplanes in all the split-nodes. an intuitive thinking, which was inspired by the data distribution in fig. 1 (b), is to achieve a global optimum by jointly considering all the hyperplanes of all the split-nodes, in the form as follows: where is the total number of split-nodes that a training sample has routed through a decision tree. as there is no mathematical solution to the problem described in eqn. [reference], an alternative way (i.e., an approximate method) to numerically solving eqn. (9) is to jointly maximize the purity of the clustered data groups at each of the split-nodes. this also means that all the data is clustered into the corners (feature-space vertices) of the feature space, as shown in fig. 2. section: ii.2 the joint maximum purity forest scheme to calculate the threshold for each split-node in each decision tree when training a random forest, we are attempting to determine an orthogonal hyperplane for a three-category classification problem, as shown in fig. 1. since the hyperplanes for the split-nodes of a decision tree are required to be orthogonal to each other, seeking an optimal orthogonal hyperplane locally can not guarantee obtaining maximum purity for the whole tree globally. as shown in fig. 2, it is easy to determine the vertical hyperplane for maximum purity, but it is hard to obtain the horizontal hyperplane for maximum purity in the original feature space. to achieve an optimal classification performance for the whole decision tree, all the split-nodes should be considered globally or simultaneously. as shown in fig. 2, a number of split-nodes, which have their hyperplanes orthogonal to each other, are required to separate the samples into different nodes. however, if we can transform the samples (zerocentered feature data) to locate them at the respective corners of the feature space, i.e. {\u22121, 1} for mdimensional features, the feature data can be easily and accurately separated by the orthogonal (either vertical or horizontal) hyperplanes, which contain the space center {0}, as illustrated in fig. 1 (b). the insight behind this is that the data is clustered into the feature-space vertices (the corners in a 2-d feature space means that the data points belong to {\u22121, 1} as the coordinate range is set to [\u22121, 1]). to tackle the original feature data, which is not ideally clustered in the vertices or corners of the feature space or close to them, as shown in fig. 1 (a), an intuitive idea is to rotate the feature space (this is equivalent to rotating the hyperplanes). this transformation clusters the feature data compactly into feature-space vertices {\u22121, 1} with a total of 2 vertices. therefore, a possible solution to the problem described in eqn. (10) is to rotate the data features by a rotation matrix\u211b\u00d7, as shown in fig. 2, through which the original feature space is transformed into a more compact clustered feature space, where all the feature data is clustered close to the feature-space vertices. this solution can be mathematically defined as follows: where\u2208\u211d\u00d7 contains n samples, each of which is a-dimensional feature vector arranged in a row, and is zero-centered, i.e. all the feature vectors are demeaned by subtracting the mean vector from each feature vector. this idea of clustering data into the feature-space vertices can also be found in locality-sensitive hashing (lsh) [reference] and image representation [reference]. in [reference], a simple and efficient alternating minimization scheme was proposed to find a rotation matrix for zero-centered feature data, which minimizes the quantization errors by mapping the feature data to the vertices of a zero-centered binary hypercube. the method is termed as iterative quantization (itq), which can work on multi-class spectral clustering and orthogonal procrustes problem. yu et al. [reference] proposed using a circulant matrix to speed up the computation, because the circulant structure enables the use of fast fourier transformation (fft). as the computation of the rotation matrix in the training and testing stage is ignorable, we choose a similar scheme to itq [reference] to determine the rotation matrix (we throw away the final quantization matrix described in eqn. [reference], which is used for hashing in [reference]), through which the original feature space can be transformed into a new compact clustered feature space:=\u211b, where the data is located at the respective vertices in the new feature space. after this transformation, a random forest with globally joint maximum purity of all the clustered data can be trained, through all the hyperplanes in the split-nodes of each decision tree. based on this idea, our proposed scheme is called joint maximum purity forest (jmpf). section: ii.3 learning the rotation matrix via clustering data into feature-space vertices assuming that\u2208\u211d is one point in the-dimensional feature space (zero-centered data), the respective vertices in the zero-centered binary hypercube space can be denoted as ()\u2208 {\u22121, 1}, and there is a total of 2 vertices in the-dimensional feature space. it is easy to see from we denote a binary code matrix\u2208 {\u22121, 1}\u00d7, whose rows= ()\u2208. for a matrix or a vector, (.) applies the sign operation to it element-wise. our objective is to minimize the error between the feature and the feature-space vertices, i.e., min\u2016\u2212\u2016. as we can see in fig. 2, when the feature space is rotated, the feature points will be more concentrated around their nearest vertices, which means that the quantization error will become smaller. therefore, the minimization problem of min\u2016\u2212\u2016 is equivalent to minimizing the error of the zerocentered data with respect to the frobenius norm, as in the following formulation: therefore, the task of this minimization problem is to determine an optimal rotation matrix\u211b to satisfy eqn. [reference]. since there are two variables in eqn. (11), the expectation-maximization (e-m) algorithm is applied to cluster data into the feature-space vertices, such that a local minimum of the binary code matrix and the rotation matrix\u211b are computed simultaneously. the idea of rotating feature data to minimize the error between the transformed data and the featurespace vertices can also be found in [reference], which showed that the rotation matrix\u211b can be initialized randomly, and then iterated to converge to the required rotation matrix. two iteration steps will be performed: in every iteration, each feature vector in the feature space is firstly quantized to the nearest vertex of the binary hypercube, i.e. to a vertex in, and then the rotation matrix\u211b is updated to minimize the quantization error by fixing. these two alternating steps are described in detail below: (1) fix\u211b and update: because the zero-centered data matrix is fixed, minimizing eqn. (12) is equivalent to maximizing the following term: where is an element of=\u211b. to maximize eqn. (13) with respect to,= 1 whenever\u2265 0 and=\u22121 otherwise, i.e.= (\u211b)\u2208 {\u22121, 1}. (2) fix and update\u211b: the problem of fixing to obtain a rotation matrix based on the objective function eqn. (11) is relative to the classic orthogonal procrustes problem [reference][reference][reference], in which a rotation matrix is determined to align one point set with another. in our algorithm, these two point sets are the zero-centered data set and the quantized matrix. therefore, a closed-form solution for\u211b is available, by applying svd on the\u00d7 matrix to obtain\u03c9 (\u03c9 is a diagonal matrix), then set\u211b= to update\u211b. section: ii.4 proof of the orthogonal procrustes problem: for completeness, we prove the orthogonal procrustes problem, for which the solution can be found in [reference][reference][reference]: proof: thus, min\u211b\u2016\u2212\u211b\u2016 equals to maximizing: the last inequality holds because z is also an orthonormal matrix, and\u2211,= 1,,\u2264 1. the objective function can be maximized if z=, i.e. section:\u211b=\u220e section: iii. joint maximum purity forest for regression and classification section: iii.1 the workflow of joint maximum purity forest random forest is a machine-learning method using an ensemble of randomized decision trees for classification. each tree in a random forest consists of split-nodes and leaf-nodes, which can be trained recursively. a random forest is constructed recursively, where each node attempts to find a splitting function or a hyperplane to separate its samples into two leaf-nodes, such that the information gain is optimized. a tree stops growing if the maximum depth is reached or if a node has achieved maximum purity, i.e. it contains only samples from one class. then, each leaf-node collects the statistics of the samples falling in it. in the evaluation phase, the probability of a query sample x belonging to class k is given by averaging all the trees, or by other methods. most random-forest-based models [reference][reference][reference][reference] share a similar workflow, as shown in fig. 3, in which the main task on training a tree in a random forest is to decide thresholds in the split-nodes and learn the regressors or classes in the leaf-nodes. rigid regression or linear regression is often employed in the leaf-nodes for the prediction task, because rigid regression has a closed-form solution, while linear regression is an efficient optimization tool, and the liblinear package [reference] can be used to fine-tune its configurations. compared to conventional random forests, our jmpf scheme has one more step, as shown in the left of fig. 3, the rotation matrix. the jmpf scheme transforms the original feature space by rotating it into a more compact, pre-clustered feature space, using a trained rotation matrix learned through clustering feature vectors iteratively into the vertices of a new feature space. the whole workflow of our proposed algorithm, the jmpf scheme, is outlined in fig. 3. the source code of our algorithm is available to download at: https:// github.com/ harleyhk/ jmpf. a section: iii.2 the inherent zero-center hyperplanes as thresholds for split-nodes in training a random forest, the two main operations for training (splitting) each split-node are to choose splitting feature (s), and to determine the threshold, using a random bagging strategy, which can avoid over-fitting in training classifiers. in the rotated compact pre-clustered feature space, the inherent zerocenter hyperplanes are inherently the optimal thresholds (to meet the max-purity criterion on two clustered data groups) after training the rotation matrix. therefore, these inherent zero-center hyperplanes can directly be set as the thresholds to achieve optimal classification performance on training a random forest. compared to conventional random forests, our proposed jmpf only needs to choose which feature (s) to split data at split-nodes. this can speed up the training process for a random forest. experimental results in the next subsection will validate this performance. section: iii.3: experimental results on jmpf regression and classification to evaluate the performances of the proposed jmpf, we test it with 15 standard machine-learning tasks, 7 for classification and 8 for regression. the datasets used in the experiments are summarized in table-1. we use standard performance evaluation metrics: error rate for classification and root mean squared error (rmse) for regression, unless otherwise specified. we firstly evaluate the proposed approach on two real applications, one for classification (table-2) and one for regression (table-3). our proposed jmpf is compared with the original random forest before refinement (denoted as rf), and two state-of-the-art variants: alternating decision forests (adf) [reference] and alternating regression forests (arf) [reference], for classification and regression, respectively. furthermore, we compare with jmpf+ adf/ arf, for demonstrating that our algorithm can be combined with other methods. we follow the experiment settings in [reference][reference]. we set the maximum tree depth d at 15, and the minimum sample number in a splitting node is set at 5. the experiments were repeated five times, and the average error and standard deviation were measured. the results are presented in table-2 and table-3, for the classification and regression tasks, respectively. in terms of accuracy, our proposed jmpf significantly outperforms the standard random forest on all classification and regression tasks. compared to rf, jmpf achieves an average of 23.57% improvement on the classification tasks, and an average of 23.13% improvement on the regression tasks. our method also consistently outperforms the state-of-theart variants: adf/ arf. moreover, the performance of our jmpf algorithm can be further improved by integrating with adf and arf, denoted as jmpf+ adf/ arf. as shown in table-2 and table-[reference], jmpf: proposed algorithm, jmpf+ arf: our proposed algorithm embedded into arf. is the error scale. the number of randomly chosen hyperplanes#\u210b is 3. the percentages in brackets for jmpf and jmpf+ arf are the reduction rates in rmse compared with the rf algorithm. section: iii.4: discussions on experimental results the computational complexity of jmpf is similar to that of the standard random forest. as illustrated in the workflow of jmpf in fig. 3, only one additional step, which computes the rotation matrix, is required, when compared to the standard random forest. for a small dataset (e.g., feature dimension size less than 500 and data size less than 10, 000), the computation required to compute the rotation matrix for clustering data into the feature-space vertices is acceptable in the training stage (about 10 seconds per level, using matlab) and negligible in the testing stage. when the dimension size becomes larger, pca dimensionality reduction can be employed. if the size of the dataset increases, such that using pca still involves heavy computation, bagging can be used to achieve comparable accuracy and the whole extra computation will be insignificant., the number hyperplane (s)#\u210b on training the random forest is 3). to study the stability of jmpf, we choose the letterorig dataset for classification and the kin8 nm dataset for regression, and the respective results are shown in fig. 4 (a) and fig. 4 (b), respectively. in the experiments, the number of trees, i.e., the number of weak classifiers in the random forest, varies from 10 to 200, and we have three observations. firstly, as shown in fig. 4, when the number of trees increases, the performance of all the algorithms improves. for classification, as shown in fig. 4 (a), when the number of trees is larger than 100, the errors are converged to become steady. on the contrary, for the regression task as shown in fig. 4 (b), the errors are almost stable, ranged from 10 to 200. secondly, the results show that jmpf consistently outperforms adf and rf, irrespective of the number of trees used. finally, fig. 4 clearly shows that jmpf can integrate with adf or arf to further improve its performance. section: iv. image super-resolution based on joint maximum purity forest section: iv.1 overview of image super-resolution and related works image super-resolution (sr), which recovers a high-resolution (hr) image from one single image or a number of low-resolution (lr) images, has been a hot research topic in the field of image processing for decades. sr is a well-known ill-posed problem, which needs artistic skills from mathematics and machine learning. prior methods on sr are mainly based on edge preserving, such as new edge-directed interpolation (nedi) [reference], soft-decision adaptive interpolation (sai) [reference], directional filtering and data-fusion (dfdf) [reference], modified edge-directed interpolation (medi) [reference], etc. the neighbor-embedding (ne) methods [reference][reference] set the milestone on the patch-learning-based superresolution approach. in this approach, each lr patch is approximated as a linear regression of its nearest lr neighbors in a collected dataset, while its hr counterpart can be reconstructed with the same coefficients of corresponding hr neighbors, based on the non-linear manifold structure. although the ne method is simple and practical, it requires a huge dataset (millions of patches) to achieve good reconstruction quality and it is computationally intensive, because k-nn is used in searching neighboring patches in the huge dataset. instead of using the patches extracted directly from natural images, yang et al. [reference] employed sparse coding [reference][reference] to represent patch images, of large size, efficiently, which opens the era for sparse coding in the image inverse problems. the sparse-coding super-resolution (scsr) approach is a framework that the hr counterpart of an lr patch can be reconstructed aided by two learned dictionaries, with the sparse constraint on the coefficients via the following formulations: the compact lr and hr dictionaries can be jointly learned with a sparsity constraint, using the following sparse representation: where and are the lr patch and the corresponding hr patch, respectively; and d and d are the lr and hr dictionaries learned from the lr and the corresponding hr patch samples, respectively. the value of in\u2016\u2016 is the sparsity factor of the coefficients.\u2016\u2016 is-norm, which means the non-zero count of the coefficients in. for each lr patch of an input lr image, the problem of finding the sparse coefficients can be formulated as follows: where is a linear or non-linear feature-extraction operator on the lr patches, which makes the lr patches more discriminative from each other. typically, can be chosen as a high-pass filter, and a simple high-pass filter can be obtained by subtracting the input from the output of a low-pass filter, as in an early work [reference]. in the ideal regularization term for the sparse constraint on the coefficients\u03b1 is the-norm (nonconvex), but, based on greedy matching, it leads to an np-hard problem. alternatively, yang et al. [reference] relaxed it to-norm, as shown in the following formulation: the lagrange multiplier provides an equivalent formulation as follows: where the parameter balances the sparsity of the solution and the fidelity of the approximation to. however, the effectiveness of sparsity was challenged in [reference][reference], as to whether real sparsity can help image classification and restoration, or locality property can achieve the same effect. timofte et al. [reference] proposed an anchored neighborhood regression (anr) framework, which relaxes the sparse decomposition optimization (- norm) of [reference][reference] to a ridge regression (- norm) problem. an important step in the anr model is the relaxation of the-norm in eqn. (23) to the-norm least-squares minimization constraint, as follows: where d and d are the lr and hr patch-based dictionaries, respectively. this-norm constraint problem can be solved with a closed-form solution from the ridge regression [reference] theory. based on the tikhonov regularization/ ridge-regression theory, the closed-form solution of the coefficients is given: we assume that the hr patches share the same coefficient\u03b1 from their counterpart lr patches, i.e.,= d. from eqn. (25), we have: therefore, the hr patches can be reconstructed by:= y, where can be considered a projection matrix, which can be calculated offline, as follows: ridge regression allows the coefficients to be calculated by multiplying the constant projection matrix with the new extracted feature, as described in eqn. (26) and eqn. [reference]. more importantly, the projection matrix can be pre-computed, and this offline learning enables significant speed-up at the prediction stage. timofte et al. [reference] further extended the anr approach to the a+ approach, which learns regressors from all the training samples, rather than from a small quantity of neighbors of the anchor atoms as anr does. later, there are numerous variants and extended approaches, based on anr and a+ [reference][reference][reference][reference][reference][reference][reference][reference]. by investigating the anr model, li et al. [reference] found that the weights of the supporting atoms can be of different values to represent their similarities to the anchor atom. based on this idea, the normal collaborative representation (cr) model in anr is generalized to a weighted model, named as weighted collaborative representation (wcr) model, as follows: where is a diagonal matrix. the weights on the diagonal atoms are proportional to their similarities to the anchor atom. similarly, the new closed-form solution for the coefficients can be calculated offline, as follows: and the new projection matrix is given as follows: the wcr model can further improve the anr or a+ model in terms of image quality, but it is still a time-consuming problem to find the most similar anchor atoms in a dictionary, and this always hinders its applications where fast speed is greatly required. schulter et al. [reference] adopted the random forest as a classifier, and the regressors are learned from the patches in the leaf-nodes. with the same number of regressors, these random-forest-based methods [reference][reference][reference][reference] can perform on a par with the a+ method in terms of accuracy. however, they achieve an increase in speed, because the sublinear search property of random forest can remarkably reduce the regressors' search complexity. recently, deep learning has become a hot research topic, which has been successfully applied to image super-resolution [reference][reference][reference][reference] and achieved promising performance, particularly in terms of image quality. in [reference][reference], a convolutional neural-network-based image super-resolution (srcnn) was proposed, in which an end-to-end mapping between lr and hr images is learned through a deep convolutional neural network (cnn). the recent emerging stream [reference][reference] on single-image sr is to formulate the problem as a clusteringregression problem, which can be solved with machine-learning tools. these approaches are learningbased methods, which attempt to reconstruct an hr image from patches with the help of an external database. these methods first decompose an image into patches, then classify them into clusters. regressors are then trained for each of the clusters, which generate mappings from an input lr patch's feature to its corresponding hr patch (see fig. 5). in the testing stage, an lr query image follows the same procedures to cut into patches and to extract features, which are then assigned to their corresponding clusters using the k-nn algorithm [reference][reference] or random forest [reference][reference][reference]. the respective hr patches are constructed through regressors learned for the clusters (see fig. 6). this kind of clustering-regression algorithms, based on random forest [reference][reference][reference], has achieved state-of-the-art performance in single image super-resolution, both in terms of accuracy and efficiency, because of the use of ensemble learning and sublinear search. as jmpf achieves promising results on both classification and regression tasks, it can be employed for image super-resolution for better performances. an overview of the training and testing processes of the proposed jmpf-based image sr method is illustrated in fig. 5 and fig. 6, respectively. in our method, the first and second-order gradients are extracted as features from each patch, followed by pca for dimensionality reduction. these features are then rotated into a more compact, pre-clustered feature space. finally, all the thresholds are directly set to the inherent zero-center hyperplanes when training the random forest, and similar to other algorithms, the regressors at the leaf-nodes are computed using the rigid regression algorithms. this approach is named as jmpf-based image super-resolution method. section: iv.3 the working processes of jmpf-based image super-resolution jmpf has been shown to achieve a better performance for clustering and classification than other random forest methods. since image super-resolution can be considered as a clustering/ classification problem, using jmpf is likely to result in better performance. this is mainly due to the features transformed to the vertices in the new feature space, so the features become more discriminative. the image super-resolution training and testing processes of our proposed jmpf-based method are described in algorithm 1 and algorithm 2, respectively. section: iv.4 experimental results on jmpf-based image super-resolution in this section, we evaluate our image sr algorithm on some standard super-resolution datasets, including set 5, set14, and b100 [reference], and compare it with a number of classical or state-of-the-art methods. these include bicubic interpolation, sparse representation sr (zeyde) [reference], anchored neighborhood regression (anr) [reference], a+ [reference], standard random forest (rf) [reference], and alternating regression forests (arf) [reference]. we set the same parameters for all the random-forest-based algorithms: the number of trees in the random forest is 10, and the maximum depth of each tree is 15. experiment results are tabulated in tables-4 and tables-5, where jmpf is our proposed jmpf-based image super-resolution method, and jmpf\uf02d is a trimmed version, such that the thresholds for the splitnodes are not the inherent zero-center hyperplanes, but set by the standard random-forest bagging strategy. we use the same training images (91 images) for all the algorithms as previous works [reference][reference][reference][reference] do. however, for jmpf+, 100 more images from the general-100 dataset [reference] are used, so as to check whether or not more training samples can further improve our proposed algorithm. table-5: detailed results of the proposed method, compared with state-of-the-art methods on the dataset set5, in terms of psnr (db) using three different magnification factors (\u00d72,\u00d73,\u00d74). table-4 tabulates the performances, in terms of the average peak signal to noise ratio (psnr) scores, of our proposed algorithm and other image sr methods, on the 3 datasets with different magnification factors. for the set5 and set14 datasets, with different magnification factors, our proposed jmpf-based algorithm can achieve a comparable performance to other recent state-of-the-art methods, such as a+ and arf. as those random-forest-based algorithms may not be stable on small datasets, when evaluation works on extensive datasets, such as b100, our proposed algorithm jmpf can stably outperform a+ and arf for all magnification factors (\u00d72,\u00d73,\u00d74). moreover, the objective quality metrics on psnr also show that the jmpf algorithm can achieve a better performance when more samples are used for training, as shown from jmpf+ in table-4. table-5 provides more details of the performances in datasets set5. to compare the visual quality of our proposed jmpf-based sr algorithm to other methods, fig. 7, shows the reconstructed hr images using different methods. some regions in the reconstructed images are also enlarged, so as to show the details in the images. in general, our proposed method can produce better quality images, particularly in areas with rich texture, which verifies the feature discrimination of the proposed jmpf scheme. section: v. conclusions in this paper, we have proposed a novel random-forest scheme, namely the joint maximum purity forest (jmpf) scheme, which rotates the feature space into a compact, clustered feature space, by jointly maximizing the purity of all the feature-space vertices. in the new pre-clustered feature space, orthogonal hyperplanes can be effectively used in the split-nodes of a decision tree, which can improve the performance of the trained random forest. compared to the standard random forests and the recent state-of-the-art variants, such as alternating decision forests (adf) [reference] and alternating regression forests (arf) [reference], our proposed random-forest method inherits the merits of random forests (fast training and testing, multi-class capability, etc.), and also yields promising results on both classification and regression tasks. experiments have shown that our method achieves an average improvement of about 20% for classification and regression on publicly benchmarked datasets. furthermore, our proposed scheme can integrate with other methods, such as adf and arf, to further improve the performance. we have also applied jmpf to single-image super-resolution. we tackle image super-resolution as a clustering-regression problem, and focus on the clustering stage, which happens at the split-nodes of each decision tree. by employing the jmpf strategy, we rotate the feature space into a pre-clustered feature space, which can cluster samples into different sub-spaces more compactly in an unsupervised problem. the compact pre-clustered feature space can provide the optimal thresholds for split-nodes in decision trees, which are the zero-centered orthogonal hyperplanes. our experiment results on intensive image benchmark datasets, such as b100, show that the proposed jmpf-based image super-resolution approach can consistently outperform recent state-of-the-art algorithms, in terms of psnr and visual quality. our method also inherits the advantages of random forests, which have fast speed on both the training and inference processes. section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "b100"
                    ],
                    [
                        "set5"
                    ],
                    [
                        "b100"
                    ]
                ],
                "Method": [
                    [
                        "joint maximum purity forest"
                    ],
                    [
                        "joint maximum purity forest"
                    ],
                    [
                        "jmpf"
                    ]
                ],
                "Metric": [
                    [
                        "rmse"
                    ],
                    [
                        "peak signal to noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "image super resolution"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "b100"
                    ]
                ],
                "Method": [
                    [
                        "joint maximum purity forest scheme",
                        "joint maximum purity forest",
                        "jmpf"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "peak signal to noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "single-image super-resolution",
                        "sr",
                        "single image super-resolution",
                        "image super-resolution training"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set14 datasets"
                    ]
                ],
                "Method": [
                    [
                        "joint maximum purity forest scheme",
                        "joint maximum purity forest",
                        "jmpf"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "peak signal to noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "single-image super-resolution",
                        "sr",
                        "single image super-resolution",
                        "image super-resolution training"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "set5"
                    ]
                ],
                "Method": [
                    [
                        "joint maximum purity forest scheme",
                        "joint maximum purity forest",
                        "jmpf"
                    ]
                ],
                "Metric": [
                    [
                        "psnr",
                        "peak signal to noise ratio"
                    ]
                ],
                "Task": [
                    [
                        "image super-resolution",
                        "single-image super-resolution",
                        "sr",
                        "single image super-resolution",
                        "image super-resolution training"
                    ]
                ]
            }
        ]
    },
    "249b3b7421d3cdb932eecfe4b67203e0e46806b2-34": {
        "doctext": "document: cell-aware stacked lstms for modeling sentences we propose a method of stacking multiple long short-term memory (lstm) layers for modeling sentences. in contrast to the conventional stacked lstms where only hidden states are fed as input to the next layer, our architecture accepts both hidden and memory cell states of the preceding layer and fuses information from the left and the lower context using the soft gating mechanism of lstms. thus the proposed stacked lstm architecture modulates the amount of information to be delivered not only in horizontal recurrence but also in vertical connections, from which useful features extracted from lower layers are effectively conveyed to upper layers. we dub this architecture cell-aware stacked lstm (cas-lstm) and show from experiments that our models achieve state-of-the-art results on benchmark datasets for natural language inference, paraphrase detection, and sentiment classification. section: introduction in the field of natural language processing (nlp), the most prevalent neural approach to obtaining sentence representations is to use recurrent neural networks (rnns), where words in a sentence are processed in a sequential and recurrent manner. along with their intuitive design, rnns have shown outstanding performance across various nlp tasks e.g. language modeling, machine translation, text classification, and parsing. among several variants of the original rnn, gated recurrent architectures such as long short-term memory (lstm) and gated recurrent unit (gru) have been accepted as de-facto standard choices for rnns due to their capability of addressing the vanishing and exploding gradient problem and considering long-term dependencies. gated rnns achieve these properties by introducing additional gating units that learn to control the amount of information to be transferred or forgotten, and are proven to work well without relying on complex optimization algorithms or careful initialization. meanwhile, the common practice for further enhancing the expressiveness of rnns is to stack multiple rnn layers, each of which has distinct parameter sets (stacked rnn). in stacked rnns, the hidden states of a layer are fed as input to the subsequent layer, and they are shown to work well due to increased depth or their ability to capture hierarchical time series which are inherent to the nature of the problem being modeled. 0.25 0.25 however this setting of stacking rnns might hinder the possibility of more sophisticated recurrence-based structures since the information from lower layers is simply treated as input to the next layer, rather than as another class of state that participates in core rnn computations. especially for gated rnns such as lstms and grus, this means that layer-to-layer connections can not fully benefit from the carefully constructed gating mechanism used in temporal transitions. some recent work on stacking rnns suggests alternative methods that encourage direct and effective interaction between rnn layers by adding residual connections, by shortcut connections, or by using cell states of lstms. in this paper, we propose a method of constructing multi-layer lstms where cell states are used in controlling the vertical information flow. this system utilizes states from the left and the lower context equally in computation of the new state, thus the information from lower layers is elaborately filtered and reflected through a soft gating mechanism. our method is easy-to-implement, effective, and can replace conventional stacked lstms without much modification of the overall architecture. we call the proposed architecture cell-aware stacked lstm, or cas-lstm, and evaluate our method on multiple benchmark datasets: snli, multinli, quora question pairs, and sst. from experiments we show that the cas-lstms consistently outperform typical stacked lstms, opening the possibility of performance improvement of architectures that use stacked lstms. our contribution is summarized as follows. we bring the idea of utilizing states coming from multiple directions to construction of stacked lstm and apply the idea to the research of sentence representation learning. there is some prior work addressing the idea of incorporating more than one type of state, however to the best of our knowledge there is little work on applying the idea to sentence encoding and text classification. we conduct extensive evaluation of the proposed method and empirically prove its effectiveness on encoding sentences. our models achieve new state-of-the-art results on snli and quora question pairs datasets, and are on par with the best performing models on multinli and sst datasets. this paper is organized as follows. we give a detailed description about the proposed method in\u00a7 [reference]. experimental results are given in\u00a7 [reference]. we study prior work related to our objective in\u00a7 [reference] and conclude in\u00a7 [reference]. section: model description in this section, we give a detailed formulation of the architectures used in experiments. subsection: notation throughout this paper, we denote matrices as boldface capital letters (), vectors as boldface lowercase letters (), and scalars as normal italic letters (). for lstm states, we denote a hidden state as and a cell state as. also, a layer index of or is denoted by superscript and a time index is denoted by a subscript, i.e. indicates the hidden state at time and layer. means the element-wise multiplication between two vectors. we write-th component of vector as. all vectors are assumed to be column vectors. subsection: stacked lstms while there exist various versions of lstm formulation, in this work we use the following, one of the most common versions: where,, and,, are trainable parameters. and are the sigmoid activation and the hyperbolic tangent activation function respectively. also we assume that where is the-th input to the network. the input gate and the forget gate control the amount of information transmitted from and, the candidate cell state and the previous cell state, to the new cell state. similarly the output gate soft-selects which portion of the cell state is to be used in the final hidden state. we can clearly see that cell states (,,) play a crucial role in forming horizontal recurrence. however the current formulation does not consider, the cell state from-th layer, in computation and thus the lower context is reflected only through the rudimentary way, hindering the possibility of controlling vertical information flow. subsection: cell-aware stacked lstms now we extend the stacked lstm formulation defined above to address the problem noted in the previous subsection. to enhance the interaction between layers in a way similar to how lstms keep and forget the information from the previous time step, we introduce the additional forget gate that determines whether to accept or ignore the signals coming from the previous layer. therefore the proposed cell-aware stacked lstm is formulated as follows: where and. can either be a vector of constants or parameters. when, the equations defined in the previous subsection are used. therefore, it can be said that each non-bottom layer of cas-lstm accepts two sets of hidden and cell states\u2014 one from the left context and the other from the below context. the left and the below context participate in computation with the equivalent procedure so that the information from lower layers can be efficiently propagated. fig. [reference] compares cas-lstm to the conventional stacked lstm architecture, and fig. [reference] depicts the computation flow of the cas-lstm. we argue that considering in computation is beneficial for the following reasons. first, contains additional information compared to since it is not filtered by. thus a model that directly uses does not rely solely on for extracting information, due to the fact that it has access to the raw information, as in temporal connections. in other words, no longer has to take all responsibility for selecting useful features for both horizontal and vertical transitions, and the burden of selecting information is shared with. another advantage of using the lies in the fact that it directly connects and. this direct connection helps and stabilizes training, since the terminal error signals can be easily backpropagated to model parameters. fig. [reference] illustrates paths between the two cell states. we find experimentally that there is little difference between letting be constant and letting it be trainable parameters, thus we set in all experiments. we also experimented with the architecture without i.e. two cell states are combined by unweighted summation similar to multidimensional rnns, and found that it leads to performance degradation and unstable convergence, likely due to mismatch in the range of cell state values between layers (for the first layer and for the others). experimental results on various are presented in\u00a7 [reference]. paragraph: connection to tree-structured rnns. the idea of having multiple states is also related to tree-structured rnns. among them, tree-structured lstms (tree-lstms) are similar to ours in that they use both hidden and cell states from children nodes. in tree-lstms, states for all children nodes are regarded as input, and they participate in the computation equally through weight-shared (in child-sum tree-lstms) or weight-unshared (in-ary tree-lstms) projection. from this perspective, each cas-lstm layer (where) can be seen as a binary tree-lstm where the structures it operates on are fixed to right-branching trees. the use of cell state in computation could be one reason that tree-lstms perform better than sequential lstms even when trivial trees (strictly left-or right-branching) are given. paragraph: connection to multidimensional rnns. multidimensional rnns (mdrnn) are an extension of 1d sequential rnns that can accept multidimensional input e.g. images, and have been successfully applied to image segmentation and handwriting recognition. notably multidimensional lstms (mdlstm) have an analogous formulation to ours except the term and the fact that we use distinct weights per column (or 'layer' in our case). from this view, cas-lstm can be seen as a certain kind of mdlstm that accepts a 2d input. grid lstms also take inputs but emit outputs, which is different from our case where a single set of hidden and cell states is produced. subsection: sentence encoders the sentence encoder network we use in our experiments takes words (assumed to be one-hot vectors) as input. the words are projected to corresponding word representations: where. then is fed to a-layer cas-lstm model, resulting in the representations. the sentence representation,, is computed by max-pooling over time as in the work of conneau2017infersent conneau2017infersent. similar to their results, from preliminary experiments we found that the max-pooling performs consistently better than mean-and last-pooling. to make models more expressive, a bidirectional cas-lstm network may also be used. in the bidirectional case, the forward representations and the backward representations are concatenated and max-pooled to yield the sentence representation. we call this bidirectional architecture bi-cas-lstm in experiments. subsection: top-layer classifiers for the natural language inference experiments, we use the following heuristic function proposed by mou2016snli mou2016snli in feature extraction: where means vector concatenation, and and are applied element-wise. and we use the following function in paraphrase identification experiments: as in the work of ji2013discriminative ji2013discriminative. for sentiment classification, we use the sentence representation itself. we feed the feature extracted from as input to the mlp classifier with relu activation followed by the fully-connected softmax layer to predict the label distribution: where, is the number of label classes, and the dimension of the mlp output, section: experiments we evaluate our method on natural language inference (nli), paraphrase identification (pi), and sentiment classification. we also conduct analysis on gate values and experiments on model variants. for detailed experimental settings, we refer readers to the supplemental material. for the nli and pi tasks, there exists recent work specializing in sentence pair classification. however in this work we confine our model to the architecture that encodes each sentence using a shared encoder without any inter-sentence interaction, in order to focus on the effectiveness of the models in extracting semantics. but note that the applicability of cas-lstm is not limited to sentence encoding based approaches. subsection: natural language inference for the evaluation of performance of the proposed method on the nli task, snli and multinli datasets are used. the objective of both datasets is to predict the relationship between a premise and a hypothesis sentence: entailment, contradiction, and neutral. snli and multinli datasets are composed of about 570k and 430k premise-hypothesis pairs respectively. glove pretrained word embeddings are used and remain fixed during training. the dimension of encoder states () is set to 300 and a 1024d mlp with one or two hidden layers is used. we apply dropout to the word embeddings and the mlp layers. the features used as input to the mlp classifier are extracted following eq. [reference]. table [reference] and [reference] contain results of the models on snli and multinli datasets. in snli, our best model achieves the new state-of-the-art accuracy of 87.0% with relatively fewer parameters. similarly in multinli, our models match the accuracy of state-of-the-art models in both in-domain (matched) and cross-domain (mismatched) test sets. note that only the glove word vectors are used as word representations, as opposed to some models that introduce character-level features. it is also notable that our proposed architecture does not restrict the selection of pooling method; the performance could further be improved by replacing max-pooling with other advanced algorithms e.g. intra-sentence attention and generalized pooling. subsection: paraphrase identification we use quora question pairs dataset in evaluating the performance of our method on the pi task. the dataset consists of over 400k question pairs, and each pair is annotated with whether the two sentences are paraphrase of each other or not. similar to the nli experiments, glove pretrained vectors, 300d encoders, and 1024d mlp are used. the number of cas-lstm layers is fixed to 2 in pi experiments. two sentence vectors are aggregated using eq. [reference] and fed as input to the mlp. the results on the quora question pairs dataset are summarized in table [reference]. again we can see that our models outperform other models by large margin, achieving the new state of the art. 0.22 0.22 0.22 0.22 0.22 0.22 subsection: sentiment classification in evaluating sentiment classification performance, the stanford sentiment treebank (sst) is used. it consists of about 12, 000 binary-parsed sentences where constituents (phrases) of each parse tree are annotated with a sentiment label (very positive, positive, neutral, negative, very negative). following the convention of prior work, all phrases and their labels are used in training but only the sentence-level data are used in evaluation. in evaluation we consider two settings, namely sst-2 and sst-5, the two differing only in their level of granularity with regard to labels. in sst-2, data samples annotated with 'neutral' are ignored from training and evaluation. the two positive labels (very positive, positive) are considered as the same label, and similarly for the two negative labels. as a result 98, 794/ 872/ 1, 821 data samples are used in training/ validation/ test, and the task is considered as a binary classification problem. in sst-5, data are used as-is and thus the task is a 5-class classification problem. all 318, 582/ 1, 101/ 2, 210 data samples for training/ validation/ test are used in the sst-5 setting. we use 300d glove vectors, 2-layer 150d or 300d encoders, and a 300d mlp classifier for the models, however unlike previous experiments we tune the word embeddings during training. the results on sst are listed in table [reference]. our models achieve the new state-of-the-art accuracy on sst-2 and competitive accuracy on sst-5, without utilizing parse tree information. subsection: forget gate analysis to inspect the effect of the additional forget gate, we investigate how the values of vertical forget gates are distributed. we sample 1, 000 random sentences from the development set of the snli dataset, and use the 3-layer cas-lstm model trained on the snli dataset to compute gate values. if all values from a vertical forget gate were to be 0, this would mean that the introduction of the additional forget gate is meaningless and the model would reduce to a plain stacked lstm. on the contrary if all values were 1, meaning that the vertical forget gates were always open, it would be impossible to say that the information is modulated effectively. fig. [reference] and [reference] represent histograms of the vertical forget gate values from the second and the third layer. from the figures we can validate that the trained model does not fall into the degenerate case where vertical forget gates are ignored. also the figures show that the values are right-skewed, which we conjecture to be a result of focusing more on a strong interaction between adjacent layers. to further verify that the gate values are diverse enough within each time step, we compute the distribution of the range of values per time step,, where. we plot the histograms in fig. [reference] and [reference]. from the figure we see that a vertical forget gate controls the amount of information flow effectively, making the decision of retaining or discarding signals. finally, to investigate the argument presented in\u00a7 [reference] that the additional forget gate helps the previous output gate with reducing the burden of extracting all needed information, we inspect the distribution of the values from. this distribution indicates how differently the vertical forget gate and the previous output gate select information from. from fig. [reference] and [reference] we can see that the two gates make fairly different decisions, from which we demonstrate that the direct path between and enables a model to utilize signals overlooked by. subsection: model variations in this subsection, we see the influence of each component of a model on performance by removing or replacing its components. the snli dataset is used for experiments, and the best performing configuration is used as a baseline for modifications. we consider the following variants: (i) models that use plain stacked lstms, (ii) models with different, (iii) models without, and (iv) models that integrate lower contexts via peephole connections. variant (iv) integrates lower contexts via the following equations: where represent peephole weights that take cell states into account. among the above equations, those that use the lower cell state are eq. [reference] and [reference]. we can see that affects the value of only via peephole connections, which makes independent of. table [reference] summarizes the results of model variants. we can again see that the use of cell states clearly improves sentence modeling performance (baseline vs. (i) and (iv) vs. (i)). also from the results of baseline and (ii), we validate that the selection of does not significantly affect performance but introducing is beneficial (baseline vs. (iii)) possibly due to its effect on normalizing information from multiple sources, as mentioned in\u00a7 [reference]. finally, from the comparison between baseline and (iv), we show that the proposed way of combining the left and the lower contexts leads to better modeling of sentence representations than that of zhang2016highway zhang2016highway in encoding sentences. section: related work paragraph: stacked recurrent neural networks. there is some prior work on methods of stacking rnns beyond the plain stacked rnns. residual lstms add residual connections between the hidden states computed at each lstm layer, and shortcut-stacked lstms concatenate hidden states from all previous layers to make the backpropagation path short. in our method, the lower context is aggregated via a gating mechanism, and we believe it modulates the amount of information to be transmitted in a more efficient and effective way than vector addition or concatenation. also, compared to concatenation, our method does not significantly increase the number of parameters. highway lstms and depth-gated lstms are similar to our proposed models in that they use cell states from the previous layer, and they are successfully applied to the field of automatic speech recognition and language modeling. however in contrast to cas-lstm, where the additional forget gate aggregates the previous layer states, and thus contexts from the left and below participate in computation equitably, in highway lstms and depth-gated lstms the previous layer states are considered only through peephole connections. the comparison of our models and this architecture is presented in\u00a7 [reference]. paragraph: multidimensional recurrent neural networks. there is another line of research that aims to extend rnns to operate on multidimensional inputs. grid lstms are a general-dimensional lstm architecture that accepts sets of hidden and cell states as input and yields sets of states as output, in contrast to our architecture, which emits a single set of states. 2d and 3d grid lstms bring a performance gain on character-level language modeling and machine translation respectively. multidimensional rnns have a similar formulation as ours, except that they do not normalize cell states and weights for all columns (layers) are tied. however they are often employed to model multidimensional data such as images of handwritten text with rnns, rather than stacking rnn layers for modeling sequential data. paragraph: deep recurrent transitions. rather than stacking recurrent layers, some work focuses on increasing the depth of horizontal recurrence. pascanu2014construct pascanu2014construct have investigated various architectures to increase the depth of rnns, inter alia deep transition rnns address the problem of deep hidden-to-hidden transitions. graves2016adaptive graves2016adaptive proposed an adaptive computation time algorithm that learns how many micro time steps to take between receiving an input and emitting an output. fast-slow rnns process data on different timescales by letting a fast cell iterate for a fixed number of time steps before a slow cell receives the next input. multiscale rnns e.g. clockwork rnns and hierarchical multiscale rnns can be also regarded as architectures with increased recurrence depth. however as noted by zilly2017rhn zilly2017rhn, increase in recurrent depth results in a longer maximum path than stacking recurrent layers and makes training difficult without careful initialization or architectural choice. section: conclusion in this paper, we proposed a method of stacking multiple lstm layers for modeling sentences, dubbed cas-lstm. it uses not only hidden states but also cell states from the previous layer, for the purpose of controlling the vertical information flow in a more elaborate way. we evaluated the proposed method on various benchmark tasks: natural language inference, paraphrase identification, and sentiment classification. our models achieve the new state-of-the-art accuracy on snli and quora question pairs datasets and obtain comparable results on multinli and sst datasets. the proposed architecture can replace any stacked lstm under one weak restriction\u2014 the size of states should be identical across all layers. for future work we plan to apply the cas-lstm architecture beyond sentence modeling tasks. various problems e.g. sequence labeling, sequence generation, and language modeling might benefit from sophisticated modulation on context integration. aggregating diverse contexts from sequential data, e.g. those from forward and backward reading of text, could also be an intriguing research direction. section: acknowledgments we thank dan edmiston for the review of the manuscript. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "stanford sentiment treebank"
                    ],
                    [
                        "sst"
                    ]
                ],
                "Method": [
                    [
                        "cell aware stacked lstms"
                    ],
                    [
                        "cell aware stacked lstm"
                    ],
                    [
                        "cas lstm"
                    ],
                    [
                        "cell aware stacked lstm"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "modeling sentences"
                    ],
                    [
                        "natural language inference"
                    ],
                    [
                        "5 class classification problem"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "quora question pairs",
                        "quora question pairs datasets"
                    ]
                ],
                "Method": [
                    [
                        "bidirectional cas-lstm network"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "paraphrase identification",
                        "pi",
                        "pi tasks",
                        "pi task"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "snli",
                        "snli dataset"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": [
                    [
                        "natural language inference",
                        "nli",
                        "nli task"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "sst",
                        "sst datasets",
                        "sst-2"
                    ]
                ],
                "Method": [
                    [
                        "bidirectional cas-lstm network"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "sentiment classification"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "sst datasets",
                        "sst-5"
                    ]
                ],
                "Method": [
                    [
                        "bidirectional cas-lstm network"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "sentiment classification"
                    ]
                ]
            }
        ]
    },
    "25a784f7f8c94c42821ee078587fc38dffcd00a4-35": {
        "doctext": "document: robust face detection via learning small faces on hard images recent anchor-based deep face detectors have achieved promising performance, but they are still struggling to detect hard faces, such as small, blurred and partially occluded faces. a reason is that they treat all images and faces equally, without putting more effort on hard ones; however, many training images only contain easy faces, which are less helpful to achieve better performance on hard images. in this paper, we propose that the robustness of a face detector against hard faces can be improved by learning small faces on hard images. our intuitions are (1) hard images are the images which contain at least one hard face, thus they facilitate training robust face detectors; (2) most hard faces are small faces and other types of hard faces can be easily converted to small faces by shrinking. we build an anchor-based deep face detector, which only output a single feature map with small anchors, to specifically learn small faces and train it by a novel hard image mining strategy. extensive experiments have been conducted on wider face, fddb, pascal faces, and afw datasets to show the effectiveness of our method. our method achieves aps of 95.7, 94.9 and 89.7 on easy, medium and hard wider face val dataset respectively, which surpass the previous state-of-the-arts, especially on the hard subset. code and model are available at. section: introduction face detection is a fundamental and important computer vision problem, which is critical for many face-related tasks, such as face alignment, tracking and recognition. stem from the recent successful development of deep neural networks, massive cnn-based face detection approaches have been proposed and achieved the state-of-the-art performance. however, face detection remains a challenging task due to occlusion, illumination, makeup, as well as pose and scale variance, as shown in the benchmark dataset wider face. current state-of-the-art cnn-based face detectors attempt to address these challenges by employing more powerful backbone models, exploiting feature pyramid-style architectures to combine features from multiple detection feature maps, designing denser anchors and utilizing larger contextual information. these methods and techniques have been shown to be successful to build a robust face detector, and improve the performance towards human-level for most images. in spite of their success for most images, an evident performance gap still exists especially for those hard images which contain small, blurred and partially occluded faces. we realize that these hard images have become the main barriers for face detectors to achieve human-level detection performance. in figure [reference], we show that, even on the train set of wider face, the official pre-trained ssh still fails on some of the images with extremely hard faces. we show two such hard training images in the upper right corner in figure [reference]. on the other hand, most training images with easy faces can be almost perfectly detected (see the illustration in the right lower corner of figure [reference]). as shown in left part of figure [reference], over two thirds of the training images already obtained perfect detection accuracy, which indicates that those easy images are less useful towards training a robust face detector. to address this issue, in this paper, we propose a robust face detector by putting more training focus on those hard images. this issue is most related to anchor-level hard example mining discussed in ohem. however, due to the sparsity of ground-truth faces and positive anchors, traditional anchor-level hard example mining mainly focuses on mining hard negative anchors, and mining hard anchors on well-detected images exhibits less effectiveness since there is no useful information that can be further exploited in these easy images. to address this issue, we propose to mine hard examples at image level in parallel with anchor level. more specifically, we propose to dynamically assign difficulty scores to training images during the learning process, which can determine whether an image is already well-detected or still useful for further training. this allows us to fully utilize the images which were not perfectly detected to better facilitate the following learning process. we show this strategy can make our detector more robust towards hard faces, without involving more complex network architecture and computation overhead. apart from mining the hard images, we also propose to improve the detection quality by exclusively exploiting small faces. small faces are typically hard and have attracted extensive research attention. existing methods aim at building a scale-invariant face detector to learn and infer on both small and big faces, with multiple levels of detection features and anchors of different sizes. compared with these methods, our detector is more efficient since it is specially designed to aggressively leveraging the small faces during training. more specifically, large faces are automatically ignored during training due to our anchor design, so that the model can fully focus on the small hard faces. additionally, experiments demonstrate that this design effectively achieves improvements on detecting all faces in spite of its simple and shallow architecture. to conclude, in this paper, we propose a novel face detector with the following contributions: we propose a hard image mining strategy, to improve the robustness of our detector to those extremely hard faces. this is done without any extra modules, parameters or computation overhead added on the existing detector. we design a single shot detector with only one detection feature map, which focuses on small faces with a specific range of sizes. this allows our model to be simple and focus on difficult small faces without struggling with scale variance. our face detector establishes state-of-the-art performance on all popular face detection datasets, including wider face, fddb, pascal faces, and afw. we achieve 95.7, 94.9 and 89.7 on easy, medium and hard wider face val dataset. our method also achieves aps of 99.00 and 99.60 on pascal faces and afw respectively, as well as a tpr of 98.7 on fddb. the remainder of this paper is organized as follows. in section [reference], we discuss some studies have been done which are related to our paper. in section [reference], we dive into details of our proposed method, and we discuss experiment results and ablation experiments in section [reference]. finally, conclusions are drawn in section [reference]. section: related work face detection has received extensive research attention. with the emergence of modern cnn and object detector, there are many face detectors proposed to achieve promising performances, by adapting general object detection framework into face detection domain. we briefly review hard example mining, face detection architecture, and anchor design& matching. subsection: hard example mining hard example mining is an important strategy to improve model quality, and has been studied extensively in image classification and general object detection. the main idea is to find some hard positive and hard negative examples at each step, and put more effort into training on those hard examples. recently, with modern detection frameworks proposed to boost the performance, ohem and focal loss have been proposed to select hard examples. ohem computed the gradients of the networks by selecting the proposals with highest losses in every minibatch; while focal loss aimed at naturally putting more focus on hard and misclassified examples by adding a factor to the standard cross entropy criterion. however, these algorithms mainly focused on anchor-level or proposal-level mining. it can not handle the imbalance of easy and hard images in the dataset. in our paper, we propose to exploit hard example mining on image level, hard image mining, to improve the quality of face detector on extremely hard faces. more specifically, we assign difficulty scores to training images while training with an sgd mechanism, and re-sample the training images to build a new training subset at the next epoch. subsection: face detection architecture recent state-of-the-art face detectors are generally built based on faster-rcnn, r-fcn or ssd. ssh exploited the rpn (region proposal network) from faster-rcnn to detect faces, by building three detection feature maps and designing six anchors with different sizes attached to the detection feature maps. s fd and pyramidbox, on the other hand, adopted ssd as their detection architecture with six different detection feature maps. different from s fd, pyramidbox exploited a feature pyramid-style structure to combine features from different detection feature maps. our proposed method, on the other hand, only builds single level detection feature map, based on vgg16, for classification and bounding-box regression, which is both simple and effective. subsection: anchor design and matching usually, anchors are designed to have different sizes to detect objects with different scales, in order to build a scale-invariant detector. ssd as well as its follow-up detectors s fd and pyramidbox, had six sets of anchors with different sizes, ranging from () to (), and their network architectures had six levels of detection feature maps, with resolutions ranging from to, respectively. similarly, ssh had the same anchor setting, and those anchors were attached to three levels of detection feature maps with resolutions ranging from to. the difference between ssh and s df is that in ssh, anchors with two neighboring sizes shared the same detection feature map, while in s df, anchors with different sizes are attached to different detection feature maps. snip discussed an alternative approach to handle scales. it showed that cnns are not robust to changes in scale, so training and testing on the same scales of an image pyramid can be a more optimal strategy. in our paper, we exploit this idea by limiting the anchor sizes to be (), () and (). then those faces with either too small or too big sizes will not be matched to any of the anchors, thus will be ignored during the training and testing. by removing those large anchors with sizes larger than (), our network focuses more on small faces which are potentially more difficult. to deal with large faces, we use multiscale training and testing to resize them to match our anchors. experiments show this design performs well on both small and big faces, although it has fewer detection feature maps and anchor sizes. section: proposed method in this section, we introduce our proposed method for effective face detection. we first discuss the architecture of our detector in section [reference], then we elaborate our hard image mining strategy in section [reference], as well as some other useful training techniques in section [reference]. subsection: single-level small face detection framework the framework of our face detector is illustrated in figure [reference]. we use vgg16 network as our backbone cnn, and combine conv4_3 and conv5_3 features, to build the detection feature map with both low-level and high-level semantic information. similar to ssh, we apply 1 1 convolution layers after conv4_3 and conv5_3 to reduce dimension, and then apply a 3 3 convolution layer on the concatenation of these two dimension reduced features. the output feature of the 3 3 convolution layer is the final detection feature map, which will be fed into the detection head for classification and bounding-box regression. the detection feature map has a resolution of of the original image (of size). we attach three anchors at each point in the grid as default face detection boxes. then we do classification and bounding-box regression on those anchors. unlike many other face detectors which build multiple feature maps to detect face with a variant range of scales, inspired by snip, faces are trained and inferred with roughly the same scales. we only have one detection feature map, with three sets of anchors attached to it. the anchors have sizes of (), () and (), and the aspect ratio is set to be 1. by making this configuration, our network only trains and infers on small and medium size of faces; and we propose to handle large faces by shrinking the images in the test phase. we argue that there is no speed or accuracy degradation for large faces, since inferring on a tiny image (with short side containing 100 or 300 pixels) is very fast, and the shrinked large face will still have enough information to be recognized. to handle the difference of anchor sizes attached to the same detection feature map, we propose a detection head which uses different dilation rates for anchors with different sizes, as shown in figure [reference]. the intuition is that in order to detect faces with different sizes, different effective receptive fields are required. this naturally requires the backbone feature map to be invariant to scales. to this end, we adopt different dilation rates for anchors with different sizes. for anchors with size (), () and (), we use a convolution with kernel size of and dilation rate of, and to gather context features at different scales. these three convolution layers share weights to reduce the model size. with this design, the input of the convolution, will be aligned to the same location of faces, regardless of the size of faces and anchors. ablation experiments show the effectiveness of this multi-dilation design. subsection: hard image mining different from ohem discussed in section [reference], which selects proposals or anchors with the highest losses, we propose a novel hard image mining strategy at image level. the intuition is that most images in the dataset are very easy, and we can achieve a very high ap even on the hard subset of the wider face val dataset with our baseline model. we believe not all training images should be treated equally, and well-recognized images will not help towards training a more robust face detector. to put more attention on training hard images instead of easy ones, we use a subset of all training images, to contain hard ones for training. at the beginning of each epoch, we build based on the difficulty scores obtained in the previous epoch. we initially use all training images to train our model (). this is due to the fact that our initial imagenet pre-trained model will only give random guess towards face detection. in this case, there is no easy image. in other words, every image is considered as hard image and fed to the network for training at the first epoch. during the training procedure, we dynamically assign different difficulty scores to training images, which is defined by the metric worst positive anchor score (wpas): where is the set of positive anchors for image, with iou over 0.5 against ground-truth boxes, is the classification logit and, are the logits of anchor for image to be foreground face and background. all images are initially marked as hard, and any image with wpas greater than a threshold will be marked as easy image. at the beginning of each epoch, we first randomly shuffle the training dataset to generate the complete training list for the following epoch of training. then given an image marked as easy, we remove it from with a probability of. the remaining training list, which focuses more on hard images, will be used for training at this epoch. note that for multi-gpu training, each gpu will maintain its training list independently. in our experiments, we set the probability to be 0.7, and the threshold to be 0.85. subsection: training strategy subsubsection: multi-scale training and anchor matching since we only have anchors covering a limited range of face scales, we train our model by varying the sizes of training images. during the training phase, we resize the training images so that the short side of the image contains pixels, where is randomly selected from. we also set an upper bound of 2000 pixels to the long side of the image considering the gpu memory limitation. for each anchor, we assign a label based on how well it matches with any ground-truth face bounding box. if an anchor has an iou (intersection over union) over 0.5 against a ground-truth face bounding box, we assign to that anchor. on the other hand, if the iou against any ground-truth face bounding box is lower than 0.3, we assign to that anchor. all other anchors will be given as the label, and thus will be ignored in the classification loss. by doing so, we only train on faces with designated scales. those faces with no anchor matching will be simply ignored, since we do not assign the anchor with largest iou to it (thus assign the corresponding anchor label) as faster-rcnn does. this anchor matching strategy will ignore the large faces, and our model can put more capacity on learning different face patterns on hard small faces instead of memorizing the change in scales. for the regression loss, all anchors with iou greater than 0.3 against ground-truth faces will be taken into account and contribute to the smooth loss. we use a smaller threshold (0.3) because (1) this will allow imperfectly matched anchors to be able to localize the face, which may be useful during the testing and (2) the regression task has less supervision since unlike classification, there are no negative anchors for computing loss and the positive anchors are usually sparse. subsubsection: anchor-level hard example mining ohem has been proven to be useful for object detection and face detection in. during our training, in parallel with our newly proposed hard image mining, we also exploit the traditional hard anchor mining method to focus more on the hard and misclassificed anchors. given a training image with size, there are anchors at the detection head, and we only select 256 of them to be involved in computing the classification loss. for all positive anchors with iou greater than against ground-truth boxes, we select the top 64 of them with lowest confidences to be recognized as face. after selecting positive anchors, () negative anchors with highest face confidence are selected to compute the classification loss as the hard negative anchors. note that we only perform ohem for classification loss, and we keep all anchors with iou greater than 0.3 for computing regression loss, without selecting a subset based on either classification loss or bounding-box regression loss. subsubsection: data augmentation data augmentation is extremely useful to make the model robust to light, scale changes and small shifts. in our proposed method, we exploit cropping and photometric distortion as data augmentation. given a training image after resizing, we crop a patch of it with a probability of. the patch has a height of and a width of which are independently drawn from and, where is the uniform distribution and, are the height and width of the resized training image. all ground-truth boxes whose centers are located inside the patch are kept. after the random cropping, we apply photometric distortion following ssd by randomly modifying the brightness, contrast, saturation and hue of the cropped image randomly. [b] 0.33 easy subset [b] 0.33 medium subset [b] 0.33 hard subset [b] 0.33 [b] 0.33 [b] 0.33 section: experiments to verify the effectiveness of our model and proposed method, we conduct extensive experiments on popular face detection datasets, including wider face, fddb, pascal faces and afw. it is worth noting that the training is only performed on the train set of wider face, and we use the same model for evaluation on all these datasets without further fine-tuning. subsection: experimental settings we train our model on the train set of wider face, which has 12880 images with 159k faces annotated. we flip all images horizontally, to double the size of our training dataset to 25760. for each training image, we first randomly resize it, and then we use the cropping and photometric distortion data augmentation methods discussed in section [reference] to pre-process the resized image. we use an imagenet pre-trained vgg16 model to initialize our network backbone, and our newly introduced layers are randomly initialized with gaussian initialization. we train the model with the itersize to be 2, for 46k iterations, with a learning rate of, and then for another 14k iterations with a smaller learning rate of. during training, we use 4 gpus to simultaneously to compute the gradient and update the weight by synchronized sgd with momentum. the first two blocks of vgg16 are frozen during the training, and the rest layers of vgg16 are set to have a double learning rate. since our model is designed and trained on only small faces, we use a multiscale image pyramid for testing to deal with faces larger than our anchors. specifically, we resize the testing image so that the short side contains 100, 300, 600, 1000 and 1400 pixels for evaluation on wider face dataset. we also follow the testing strategies used in pyramidbox such as horizontal flip and bounding-box voting. subsection: experiment results wider face dataset includes 3226 images and 39708 faces labelled in the val dataset, with three subsets- easy, medium and hard. in figure [reference], we show the precision-recall (pr) curve and average precision (ap) for our model compared with many other state-of-the-arts on these three subsets. as we can see, our method achieves the best performance on the hard subset, and outperforms the current state-of-the-art by a large margin. since the hard set is a super set of small and medium, which contains all faces taller than 10 pixels, the performance on hard set can represent the performance on the full testing dataset more accurately. our performance on the medium subset is comparable to the most recent state-of-the-art and the performance on the easy subset is a bit worse since our method focuses on learning hard faces, and the architecture of our model is simpler compared with other state-of-the-arts. there is also a wider face test dataset with no annotations provided publicly. it contains 16097 images, and is evaluated by wider face author team. we report the performance of our method at figure [reference] for the hard subset. fddb dataset includes 5171 faces on a set of 2845 images, and we use our model trained on wider face train set to infer on the fddb dataset. we use the raw bounding-box result without fitting it into ellipse to compute roc. we show the discontinuous roc curve at figure [reference] compared with, and our method achieves the state-of-the-art performance of tpr=98.7% given 1000 false positives. pascal faces dataset includes 1335 labeled faces on a set of 851 images extracted for the pascal voc dataset. we show the pr curve at figure [reference] compared with, and our method achieves a new the state-of-the-art performance of ap=99.0. afw dataset includes 473 faces labelled in a set of 205 images. as shown in figure [reference] compared with, our method achieves state-of-the-art and almost perfect performance, with an ap of 99.60. subsection: ablation study and diagnosis subsubsection: ablation experiments in order to verify the performance of our single level face detector, as well as the effectiveness of our proposed hard image mining, the dilated-head classification and regression structure, we conduct various ablation experiments on the wider face val dataset. all results are summarized in table [reference]. from table [reference], we can see that our single level baseline model can achieve performance comparable to the current state-of-the-art face detector, especially on the hard subset. our model with single detection feature map performs better than the one with three detection feature maps, despite its shallower structure, fewer parameters and anchors. this confirms the effectiveness of our simple face detector with single detection feature map focusing on small faces. we also separately verify our newly proposed hard image mining (him) and dilated head architecture (dh) described in subsection [reference] and figure [reference] respectively. him can improve the performance on hard subset significantly without involving more complex network architecture nor computation overhead. dh itself can also boost the performance, which shows the effectiveness of designing larger convolution for larger anchors. combining him and dh together can improve further towards the state-of-the-art performance. subsubsection: diagnosis of hard image mining we investigate the effects of our hard image mining mechanism. we show the ratio of and (the ratio of the number of selected training images to the number of ignored training images) in figure [reference] for each epoch. we can see that at the first epoch, all training images are used to train the model. meanwhile, as the training process continues, more and more training images will be ignored. at the last epoch, over a half images will be ignored and thus will not be included in. subsubsection: diagnosis of data augmentation we investigate the effectiveness of the photometric distortion as well as the cropping mechanisms as discussed in subsection [reference]. the ablation results evaluated on wider face val dataset are shown in table [reference]. both photometric distortion and cropping can contribute to a more robust face detector. subsubsection: diagnosis of multi-scale testing our face detector with one detection feature map is design for small face detection, and our anchors are only capable of capturing faces with sizes ranging from () to (). as a result, it is critical to adopt multi-scale testing to deal with large faces. different from ssh, s fd and pyramidbox, our testing pyramid includes some extreme small scales (short side contains only 100 or 300 pixels). in table [reference], we show the effectiveness of these extreme small scales to deal with easy and large images. our full evaluation resizes the image so that the short side contains 100, 300, 600, 1000 and 1400 pixels respectively, to build an image pyramid. we diagnose the impact of the extra small scales (100 and 300) by removing them from the image pyramid. as shown in table [reference], the extra small scales are crucial to detect easy faces. without resizing the short side to contain 100 and 300 pixels, the performance on easy subset is only, which is even lower than the performance on medium and hard which contain much harder faces. we will show in the next subsection that these extra small scales (and) lead to negligible computation overhead, due to the lower resolution. subsubsection: diagnosis of accuracy/ speed trade-off we evaluate the speed of our method as well as some other popular face detectors in table [reference]. for fair comparison, we run all methods on the same machine, with one titan x (maxwell) gpu, and intel core i7-4770 k 3.50ghz. all methods except for pyramidbox are based on caffe1 implementation, which is compiled with cuda 9.0 and cudnn 7. for pyramidbox, we follow the official fluid code and the default configurations. we use the officially built paddlepaddle with cuda 9.0 and cudnn 7. for ssh, s fd and pyramid, we use the official inference code and configurations. for ssh, we use multi-scale testing with the short side containing 500, 800, 1200 and 1600 pixels, and for s fd, we execute the official evaluation code with both multi-scale testing and horizontal flip. pyramidbox takes a similar testing configuration as s fd. as shown in table [reference], our detector can outperform ssh, s fd and pyramidbox significantly with a smaller inference time. based on that, using horizontal flip can further improve the performance slightly. in terms of gpu memory usage, our method uses only a half of what pyramidbox occupies, while achieving better performance. ours in table [reference] indicates our method without extra small scales in inference,, evaluated with scales [600, 1000, 1400]. it is only faster than evaluation with [100, 300, 600, 1000, 1400] (1.59 compared with 1.70). this proves that although our face detector is only trained on small faces, it can perform well on large faces, by simply shrinking the testing image with negligible computation overhead. section: conclusion to conclude, we propose a novel face detector to focus on learning small faces on hard images, which achieves the state-of-the-art performance on all popular face detection datasets. we propose a hard image mining strategy by dynamically assigning difficulty scores to training images, and re-sampling subsets with hard images for training before each epoch. we also design a single shot face detector with only one detection feature map, to train and test on small faces. with these designs, our model can put more attention on learning small hard faces instead of memorizing change of scales. extensive experiments and ablations have been done to show the effectiveness of our method, and our face detector achieves the state-of-the-art performance on all popular face detection datasets, including wider face, fddb, pascal faces and afw. our face detector also enjoys faster multi-scale inference speed and less gpu memory usage. our proposed method are flexible and can be applied to other backbones and tasks, which we remain as future work. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "wider face"
                    ],
                    [
                        "wider face fddb"
                    ],
                    [
                        "wider face fddb pascal faces"
                    ],
                    [
                        "fddb"
                    ],
                    [
                        "fddb pascal faces"
                    ],
                    [
                        "pascal faces"
                    ],
                    [
                        "afw"
                    ],
                    [
                        "afw datasets"
                    ],
                    [
                        "wider face val dataset"
                    ],
                    [
                        "wider face test dataset"
                    ],
                    [
                        "pascal faces"
                    ],
                    [
                        "labeled faces"
                    ],
                    [
                        "wider face fddb pascal faces"
                    ]
                ],
                "Method": [
                    [
                        "anchor based deep face detectors"
                    ]
                ],
                "Metric": [
                    [
                        "aps"
                    ],
                    [
                        "aps"
                    ],
                    [
                        "average precision"
                    ],
                    [
                        "ap"
                    ]
                ],
                "Task": [
                    [
                        "robust face detection"
                    ],
                    [
                        "face detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "robust face detector"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "afw"
                    ]
                ],
                "Method": [
                    [
                        "anchor-based deep face detectors",
                        "anchor-based deep face detector",
                        "anchor design",
                        "anchors"
                    ]
                ],
                "Metric": [
                    [
                        "aps",
                        "ap",
                        "average precision",
                        "false positives",
                        "ap=99.0",
                        "accuracy/ speed trade-off",
                        "multi-scale inference speed"
                    ]
                ],
                "Task": [
                    [
                        "robust face detection",
                        "face detection",
                        "face detectors",
                        "human-level detection",
                        "face detection domain",
                        "face detector",
                        "effective face detection",
                        "small face detection"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "fddb"
                    ]
                ],
                "Method": [
                    [
                        "anchor-based deep face detectors",
                        "anchor-based deep face detector",
                        "anchor design",
                        "anchors"
                    ]
                ],
                "Metric": [
                    [
                        "aps",
                        "ap",
                        "average precision",
                        "false positives",
                        "ap=99.0",
                        "accuracy/ speed trade-off",
                        "multi-scale inference speed"
                    ]
                ],
                "Task": [
                    [
                        "robust face detection",
                        "face detection",
                        "face detectors",
                        "human-level detection",
                        "face detection domain",
                        "face detector",
                        "effective face detection",
                        "small face detection"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "pascal faces",
                        "face val dataset",
                        "pascal voc dataset"
                    ]
                ],
                "Method": [
                    [
                        "anchor-based deep face detectors",
                        "anchor-based deep face detector",
                        "anchor design",
                        "anchors"
                    ]
                ],
                "Metric": [
                    [
                        "aps",
                        "ap",
                        "average precision",
                        "false positives",
                        "ap=99.0",
                        "accuracy/ speed trade-off",
                        "multi-scale inference speed"
                    ]
                ],
                "Task": [
                    [
                        "robust face detection",
                        "face detection",
                        "face detectors",
                        "human-level detection",
                        "face detection domain",
                        "face detector",
                        "effective face detection",
                        "small face detection"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "hard images",
                        "wider face",
                        "benchmark dataset wider face",
                        "wider face val dataset",
                        "wider face dataset",
                        "hard set",
                        "wider face test dataset",
                        "wider face author team",
                        "wider face train set",
                        "hard subset"
                    ]
                ],
                "Method": [
                    [
                        "anchor-based deep face detectors",
                        "anchor-based deep face detector",
                        "anchor design",
                        "anchors"
                    ]
                ],
                "Metric": [
                    [
                        "aps",
                        "ap",
                        "average precision",
                        "false positives",
                        "ap=99.0",
                        "accuracy/ speed trade-off",
                        "multi-scale inference speed"
                    ]
                ],
                "Task": [
                    [
                        "robust face detection",
                        "face detection",
                        "face detectors",
                        "human-level detection",
                        "face detection domain",
                        "face detector",
                        "effective face detection",
                        "small face detection"
                    ]
                ]
            }
        ]
    },
    "25f5df29342a04936ba0d308b4d1b8245a7e8f5c-36": {
        "doctext": "convolutional pose machines section: abstract pose machines provide a sequential prediction framework for learning rich implicit spatial models. in this work we show a systematic design for how convolutional networks can be incorporated into the pose machine framework for learning image features and image-dependent spatial models for the task of pose estimation. the contribution of this paper is to implicitly model long-range dependencies between variables in structured prediction tasks such as articulated pose estimation. we achieve this by designing a sequential architecture composed of convolutional networks that directly operate on belief maps from previous stages, producing increasingly refined estimates for part locations, without the need for explicit graphical model-style inference. our approach addresses the characteristic difficulty of vanishing gradients during training by providing a natural learning objective function that enforces intermediate supervision, thereby replenishing back-propagated gradients and conditioning the learning procedure. we demonstrate state-of-the-art performance and outperform competing methods on standard benchmarks including the mpii, lsp, and flic datasets. section: introduction we introduce convolutional pose machines (cpms) for the task of articulated pose estimation. cpms inherit the benefits of the pose machine [reference] architecture-the implicit learning of long-range dependencies between image and multi-part cues, tight integration between learning and inference, a modular sequential design-and combine them with the advantages afforded by convolutional architectures: the ability to learn feature representations for both image and spatial context directly from data; a differentiable architecture that allows for globally joint training with backpropagation; and the ability to efficiently handle large training datasets. cpms consist of a sequence of convolutional networks that repeatedly produce 2d belief maps [reference] for the location [reference] we use the term belief in a slightly loose sense, however the belief of each part. at each stage in a cpm, image features and the belief maps produced by the previous stage are used as input. the belief maps provide the subsequent stage an expressive non-parametric encoding of the spatial uncertainty of location for each part, allowing the cpm to learn rich image-dependent spatial models of the relationships between parts. instead of explicitly parsing such belief maps either using graphical models [reference][reference][reference] or specialized post-processing steps [reference][reference], we learn convolutional networks that directly operate on intermediate belief maps and learn implicit image-dependent spatial models of the relationships between parts. the overall proposed multistage architecture is fully differentiable and therefore can be trained in an end-to-end fashion using backpropagation. at a particular stage in the cpm, the spatial context of part beliefs provide strong disambiguating cues to a subsequent stage. as a result, each stage of a cpm produces belief maps with increasingly refined estimates for the locations of each part (see figure 1). in order to capture longrange interactions between parts, the design of the network in each stage of our sequential prediction framework is motivated by the goal of achieving a large receptive field on both the image and the belief maps. we find, through experiments, that large receptive fields on the belief maps are crucial for learning long range spatial relationships and remaps described are closely related to beliefs produced in message passing inference in graphical models. the overall architecture can be viewed as an unrolled mean-field message passing inference algorithm [reference] that is learned end-to-end using backpropagation. sult in improved accuracy. composing multiple convolutional networks in a cpm results in an overall network with many layers that is at risk of the problem of vanishing gradients [reference][reference][reference][reference] during learning. this problem can occur because backpropagated gradients diminish in strength as they are propagated through the many layers of the network. while there exists recent work 2 which shows that supervising very deep networks at intermediate layers aids in learning [reference][reference], they have mostly been restricted to classification problems. in this work, we show how for a structured prediction problem such as pose estimation, cpms naturally suggest a systematic framework that replenishes gradients and guides the network to produce increasingly accurate belief maps by enforcing intermediate supervision periodically through the network. we also discuss different training schemes of such a sequential prediction architecture. our main contributions are (a) learning implicit spatial models via a sequential composition of convolutional architectures and (b) a systematic approach to designing and training such an architecture to learn both image features and image-dependent spatial models for structured prediction tasks, without the need for any graphical model style inference. we achieve state-of-the-art results on standard benchmarks including the mpii, lsp, and flic datasets, and analyze the effects of jointly training a multi-staged architecture with repeated intermediate supervision. section: related work the classical approach to articulated pose estimation is the pictorial structures model [reference][reference][reference][reference][reference][reference][reference][reference] in which spatial correlations between parts of the body are expressed as a tree-structured graphical model with kinematic priors that couple connected limbs. these methods have been successful on images where all the limbs of the person are visible, but are prone to characteristic errors such as double-counting image evidence, which occur because of correlations between variables that are not captured by a tree-structured model. the work of kiefel et al. [reference] is based on the pictorial structures model but differs in the underlying graph representation. hierarchical models [reference][reference] represent the relationships between parts at different scales and sizes in a hierarchical tree structure. the underlying assumption of these models is that larger parts (that correspond to full limbs instead of joints) can often have discriminative image structure that can be easier to detect and consequently help reason about the location of smaller, harder-to-detect parts. non-tree models [reference][reference][reference][reference][reference] incorporate interactions that introduce loops to augment the tree structure with additional edges that capture symmetry, occlusion and long-range relation-ships. these methods usually have to rely on approximate inference during both learning and at test time, and therefore have to trade off accurate modeling of spatial relationships with models that allow efficient inference, often with a simple parametric form to allow for fast inference. in contrast, methods based on a sequential prediction framework [reference] learn an implicit spatial model with potentially complex interactions between variables by directly training an inference procedure, as in [reference][reference][reference][reference]. there has been a recent surge of interest in models that employ convolutional architectures for the task of articulated pose estimation [reference][reference][reference][reference][reference][reference][reference]. toshev et al. [reference] take the approach of directly regressing the cartesian coordinates using a standard convolutional architecture [reference]. recent work regresses image to confidence maps, and resort to graphical models, which require hand-designed energy functions or heuristic initialization of spatial probability priors, to remove outliers on the regressed confidence maps. some of them also utilize a dedicated network module for precision refinement [reference][reference]. in this work, we show the regressed confidence maps are suitable to be inputted to further convolutional networks with large receptive fields to learn implicit spatial dependencies without the use of hand designed priors, and achieve state-of-the-art performance over all precision region without careful initialization and dedicated precision refinement. pfister et al. [reference] also used a network module with large receptive field to capture implicit spatial models. due to the differentiable nature of convolutions, our model can be globally trained, where tompson et al. [reference] and steward et al. [reference] also discussed the benefit of joint training. carreira et al. [reference] train a deep network that iteratively improves part detections using error feedback but use a cartesian representation as in [reference] which does not preserve spatial uncertainty and results in lower accuracy in the highprecision regime. in this work, we show how the sequential prediction framework takes advantage of the preserved uncertainty in the confidence maps to encode the rich spatial context, with enforcing the intermediate local supervisions to address the problem of vanishing gradients. section: method section: pose machines we denote the pixel location of the p-th anatomical landmark (which we refer to as a part), y p\u2208 z\u2282 r 2, where z is the set of all (u, v) locations in an image. our goal is to predict the image locations y= (y 1,..., y p) for all p parts. a pose machine [reference] (see figure 2a and 2b) consists of a sequence of multi-class predictors, g t (\u00b7), that are trained to predict the location of each part in each level of the hierarchy. in each stage t\u2208 {1... t}, the classifiers g t predict beliefs for assigning a location to each part y p= z,\u2200z\u2208 z, based on features extracted from the image at the location z denoted by x z\u2208 r d and contextual information from the preceding classifier in the neighbor-26\u21e5 26 60\u21e5 60 96\u21e5 96 160\u21e5 160 240\u21e5 240 320\u21e5 320 400\u21e5 400 hood around each y p in stage t. a classifier in the first stage t= 1, therefore produces the following belief values: where is the score predicted by the classifier g 1 for assigning the p th part in the first stage at image location z. we represent all the beliefs of part p evaluated at every location z= (u, v) t in the image as b p t\u2208 r w\u00d7h, where w and h are the width and height of the image, respectively. that is, b for convenience, we denote the collection of belief maps for all the parts as b t\u2208 r w\u00d7h\u00d7 (p+ 1) (p parts plus one for background). in subsequent stages, the classifier predicts a belief for assigning a location to each part y p= z,\u2200z\u2208 z, based on (1) features of the image data x t z\u2208 r d again, and (2) contextual information from the preceeding classifier in the neighborhood around each y p: where\u03c8 t>1 (\u00b7) is a mapping from the beliefs b t\u22121 to context features. in each stage, the computed beliefs provide an increasingly refined estimate for the location of each part. note that we allow image features x z for subsequent stage to be different from the image feature used in the first stage x. the pose machine proposed in [reference] used boosted random forests for prediction ({g t}), fixed hand-crafted image features across all stages (x= x), and fixed hand-crafted context feature maps (\u03c8 t (\u00b7)) to capture spatial context across all stages. section: convolutional pose machines we show how the prediction and image feature computation modules of a pose machine can be replaced by a deep convolutional architecture allowing for both image and contextual feature representations to be learned directly from data. convolutional architectures also have the advantage of being completely differentiable, thereby enabling endto-end joint training of all stages of a cpm. we describe our design for a cpm that combines the advantages of deep convolutional architectures with the implicit spatial modeling afforded by the pose machine framework. section: keypoint localization using local image evidence the first stage of a convolutional pose machine predicts part beliefs from only local image evidence. figure 2c shows the network structure used for part detection from local image evidence using a deep convolutional network. the evidence is local because the receptive field of the first stage of the network is constrained to a small patch around the output pixel location. we use a network structure composed of five convolutional layers followed by two 1\u00d7 1 convolutional layers which results in a fully convolutional archi-figure 3: spatial context from belief maps of easier-to-detect parts can provide strong cues for localizing difficult-to-detect parts. the spatial contexts from shoulder, neck and head can help eliminate wrong (red) and strengthen correct (green) estimations on the belief map of right elbow in the subsequent stages. tecture [reference]. in practice, to achieve certain precision, we normalize input cropped images to size 368\u00d7 368 (see section 4.2 for details), and the receptive field of the network shown above is 160\u00d7 160 pixels. the network can effectively be viewed as sliding a deep network across an image and regressing from the local image evidence in each 160\u00d7 160 image patch to a p+ 1 sized output vector that represents a score for each part at that image location. section: sequential prediction with learned spatial context features while the detection rate on landmarks with consistent appearance, such as the head and shoulders, can be favorable, the accuracies are often much lower for landmarks lower down the kinematic chain of the human skeleton due to their large variance in configuration and appearance. the landscape of the belief maps around a part location, albeit noisy, can, however, be very informative. illustrated in figure 3, when detecting challenging parts such as right elbow, the belief map for right shoulder with a sharp peak can be used as a strong cue. a predictor in subsequent stages (g t>1) can use the spatial context (\u03c8 t>1 (\u00b7)) of the noisy belief maps in a region around the image location z and improve its predictions by leveraging the fact that parts occur in consistent geometric configurations. in the second stage of a pose machine, the classifier g 2 accepts as input the image features x 2 z and features computed on the beliefs via the feature function\u03c8 for each of the parts in the previous stage. the feature function\u03c8 serves to encode the landscape of the belief maps from the previous stage in a spatial region around the location z of the different parts. for a convolutional pose machine, we do not have an explicit function that computes context features. instead, we define\u03c8 as being the receptive field of the predictor on the beliefs from the previous stage. the design of the network is guided by achieving a receptive field at the output layer of the second stage network that is large enough to allow the learning of potentially complex and long-range correlations between parts. by simply supplying features on the outputs of the previous stage (as opposed to specifying potential functions in a graphical model), the convolutional layers in the subsequent stage allow the classifier to freely combine contextual information by picking the most predictive features. the belief maps from the first stage are generated from a network that examined the image locally with a small receptive field. in the second stage, we design a network that drastically increases the equivalent receptive field. large receptive fields can be achieved either by pooling at the expense of precision, increasing the kernel size of the convolutional filters at the expense of increasing the number of parameters, or by increasing the number of convolutional layers at the risk of encountering vanishing gradients during training. our network design and corresponding receptive field for the subsequent stages (t\u2265 2) is shown in figure 2d. we choose to use multiple convolutional layers to achieve large receptive field on the 8\u00d7 downscaled heatmaps, as it allows us to be parsimonious with respect to the number of parameters of the model. we found that our stride-8 network performs as well as a stride-4 one even at high precision region, while it makes us easier to achieve larger receptive fields. we also repeat similar structure for image feature maps to make the spatial context be image-dependent and allow error correction, following the structure of pose machine. we find that accuracy improves with the size of the receptive field. in figure 4 we show the improvement in accuracy on the flic dataset [reference] as the size of the receptive field on the original image is varied by varying the architecture without significantly changing the number of parameters, through a series of experimental trials on input images normalized to a size of 304\u00d7 304. we see that the accuracy improves as the effective receptive field increases, and starts to saturate around 250 pixels, which also happens to be roughly the size of the normalized object. this improvement in accuracy with receptive field size suggests that the network does indeed encode long range interactions between parts and that doing so is beneficial. in our best performing setting in figure 2, we normalize cropped images into a larger size of 368\u00d7 368 pixels for better precision, and the receptive field of the second stage output on the belief maps of the first stage is set to 31\u00d7 31, which is equivalently 400\u00d7 400 pixels on the original image, where the radius can usually cover any pair of the parts. with more stages, the effective receptive field is even larger. in the following section we show our results from up to 6 stages. section: learning in convolutional pose machines the design described above for a pose machine results in a deep architecture that can have a large number of layers. training such a network with many layers can be prone to the problem of vanishing gradients [reference][reference][reference] where, as observed by bradley [reference] and bengio et al. [reference], the magnitude of back-propagated gradients decreases in strength with the number of intermediate layers between the output layer and the input layer. fortunately, the sequential prediction framework of the pose machine provides a natural approach to training our deep architecture that addresses this problem. each stage of the pose machine is trained to repeatedly produce the belief maps for the locations of each of the parts. we encourage the network to repeatedly arrive at such a representation by defining a loss function at the output of each stage t that minimizes the l 2 distance between the predicted and ideal belief maps for each part. the ideal belief map for a part p is written as b p* (y p= z), which are created by putting gaussian peaks at ground truth locations of each body part p. the cost function we aim to minimize at the output of each stage at each level is therefore given by: the overall objective for the full architecture is obtained by adding the losses at each stage and is given by: we use standard stochastic gradient descend to jointly train all the t stages in the network. to share the image feature x across all subsequent stages, we share the weights of corresponding convolutional layers (see figure 2) across stages t\u2265 2. section: evaluation section: analysis addressing vanishing gradients. the objective in equation 5 describes a decomposable loss function that operates on different parts of the network (see figure 2). specifically, each term in the summation is applied to the network after each stage t effectively enforcing supervision in intermediate stages through the network. intermediate supervision has the advantage that, even though the full architecture can have many layers, it does not fall prey to the vanishing gradient problem as the intermediate loss functions replenish the gradients at each stage. we verify this claim by observing histograms of gradient magnitude (see figure 5) at different depths in the architecture across training epochs for models with and without intermediate supervision. in early epochs, as we move from the output layer to the input layer, we observe on the model larger variance across all layers, suggesting that learning is indeed occurring in all the layers thanks to intermediate supervision. we also notice that as training progresses, the variance in the gradient magnitude distributions decreases pointing to model convergence. benefit of end-to-end learning. we see in figure 6a that replacing the modules of a pose machine with the appropriately designed convolutional architecture provides a large boost of 42.4 percentage points over the previous approach of [reference] in the high precision regime (pck@0.1) and 30.9 percentage points in the low precision regime (pck@0.2). comparison on training schemes. we compare different variants of training the network in figure 6b on the lsp dataset with person-centric (pc) annotations. to demonstrate the benefit of intermediate supervision with joint training across stages, we train the model in four ways: (i) training from scratch using a global loss function that enforces intermediate supervision (ii) stage-wise; where each stage is trained in a feed-forward fashion and stacked (iii) as same as (i) but initialized with weights from (ii), and (iv) as same as (i) but with no intermediate supervision. we find that network (i) outperforms all other training methods, showing that intermediate supervision and joint training across stage is indeed crucial in achieving good performance. the stagewise training in (ii) saturate at suboptimal, and the jointly fine-tuning in (iii) improves from this sub-optimal to the accuracy level closed to (i), however with effectively longer training iterations. performance across stages. we show a comparison of performance across each stage on the lsp dataset (pc) in figure 6c. we show that the performance increases monotonically until 5 stages, as the predictors in subsequent stages make use of contextual information in a large receptive field on the previous stage beliefs maps to resolve confusions between parts and background. we see diminishing returns at the 6th stage, which is the number we choose for reporting our best results in this paper for lsp and mpii datasets. section: datasets and quantitative analysis in this section we present our numerical results in various standard benchmarks including the mpii, lsp, and flic datasets. to have normalized input samples of 368\u00d7 368 for training, we first resize the images to roughly make the samples into the same scale, and then crop or pad the image according to the center positions and rough scale estimations provided in the datasets if available. in datasets such as lsp without these information, we estimate them according to joint positions or image sizes. for testing, we perform similar resizing and cropping (or padding), but estimate center position and scale only from image sizes when necessary. in addition, we merge the belief maps from different scales (perturbed around the given one) for final predictions, to handle the inaccuracy of the given scale estimation. we define and implement our model using the caffe [13] libraries for deep learning. we publicly release the source code and details on the architecture, learning parameters, design decisions and data augmentation to ensure full reproducibility. [reference] mpii human pose dataset. we show in figure 8 our results on the mpii human pose dataset [reference] which consists more than 28000 training samples. we choose to randomly augment the data with rotation degrees in [\u221240\u2022, 40\u2022], scaling with factors in [0.7, 1.3], and horizonal flipping. the evaluation is based on pckh metric [reference] where the error tolerance is normalized with respect to head size of the target. because there often are multiple people in the proximity of the interested person (rough center position is given in the dataset), we made two sets of ideal belief maps for training: one includes all the peaks for every person appearing in the proximity of the primary subject and the second type where we only place peaks for the primary subject. we supply the first set of belief maps to the loss layers in the first stage as the initial stage only relies on local image evidence to make predictions. we supply the second type of belief maps to the wrists elbows (a) (b) loss layers of all subsequent stages. we also find that supplying to all subsequent stages an additional heat-map with a gaussian peak indicating center of the primary subject is beneficial. our total pckh-0.5 score achieves state of the art at 87.95% (88.52% when adding lsp training data), which is 6.11% higher than the closest competitor, and it is noteworthy that on the ankle (the most challenging part), our pckh-0.5 score is 78.28% (79.41% when adding lsp training data), which is 10.76% higher than the closest competitor. this result shows the capability of our model to capture long distance context given ankles are the farthest parts from head and other more recognizable parts. figure 11 shows our accuracy is also consistently significantly higher than other methods across various view angles defined in [reference], especially in those challenging non-frontal views. in summary, our method improves the accuracy in all parts, over all precisions, across all view angles, and is the first one achieving such high accuracy without any pre-training from other data, or post-inference parsing with hand-design priors or initialization of such a structured prediction task as in [reference][reference]. our methods also does not need another module dedicated to location refinement as in [reference] to achieve great high-precision accuracy with a stride-8 network. leeds sports pose (lsp) dataset. we evaluate our method on the extended leeds sports dataset [reference] that consists of 11000 images for training and 1000 images for testing. we trained on person-centric (pc) annotations and evaluate our method using the percentage correct keypoints (pck) metric [reference]. using the same augmentation scheme as for the mpi dataset, our model again achieves state of the art at 84.32% (90.5% when adding mpii train-mpii flic lsp figure 10: qualitative results of our method on the mpii, lsp and flic datasets respectively. we see that the method is able to handle non-standard poses and resolve ambiguities between symmetric parts for a variety of different relative camera views. ing data). note that adding mpii data here significantly boosts our performance, due to its labeling quality being much better than lsp. because of the noisy label in the lsp dataset, pishchulin et al. [reference] reproduced the dataset with original high resolution images and better labeling quality. flic dataset. we evaluate our method on the flic dataset [reference] which consists of 3987 images for training and 1016 images for testing. we report accuracy as per the metric introduced in sapp et al. [reference] for the elbow and wrist joints in figure 12. again, we outperform all prior art at pck@0.2 with 97.59% on elbows and 95.03% on wrists. in higher precision region our advantage is even more significant: 14.8 percentage points on wrists and 12.7 percentage points on elbows at pck@0.05, and 8.9 percentage points on wrists and 9.3 percentage points on elbows at pck@0.1. section: discussion convolutional pose machines provide an end-to-end architecture for tackling structured prediction problems in computer vision without the need for graphical-model style inference. we showed that a sequential architecture composed of convolutional networks is capable of implicitly learning a spatial models for pose by communicating increasingly refined uncertainty-preserving beliefs between stages. problems with spatial dependencies between variables arise in multiple domains of computer vision such as semantic image labeling, single image depth prediction and object detection and future work will involve extending our architecture to these problems. our approach achieves state of the art accuracy on all primary benchmarks, however we do observe failure cases mainly when multiple people are in close proximity. handling multiple people in a single end-to-end architecture is also a challenging problem and an interesting avenue for future work. section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "mpii"
                    ],
                    [
                        "mpii lsp"
                    ],
                    [
                        "flic datasets"
                    ],
                    [
                        "flic dataset"
                    ],
                    [
                        "lsp dataset"
                    ],
                    [
                        "mpii datasets"
                    ],
                    [
                        "flic"
                    ],
                    [
                        "flic datasets"
                    ],
                    [
                        "mpii human pose dataset"
                    ],
                    [
                        "mpii human pose dataset"
                    ]
                ],
                "Method": [
                    [
                        "convolutional pose machines"
                    ],
                    [
                        "pose machines"
                    ],
                    [
                        "convolutional pose machines"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ],
                    [
                        "percentage correct keypoints"
                    ],
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "pose estimation"
                    ],
                    [
                        "articulated pose estimation"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "flic datasets",
                        "flic"
                    ]
                ],
                "Method": [
                    [
                        "convolutional pose machines",
                        "pose machines",
                        "cpms",
                        "pose machine",
                        "cpm",
                        "convolutional pose machine"
                    ]
                ],
                "Metric": [
                    [
                        "pck@0.2"
                    ]
                ],
                "Task": [
                    [
                        "pose estimation"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "lsp",
                        "lsp dataset",
                        "lsp training data",
                        "leeds sports pose",
                        "extended leeds sports dataset"
                    ]
                ],
                "Method": [
                    [
                        "convolutional pose machines",
                        "pose machines",
                        "cpms",
                        "pose machine",
                        "cpm",
                        "convolutional pose machine"
                    ]
                ],
                "Metric": [
                    [
                        "high precision regime",
                        "pck@0.1",
                        "low precision regime",
                        "percentage correct keypoints",
                        "pck",
                        "pck@0.05"
                    ]
                ],
                "Task": [
                    [
                        "pose estimation"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "mpii",
                        "mpii datasets",
                        "mpi dataset"
                    ]
                ],
                "Method": [
                    [
                        "convolutional pose machines",
                        "pose machines",
                        "cpms",
                        "pose machine",
                        "cpm",
                        "convolutional pose machine"
                    ]
                ],
                "Metric": [
                    [
                        "pckh-0.5 score"
                    ]
                ],
                "Task": [
                    [
                        "pose estimation"
                    ]
                ]
            }
        ]
    },
    "269730dbbabed8b8b5ba720e44a4c31b1f51e8f1-37": {
        "doctext": "published as a conference paper at iclr 2017 query-reduction networks for question answering section: abstract in this paper, we study the problem of question answering when reasoning over multiple facts is required. we propose query-reduction network (qrn), a variant of recurrent neural network (rnn) that effectively handles both short-term (local) and long-term (global) sequential dependencies to reason over multiple facts. qrn considers the context sentences as a sequence of state-changing triggers, and reduces the original query to a more informed query as it observes each trigger (context sentence) through time. our experiments show that qrn produces the state-of-the-art results in babi qa and dialog tasks, and in a real goal-oriented dialog dataset. in addition, qrn formulation allows parallelization on rnn's time axis, saving an order of magnitude in time complexity for training and inference. section: introduction in this paper, we address the problem of question answering (qa) when reasoning over multiple facts is required. for example, consider we know that frogs eat insects and flies are insects. then answering do frogs eat flies? requires reasoning over both of the above facts. question answering, more specifically context-based qa, has been extensively studied in machine comprehension tasks [reference][reference][reference][reference]. however, most of the datasets are primarily focused on lexical and syntactic understanding, and hardly concentrate on inference over multiple facts. recently, several datasets aimed for testing multi-hop reasoning have emerged; among them are story-based qa and the dialog task. recurrent neural network (rnn) and its variants, such as long short-term memory (lstm) [reference] and gated recurrent unit (gru) [reference], are popular choices for modeling natural language. however, when used for multi-hop reasoning in question answering, purely rnn-based models have shown to perform poorly. this is largely due to the fact that rnn's internal memory is inherently unstable over a long term. for this reason, most recent approaches in the literature have mainly relied on global attention mechanism and shared external memory [reference][reference][reference][reference]. the attention mechanism allows these models to focus on a single sentence in each layer. they can sequentially read multiple relevant sentences from the memory with multiple layers to perform multi-hop reasoning. however, one major drawback of these standard attention mechanisms is that they are insensitive to the time step (memory address) of the sentences when accessing them. our proposed model, query-reduction network 1 (qrn), is a single recurrent unit that addresses the long-term dependency problem of most rnn-based models by simplifying the recurrent update, while taking the advantage of rnn's capability to model sequential data (figure 1). qrn considers the context sentences as a sequence of state-changing triggers, and transforms (reduces) the original query to a more informed query as it observes each trigger through time. for instance in figure 1b, the original question, where is the apple?, can not be directly answered by any single sentence from the story. after observing the first sentence, sandra got the apple there, qrn transforms the original question to a reduced query where is sandra?, which is presumably 1 code is publicly available at: seominjoon.github.io/ qrn/ figure 1: (1a) qrn unit, (1b) 2-layer qrn on 5-sentence story, and (1c) entire qa system (qrn and input/ output modules). x, q,\u0177 are the story, question and predicted answer in natural language, respectively. x= x1,..., xt, q,\u0177 are their corresponding vector representations (upright font).\u03b1 and\u03c1 are update gate and reduce functions, respectively.\u0177 is assigned to be h 2 5, the local query at the last time step in the last layer. also, red-colored text is the inferred meanings of the vectors (see' interpretations' of section 5.3). easier to answer than the original question given the context provided by the first sentence. 2 unlike rnn-based models, qrn's candidate state (h t in figure 1a) does not depend on the previous hidden state (h t\u22121). compared to memory-based approaches [reference][reference][reference][reference], qrn can better encodes locality information because it does not use a global memory access controller (circle nodes in figure 2), and the query updates are performed locally. in short, the main contribution of qrn is threefold. first, qrn is a simple variant of rnn that reduces the query given the context sentences in a differentiable manner. second, qrn is situated between the attention mechanism and rnn, effectively handling time dependency and long-term dependency problems of each technique, respectively. hence it is well-suited for sequential data with both local and global interactions (note that qrn is not the replacement of rnn, which is arguably better for modeling complex local interactions). third, unlike most rnn-based models, qrn can be parallelized over time by computing candidate reduced queries (h t) directly from local input queries (q t) and context sentence vectors (x t). in fact, the parallelizability of qrn implies that qrn does not suffer from the vanishing gradient problem of rnn, hence effectively addressing the long-term dependency. we experimentally demonstrate these contributions by achieving the state-of-the-art results on story-based qa and interactive dialog datasets. section: model in story-based qa (or dialog dataset), the input is the context as a sequence of sentences (story or past conversations) and a question in natural language (equivalent to the user's last utterance in the dialog). the output is the predicted answer to the question in natural language (the system's next utterance in the dialog). the only supervision provided during training is the answer to the question. in this paper we particularly focus on end-to-end solutions, i.e., the only supervision comes from questions and answers, and we restrain from using manually defined rules or external language resources, such as lexicon or dependency parser. let x 1,..., x t denote the sequence of sentences, where t is the number of sentences in the story, and let q denote the question. let\u0177 denote the predicted answer, and y denote the true answer. our proposed system for end-to-end qa task is divided into three modules (figure 1c): input module, qrn layers, and output module. input module. input module maps each sentence x t and the question q to d-dimensional vector space, x t\u2208 r d and q t\u2208 r d. we adopt a previous solution for the input module (details in section 5). qrn layers. qrn layers use the sentence vectors and the question vector from the input module to obtain the predicted answer in vector space,\u0177\u2208 r d. a qrn layer refers to the recurrent application of a qrn unit, which can be considered as a variant of rnn with two inputs, two outputs, and a hidden state (reduced query), all of which operate in vector space. the details of the qrn module is explained throughout this section (2.1, 2.2). output module. output module maps\u0177 obtained from qrn to a natural language answer\u0177. similar to the input module, we adopt a standard solution for the output module (details in section 5). we first formally define the base model of a qrn unit, and then we explain how we connect the input and output modules to it (section 2.1). we also present a few extensions to the network that can improve qrn's performance (section 2.2). finally, we show that qrn can be parallelized over time, giving computational advantage over most rnn-based models by one order of magnitude (section 3). section: qrn unit as an rnn-based model, qrn is a single recurrent unit that updates its hidden state (reduced query) through time and layers. figure 1a depicts the schematic structure of a qrn unit, and figure 1b demonstrates how layers are stacked. a qrn unit accepts two inputs (local query vector q t\u2208 r d and sentence vector x t\u2208 r d), and two outputs (reduced query vector h t\u2208 r d, which is similar to the hidden state in rnn, and the sentence vector x t from the input without modification). the local query vector is not necessarily identical to the original query (question) vector q. in order to compute the outputs, we use update gate function\u03b1: intuitively, the update gate function measures the relevance between the sentence and the local query and is used to update the hidden state. the reduce function transforms the local query input to a candidate state which is a new reduced (easier) query given the sentence. the outputs are calculated with the following equations: where z t is the scalar update gate, h t is the candidate reduced query, and h t is the final reduced query at time step t,\u03c3 (\u00b7) is sigmoid activation, tanh (\u00b7) is hyperboolic tangent activation (applied element-wise),\u2022 is element-wise vector multiplication, and [;] is vector concatenation along the row. as a base case, h 0= 0. here we have explicitly defined\u03b1 and\u03c1, but they can be any reasonable differentiable functions. the update gate is similar to the global attention mechanism [reference][reference] in that it measures the similarity between the sentence (a memory slot) and the query. however, a significant difference is that the update gate is computed using sigmoid (\u03c3) function on the current memory slot only (hence internally embedded within the unit), whereas the global attention is computed using softmax function over the entire memory (hence globally defined). the update gate can be rather considered as local sigmoid attention. section: stacking layers we just showed the single-layer case of qrn, but qrn with multiple layers is able to perform reasoning over multiple facts more effectively, as shown in the example of figure 1b. in order to stack several layers of qrn, the outputs of the current layer are used as the inputs to the next layer. that is, using superscript k to denote the current layer's index (assuming 1-based indexing), we let q k+ 1 t= h k t. note that x t is passed to the next layer without any modification, so we do not put a layer index on it. bi-direction. so far we have assumed that qrn only needs to look at past sentences, whereas often times, query answers can depend on future sentences. for instance, consider a sentence\" john dropped the football.\" at time t. then, even if there is no mention about the\" football\" in the past (at time i< t), it can be implied that\" john\" has the\" football\" at the current time t. in order to incorporate the future dependency, we obtain\u2212\u2192 h t and\u2190\u2212 h t in both forward and backward directions, respectively, using equation 3. we then add them together to get q t for the next layer. that is, [reference] are shared between the two directions. connecting input and output modules. figure 1c depicts how qrn is connected with the input and output modules. in the first layer of qrn, q 1 t= q for all t, where q is obtained from the input module by processing the natural language question input q. x t is also obtained from x t by the same input module. the output at the last time step in the last layer is passed to the output module. that is, y= h k t where k represent the number of layers in the network. then the output module gives the predicted answer\u0177 in natural language. section: extensions here we introduce a few extensions of qrn, and later in our experiments, we test qrn's performance with and without each of these extensions. reset gate. inspired by gru [reference], we found that it is useful to allow the qrn unit to reset (nullify) the candidate reduced query (i.e., h t) when necessary. for this we use a reset gate function\u03b2:, which can be defined similarly to the update gate function: where w (r)\u2208 r 1\u00d7d is a weight matrix, and b (r)\u2208 r is a bias term. equation 3 is rewritten as note that we do not use the reset gate in the last layer. vector gates. as in lstm and gru, update and reset gates can be vectors instead of scalar values for fine-controlled gating. for vector gates, we modify the row dimension of weights and biases in equation 1 and 5 from 1 to d. then we obtain z t, r t\u2208 r d (instead of z t, r t\u2208 r), and these can be element-wise multiplied (\u2022) instead of being broadcasted in equation 3 and 6. section: parallelization an important advantage of qrn is that the recurrent updates in equation 3 and 5 can be computed in parallel across time. this is in contrast with most rnn-based models that can not be parallelized, where computing the candidate hidden state at time t explicitly requires the previous hidden state. in qrn, the final reduced queries (h t) can be decomposed into computing over candidate reduced queries (h t), without looking at the previous reduced query. here we primarily show that the query update in equation 3 can be parallelized by rewriting the equation with matrix operations. the extension to equation 5 is straightforward. the proof for qrn with vector gates is shown in appendix b. the recursive definition of equation 3 can be explicitly written as let b i= log (1\u2212 z i) for brevity. then we can rewrite equation 7 as the following equation: [reference] figure 2: the schematics of qrn and the two state-of-the-art models, end-to-end memory networks (n2n) and improved dynamic memory networks (dmn+), simplified to emphasize the differences among the models. agru is a variant of gru where the update gate is replaced with soft attention, proposed by [reference]. where l, l\u2208 r t\u00d7t are lower and strictly lower triangular matrices of 1's, respectively,\u2022 is elementwise multiplication, and b is a matrix where t b's are tiled across the column, i. section: related work qrn is inspired by rnn-based models with gating mechanism, such as lstm [reference] and gru [reference]. while gru and lstm use the previous hidden state and the current input to obtain the candidate hidden state, qrn only uses the current two inputs to obtain the candidate reduced query (equivalent to candidate hidden state). we conjecture that this not only gives computational advantage via parallelization, but also makes training easier, i.e., avoiding vanishing gradient (which is critical for long-term dependency), overfitting (by simplifying the model), and converging to local minima. the idea of structurally simplifying (constraining) rnns for learning longer-term patterns has been explored in recent previous work, such as structurally constrained recurrent network [reference] and strongly-typed recurrent neural network (strnn) [reference]. qrn is similar to strnn in that both architectures use gating mechanism, and the gates and the candidate hidden states do not depend on the previous hidden states, which simplifies the recurrent relation. however, qrn can be distinguished from strnn in three ways. first, qrn's update gate simulates attention mechanism, measuring the relevance between the input sentence and query. on the other hand, the gates in strnn can be considered as the simplification of lstm/ gru by removing their dependency on previous hidden state. second, qrn is an rnn that is natively compatible with context-based qa tasks, where the qrn unit accepts two inputs, i.e. each context sentence and query. this is distinct from strnn which has only one input. third, we show that qrn is timewise-parallelizable on gpus. our parallelization algorithm is also applicable to strnn. end-to-end memory network (n2n) [reference] uses external memory with multi-layer attention mechanism to focus on sentences that are relevant to the question. there are two key differences between n2n and our qrn. first, n2n summarizes the entire memory in each layer to control the attention in the next layer (circle nodes in figure 2b). instead, qrn does not have any controller node (figure 2a) and is able to focus on relevant sentences through the update gate that is internally embodied within its unit. second, n2n adds time-dependent trainable weights to the sentence representations to model the time dependency of the sentences (as discussed in section 1). qrn does not need such additional weights as its inherent rnn architecture allows qrn to effectively model the time dependency. neural reasoner [reference] and gated end-toend memory network [reference]) are variants of memn2n that share its fundamental characteristics. improved dynamic memory network (dmn+) [reference] uses the hybrid of the attention mechanism and the rnn architecture to model the sequence of sentences. it consists of two distinct grus, one for the time axis (rectangle nodes in figure 2c) and one for the layer axis (circle nodes in figure 2c). note that the update gate of the gru for the time axis is replaced with external softmax attention weights. dmn+ uses the time-axis gru to summarizes the entire memory in each layer, and then the layer-axis gru controls the attention weights in each layer. in contrast, qrn is simply a single recurrent unit without any controller node. section: experiments 5.1 data babi story-based qa dataset babi story-based qa dataset is composed of 20 different tasks (appendix a), each of which has 1, 000 (1k) synthetically-generated story-question pair. a story can be as short as two sentences and as long as 200+ sentences. a system is evaluated on the accuracy of getting the correct answers to the questions. the answers are single words or lists (e.g.\" football, apple\"). answering questions in each task requires selecting a set of relevant sentences and applying different kinds of logical reasoning over them. the dataset also includes 10k training data (for each task), which allows training more complex models. note that dmn+ [reference] only reports on the 10k dataset. babi dialog dataset babi dialog dataset consists of 5 different tasks (table 3), each of which has 1k synthetically-generated goal-oriented dialogs between a user and the system in the domain of restaurant reservation. each dialog is as long as 96 utterances and comes with external knowledge base (kb) providing information of each restaurant. the authors also provide out-of-vocabulary (oov) version of the dataset, where many of the words and kb keywords in test data are not seen during training. a system is evaluated on the accuracy of its response to each utterance of the user, choosing from up to 2500 possible candidate responses. a system is required not only to understand the user's request but also refer to previous conversations in order to obtain the context information of the current conversation. transformed the second dialog state tracking challenge (dstc2) dataset [reference] into the same format as the babi dialog dataset, for the measurement of performance on a real dataset. each dialog can be as long as 800+ utterances, and a system needs to choose from 2407 possible candidate responses for each utterance of the user. note that the evaluation metric of the original dstc2 is different from that of the transformed dstc2, so previous work on the original dstc2 should not be directly compared to our work. we will refer to this transformed dstc2 dataset by\" task 6\" of dialog dataset. section: dstc2 (task 6) dialog dataset section: model details input module. in the input module, we are given sentences (previous conversations in dialog) x t and a question (most recent user utterance) q, and we want to obtain their vector representations, x t, q\u2208 r d. we use a trainable embedding matrix a\u2208 r d\u00d7v to encode the one-hot vector of each word x tj in each sentence x t into a d-dimensional vector x tj\u2208 r d. then the sentence representation x t is obtained by position encoder. the same encoder with the same embedding matrix is also used to obtain the question vector q from q. output module for story-based qa. in the output module, we are given the vector representation of the predicted answer\u0177 and we want to obtain the natural language form of the answer,\u0177. we use a v-way single-layer softmax classifier to map\u0177 to a v-dimensional sparse vector, v= softmax w (y)\u0177\u2208 r v, where w (y)\u2208 r v\u00d7d is a weight matrix. then the final answer\u0177 is simply the argmax word inv. to handle questions with multiple-word answers, we consider each of them as a single word that contains punctuations such as space and comma, and put it in the vocabulary. output module for dialog. we use a fixed number single-layer softmax classifiers, each of which is similar to that of the sotry-based qa model, to sequentially output each word of the system's response. while it is similar in spirit to the rnn decoder [reference], our output module does not have a recurrent hidden state or gating mechanism. instead, it solely uses the final ouptut of the qrn,\u0177, and the current word output to influence the prediction of the next word among possible candidates. training. we withhold 10% of the training for development. we use the hidden state size of 50 by deafult. batch sizes of 32 for babi story-based qa 1k, babi dialog and dstc2 dialog, and 128 for babi qa 10k are used. the weights in the input and output modules are initialized with zero mean and the standard deviation of 1/\u221a d. weights in the qrn unit are initialized using techniques by [reference], and are tied across the layers. forget bias of 2.5 is used for update gates (no bias for reset gates). l2 weight decay of 0.001 (0.0005 for qa 10k) is used for all weights. the loss function is the cross entropy betweenv and the one-hot vector of the true answer. the loss is minimized by stochastic gradient descent for maximally 500 epochs, but training is early stopped if the loss on the development data does not decrease for 50 epochs. the learning rate is controlled by adagrad [reference] with the initial learning rate of 0.5 (0.1 for qa 10k). since the model is sensitive to the weight initialization, we repeat each training procedure 10 times (50 times for 10k) with the new random initialization of the weights and report the result on the test data with the lowest loss on the development data. section: results. we compare our model with baselines and previous state-of-the-art models on story-based and dialog tasks (table 1). these include lstm [reference], end-to-end memory networks (n2n) [reference], dynamic memory networks (dmn+) [reference], gated end-to-end memory networks (gmemn2n) [reference], and differentiable neural computer (dnc) [reference]. story-based qa. table 1 (top) reports the summary of results of our model (qrn) and previous work on babi qa (task-wise results are shown in table 2 in appendix). in 1k data, qrn's' 2r' (2 layers+ reset gate+ d= 50) outperforms all other models by a large margin (2.8+%). in 10k dataset, the average accuracy of qrn's' 6r200' (6 layers+ reset gate+ d= 200) model outperforms all previous models by a large margin (2.5+%), achieving a nearly perfect score of 99.7%. dialog. table 1 (bottom) reports the summary of the results of our model (qrn) and previous work on babi dialog and task 6 dialog (task-wise results are shown in table 3 in appendix). as done in previous work [reference], we also report results when we use' match' for dialogs.' match' is the extension to the model which additionally takes as input whether each answer candidate matches with context (more details on appendix). qrn outperforms previous work by a large margin (2.0+%) in every comparison. ablations. we test four types of ablations (also discussed in section 2.2): number of layers (1, 2, 3, or 6), reset gate (r), and gate vectorization (v) and the dimension of the hidden vector (50, 100). we show a subset of combinations of the ablations for babi qa in table 1 and table 2; other combinations performed poorly and/ or did not give interesting observations. according to the ablation results, we infer that: (a) when the number of layers is only one, the model lacks reasoning capability. in the case of 1k dataset, when there are too many layers (6), it seems correctly training the model becomes increasingly difficult. in the case of 10k dataset, many layers (6) and hidden dimensions (200) parallelization. we implement qrn with and without parallelization in tensorflow [reference]) on a single titan x gpu to qunaitify the computational gain of the parallelization. for qrn without parallelization, we use the rnn library provided by tensorflow. qrn with parallelization gives 6.2 times faster training and inference than qrn without parallelization on average. we expect that the speedup can be even higher for datasets with larger context. interpretations. an advantage of qrn is that the intermediate query updates are interpretable. figure 1 shows intermediate local queries (q k t) interpreted in natural language, such as\" where is sandra?\". in order to obtain these, we place a decoder on the input question embedding q and add its loss for recovering the question to the classification loss (similarly to [reference]). we then use the same decoder to decode the intermediate queries. this helps us understand the flow of information in the networks. in figure 1, the question where is apple? is transformed into where is sandra? at t= 1. at t= 2, as sandra dropped the apple, the apple is no more relevant to sandra. we obtain where is daniel? at time t= 3, and it is propagated until t= 5, where we observe a sentence (fact) that can be used to answer the query. visualization. figure 3 shows vizualization of the (scalar) magnitudes of update and reset gates on story sentences and dialog utterances. more visualizations are shown in appendices: figure 4 and figure 5. in figure 3, we observe high values on facts that provide information to answer question (the system's next utterance for dialog). in qa task 2 example (top left), we observe high update gate values in the first layer on facts that state who has the apple, and in the second layer, the high update gate values are on those that inform where that person went to. we also observe that the forward reset gate at t= 2 in the first layer (\u2212\u2192 r 1 2) is low, which is signifying that apple no more belongs to sandra. in dialog task 3 (bottom left), the model is able to infer that three restaurants are already recommended so that it can recommend another one. in dialog task 6 (bottom), the model focuses on the sentences containing spanish, and does not concentrate much on other facts such as i do n't care. section: conclusion in this paper, we introduce query-reduction network (qrn) to answer context-based questions and carry out conversations with users that require multi-hop reasoning. we show the state-of-theart results in the three datasets of story-based qa and dialog. we model a story or a dialog as a sequence of state-changing triggers and compute the final answer to the question or the system's next utterance by recurrently updating (or reducing) the query. qrn is situated between the attention mechanism and rnn, effectively handling time dependency and long-term dependency problems of each technique, respectively. it addresses the long-term dependency problem of most rnns by simplifying the recurrent update, in which the candidate hidden state (reduced query) does not depend on the previous state. moreover, qrn can be parallelized and can address the well-known problem of rnn's vanishing gradients. section: a task-wise results here we provide detailed per-task breakdown of our results in qa (table 2) and dialog datasets (table 3). table 2: babi qa dataset error rates (%) of qrn and previous work: lstm, end-to-end memory networks (n2n) [reference], dynamic memory networks (dmn+) [reference], gated end-to-end memory networks (gmemn2n) [reference]. results within each task of differentiable neural computer (dnc) were not provided in its paper [reference] table 3: babi dialog and dstc2 dialog dataset average error rates (%) of qrn and previous work: end-to-end memory networks (n2n) and gated end-to-end memory networks (gmemn2n [reference]). for qrn, a number in the front [reference][reference][reference][reference] indicates the number of layers and a number in the back (100) indicates the dimension of hidden vector, while the default value is 50.' r' indicates that the reset gate is used,' v' indicates that the gates were vectorized, and'+' indicates that' match' was used. section: b vector gate parallelization for vector gates, we have z t\u2208 r d instead of z t\u2208 r. therefore the following equation replaces equation 7: where z j k is the k-th column vector of z j. let b ij= log (1\u2212 z i j) for brevity. then, we can rewrite equation 8 as following:... where l, l\u2208 r t\u00d7t are lower and strictly lower triangular matrices of 1's are tiled across the column. section: c model details match. while similar in spirit, our' match' model is slightly different from previous work (bordes and [reference]. we use answer candidate embedding matrix, and add 2 dimension of 0-1 matrix which expresses whether the answer candidate matches with any word in the paragraph and the question. in other words, the softmax is computed b\u0177 are trainable weight matrices, and m (y)\u2208 r v\u00d72 is the 0-1 match matrix. section: d visualizations visualization of story-based qa. figure 4 shows visualization of models for story-based qa tasks. in the task 3 (left), the model focuses on the facts that contain' football' in the first layer, and found out where mary journeyed to before the bathroom in the second layer. in task 7 (right), the model focuses on the facts that provide information about the location of sandra. can you make a restaurant reservation for eight in a cheap price range in madrid 0.00 1.00 0.93 1.00 i' m on it. 0.00 1.00 0.74 0.00 any preference on a type of cuisine. 0.00 0.11 1.00 0.01 i love british food. 0.00 0.99 0.99 0.57 okay let me look into some options for you. here it is: resto-paris-expen-spanish-8stars-address figure 5: visualization of update and reset gates in qrn' 2r' model for on several tasks of babi dialog and dstc2 dialog (table 3). we do not put reset gate in the last layer. note that we only show some of recent sentences here, even the dialog has more sentences. visualization of dialog. figure 5 shows visualization of models for dialog tasks. in the first dialog of task 1, the model focuses on the user utterance that mentions the user's desired cuisine and location, and the current query (user's last utterance) informs the system of the number of people, so the system is able to learn that it now needs to ask the user about the desired price range. in the second dialog of task 1, the model focuses on the facts that provide information about the requests of the user. in task 4 (third), the model focuses on what restaurant a user is talking about and the information about the restaurant. section: section: acknowledgments this research was supported by the nsf (iis 1616112), allen institute for ai (66-9175), allen distinguished investigator award, google research faculty award, and samsung gro award. we thank the anonymous reviewers for their helpful comments. section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "babi qa"
                    ],
                    [
                        "dstc2 dataset"
                    ],
                    [
                        "babi dialog dataset"
                    ],
                    [
                        "dstc2 dialog dataset"
                    ]
                ],
                "Method": [
                    [
                        "qrn"
                    ],
                    [
                        "gated end toend memory network"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "question answering"
                    ],
                    [
                        "answering"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "babi dialog dataset",
                        "babi story-based qa",
                        "babi dialog",
                        "babi qa"
                    ]
                ],
                "Method": [
                    [
                        "query-reduction networks",
                        "query-reduction network",
                        "qrn",
                        "query-reduction network 1"
                    ]
                ],
                "Metric": [
                    [
                        "error rates"
                    ]
                ],
                "Task": [
                    [
                        "question answering",
                        "qa",
                        "context-based qa"
                    ]
                ]
            }
        ]
    },
    "270e65acc071b9e4e2a632720130c0e10cb6fa08-38": {
        "doctext": "document: neural tree indexers for text understanding recurrent neural networks (rnns) process input text sequentially and model the conditional transition between word tokens. in contrast, the advantages of recursive networks include that they explicitly model the compositionality and the recursive structure of natural language. however, the current recursive architecture is limited by its dependence on syntactic tree. in this paper, we introduce a robust syntactic parsing-independent tree structured model, neural tree indexers (nti) that provides a middle ground between the sequential rnns and the syntactic tree-based recursive models. nti constructs a full n-ary tree by processing the input text with its node function in a bottom-up fashion. attention mechanism can then be applied to both structure and node function. we implemented and evaluated a binary-tree model of nti, showing the model achieved the state-of-the-art performance on three different nlp tasks: natural language inference, answer sentence selection, and sentence classification, outperforming state-of-the-art recurrent and recursive neural networks. section: introduction recurrent neural networks (rnns) have been successful for modeling sequence data. rnns equipped with gated hidden units and internal short-term memories, such as long short-term memories (lstm) have achieved a notable success in several nlp tasks including named entity recognition, constituency parsing, textual entailment recognition, question answering, and machine translation. however, most lstm models explored so far are sequential. it encodes text sequentially from left to right or vice versa and do not naturally support compositionality of language. sequential lstm models seem to learn syntactic structure from the natural language however their generalization on unseen text is relatively poor comparing with models that exploit syntactic tree structure. unlike sequential models, recursive neural networks compose word phrases over syntactic tree structure and have shown improved performance in sentiment analysis. however its dependence on a syntactic tree architecture limits practical nlp applications. in this study, we introduce neural tree indexers (nti), a class of tree structured models for nlp tasks. nti takes a sequence of tokens and produces its representation by constructing a full n-ary tree in a bottom-up fashion. each node in nti is associated with one of the node transformation functions: leaf node mapping and non-leaf node composition functions. unlike previous recursive models, the tree structure for nti is relaxed, i.e., nti does not require the input sequences to be parsed syntactically; and therefore it is flexible and can be directly applied to a wide range of nlp tasks beyond sentence modeling. furthermore, we propose different variants of node composition function and attention over tree for our nti models. when a sequential leaf node transformer such as lstm is chosen, the nti network forms a sequence-tree hybrid model taking advantage of both conditional and compositional powers of sequential and recursive models. figure shows a binary-tree model of nti. although the model does not follow the syntactic tree structure, we empirically show that it achieved the state-of-the-art performance on three different nlp applications: natural language inference, answer sentence selection, and sentence classification. section: related work subsection: recurrent neural networks and attention mechanism rnns model input text sequentially by taking a single token at each time step and producing a corresponding hidden state. the hidden state is then passed along through the next time step to provide historical sequence information. although a great success in a variety of tasks, rnns have limitations. among them, it is not efficient at memorizing long or distant sequence. this is frequently called as information flow bottleneck. approaches have therefore been developed to overcome the limitations. for example, to mitigate the information flow bottleneck, bahdanau:15 extended rnns with a soft attention mechanism in the context of neural machine translation, leading to improved the results in translating longer sentences. rnns are linear chain-structured; this limits its potential for natural language which can be represented by complex structures including syntactic structure. in this study, we propose models to mitigate this limitation. subsection: recursive neural networks unlike rnns, recursive neural networks explicitly model the compositionality and the recursive structure of natural language over tree. the tree structure can be predefined by a syntactic parser. each non-leaf tree node is associated with a node composition function which combines its children nodes and produces its own representation. the model is then trained by back-propagating error through structures. the node composition function can be varied. a single layer network with non-linearity was adopted in recursive auto-associate memories and recursive autoencoders. socher2012semantic extended this network with an additional matrix representation for each node to augment the expressive power of the model. tensor networks have also been used as composition function for sentence-level sentiment analysis task. recently, zhu2015long introduced s-lstm which extends lstm units to compose tree nodes in a recursive fashion. in this paper, we introduce a novel attentive node composition function that is based on s-lstm. our nti model does not rely on either a parser output or a fine-grained supervision of non-leaf nodes, both required in previous work. in nti, the supervision from the target labels is provided at the root node. as such, our nti model is robust and applicable to a wide range of nlp tasks. we introduce attention over tree in nti to overcome the vanishing/ explode gradients challenges as shown in rnns. section: methods our training set consists of examples, where the input is a sequence of word tokens and the output can be either a single target or a sequence. each input word token is represented by its word embedding. nti is a full n-ary tree (and the sub-trees can be overlapped). it has two types of transformation function: non-leaf node function and leaf node function. computes a (possibly non-linear) transformation of the input word embedding. is a function of its child nodes representation, where is the total number of child nodes of this non-leaf node. nti can be implemented with different tree structures. in this study we implemented and evaluated a binary tree form of nti: a non-leaf node can take in only two direct child nodes (i.e.,). therefore, the function composes its left child node and right child node. figure illustrates our nti model that is applied to question answering (a) and natural language inference tasks (b). note that the node and leaf node functions are neural networks and are the only training parameters in nti. we explored two different approaches to compose node representations: an extended lstm and attentive node composition functions, to be described below. subsection: non-leaf node composition functions we define two different methods for non-leaf node function. lstm-based non-leaf node function (s-lstm): we initiate with lstm. for non-leaf node, we adopt s-lstm zhu2015long, an extension of lstm to tree structures, to learn a node representation by its children nodes. let,, and be vector representations and cell states for the left and right children. an s-lstm computes a parent node representation and a node cell state as where and biases (for brevity we eliminated the bias terms) are the training parameters. and denote the element-wise function and the element-wise vector multiplication. extension of s-lstm non-leaf node function to compose more children is straightforward. however, the number of parameters increases quadratically in s-lstm as we add more child nodes. attentive non-leaf node function (anf): some nlp applications (e.g., qa and machine translation) would benefit from a dynamic query dependent composition function. we introduce anf as a new non-leaf node function. unlike s-lstm, anf composes the child nodes attentively in respect to another relevant input vector. the input vector can be a learnable representation from a sequence representation. given a matrix resulted by concatenating the child node representations, and the third input vector, anf is defined as where is a learnable matrix, the attention score and the attention weight vector for each child. is an attention scoring function, which can be implemented as a multi-layer perceptron (mlp) or a matrix-vector product. the matrices and and the vector are training parameters. is a vector of ones and the outer product. we use function for non-linear transformation. subsection: attention over tree comparing with sequential lstm models, nti has less recurrence, which is defined by the tree depth, for binary tree where is the length of the input sequence. however, nti still needs to compress all the input information into a single representation vector of the root. this imposes practical difficulties when processing long sequences. we address this issue with attention mechanism over tree. in addition, the attention mechanism can be used for matching trees (described in section 4 as tree matching nti) that carry different sequence information. we first define a global attention and then introduce a tree attention which considers the parent-child dependency for calculation of the attention weights. global attention: an attention neural network for the global attention takes all node representations as input and produces an attentively blended vector for the whole tree. this neural net is similar to anf. particularly, given a matrix resulted by concatenating the node representations,\u2026, and the relevant input representation, the global attention is defined as where and are training parameters and the attention weight vector for each node. this attention mechanism is robust as it globally normalizes the attention score with to obtain the weights. however, it does not consider the tree structure when producing the final representation. tree attention: we modify the global attention network to the tree attention mechanism. the resulting tree attention network performs almost the same computation as anf for each node. it compares the parent and children nodes to produce a new representation assuming that all node representations are constructed. given a matrix resulted by concatenating the parent node representation, the left child and the right child and the relevant input representation, every non-leaf node simply updates its own representation by using the following equation in a bottom-up manner. and this equation is similarity to the global attention. however, now each non-leaf node attentively collects its own and children representations and passes towards the root which finally constructs the attentively blended tree representation. note that unlike the global attention, the tree attention locally normalizes the attention scores with. section: experiments we describe in this section experiments on three different nlp tasks, natural language inference, question answering and sentence classification to demonstrate the flexibility and the effectiveness of nti in the different settings. we trained nti using adam with hyperparameters selected on development set. the pre-trained 300-d glove 840b vectors were obtained for the word embeddings. the word embeddings are fixed during training. the embeddings for out-of-vocabulary words were set to zero vector. we pad the input sequence to form a full binary tree. a padding vector was inserted when padding. we analyzed the effects of the padding size and found out that it has no influence on the performance (see appendix [reference]). the size of hidden units of the nti modules were set to 300. the models were regularized by using dropouts and an weight decay. subsection: natural language inference we conducted experiments on the stanford natural language inference (snli) dataset, which consists of 549, 367/ 9, 842/ 9, 824 premise-hypothesis pairs for train/ dev/ test sets and target label indicating their relation. unless otherwise noted, we follow the setting in the previous work and use an mlp for classification which takes in nti outputs and computes the concatenation, absolute difference and elementwise product of the two sentence representations. the mlp has also an input layer with 1024 units with activation and a output layer. we explored nine different task-oriented nti models with varying complexity, to be described below. for each model, we set the batch size to 32. the initial learning, the regularization strength and the number of epoch to be trained are varied for each model. nti-slstm: this model does not rely on transformer but uses the s-lstm units for the non-leaf node function. we set the initial learning rate to 1e-3 and regularizer strength to 3e-5, and train the model for 90 epochs. the neural net was regularized by 10% input dropouts and the 20% output dropouts. nti-slstm-lstm: we use lstm for the leaf node function. concretely, the lstm output vectors are given to nti-slstm and the memory cells of the lowest level s-lstm were initialized with the lstm memory states. the hyper-parameters are the same as the previous model. nti-slstm node-by-node global attention: this model learns inter-sentence relation with the global attention over premise-indexed tree, which is similar to word-by-word attention model of rocktaschel:16 in that it attends over the premise tree nodes at every time step of hypothesis encoding. we tie the weight parameters of the two nti-slstms for premise and hypothesis and no transformer used. we set the initial learning rate to 3e-4 and regularizer strength to 1e-5, and train the model for 40 epochs. the neural net was regularized by 15% input dropouts and the 15% output dropouts. nti-slstm node-by-node tree attention: this is a variation of the previous model with the tree attention. the hyper-parameters are the same as the previous model. nti-slstm-lstm node-by-node global attention: in this model we include lstm as the leaf node function. here we initialize the memory cell of s-lstm with lstm memory and hidden/ memory state of hypothesis lstm with premise lstm (the later follows the work of). we set the initial learning rate to 3e-4 and regularizer strength to 1e-5, and train the model for 10 epochs. the neural net was regularized by 10% input dropouts and the 15% output dropouts. nti-slstm-lstm node-by-node tree attention: this is a variation of the previous model with the tree attention. the hyper-parameters are the same as the previous model. tree matching nti-slstm-lstm global attention: this model first constructs the premise and hypothesis trees simultaneously with the nti-slstm-lstm model and then computes their matching vector by using the global attention and an additional lstm. the attention vectors are produced at each hypothesis tree node and then are given to the lstm model sequentially. the lstm model compress the attention vectors and outputs a single matching vector, which is passed to an mlp for classification. the mlp for this tree matching setting has an input layer with 1024 units with activation and a output layer. unlike wangj15b's matching lstm model which is specific to matching sequences, we use the standard lstm units and match trees. we set the initial learning rate to 3e-4 and regularizer strength to 3e-5, and train the model for 20 epochs. the neural net was regularized by 20% input dropouts and the 20% output dropouts. tree matching nti-slstm-lstm tree attention: we replace the global attention with the tree attention. the hyper-parameters are the same as the previous model. full tree matching nti-slstm-lstm global attention: this model produces two sets of the attention vectors, one by attending over the premise tree regarding each hypothesis tree node and another by attending over the hypothesis tree regarding each premise tree node. each set of the attention vectors is given to a lstm model to achieve full tree matching. the last hidden states of the two lstm models (i.e. one for each attention vector set) are concatenated for classification. the training weights are shared among the lstm models the hyper-parameters are the same as the previous model. table [reference] shows the results of our models. for comparison, we include the results from the published state-of-the-art systems. while most of the sentence encoder models rely solely on word embeddings, the dependency tree cnn and the spinn-pi models make use of sentence parser output; which present strong baseline systems. the last set of methods designs inter-sentence relation with soft attention. our best score on this task is 87.3% accuracy obtained with the full tree matching nti model. the previous best performing model on the task performs phrase matching by using the attention mechanism. our results show that nti-slstm improved the performance of the sequential lstm encoder by approximately 2%. not surprisingly, using lstm as leaf node function helps in learning better representations. our nti-slstm-lstm is a hybrid model which encodes a sequence sequentially through its leaf node function and then hierarchically composes the output representations. the node-by-node attention models improve the performance, indicating that modeling inter-sentence interaction is an important element in nli. aggregating matching vector between trees or sequences with a separate lstm model is effective. the global attention seems to be robust on this task. the tree attention were not helpful as it normalizes the attention scores locally in parent-child relationship. subsection: answer sentence selection for this task, a model is trained to identify the correct sentences that answer a factual question, from a set of candidate sentences. we experiment on wikiqa dataset constructed from wikipedia. the dataset contains 20, 360/ 2, 733/ 6, 165 qa pairs for train/ dev/ test sets. we used the same setup in the language inference task except that we replace the layer with a layer and model the following conditional probability distribution. where and are the question and the answer encoded vectors and denotes the output of the hidden layer of the mlp. for this task, we use nti-slstm-lstm to encode answer candidate sentences and nti-anf-lstm to encode the question sentences. note that nti-anf-lstm is relied on anf as the non-leaf node function. vector for nti-anf-lstm is the answer representation produced by the answer encoding nti-slstm-lstm model. we set the batch size to 4 and the initial learning rate to 1e-3, and train the model for 10 epochs. we used 20% input dropouts and no weight decay. following previous work, we adopt map and mrr as the evaluation metrics for this task. table [reference] presents the results of our model and the previous models for the task. the classifier with handcrafted features is a svm model trained with a set of features. the bigram-cnn model is a simple convolutional neural net. the deep lstm and lstm attention models outperform the previous best result by a large margin, nearly 5-6%. nasm improves the result further and sets a strong baseline by combining variational auto-encoder with the soft attention. in nasm, they adopt a deep three-layer lstm and introduced a latent stochastic attention mechanism over the answer sentence. our nti model exceeds nasm by approximately 0.4% on map for this task. subsection: sentence classification lastly, we evaluated nti on the stanford sentiment treebank (sst). this dataset comes with standard train/ dev/ test sets and two subtasks: binary sentence classification or fine-grained classification of five classes. we trained our model on the text spans corresponding to labeled phrases in the training set and evaluated the model on the full sentences. we use nti-slstm and nti-slstm-lstm models to learn sentence representations for the task. the sentence representations were passed to a two-layer mlp for classification. we set the batch size to 64, the initial learning rate to 1e-3 and regularizer strength to 3e-5, and train each model for 10 epochs. the nti-slstm model was regularized by 10%/ 20% of input/ output and 20%/ 30% of input/ output dropouts and the nti-slstm-lstm model 20% of input and 20%/ 30% of input/ output dropouts for binary and fine-grained settings. nti-slstm-lstm (as shown in table [reference]) set the state-of-the-art results on both subtasks. our nti-slstm model performed slightly worse than its constituency tree-based counter part, ct-lstm model. the ct-lstm model composes phrases according to the output of a sentence parser and uses a node composition function similar to s-lstm. after we transformed the input with the lstm leaf node function, we achieved the best performance on this task. section: qualitative analysis subsection: attention and compositionality to help analyzing the results, we output attention weights by our nti-slstm node-by-node global attention model. figure [reference] shows the attention heatmaps for two sentences in the snli test set. it shows that our model semantically aligns single or multiword expressions (\" little child\" and\" toddler\";\" rock wall\" and\" stone\"). in addition, our model is able to re-orient its attention over different parts of the hypothesis when the expression is more complex. for example, for (c)\" rock wall in autumn\", nti mostly focuses on the nodes in depth 1, 2 and 3 representing contexts related to\" a stone\",\" leaves.\" and\" a stone wall surrounded\". surprisingly, attention degree for the single word expression like\" stone\",\" wall\" and\" leaves\" is lower to compare with multiword phrases. sequence models lack this property as they have no explicit composition module to produce such mutiword phrases. finally, the most interesting pattern is that the model attends over higher level (low depth) tree nodes with rich semantics when considering a (c) longer phrase or (d) full sentence. as shown in (d), the nti model aligns the root node representing the whole hypothesis sentence to the higher level tree nodes covering larger sub-trees in the premise. it certainly ignores the lower level single word expressions and only starts to attend when the words are collectively to form rich semantics. subsection: learned representations of phrases and sentences using cosine similarity between their representations produced by the nti-slstm model, we show that nti is able to capture paraphrases on snli test data. as shown in table [reference], nti seems to distinguish plural from singular forms (similar phrases to\" a person\"). in addition, nti captures non-surface knowledge. for example, the phrases similar to\" park for fun\" tend to align to the semantic content of fun and park, including\" people play frisbee outdoors\". the nti model was able to relate\" santa claus\" to christmas and snow. interestingly, the learned representations were also able to connect implicit semantics. for example, nti found that\" sad, depressed, and hatred\" is close to the phrases like\" an obama supporter is upset\". overall the nti model is robust to the length of the phrases being matched. given a short phrase, nti can retrieve longer yet semantically coherent sequences from the snli test set. in table [reference], we show nearest-neighbor sentences from snli test set. note that the sentences listed in the first two columns sound semantically coherent but not the ones in the last column. the query sentence\" a dog sells a women a hat\" does not actually represent a common-sense knowledge and this sentence now seem to confuse the nti model. as a result, the retrieved sentence are arbitrary and not coherent. subsection: effects of padding size we introduced a special padding character in order to construct full binary tree. does this padding character influence the performance of the nti models? in figure [reference], we show relationship between the padding size and the accuracy on stanford sentiment analysis data. each sentence was padded to form a full binary tree. the x-axis represents the number of padding characters introduced. when the padding size is less (up to 10), the nti-slstm-lstm model performs better. however, this model tends to perform poorly or equally when the padding size is large. overall we do not observe any significant performance drop for both models as the padding size increases. this suggests that nti learns to ignore the special padding character while processing padded sentences. the same scenario was also observed while analyzing attention weights. the attention over the padded nodes was nearly zero. section: discussion and conclusion we introduced neural tree indexers, a class of tree structured recursive neural network. the nti models achieved state-of-the-art performance on different nlp tasks. most of the nti models form deep neural networks and we think this is one reason that nti works well even if it lacks direct linguistic motivations followed by other syntactic-tree-structured recursive models. cnn and nti are topologically related. both nti and cnns are hierarchical. however, current implementation of nti only operates on non-overlapping sub-trees while cnns can slide over the input to produce higher-level representations. nti is flexible in selecting the node function and the attention mechanism. like cnn, the computation in the same tree-depth can be parallelized effectively; and therefore nti is scalable and suitable for large-scale sequence processing. note that nti can be seen as a generalization of lstm. if we construct left-branching trees in a bottom-up fashion, the model acts just like sequential lstm. different branching factors for the underlying tree structure have yet to be explored. nti can be extended so it learns to select and compose dynamic number of nodes for efficiency, essentially discovering intrinsic hierarchical structure in the input. section: acknowledgments we would like to thank the anonymous reviewers for their insightful comments and suggestions. this work was supported in part by the grant hl125089 from the national institutes of health (nih). any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect those of the sponsor. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "snli dataset"
                    ],
                    [
                        "wikiqa dataset"
                    ],
                    [
                        "stanford sentiment treebank"
                    ],
                    [
                        "snli test set"
                    ],
                    [
                        "stanford sentiment analysis data"
                    ]
                ],
                "Method": [
                    [
                        "neural tree indexers"
                    ],
                    [
                        "nti"
                    ]
                ],
                "Metric": [
                    [
                        "mrr"
                    ]
                ],
                "Task": [
                    [
                        "natural language inference"
                    ],
                    [
                        "fine grained classification"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "stanford natural language inference",
                        "snli"
                    ]
                ],
                "Method": [
                    [
                        "nti-slstm-lstm"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "natural language inference",
                        "nli",
                        "language inference task"
                    ]
                ]
            }
        ]
    },
    "2777cd26b2c257843273fe41ad4c5b8cdf1b1b75-39": {
        "doctext": "document: understanding humans in crowded scenes: deep nested adversarial learning and a new benchmark for multi-human parsing despite the noticeable progress in perceptual tasks like detection, instance segmentation and human parsing, computers still perform unsatisfactorily on visually understanding humans in crowded scenes, such as group behavior analysis, person re-identification and autonomous driving, etc. to this end, models need to comprehensively perceive the semantic information and the differences between instances in a multi-human image, which is recently defined as the multi-human parsing task. in this paper, we present a new large-scale database\" m ulti-h uman p arsing (mhp)\" for algorithm development and evaluation, and advances the state-of-the-art in understanding humans in crowded scenes. mhp contains 25, 403 elaborately annotated images with 58 fine-grained semantic category labels, involving 2-26 persons per image and captured in real-world scenes from various viewpoints, poses, occlusion, interactions and background. we further propose a novel deep n ested a dversarial n etwork (nan) model for multi-human parsing. nan consists of three g enerative a dversarial n etwork (gan)- like sub-nets, respectively performing semantic saliency prediction, instance-agnostic parsing and instance-aware clustering. these sub-nets form a nested structure and are carefully designed to learn jointly in an end-to-end way. nan consistently outperforms existing state-of-the-art solutions on our mhp and several other datasets, and serves as a strong baseline to drive the future research for multi-human parsing. section: introduction one of the primary goals of intelligent human-computer interaction is understanding the humans in visual scenes. it involves several perceptual tasks including detection, i.e. localizing different persons at a coarse, bounding box level (fig. [reference] (a)), instance segmentation, i.e. labelling each pixel of each person uniquely (fig. [reference] (b)), and human parsing, i.e. decomposing persons into their semantic categories (fig. [reference] (c)). recently, deep learning based methods have achieved remarkable sucess in these perceptual tasks thanks to the availability of plentiful annotated images for training and evaluation purposes. though exciting, current progress is still far from the utimate goal of visually understanding humans. as fig. [reference] shows, previous efforts on understanding humans in visual scenes either only consider coarse information or are agnostic to different instances. in the real-world scenarios, it is more likely that there simutaneously exist multiple persons, with various human interactions, poses and occlusion. thus, it is more practically demanded to parse human body parts and fashion items at the instance level, which is recently defined as the multi-human parsing task. multi-human parsing enables more detailed understanding of humans in crowded scenes and aligns better with many real-world applications, such as group behavior analysis, person re-identification, e-commerce, image editing, video surveillance, autonomous driving and virtual reality. however, the existing benchmark datasets are not suitable for such a new task. even though li et al. proposed a preliminary m ulti-h uman p arsing (mhp v1.0) dataset, it only contains 4, 980 images annotated with 18 semantic labels. in this work, we propose a new large-scale benchmark\" m ulti-h uman p arsing (mhp v2.0)\", aiming to push the frontiers of multi-human parsing research towards holistically understanding humans in crowded scenes. the data in mhp v2.0 cover wide variability and complexity w.r.t. viewpoints, poses, occlusion, human interactions and background. it in total includes 25, 403 human images with pixel-wise annotations of 58 semantic categories. we further propose a novel deep n ested a dversarial n etwork (nan) model for solving the challenging multi-human parsing problem. unlike most existing methods which rely on separate stages of instance localization, human parsing and result refinement, the proposed nan parses semantic categories and differentiates different person instances simultaneously in an effective and time-efficient manner. nan consists of three g enerative a dversarial n etwork (gan)- like sub-nets, respectively performing semantic saliency prediction, instance-agnostic parsing and instance-aware clustering. each sub-task is simpler than the original multi-human parsing task, and is more easily addressed by the corresponding sub-net. unlike many multi-task learning applications, in our method the sub-nets depend on each other, forming a causal nest by dynamically boosting each other through an adversarial strategy (see fig. [reference]), which is hence called a\" nested adversarial learning\" structure. such a structure enables effortless gradient b ackpro p agation (bp) in nan such that it can be trained in a holistic, end-to-end way, which is favorable to both accuracy and speed. we conduct qualitative and quantitative experiments on the mhp v2.0 dataset proposed in this work, as well as the mhp v1.0, pascal-person-part and buffy benchmark datasets. the results demonstrate the superiority of nan on multi-human parsing over the state-of-the-arts. our contributions are summarized as follows. we propose a new large-scale benchmark and evaluation server to advance understanding of humans in crowded scenes, which contains 25, 403 images annotated pixel-wisely with 58 semantic category labels. we propose a novel deep n ested a dversarial n etwork (nan) model for multi-human parsing, which serves as a strong baseline to inspire more future research efforts on this task. comprehensive evaluations on the mhp v2.0 dataset proposed in this work, as well as the mhp v1.0, pascal-person-part and buffy benchmark datasets verify the superiority of nan on understanding humans in crowded scenes over the state-of-the-arts. section: related work paragraph: human parsing datasets the statistics of popular publicly available datasets for human parsing are summarized in tab. [reference]. the buffy dataset was released in 2011 for human parsing and instance segmentation. it contains only 748 images annotated with 13 semantic categories. the fashionista dataset was released in 2012 for human parsing, containing limited images annotated with 56 fashion categories. the pascal-person-part dataset was initially annotated by chen et al. from the pascal-voc-2010 dataset. chen et al. extended it for human parsing with 7 coarse body part labels. the atr dataset was released in 2015 for human parsing with a large number of images annotated with 18 semantic categories. the lip dataset further extended atr by cropping person instances from microsoft coco. it is a large-scale human parsing dataset with densely pixel-wise annotations of 20 semantic categories. but it has two limitations. 1) despite the large data size, it contains limited semantic category annotations, which restricts the fine-grained understanding of humans in visual scenes. 2) in lip, only a small proportion of images involve multiple persons with interactions. such an instance-agnostic setting severely deviates from reality. even in the mhp v1.0 dataset proposed by li et al. for multi-human parsing, only 4, 980 images are included and annotated with 18 semantic labels. comparatively, our mhp v2.0 dataset contains 25, 403 elaborately annotated images with 58 fine-grained semantic part labels. it is the largest and most comprehensive multi-human parsing dataset to date, to our best knowledge. visual comparisons between lip, mhp v1.0 and our mhp v2.0 are provided in fig. [reference]. paragraph: human parsing approaches recently, many research efforts have been devoted to human parsing due to its wide range of potential applications. for example, liang et al. proposed a proposal-free network for instance segmentation by directly predicting the instance numbers of different categories and the pixel-level information. gong et al. proposed a self-supervised structure-sensitive learning approach, which imposes human pose structures to parsing results without resorting to extra supervision. liu et al. proposed a single frame video parsing method which integrates frame parsing, optical flow estimation and temporal fusion into a unified network. zhao et al. proposed a self-supervised neural aggregation network, which learns to aggregate the multi-scale features and incorporates a self-supervised joint loss to ensure the consistency between parsing and pose. he et al. proposed the mask r-cnn, which is extended from faster r-cnn by adding a branch for predicting an object mask in parallel with the existing branch for bounding box recognition. brabandere et al. proposed to tackle instance segmentation with a discriminative loss function, operating at the pixel level, which encourages a convolutional network to produce a representation of the image that can be easily clustered into instances with a simple post-processing step. however, these methods either only consider coarse semantic information or are agnostic to different instances. to enable more detailed human-centric analysis, li et al. initially proposed the multi-human parsing task, which aligns better with the realistic scenarios. they also proposed a novel mh-parser model as a reference method which generates parsing maps and instance masks simutaneously in a bottom-up fashion. jiang et al. proposed a new approach to segment human instances and label their body parts using region assembly. li et al. proposed a framework with a human detector and a category-level segmentation module to segment the parts of objects at the instance level. these methods involve mutiple separate stages for instance localization, human parsing and result refinement. in comparison, the proposed nan produces accurate multi-human parsing results through a single forward-pass in a time-efficient manner without tedious pre-or post-processing. section: multi-human parsing benchmark in this section, we introduce the\" m ulti-h uman p arsing (mhp v2.0)\", a new large-scale dataset focusing on semantic understanding of humans in crowded scenes with several appealing properties. 1) it contains 25, 403 elaborately annotated images with 58 fine-grained labels on body parts, fashion items and one background label, which is larger and more comprehensive than previous similar attempts. 2) the images within mhp v2.0 are collected from real-world scenarios, involving humans with various viewpoints, poses, occlusion, interactions and resolution. 3) the background of images in mhp v2.0 is more complex and diverse than previous datasets. some examples are showed in fig. [reference]. the mhp v2.0 dataset is expected to provide a new benchmark suitable for multi-human parsing together with a standard evaluation server where the test set will be kept secret to avoid overfitting. subsection: image collection and annotation we manually specify some underlying relationships (such as family, couple, team, etc.) and possible scenes (such as sports, conferences, banquets, etc.) to ensure the diversity of returned results. based on any one of these specifications, corresponding multi-human images are located by performing internet searches over creative commons licensed imagery. for each identified image, the contained human number and the corresponding url are stored in a spreadsheet. automated scrapping software is used to download the multi-human imagery and stores all relevant information in a relational database. moreover, a pool of images containing clearly visible persons with interactions and rich fashion items is also constructed from the existing human-centric datasets to augment and complement internet scraping results. after curating the imagery, manual annotation is conducted by professional data annotators, which includes two distinct tasks. the first task is manually counting the number of foreground persons and duplicating each image to several copies according to the count number. each duplicated image is marked with the image id, the contained person number and a self-index. the second is assigning the fine-grained pixel-wise label to each semantic category for each person instance. we implement an annotation tool and generate multi-scale superpixels of images based on to speed up the annotation. see fig. [reference] for an example. each multi-human image contains at least two instances. the annotation for each instance is done in a left-to-right order, corresponding to the duplicated image with the self-index from beginning to end. for each instance, 58 semantic categories are defined and annotated, including cap/ hat, helmet, face, hair, left-arm, right-arm, left-hand, right-hand, protector, bikini/ bra, jacket/ windbreaker/ hoodie, t-shirt, polo-shirt, sweater, singlet, torso-skin, pants, shorts/ swim-shorts, skirt, stockings, socks, left-boot, right-boot, left-shoe, right-shoe, left-highheel, right-highheel, left-sandal, right-sandal, left-leg, right-leg, left-foot, right-foot, coat, dress, robe, jumpsuits, other-full-body-clothes, headwear, backpack, ball, bats, belt, bottle, carrybag, cases, sunglasses, eyewear, gloves, scarf, umbrella, wallet/ purse, watch, wristband, tie, other-accessaries, other-upper-body-clothes and other-lower-body-clothes. each instance has a complete set of annotations whenever the corresponding category appears in the current image. when annotating one instance, others are regarded as background. thus, the resulting annotation set for each image consists of instance-level parsing masks, where is the number of persons in the image. after annotation, manual inspection is performed on all images and corresponding annotations to verify the correctness. in cases where annotations are erroneous, the information is manually rectified by 5 well informed analysts. the whole work took around three months to accomplish by 25 professional data annotators. subsection: dataset splits and statistics in total, there are 25, 403 images in the mhp v2.0 dataset. each image contains 2-26 person instances, with 3 on average. the resolution of the images ranges from 85 100 to 4, 511 6, 919, with 644 718 on average. we spit the images into training, validation and testing sets. following random selection, we arrive at a unique split consisting of 15, 403 training and 5, 000 validation images with publicly available annotations, as well as 5, 000 testing images with annotations withheld for benchmarking purpose. the statistics w.r.t. data distribution on 59 semantic categories, the average semantic category number per image and the average instance number per image in the mhp v2.0 dataset are illustrated in fig. [reference] (a), (b) and (c), respectively. in general, face, arms and legs are the most remarkable parts of a human body. however, understanding humans in crowded scenes needs to analyze fine-grained details of each person of interest, including different body parts, clothes and accessaries. we therefore define 11 body parts, and 47 clothes and accessaries. among these 11 body parts, we divide arms, hands, legs and feet into left and right side for more precise analysis, which also increases the difficulty of the task. we define hair, face and torso-skin as the remaining three body parts, which can be used as auxiliary guidance for more comprehensive instance-level analysis. as for clothing categories, we have common clothes like coat, jacket/ windbreaker/ hoodie, sweater, singlet, pants, shorts/ swim-shorts and shoes, confusing categories such as t-shirt v.s. polo-shirt, stockings v.s. socks, skirt v.s. dress and robe, and boots v.s. sandals and highheels, and infrequent categories such as cap/ hat, helmet, protector, bikini/ bra, jumpsuits, gloves and scarf. furthermore, accessaries like sunglasses, belt, tie, watch and bags are also taken into account, which are common but hard to predict, especially for the small-scale ones. to summarize, the pre-defined semantic categories of mhp v2.0 involve most body parts, clothes and accessaries of different styles for men, women and children in all seasons. the images in the mhp v2.0 dataset contain diverse instance numbers, viewpoints, poses, occlusion, interactions and background complexities. mhp v2.0 aligns better with real-world scenarios and serves as a more realistic benchmark for human-centric analysis, which pushes the frontiers of fine-grained multi-human parsing research. section: deep nested adversarial networks as shown in fig. [reference], the proposed deep n ested a dversarial n etwork (nan) model consists of three gan-like sub-nets that jointly perform semantic saliency prediction, instance-agnostic parsing and instance-aware clustering end-to-end. nan produces accurate multi-human parsing results through a single forward-pass in a time-efficient manner without tedious pre-or post-processing. we now present each component in details. subsection: semantic saliency prediction large modality and interaction variations are the main challenge to multi-human parsing and also the key obstacle to learning a well-performing human-centric analysis model. to address this problem, we propose to decompose the original task into three granularities and adaptively impose a prior on the specific process, each with the aid of a gan-based sub-net. this reduces the training complexity and leads to better empirical performance with limited data. the first sub-net estimates semantic saliency maps to locate the most noticeable and eye-attracting human regions in images, which serves as a basic prior to facilitate further processing on humans, as illustrated in fig. [reference] left. we formulate semantic saliency prediction as a binary pixel-wise labelling problem to segment out foreground v.s. background. inspired by the recent success of f ully c onvolutional n etwork s (fcns) based methods on image-to-image applications, we leverage an fcn backbone (fcn-8s) as the generator of nan for semantic saliency prediction, where denotes the network parameters, and,, and denote the image height, width, channel number and semantic category (i.e., foreground plus background) number, repectively. formally, let the input rgb image be denoted by and the semantic saliency map be denoted by, then the key requirements for are that the semantic saliency map should present indistinguishable properities compared with a real one (i.e., ground truth) in appearance while preserving the intrinsic contextually remarkable information. to this end, we propose to learn by minimizing a combination of two losses: where is the adv ersarial loss for refining realism and alleviating artifacts, is the s emantic s aliency loss for pixel-wise image labelling, are weighting parameters among different losses. is a pixel-wise cross-entropy loss calculated based on the binary pixel-wise annotations to learn: is proposed to narrow the gap between the distributions of generated and real results. to facilitate this process, we leverage a c onvolutional n eural n etwork (cnn) backbone as the discriminator to be as simple as possible to avoid typical gan tricks. we alternatively optimize and to learn and: where denotes the binary real v.s. fake indicator. subsection: instance-agnostic parsing the second sub-net concatenates the information from the original rgb image with semantic saliency prior as input and estimates a fine-grained instance-agnostic parsing map, which further serves as stronger semantic guidance from the global perspective to facilitate instance-aware clustering, as illustrated in fig. [reference] middle. we formulate instance-agnostic parsing as a multi-class dense classification problem to mask semantically consistent regions of body parts and fashion items. inspired by the leading performance of the skip-net on recognition tasks, we modify a skip-net (ws-resnet) into an fcn-based architecture as the generator of nan to learn a highly non-linear transformation for instance-agnostic parsing, where denotes the network parameters for the generator and denotes the semantic category number. the prediction is downsampled by for accuracy v.s. speed trade-off. contextual information from global and local regions compensates each other and naturally benefits human parsing. the hierarchical features within a skip-net are multi-scale in nature due to the increasing receptive field sizes, which are combined together via skip connections. such a combined representation comprehensively maintains the contextual information, which is crucial for generating smooth and accurate parsing results. formally, let the instance-agnostic parsing map be denoted by, then similar to the first sub-net, we propose to learn by minimizing: where is the g lobal p arsing loss for semantic part labelling. is a standard pixel-wise cross-entropy loss calculated based on the multi-class pixel-wise annotations to learn. is also slightly finetuned due to the hinged gradient backpropagation route within the nested structure: is proposed to ensure the correctness and realism of the current phase and also the previous one for information flow consistency. to facilitate this process, we leverage a same cnn backbone with as the discriminator, which are learned separately. we alternatively optimize and to learn, and slightly finetune: subsection: instance-aware clustering the third sub-net concatenates the information from the original rgb image with semantic saliency and instance-agnostic parsing priors as input and estimates an instance-aware clustering map by associating each semantic parsing mask to one of the person instances in the scene, as illustrated in fig. [reference] right. inspired by the observation that a human glances at an image and instantly knows how many and where the objects are in the image, we formulate instance-aware clustering by parallelly inferring the instance number and pixel-wise instance location, discarding the requirement of time-consuming region proposal generation. we modify a same backbone architecture to incorporate two sibling branches as the generator of nan for location-sensitive learning, where denotes the network parameters for the generator and denotes the pre-defined instance location coordinate number. as multi-scale features integrating both global and local contextual information are crucial for increasing location prediction accuracy, we further augment the pixel-wise instance location prediction branch with a m ulti-s cale f usion u nit (msfu) to fuse shallow -, middle-and deep-level features, while using the feature maps downsampled by concatenated with feature maps from the first branch for instance number regression. formally, let the pixel-wise instance location map be denoted by and the instance number be denoted by, then we propose to learn by minimizing: where is the p ixel-wise i nstance l ocation loss for pixel-wise instance location regression and is the i nstance n umber loss for instance number regression. is a standard smooth-loss calculated based on the foreground pixel-wise instance location annotations to learn. since a person instance can be identified by its top-left corner and bottom-right corner of the surrounding bounding box, for each pixel belonging to the person instance, the pixel-wise instance location vector is defined as, where and are the width and height of the person instance for normalization, respectively. is a standard loss calculated based on the instance number annotations to learn. and are also slightly finetuned due to the chained schema within the nest: given these information, instance-aware clustering maps can be effortlessly generated with little computational overhead, which are denoted by. similar to, is proposed to ensure the correctness and realism of all phases for the information flow consistency. to facilitate this process, we leverage a same cnn backbone with as the discriminator, which are learned separately. we alternatively optimize and to learn, and slightly finetune and: subsection: training and inference the goal of nan is to use sets of real targets to learn three gan-like sub-nets that mutually boost and jointly accomplish multi-human parsing. each separate loss serves as a deep supervision within the nested structure benefitting network convergence. the overall objective function for nan is clearly, the nan is end-to-end trainable and can be optimized with the proposed nested adversarial learning strategy and bp algorithm. during testing, we simply feed the input image into nan to get the instance-agnostic parsing map from, pixel-wise instance location map and instance number from. then we employ an off-the-shelf clustering method to obtain the instance-aware clustering map. example results are visualized in fig. [reference]. section: experiments we evaluate nan qualitatively and quantitatively under various settings and granularities for understanding humans in crowded scenes. in particular, we evaluate multi-human parsing performance on the mhp v2.0 dataset proposed in this work, as well as the mhp v1.0 and pascal-person-part benchmark datasets. we also evaluate instance-agnostic parsing and instance-aware clustering results on the buffy benchmark dataset, which are byproducts of nan. subsection: experimental settings subsubsection: implementation details throughout the experiments, the sizes of the rgb image, the semantic saliency prediction, inputs to the discriminator and inputs to the generator are fixed as; the sizes of the instance-agnostic parsing prediction, instance-aware clustering prediction, inputs to the discriminator, inputs to the generator, inputs to the discriminator and instance location map are fixed as; the channel number of the pixel-wise instance location map is fixed as, incorporating two corner points of the associated bounding box; the constraint factors are empirically fixed as and, respectively; the generator is initialized with fcn-8s by replacing the last layer with a new convolutional layer with kernel size, pretrained on pascal-voc-2011 and finetuned on the target dataset; the generator is initialized with ws-resnet by eliminating the spatial pooling layers, increasing the strides of the first convolutional layers up to 2 in b, eliminating the top-most global pooling layer and the linear classifier, and adding two new convolutional layers with kernel sizes and, pretrained on imagenet and pascal-voc-2012, and finetuned on the target dataset; the generator is initialized with the same backbone architecture and pre-trained weights with (which are learned separately), by further augmenting it with two sibling branches for pixel-wise instance location map prediction and instance number prediction, where the first branch utilizes a msfu (three convolutional layers with kernal sizes for specific scale adaption) ended with a convolutional layer with kernel size for multi-scale feature aggregation and a final convolutional layer with kernel size for location regression and the second branch utilizes the feature maps downsampled by 8 concatenated with the feature maps from the first branch ended with a global pooling layer, a hidden 512-way fully-connected layer and a final 1-way fully-connected layer for instance number regression; the three discriminators (which are learned separately) are all initialized with a vgg-16 by adding a new convolutional layer at the very begining with kernel size for input adaption, and replacing the last layer with a new 1-way fully-connected layer activated by sigmoid, pre-trained on imagenet and finetuned on the target dataset; the newly added layers are randomly initialized by drawing weights from a zero-mean gaussian distribution with standard deviation; we employ an off-the-shelf clustering method to obtain the instance-aware clustering map; the dropout ratio is empirically fixed as; the weight decay and batch size are fixed as and, respectively; we use an initial learning rate of for pre-trained layers, and for newly added layers in all our experiments; we decrease the learning rate to of the previous one after 20 epochs and train the network for roughly 60 epochs one after the other; the proposed network is implemented based on the publicly available tensorflow platform, which is trained using adam () on four nvidia geforce gtx titan x gpus with 12 g memory; the same training setting is utilized for all our compared network variants; we evaluate the testing time by averaging the running time for images on the target set on nvidia geforce gtx titan x gpu and intel core i7-4930 k cpu@3.40ghz; our nan can rapidly process one image in about 1 second, which compares much favorably to other state-of-the-art approaches, as the current state-of-the-art methods rely on region proposal preprocessing and complex processing steps. subsubsection: evaluation metrics following, we use the a verage p recision based on p art () and p ercentage of c orrectly parsed semantic p arts (pcp) metrics for multi-human parsing evaluation. different from the a verage p recision based on r egion () used in instance segmentation, uses part-level pixel i ntersection o ver u nion (iou) of different semantic part categories within a person instance to determine if one instance is a true positive. we prefer over as we focus on human-centric analysis and we aim to investigate to how well a person instance as a whole is parsed. additionally, we also report the, which is the mean of the at iou thresholds ranging from to, in increments of 0.1. as averages the iou of each semantic part category, it fails to reflect how many semantic parts are correctly parsed. we further incorporate the pcp, originally used in human pose estimation, to evaluate the parsing quality within person instances. for each true-positive person instance, we find all the semantic categories (excluding background) with pixel iou larger than a threshold, which are regarded as correctly parsed. the pcp of one person instance is the ratio between the correctly parsed semantic category number and the total semantic category number of that person. missed person instances are assigned with pcp. the overall pcp is the average pcp for all person instances. note that pcp is also a human-centric evaluation metric. subsection: evaluations on the mhp v2.0 benchmark the mhp v2.0 dataset proposed in this paper is the largest and most comprehensive multi-human parsing benchmark to date, which extends mhp v1.0 to push the frontiers of understanding humans in crowded scenes by containing 25, 403 elaborately annotated images with 58 fine-grained semantic category labels. annotation examples are visualized in fig. [reference] (c). the data are randomly organized into 3 splits, consisting of 15, 403 training and 5, 000 validation images with publicly available annotations, as well as 5, 000 testing images with annotations withheld for benchmarking purpose. evaluation systems report the and pcp over the validation and testing sets. subsubsection: component analysis we first investigate different architectures and loss function combinations of nan to see their respective roles in multi-human parsing. we compare 16 variants from four aspects, i.e., different baselines (mask r-cnn and mh-parser), different network structures (w/ o, w/ o concatenated input (rgb only), w/ o concatenated input (rgb only), w/ o, w/ o, w/ o concatenated input, w/ o, w/ o concatenated input, w/ o msfu), our proposed nan, and upperbounds (: use the ground truth semantic saliency maps instead of prediction while keeping other settings the same;: use the ground truth instance-agnostic parsing maps instead of prediction while keeping other settings the same;: use the ground truth instance number instead of prediction while keeping other settings the same;: use the ground truth pixel-wise instance location maps instead of prediction while keeping other settings the same). the performance comparison in terms of@iou=0.5, and pcp@iou=0.5 on the mhp v2.0 validation set is reported in tab. [reference]. by comaring the results from the v.s. panels, we observe that our proposed nan consistently outperforms the baselines mask r-cnn and mh-parser by a large margin, i.e., and in terms of, and in terms of, and and in terms of pcp. mask r-cnn suffers difficulties to differentiate entangled humans. mh-parser involves multiple stages for instance localization, human parsing and result refinement with high complexity, yielding sub-optimal results, whereas nan parses semantic categories, differentiates different person instances and refines results simultaneously through deep nested adversarial learning in an effective yet time-efficient manner. by comaring the results from the v.s. panels, we observe that nan consistently outperforms the 9 variants in terms of network structure. in particular, w/ o refers to truncating the semantic saliency prediction sub-net from nan, leading to, and performance drop in terms of all metrics. this verifies the necessity of semantic saliency prediction that locates the most noticeable human regions in images to serve as a basic prior to facilitate further human-centic processing. the superiority of incorporating adaptive prior information to specific process can be verified by comparing w/ o concatenated input with nan, i.e.,, and;, and differences in terms of all metrics. the superiority of incorporating adversarial learning to specific process can be verified by comparing w/ o with nan, i.e.,, and;, and;, and decrease in terms of all metrics. nested adversarial learning strategy ensures the correctness and realism of all phases for information flow consistency, the superiority of which is verified by comparing w/ o concatenated input with nan, i.e.,, and;, and decline in terms of all metrics. msfu dynamically fuses multi-scale features for enhancing instance-aware clustering accuracy, the superiority of which is verified by comparing w/ o msfu with nan, i.e.,, and drop in terms of all metrics. finally, we also evaluate the limitations of our current algorithm. by comparing with nan, only, and improvement in term of all metrics are obtained, which shows that the errors from semantic saliency prediction are already small and have only little effect on the final results. a large gap between, and of and, and of nan shows that a better instance-agnostic parsing network architecture can definitely help improve the performance of multi-human parsing under our nan framework. by comparing and with nan,, and;, and improvement in term of all metrics are obtained, which shows that accurate instance-aware clustering results are critical for superior multi-human parsing. subsubsection: quantitative comparison the performance comparison of the proposed nan with two state-of-the-art methods in terms of@iou=0.5, and pcp@iou=0.5 on the mhp v2.0 testing set is reported in tab. [reference]. following, we conduct experiments under three settings: all reports the evaluation over the whole testing set; inter%20 reports the evaluation over the sub-set containing the images with top 20% interaction intensity; inter%10 reports the evaluation over the sub-set containing the images with top 10% interaction intensity. our nan is significantly superior over other state-of-the-arts on setting-1. in particular, nan improves the-best by, and in terms of all metrics. for the more challenging scenarios with intensive interactions (setting-2, 3), nan also consistently achieves the best performance. in particular, for inter%20 and inter%10, nan improves the-best by, and;, and in terms of all metrics. this verifies the effectiveness of our nan for multi-human parsing and understanding humans in crowded scenes. moreover, nan can rapidly process one 512 512 image in about 1 second with acceptable resource consumption, which is attractive to real applications. this compares much favorably to mh-parser (14.94 img/ s), which relies on separate and complex post-processing (including crf) steps. subsubsection: qualitative comparison fig. [reference] visualizes the qualitative comparison of the proposed nan with two state-of-the-art methods and corresponding ground truths on the mhp v2.0 dataset. note that mask r-cnn only offers silhouettes of different person instances, we only compare our instance-aware clustering results with it while comparing our holistic results with mh-parser. it can be observed that the proposed nan performs well in multi-human parsing with a wide range of viewpoints, poses, occlusion, interactions and background complexity. the instance-agnostic parsing and instance-aware clustering predictions of nan present high consistency with corresponding ground truths, thanks to the novel network structure and effective training strategy. in contrast, mask r-cnn suffers difficulties to differentiate entangled humans, while mh-parser struggles to generate fine-grained parsing results and clearly segmented instance masks. this further desmonstrates the effectiveness of the proposed nan. we also show some failure cases of our nan in fig. [reference]. as can be observed, humans in crowded scenes with heavy occlusion, extreme poses and intensive interactions are difficult to identify and segment. some small-scale semantic categories within person instances are difficult to parse. this confirms that mhp v2.0 aligns with real-world situations and deserves more furture attention and research efforts. subsection: evaluations on the mhp v1.0 benchmark the mhp v1.0 dataset is the first multi-human parsing benchmark, originally proposed by li et al., which contains 4, 980 images annotated with 18 semantic labels. annotation examples are visualized in fig. [reference] (b). the data are randomly organized into 3 splits, consisting of 3, 000 training, 1, 000 validation and 1, 000 testing images with publicly available annotations. evaluation systems report the and pcp over the testing set. refer to for more details. the performance comparison of the proposed nan with three state-of-the-art methods in terms of@iou=0.5, and pcp@iou=0.5 on the mhp v1.0 testing set is reported in tab. [reference]. with the nested adversarial learning of semantic saliency prediction, instance-agnostic parsing and instance-aware clustering, our method outperforms the-best by for, for and for pcp. visual comparison of multi-human parsing results by nan and three state-of-the-art methods is provided in fig. [reference], which further validates the advantages of our nan over existing solutions. subsection: evaluations on the pascal-person-part benchmark the pascal-person-part dataset is a set of additional annotations for pascal-voc-2010. it goes beyond the original pascal object detection task by providing pixel-wise labels for six human body parts, i.e., head, torso, upper -/ lower-arms, and upper -/ lower-legs. the rest of each image is considered as background. there are 3, 535 images in the pascal-person-part dataset, which is split into separate training set containing 1, 717 images and testing set containing 1, 818 images. for fair comparison, we report the over the testing set for multi-human parsing. refer to for more details. the performance comparison of the proposed nan with two state-of-the-art methods in terms of@iou= and on the pascal-person-part testing set is reported in tab. [reference]. our method dramatically surpasses the-best by for and for. qualitative multi-human parsing results by nan are visualized in fig. [reference], which possess a high concordance with corresponding ground truths. this again verifies the effectiveness of our method for human-centric analysis. subsection: evaluations on the buffy benchmark the buffy dataset was released in 2011 for human parsing and instance segmentation, which contains 748 images annotated with 12 semantic labels. the data are randomly organized into 2 splits, consisting of 452 training and 296 testing images with publicly available annotations. for fair comparison, we report the f orward (f) and b ackward (b) scores over the episode 4, 5 and 6 for instance segmentation evaluation. refer to for more details. the performance comparison of the proposed nan with three state-of-the-art methods in terms of f and b scores on the buffy dataset episode 4, 5 and 6 is reported in tab. [reference]. our nan consistently achieves the best performance for all metrics. in particualr, nan significantly improves the-best by for f score and for b score, with an average boost of. qualitative instance-agnostic parsing and instance-aware clustering results by nan are visualized in fig. [reference], which well shows the promising potential of our method for fine-grained understanding humans in crowded scenes. section: conclusions in this work, we presented\" m ulti-h uman p arsing (mhp v2.0)\", a large-scale multi-human parsing dataset and a carefully designed benchmark to spark progress in understanding humans in crowded scenes. mhp v2.0 contains 25, 403 images, which are richly labelled with 59 semantic categories. we also proposed a novel deep n ested a dversarial n etwork (nan) model to address this challenging problem and performed detailed evaluations of the proposed method with current state-of-the-arts on mhp v2.0 and several other datasets. we envision the proposed mhp v2.0 dataset and the baseline method would drive the human parsing research towards real-world application scenario with simultaneous presence of multiple persons and complex interactions among them. in future, we will continue to take efforts to construct a more comprehensive multi-human parsing benchmark dataset with more images and more detailed semantic category annotations to further push the frontiers of multi-human parsing research. section: acknowledgement the work of jian zhao was partially supported by c hina s cholarship c ouncil (csc) grant 201503170248. the work of jiashi feng was partially supported by nus startup r-263-000-c08-133, moe tier-i r-263-000-c21-112, nus ids r-263-000-c67-646 and ecra r-263-000-c87-133. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "m"
                    ],
                    [
                        "mhp"
                    ],
                    [
                        "mhp v2.0"
                    ],
                    [
                        "mhp v2.0 dataset"
                    ],
                    [
                        "mhp v1.0"
                    ],
                    [
                        "pascal person part"
                    ],
                    [
                        "mhp v2.0 dataset"
                    ],
                    [
                        "mhp v2.0 dataset"
                    ],
                    [
                        "mhp v2.0 dataset"
                    ],
                    [
                        "mhp v2.0 validation set"
                    ]
                ],
                "Method": [
                    [
                        "deep nested adversarial learning"
                    ],
                    [
                        "deep n ested"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "understanding humans in crowded scenes"
                    ],
                    [
                        "multi human parsing"
                    ],
                    [
                        "parsing"
                    ],
                    [
                        "multi human parsing"
                    ],
                    [
                        "multi human parsing task"
                    ],
                    [
                        "fine grained multi human parsing"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "mhp v1.0",
                        "mhp v1.0 benchmark"
                    ]
                ],
                "Method": [
                    [
                        "n ested a dversarial n etwork",
                        "nan",
                        "deep nested adversarial networks",
                        "nested adversarial learning strategy"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "multi-human parsing",
                        "mhp",
                        "m ulti-h uman p arsing",
                        "lip"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "mhp v2.0",
                        "mhp v2.0 dataset",
                        "mhp v2.0 benchmark"
                    ]
                ],
                "Method": [
                    [
                        "n ested a dversarial n etwork",
                        "nan",
                        "deep nested adversarial networks",
                        "nested adversarial learning strategy"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "multi-human parsing",
                        "mhp",
                        "m ulti-h uman p arsing",
                        "lip"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "pascal-person-part",
                        "pascal-person-part benchmark datasets"
                    ]
                ],
                "Method": [
                    [
                        "n ested a dversarial n etwork",
                        "nan",
                        "deep nested adversarial networks",
                        "nested adversarial learning strategy"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "multi-human parsing",
                        "mhp",
                        "m ulti-h uman p arsing",
                        "lip"
                    ]
                ]
            }
        ]
    },
    "27a99c21a1324f087b2f144adc119f04137dfd87-40": {
        "doctext": "document: deep fried convnets the fully-connected layers of deep convolutional neural networks typically contain over 90% of the network parameters. reducing the number of parameters while preserving predictive performance is critically important for training big models in distributed systems and for deployment in embedded devices. in this paper, we introduce a novel adaptive fastfood transform to reparameterize the matrix-vector multiplication of fully connected layers. reparameterizing a fully connected layer with inputs and outputs with the adaptive fastfood transform reduces the storage and computational costs costs from to and respectively. using the adaptive fastfood transform in convolutional networks results in what we call a deep fried convnet. these convnets are end-to-end trainable, and enable us to attain substantial reductions in the number of parameters without affecting prediction accuracy on the mnist and imagenet datasets. section: introduction in recent years we have witnessed an explosion of applications of convolutional neural networks with millions and billions of parameters. reducing this vast number of parameters would improve the efficiency of training in distributed architectures. it would also allow for the deployment of state-of-the-art convolutional neural networks on embedded mobile applications. these train and test time considerations are both of great importance. a standard convolutional network is composed of two types of layers, each with very different properties. convolutional layers, which contain a small fraction of the network parameters, represent most of the computational effort. in contrast, fully connected layers contain the vast majority of the parameters but are comparatively cheap to evaluate. this imbalance between memory and computation suggests that the efficiency of these two types of layers should be addressed in different ways. and both describe methods for minimizing computational cost of evaluating a network at test time by approximating the learned convolutional filters with separable approximations. these approaches realize speed gains at test time but do not address the issue of training, since the approximations are made after the network has been fully trained. additionally, neither approach achieves a substantial reduction in the number of parameters, since they both work with approximations of the convolutional layers, which represent only a small portion of the total number of parameters. many other works have addressed the computational efficiency of convolutional networks in more specialized settings. in contrast to the above approaches, demonstrates that there is significant redundancy in the parameterization of several deep learning models, and exploits this to reduce the number of parameters. more specifically, their method represents the parameter matrix as a product of two low rank factors, and the training algorithm fixes one factor (called static parameters) and only updates the other factor (called dynamic parameters). uses low-rank matrix factorization to reduce the size of the fully connected layers at train time. they demonstrate large improvements in reducing the number of parameters of the output softmax layer, but only modest improvements for the hidden fully connected layers. implements low-rank factorizations using the svd after training the full model. in contrast, the methods advanced in and this paper apply both at train and test time. in this paper we show how the number of parameters required to represent a deep convolutional neural network can be substantially reduced without sacrificing predictive performance. our approach works by replacing the fully connected layers of the network with an adaptive fastfood transform, which is a generalization of the fastfood transform for approximating kernels. convolutional neural networks with adaptive fastfood transforms, which we refer to as deep fried convnets, are end-to-end trainable and achieve the same predictive performance as standard convolutional networks on imagenet using approximately half the number of parameters. several works have considered kernel methods in deep learning. the doubly stochastic gradients method of showed that effective use of randomization can allow kernel methods to scale to extremely large data sets. however, the approach used fixed convolutional features, and can not jointly learn the kernel classifier and convolutional filters. showed how to learn a kernel function in an unsupervised manner. there have been other attempts to replace the fully connected layers. the network in network architecture of achieves state of the art results on several deep learning benchmarks by replacing the fully connected layers with global average pooling. a similar approach was used by to win the ilsvrc 2014 object detection competition. although the global average pooling approach achieves impressive results, it has two significant drawbacks. first, feature transfer is more difficult with this approach. it is very common in practice to take a convolutional network trained on imagenet and re-train the top layer on a different data set, re-using the features learned from imagenet for the new task (potentially with fine-tuning), and this is difficult with global average pooling. this deficiency is noted by, and motivates them to add an extra linear layer to the top of their network to enable them to more easily adapt and fine tune their network to other label sets. the second drawback of global average pooling is computation. convolutional layers are much more expensive to evaluate than fully connected layers, so replacing fully connected layers with more convolutions can decrease model size but comes at the cost of increased evaluation time. in parallel or after the first (technical report) version of this work, several researchers have attempted to create sparse networks by applying pruning or sparsity regularizers. these approaches however require training the original full model and, consequently, do not enjoy the efficient training time benefits of the techniques proposed in this paper. since then, hashing methods have also been advanced to reduce the number of parameters. hashes have irregular memory access patterns and, consequently, good performance on large gpu-based platforms is yet to be demonstrated. finally, distillation also offers a way of compressing neural networks, as a post-processing step. section: the adaptive fastfood transform large dense matrices are the main building block of fully connected neural network layers. in propagating the signal from the-th layer with activations to the-th layer with activations, we have to compute the storage and computational costs of this matrix multiplication step are both. the storage cost in particular can be prohibitive for many applications. our proposed solution is to reparameterize the matrix of parameters with an adaptive fastfood transform, as follows in section [reference], we will provide background and intuitions behind this design. for now it suffices to state that the storage requirements of this reparameterization are and the computational cost is. we will also show in the experimental section that these theoretical savings are mirrored in practice by significant reductions in the number of parameters without increased prediction errors. to understand these claims, we need to describe the component modules of the adaptive fastfood transform. for simplicity of presentation, let us first assume that. adaptive fastfood has three types of module: and are diagonal matrices of parameters. in the original non-adaptive fastfood formulation they are random matrices, as described further in section [reference]. the computational and storage costs are trivially. is a random permutation matrix. it can be implemented as a lookup table, so the storage and computational costs are also. denotes the walsh-hadamard matrix, which is defined recursively as the fast hadamard transform, a variant of fast fourier transform, enables us to compute in time. in summary, the overall storage cost of the adaptive fastfood transform is, while the computational cost is. these are substantial theoretical improvements over the costs of ordinary fully connected layers. when the number of output units is larger than the number of inputs, we can perform adaptive fastfood transforms and stack them to attain the desired size. in doing so, the computational and storage costs become and respectively, as opposed to the more substantial costs for linear modules. the number of outputs can also be refined with pruning. subsection: learning fastfood by backpropagation the parameters of the adaptive fastfood transform (and) can be learned by standard error derivative backpropagation. moreover, the backward pass can also be computed efficiently using the fast hadamard transform. in particular, let us consider learning the-th layer of the network,. for simplicity, let us again assume that and that. using backpropagation, assume we already have, where is the objective function, then since is a diagonal matrix, we only need to calculate the derivative with respect to the diagonal entries and this step requires only operations. proceeding in this way, denote the partial products by then the gradients with respect to different parameters in the fastfood layer can be computed recursively as follows: note that the operations in and are simply applications of the hadamard transform, since, and consequently can be computed in time. the operation in is an application of a permutation (the transpose of permutation matrix is a permutation matrix) and can be computed in time. all other operations are diagonal matrix multiplications. section: intuitions behind adaptive fastfood the proposed adaptive fastfood transform may be understood either as a trainable type of structured random projection or as an approximation to the feature space of a learned kernel. both views not only shed light on adaptive fastfood and competing techniques, but also open up room to innovate new techniques to reduce computation and memory in neural networks. subsection: a view from structured random projections adaptive fastfood is based on the fastfood transform, in which the diagonal matrices, and have random entries. in the experiments, we will compare the performance of the existing random and proposed adaptive versions of fastfood when used to replace fully connected layers in convolutional neural networks. the intriguing idea of constructing neural networks with random weights has been reasonably explored in the neural networks field. this idea is related to random projections, which have been deeply studied in theoretical computer science. in a random projection, the basic operation is of the form where is a random matrix, either gaussian or binary. importantly, the embeddings generated by these random projections approximately preserve metric information, as formalized by many variants of the celebrated johnson-lindenstrauss lemma. the one shortcoming of random projections is that the cost of storing the matrix is. using a sparse random matrix by itself to reduce this cost is often not a viable option because the variance of the estimates of can be very high for some inputs, for example when is also sparse. to see this, consider the extreme case of a very sparse input, then many of the products with will be zero and hence not help improve the estimates of metric properties of the embedding space. one popular option for reducing the storage and computational costs of random projections is to adopt random hash functions to replace the random matrix multiplication. for example, the count-sketch algorithm uses pairwise independent hash functions to carry this job very effectively in many applications. this technique is often referred to as the hashing trick in the machine learning literature. hashes have irregular memory access patterns, so it is not clear how to get good performance on gpus when following this approach, as pointed out in. ailon and chazelle introduced an alternative approach that is not only very efficient, but also preserves most of the desirable theoretical properties of random projections. their idea was to replace the random matrix by a transform that mimics the properties of random matrices, but which can be stored efficiently. in particular, they proposed the following phd transform: where is a sparse random matrix with gaussian entries, is a hadamard matrix and is a diagonal matrix with entries drawn independently with probability. the inclusion of the hadamard transform avoids the problems of using a sparse random matrix by itself, but it is still efficient to compute. we can think of the original fastfood transform as an alternative to this. fastfood reduces the computation and storage of random projections to and respectively. in the original formulation and are diagonal random matrices, which are computed once and then stored. in contrast, in our proposed adaptive fastfood transform, the diagonal matrices are learned by backpropagation. by adapting, we are effectively implementing automatic relevance determination on features. the matrix controls the bandwidth of the kernel and its spectral incoherence. finally, represents different kernel types. for example, for the rbf kernel follows chi-squared distribution. by adapting, we learn the correct kernel type. while we have introduced fastfood in this section, it was originally proposed as a fast way of computing random features to approximate kernels. we expand on this perspective in the following section. subsection: a view from kernels there is a nice duality between inner products of features and kernels. this duality can be used to design neural network modules using kernels and vice-versa. for computational reasons, we often want to determine the features associated with a kernel. working with features is preferable when the kernel matrix is dense and large. (storing this matrix requires space, and computing it takes operations, where is the number of data points and is the dimension.) we might also want to design statistical methods using kernels and then map these designs to features that can be used as modules in neural networks. unfortunately, one of the difficulties with this line of attack is that deriving features from kernels is far from trivial in general. an important fact, noted in, is that infinite kernel expansions can be approximated in an unbiased manner using randomly drawn features. for shift-invariant kernels this relies on a classical result from harmonic analysis, known as bochner's lemma, which states that a continuous shift-invariant kernel on is positive definite if and only if is the fourier transform of a non-negative measure. this measure, known as the spectral density, in turn implies the existence of a probability density such that where the imaginary part is dropped since both the kernel and distribution are real. we can apply monte carlo methods to approximate the above expectation, and hence approximate the kernel with an inner product of stacked cosine and sine features. specifically, suppose we sample vectors from and collect them in a matrix. the kernel can then be approximated as the inner-product of the following random features: that is, is the neural network module, consisting of a linear layer and entry-wise nonlinearities (cosine and sine in the above equation), that corresponds to a particular implicit kernel function. approximating a given kernel function with random features requires the specification of a sampling distribution. such distributions have been derived for many popular kernels. for example, if we want the implicit kernel to be a squared exponential kernel, we know that the distribution must be gaussian:. in other words, if we draw the rows of from this gaussian distribution and use equation ([reference]) to implement a neural module, we are implicitly approximating a squared exponential kernel. as another example of the mapping between kernels and random features, introduced the rotationally invariant arc-cosine kernel where is the angle between and. then by choosing to be a random gaussian matrix, they showed that this kernel can be approximated with rectified linear unit (relu) features: the fastfood transform was introduced to replace in equation [reference] with, thus decreasing the computational and storage costs. section: deep fried convolutional networks we propose to greatly reduce the number of parameters of the fully connected layers by replacing them with an adaptive fastfood transform followed by a nonlinearity. we call this new architecture a deep fried convolutional network. an illustration of this architecture is shown in figure [reference]. in principle, we could also apply the adaptive fastfood transform to the softmax classifier. however, reducing the memory cost of this layer is already well studied; for example, show that low-rank matrix factorization can be applied during training to reduce the size of the softmax layer substantially. importantly, they also show that training a low rank factorization for the internal layers performs poorly, which agrees with the results of. for this reason, we focus our attention on reducing the size of the internal layers. section: mnist experiment the first problem we study is the classical mnist optical character recognition task. this simple task serves as an easy proof of concept for our method, and contrasting the results in this section with our later experiments gives insights into the behavior of the adaptive fastfood transform at different scales. as a reference model we use the caffe implementation of the lenet convolutional network. it achieves an error rate of on the mnist dataset. we jointly train all layers of the deep fried network (including convolutional layers) from scratch. we compare both the adaptive and non-adaptive fastfood transforms using 1024 and 2048 features. for the non-adaptive transforms we report the best performance achieved by varying the standard deviation of the random gaussian matrix over the set, and for the adaptive variant we learn these parameters by backpropagation as described in section [reference]. the results of the mnist experiment are shown in table [reference]. because the width of the deep fried network is substantially larger than the reference model, we also experimented with adding dropout in the model, which increased performance in the deep fried case. deep fried networks are able to obtain high accuracy using only a small fraction of of parameters of the original network (11 times reduction in the best case). interestingly, we see no benefit from adaptation in this experiment, with the more powerful adaptive models performing equivalently or worse than their non-adaptive counterparts; however, this should be contrasted with the imagenet results reported in the following sections. section: imagenet experiments we now examine how deep fried networks behave in a more realistic setting with a much larger dataset and many more classes. specifically, we use the imagenet ilsvrc-2012 dataset which has 1.2 m training examples and 50 k validation examples distributed across 1000 classes. we use the the caffe imagenet model as the reference model in these experiments. this model is a modified version of alexnet, and achieves top-1 error on the ilsvrc-2012 validation set. the initial layers of this model are a cascade of convolution and pooling layers with interspersed normalization. the last several layers of the network take the form of an mlp and follow a 9216-4096-4096-1000 architecture. the final layer is a logistic regression layer with 1000 output classes. all layers of this network use the relu nonlinearity, and dropout is used in the fully connected layers to prevent overfitting. there are total of 58, 649, 184 parameters in the reference model, of which 58, 621, 952 are in the fully connected layers and only 27, 232 are in the convolutional layers. the parameters of fully connected layer take up of the total number of parameters. we show that the adaptive fastfood transform can be used to substantially reduce the number of parameters in this model. subsection: fixed feature extractor previous work on applying kernel methods to imagenet has focused on building models on features extracted from the convolutional layers of a pre-trained network. this setting is less general than training a network from scratch but does mirror the common use case where a convolutional network is first trained on imagenet and used as a feature extractor for a different task. in order to compare our adaptive fastfood transform directly to this previous work, we extract features from the final convolutional layer of a pre-trained reference model and train an adaptive fastfood transform classifier using these features. although the reference model uses two fully connected layers, we investigate replacing these with only a single fastfood transform. we experiment with two sizes for this transform: fastfood 16 and fastfood 32 using 16, 384 and 32, 768 fastfood features respectively. since the fastfood transform is a composite module, we can apply dropout between any of its layers. in the experiments reported here, we applied dropout after the matrix and after the matrix. we also applied dropout to the last convolutional layer (that is, before the matrix). we also train an mlp with the same structure as the top layers of the reference model for comparison. in this setting it is important to compare against the re-trained mlp rather than the jointly trained reference model, as training on features extracted from fixed convolutional layers typically leads to lower performance than joint training. the results of the fixed feature experiment are shown in table [reference]. following and we observe that training on imagenet activations produces significantly lower performance than of the original, jointly trained network. nonetheless, deep fried networks are able to outperform both the re-trained mlp model as well as the results in while using fewer parameters. in contrast with our mnist experiment, here we find that the adaptive fastfood transform provides a significant performance boost over the non-adaptive version, improving top-1 performance by 4.5-6.5%. subsection: jointly trained model finally, we train a deep fried network from scratch on imagenet. with 16, 384 features in the fastfood layer we lose less than 0.3% top-1 validation performance, but the number of parameters in the network is reduced from 58.7 m to 16.4 m which corresponds to a factor of 3.6x. by further increasing the number of features to 32, 768, we are able to perform 0.6% better than the reference model while using approximately half as many parameters. results from this experiment are shown in table [reference]. nearly all of the parameters of the deep fried network reside in the final softmax regression layer, which still uses a dense linear transformation, and accounts for more than 99% of the parameters of the network. this is a side effect of the large number of classes in imagenet. for a data set with fewer classes the advantage of deep fried convolutional networks would be even greater. moreover, as shown by, the last layer often contains considerable redundancy. we also note that any of the techniques from could be applied to the final layer of a deep fried network to further reduce memory consumption at test time. we illustrate this with low-rank matrix factorization in the following section. section: comparison with post processing in this section we provide a comparison to some existing works on reducing the number of parameters in a convolutional neural network. the techniques we compare against here are post-processing techniques, which start from a full trained model and attempt to compress it, whereas our method trains the compressed network from scratch. matrix factorization is the most common method for compressing neural networks, and has proven to be very effective. given the weight matrix of fully connected layers, we factorize it as where and and is a diagonal matrix. in order to reduce the parameters, we truncate all but the largest singular values, leading to the approximation where and and has been absorbed into the other two factors. if is sufficiently small then storing and is less expensive than storing directly, and this parameterization is still learnable. it has been shown that training a factorized representation directly leads to poor performance (although it does work when applied only to the final logistic regression layer). however, first training a full model, then preforming an svd of the weight matrices followed by a fine tuning phase preserves much of the performance of the original model. we compare our deep fried approach to svd followed by fine tuning, and show that our approach achieves better performance per parameter in spite of training a compressed parameterization from scratch. we also compare against a post-processed version of our model, where we train a deep fried convnet and then apply svd plus fine-tuning to the final softmax layer, which further reduces the number of parameters. results of these post-processing experiments are shown in table [reference]. for the svd decomposition of each of the three fully connected layers in the reference model we set in svd-half and in svd-quarter. svd-half-f and svd-quarter-f mean that the model has been fine tuned after the decomposition. there is 1% drop in accuracy for svd-half and 3.5% drop for svd-quarter. even though the increase in the error for the svd can be mitigated by finetuning (the drop decreases to 0.1% for svd-half-f and 1.3% for svd-quarter-f), deep fried convnets still perform better both in terms of the accuracy and the number of parameters. applying a rank 600 svd followed by fine tuning to the final softmax layer of the adaptive fastfood 32 model removes an additional 12.5 m parameters at the expense of 0.7% top-1 error. for reference, we also include the results of collins and kohli, who pre-train a full network and use a sparsity regularizer during fine-tuning to encourage connections in the fully connected layers to be zero. they are able to achieve a significant reduction in the number of parameters this way, however the performance of their compressed network suffers when compared to the reference model. another drawback of this method is that using sparse weight matrices requires additional overhead to store the indexes of the non-zero values. the index storage takes up space and using sparse representation is better than using a dense matrix only when number of nonzero entries is small. section: conclusion many methods have been advanced to reduce the size of convolutional networks at test time. in contrast to this trend, the adaptive fastfood transform introduced in this paper is end-to-end differentiable and hence it enables us to attain reductions in the number of parameters even at train time. deep fried convnets capitalize on the proposed adaptive fastfood transform to achieve a substantial reduction in the number of parameters without sacrificing predictive performance on mnist and imagenet. they also compare favorably against simple test-time low-rank matrix factorization schemes. our experiments have also cast some light on the issue of random versus adaptive weights. the structured random transformations developed in the kernel literature perform very well on mnist without any learning; however, when moving to imagenet, the benefit of adaptation becomes clear, as it allows us to achieve substantially better performance. this is an important point which illustrates the importance of learning which would not have been visible from experiments only on small data sets. the fastfood transform allows for a theoretical reduction in computation from to. however, the computation in convolutional neural networks is dominated by the convolutions, and hence deep fried convnets are not necessarily faster in practice. it is clear looking at out results on imagenet in table 2 that the remaining parameters are mostly in the output softmax layer. the comparative experiment in section 7 showed that the matrix of parameters in the softmax can be easily compressed using the svd, but many other methods could be used to achieve this. one avenue for future research involves replacing the softmax matrix, at train and test times, using the abundant set of techniques that have been proposed to solve this problem, including low-rank decomposition, adaptive fastfood, and pruning. the development of gpu optimized fastfood transforms that can be used to replace linear layers in arbitrary neural models would also be of great value to the entire research community given the ubiquity of fully connected layers layers. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "mnist"
                    ],
                    [
                        "imagenet datasets"
                    ]
                ],
                "Method": [
                    [
                        "deep fried convnets"
                    ],
                    [
                        "adaptive fastfood transform"
                    ],
                    [
                        "fastfood transform"
                    ],
                    [
                        "lenet convolutional network"
                    ]
                ],
                "Metric": [
                    [
                        "top-1 error"
                    ],
                    [
                        "top-1 error"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "mnist",
                        "imagenet ilsvrc-2012 dataset"
                    ]
                ],
                "Method": [
                    [
                        "deep fried convnets",
                        "deep fried convnet",
                        "convnets",
                        "deep fried convolutional networks",
                        "deep fried convolutional network",
                        "deep fried network",
                        "deep fried networks"
                    ]
                ],
                "Metric": [
                    [
                        "prediction errors",
                        "error rate",
                        "top-1 error",
                        "error"
                    ]
                ],
                "Task": []
            }
        ]
    },
    "27aa0f3ec934925265f93fac7ff1cd1d70ceb618-41": {
        "doctext": "strong baselines for neural semi-supervised learning under domain shift section: abstract novel neural models have been proposed in recent years for learning under domain shift. most models, however, only evaluate on a single task, on proprietary datasets, or compare to weak baselines, which makes comparison of models difficult. in this paper, we re-evaluate classic general-purpose bootstrapping approaches in the context of neural networks under domain shifts vs. recent neural approaches and propose a novel multi-task tri-training method that reduces the time and space complexity of classic tri-training. extensive experiments on two benchmarks are negative: while our novel method establishes a new state-of-the-art for sentiment analysis, it does not fare consistently the best. more importantly, we arrive at the somewhat surprising conclusion that classic tri-training, with some additions, outperforms the state of the art. we conclude that classic approaches constitute an important and strong baseline. section: introduction deep neural networks (dnns) excel at learning from labeled data and have achieved state of the art in a wide array of supervised nlp tasks such as dependency parsing [reference], named entity recognition [reference], and semantic role labeling [reference]. in contrast, learning from unlabeled data, especially under domain shift, remains a challenge. this is common in many real-world applications where the distribution of the training and test data differs. many state-of-the-art domain adaptation approaches leverage task-specific characteristics such as sentiment words [reference][reference] or distributional features [reference][reference] which do not generalize to other tasks. other approaches that are in theory more general only evaluate on proprietary datasets [reference] or on a single benchmark [reference], which carries the risk of overfitting to the task. in addition, most models only compare against weak baselines and, strikingly, almost none considers evaluating against approaches from the extensive semi-supervised learning (ssl) literature [reference]. in this work, we make the argument that such algorithms make strong baselines for any task in line with recent efforts highlighting the usefulness of classic approaches [reference][reference]. we re-evaluate bootstrapping algorithms in the context of dnns. these are general-purpose semi-supervised algorithms that treat the model as a black box and can thus be used easily-with a few additions-with the current generation of nlp models. many of these methods, though, were originally developed with in-domain performance in mind, so their effectiveness in a domain adaptation setting remains unexplored. in particular, we re-evaluate three traditional bootstrapping methods, self-training [reference], tri-training [reference], and tritraining with disagreement [reference] for neural network-based approaches on two nlp tasks with different characteristics, namely, a sequence prediction and a classification task (pos tagging and sentiment analysis). we evaluate the methods across multiple domains on two wellestablished benchmarks, without taking any further task-specific measures, and compare to the best results published in the literature. we make the somewhat surprising observation that classic tri-training outperforms task-agnostic state-of-the-art semi-supervised learning [reference] and recent neural adaptation approaches [reference][reference]. in addition, we propose multi-task tri-training, which reduces the main deficiency of tri-training, namely its time and space complexity. it establishes a new state of the art on unsupervised domain adaptation for sentiment analysis but it is outperformed by classic tri-training for pos tagging. contributions our contributions are: a) we propose a novel multi-task tri-training method. b) we show that tri-training can serve as a strong and robust semi-supervised learning baseline for the current generation of nlp models. c) we perform an extensive evaluation of bootstrapping 1 algorithms compared to state-of-the-art approaches on two benchmark datasets. d) we shed light on the task and data characteristics that yield the best performance for each model. section: neural bootstrapping methods we first introduce three classic bootstrapping methods, self-training, tri-training, and tri-training with disagreement and detail how they can be used with neural networks. for in-depth details we refer the reader to [reference][reference][reference]). we introduce our novel multitask tri-training method in\u00a7 2.3. section: self-training self-training [reference][reference]) is one of the earliest and simplest bootstrapping approaches. in essence, it leverages the model's own predictions on unlabeled data to obtain additional information that can be used during training. typically the most confident predictions are taken at face value, as detailed next. self-training trains a model m on a labeled training set l and an unlabeled data set u. at each iteration, the model provides predictions m (x) in the form of a probability distribution over classes for all unlabeled examples x in u. if the probability assigned to the most likely class is higher than a predetermined threshold\u03c4, x is added to the labeled examples with p (x)= arg max m (x) as pseudo-label. this instantiation is the most widely used and shown in algorithm 1. calibration it is well-known that output probabilities in neural networks are poorly calibrated [reference]. using a fixed threshold\u03c4 is thus algorithm 1 self-training [reference] l\u2190 l\u222a {(x, p (x))} 6: until no more predictions are confident not the best choice. while the absolute confidence value is inaccurate, we can expect that the relative order of confidences is more robust. for this reason, we select the top n unlabeled examples that have been predicted with the highest confidence after every epoch and add them to the labeled data. this is one of the many variants for self-training, called throttling [reference]. we empirically confirm that this outperforms the classic selection in our experiments. online learning in contrast to many classic algorithms, dnns are trained online by default. we compare training setups and find that training until convergence on labeled data and then training until convergence using self-training performs best. classic self-training has shown mixed success. in parsing it proved successful only with small datasets [reference] or when a generative component is used together with a reranker in high-data conditions [reference][reference]. some success was achieved with careful task-specific data selection [reference], while others report limited success on a variety of nlp tasks [reference][reference][reference]. its main downside is that the model is not able to correct its own mistakes and errors are amplified, an effect that is increased under domain shift. section: tri-training tri-training [reference]) is a classic method that reduces the bias of predictions on unlabeled data by utilizing the agreement of three independently trained models. tri-training (cf. algorithm 2) first trains three models m 1, m 2, and m 3 on bootstrap samples of the labeled data l. an unlabeled data point is added to the training set of a model m i if the other two models m j and m k agree on its label. training stops when the classifiers do not change anymore. tri-training with disagreement [reference] algorithm 2 tri-training [reference] 1: for i\u2208 {1.. 3} do 2: for i\u2208 {1.. 3} do 6: for x\u2208 u do 8: 10: until none of m i changes 11: apply majority vote over m i is based on the intuition that a model should only be strengthened in its weak points and that the labeled data should not be skewed by easy data points. in order to achieve this, it adds a simple modification to the original algorithm (altering line 8 in algorithm 2), requiring that for an unlabeled data point on which m j and m k agree, the other model m i disagrees on the prediction. tri-training with disagreement is more data-efficient than tritraining and has achieved competitive results on part-of-speech tagging [reference]. sampling unlabeled data both tri-training and tri-training with disagreement can be very expensive in their original formulation as they require to produce predictions for each of the three models on all unlabeled data samples, which can be in the millions in realistic applications. we thus propose to sample a number of unlabeled examples at every epoch. for all traditional bootstrapping approaches we sample 10k candidate instances in each epoch. for the neural approaches we use a linearly growing candidate sampling scheme proposed by [reference], increasing the candidate pool size as the models become more accurate. confidence thresholding similar to selftraining, we can introduce an additional requirement that pseudo-labeled examples are only added if the probability of the prediction of at least one model is higher than some threshold\u03c4. we did not find this to outperform prediction without threshold for traditional tri-training, but thresholding proved essential for our method (\u00a7 2.3). the most important condition for tri-training and tri-training with disagreement is that the models are diverse. typically, bootstrap samples are used to create this diversity [reference][reference]. however, training separate models on bootstrap samples of a potentially large amount of training data is expensive and takes a lot of time. this drawback motivates our approach. section: multi-task tri-training in order to reduce both the time and space complexity of tri-training, we propose multi-task tritraining (mt-tri). mt-tri leverages insights from multi-task learning (mtl) [reference] to share knowledge across models and accelerate training. rather than storing and training each model separately, we propose to share the parameters of the models and train them jointly using mtl. 2 all models thus collaborate on learning a joint representation, which improves convergence. the output softmax layers are model-specific and are only updated for the input of the respective model. we show the model in figure 1 (as instantiated for pos tagging). as the models leverage a joint representation, we need to ensure that the features used for prediction in the softmax layers of the different models are as diverse as possible, so that the models can still learn from each other's predictions. in contrast, if the parameters in all output softmax layers were the same, the method would degenerate to self-training. to guarantee diversity, we introduce an orthogonality constraint [reference] as an additional loss term, which we define as follows: where|\u00b7 2 f is the squared frobenius norm and w m 1 and w m 2 are the softmax output parameters of the two source and pseudo-labeled output layers m 1 and m 2, respectively. the orthogonality constraint encourages the models not to rely on the same features for prediction. as enforcing pairwise orthogonality between three matrices is not possible, we only enforce orthogonality between the softmax output layers of m 1 and m 2, 3 while m 3 is gradually trained to be more target-specific. we parameterize l orth by\u03b3=0.01 following. we do not further tune\u03b3. more formally, let us illustrate the model by taking the sequence prediction task (figure 1) as illustration. given an utterance with labels y 1,.., y n, our multi-task tri-training loss consists of three task-specific (m 1, m 2, m 3) tagging loss functions (where h is the uppermost bi-lstm encoding): in contrast to classic tri-training, we can train the multi-task model with its three model-specific outputs jointly and without bootstrap sampling on the labeled source domain data until convergence, as the orthogonality constraint enforces different representations between models m 1 and m 2. from this point, we can leverage the pair-wise agreement of two output layers to add pseudo-labeled examples as training data to the third model. we train the third output layer m 3 only on pseudo-labeled target instances in order to make tri-training more robust to a domain shift. for the final prediction, majority voting of all three output layers is used, which resulted in the best instantiation, together with confidence thresholding (\u03c4= 0.9, except for highresource pos where\u03c4= 0.8 performed slightly better). we also experimented with using a domainadversarial loss [reference] on the jointly learned representation, but found this not to help. the full pseudo-code is given in algorithm 3. computational complexity the motivation for mt-tri was to reduce the space and time complexity of tri-training. we thus give an estimate of its efficiency gains. mt-tri is~3\u00d7 more spaceefficient than regular tri-training; tri-training stores one set of parameters for each of the three models, while mt-tri only stores one set of parameters (we use three output layers, but these make up a comparatively small part of the total parameter budget). in terms of time efficiency, tri-training first [reference] we also tried enforcing orthogonality on a hidden layer rather than the output layer, but this did not help. 10: until end condition is met 11: apply majority vote over m i requires to train each of the models from scratch. the actual tri-training takes about the same time as training from scratch and requires a separate forward pass for each model, effectively training three independent models simultaneously. in contrast, mt-tri only necessitates one forward pass as well as the evaluation of the two additional output layers (which takes a negligible amount of time) and requires about as many epochs as tri-training until convergence (see table 3, second column) while adding fewer unlabeled examples per epoch (see section 3.4). in our experiments, mt-tri trained about 5-6\u00d7 faster than traditional tri-training. mt-tri can be seen as a self-ensembling technique, where different variations of a model are used to create a stronger ensemble prediction. recent approaches in this line are snapshot ensembling) that ensembles models converged to different minima during a training run, asymmetric tri-training [reference]) (asym) that leverages agreement on two models as information for the third, and temporal ensembling [reference], which ensembles predictions of a model at different epochs. we tried to compare to temporal ensembling in our experiments, but were not able to obtain consistent results. [reference] we compare to the closest most recent method, asymmetric tritraining [reference]. it differs from ours in two aspects: a) asym leverages only pseudolabels from data points on which m 1 and m 2 agree, and b) it uses only one task (m 3) as final predictor. in essence, our formulation of mt-tri is closer to the original tri-training formulation (agreements on two provide pseudo-labels to the third) thereby incorporating more diversity. [reference] for pos tagging (above) and the amazon reviews dataset [reference] for sentiment analysis (below). section: experiments in order to ascertain which methods are robust across different domains, we evaluate on two widely used unsupervised domain adaptation datasets for two tasks, a sequence labeling and a classification task, cf. table 1 for data statistics. section: pos tagging for pos tagging we use the sancl 2012 shared task dataset [reference] and compare to the top results in both low and high-data conditions [reference][reference]. both are strong baselines, as the flors tagger has been developed for this challenging dataset and it is based on contextual distributional features (excluding the word's identity), and hand-crafted suffix and shape features (including some languagespecific morphological features). we want to gauge to what extent we can adopt a nowadays fairly standard (but more lexicalized) general neural tagger. our pos tagging model is a state-of-the-art bi-lstm tagger [reference] with word and 100-dim character embeddings. word embeddings are initialized with the 100-dim glove embeddings [reference]. the bilstm has one hidden layer with 100 dimensions. the base pos model is trained on wsj with early stopping on the wsj development set, using patience 2, gaussian noise with\u03c3= 0.2 and word dropout with p= 0.25 [reference]. regarding data, the source domain is the ontonotes 4.0 release of the penn treebank wall street journal (wsj) annotated for 48 fine-grained pos tags. this amounts to 30, 060 labeled sentences. we use 100, 000 wsj sentences from 1988 as unlabeled data, following [reference]. [reference] as target data, we use the five sancl domains (answers, emails, newsgroups, reviews, weblogs). we restrict the amount of unlabeled data for each sancl domain to the first 100k sentences, and do not do any pre-processing. we consider the development set of answers as our only target dev set to set hyperparameters. this may result in suboptimal per-domain settings but better resembles an unsupervised adaptation scenario. section: sentiment analysis for sentiment analysis, we evaluate on the amazon reviews dataset [reference]. reviews with 1 to 3 stars are ranked as negative, while reviews with 4 or 5 stars are ranked as positive. the dataset consists of four domains, yielding 12 adaptation scenarios. we use the same pre-processing and architecture as used in [reference][reference]: 5, 000-dimensional tf-idf weighted unigram and bigram features as input; 2k labeled source samples and 2k unlabeled target samples for training, 200 labeled target samples for validation, and between 3k-6k samples for testing. the model is an mlp with one hidden layer with 50 dimensions, sigmoid activations, and a softmax output. we compare against the variational fair autoencoder (vfae) [reference] model and domain-adversarial neural networks (dann) [reference]. section: baselines besides comparing to the top results published on both datasets, we include the following baselines: a) the task model trained on the source domain; b) self-training (self); c) tri-training (tri); d) tri-training with disagreement (tri-d); and e) asymmetric tri-training [reference]). our proposed model is multi-task tri-training (mttri). we implement our models in dynet. reporting single evaluation scores might result in biased results [reference]. throughout the paper, we report mean accuracy and standard deviation over five runs for pos tagging and over ten runs for sentiment analysis. significance is computed using bootstrap test. the code for all experiments is released at: https:// github.com/ bplank/ semi-supervised-baselines. section: results section: sentiment analysis we show results for sentiment analysis for all 12 domain adaptation scenarios in figure 2. for clarity, we also show the accuracy scores averaged across each target domain as well as a global macro average in table 2 self-training achieves surprisingly good results but is not able to compete with tri-training. tritraining with disagreement is only slightly better than self-training, showing that the disagreement component might not be useful when there is a strong domain shift. tri-training achieves the best average results on two target domains and clearly outperforms the state of the art on average. mt-tri finally outperforms the state of the art on 3/ 4 domains, and even slightly traditional tritraining, resulting in the overall best method. this improvement is mainly due to the b ->e and d ->e scenarios, on which tri-training struggles. these domain pairs are among those with the highest adistance [reference], which highlights that tri-training has difficulty dealing with a strong shift in domain. our method is able to mitigate this deficiency by training one of the three output layers only on pseudo-labeled target domain examples. in addition, mt-tri is more efficient as it adds a smaller number of pseudo-labeled examples than tri-training at every epoch. for sentiment analysis, tri-training adds around 1800-1950/ 2000 unlabeled examples at every epoch, while mt-tri only adds around 100-300 in early epochs. this shows that the orthogonality constraint is useful for inducing diversity. in addition, adding fewer examples poses a smaller risk of swamping the learned representations with useless signals and is more akin to fine-tuning, the standard method for supervised domain adaptation [reference]. we observe an asymmetry in the results between some of the domain pairs, e.g. b ->d and d ->b. we hypothesize that the asymmetry may be due to properties of the data and that the domains are relatively far apart e.g., in terms of a-distance. in fact, asymmetry in these domains is already reflected table 4: accuracy for pos tagging on the dev and test sets of the sancl domains, models trained on full source data setup. values for methods with* are from [reference]. in the results of [reference] and is corroborated in the results for asymmetric tri-training [reference] and our method. we note a weakness of this dataset is high variance. existing approaches only report the mean, which makes an objective comparison difficult. for this reason, we believe it is essential to evaluate proposed approaches also on other tasks. pos tagging results for tagging in the low-data regime (10% of wsj) are given in table 3. self-training does not work for the sequence prediction task. we report only the best instantiation (throttling with n=800). our results contribute to negative findings regarding self-training [reference][reference]. in the low-data setup, tri-training with disagreement works best, reaching an overall average accuracy of 89.70, closely followed by classic tritraining, and significantly outperforming the baseline on 4/ 5 domains. the exception is newsgroups, a difficult domain with high oov rate where none of the approches beats the baseline (see\u00a7 3.4). our proposed mt-tri is better than asymmetric tritraining, but falls below classic tri-training. it beats table 5: accuracy scores on dev sets for oov and unknown word-tag (uwt) tokens. the baseline significantly on only 2/ 5 domains (answers and emails). the flors tagger [reference] fares better. its contextual distributional features are particularly helpful on unknown word-tag combinations (see\u00a7 3.4), which is a limitation of the lexicalized generic bi-lstm tagger. for the high-data setup (table 4) results are similar. disagreement, however, is only favorable in the low-data setups; the effect of avoiding easy points no longer holds in the full data setup. classic tritraining is the best method. in particular, traditional tri-training is complementary to word embedding initialization, pushing the non-pre-trained baseline to the level of src with glove initalization. tritraining pushes performance even further and results in the best model, significantly outperforming the baseline again in 4/ 5 cases, and reaching flors performance on weblogs. multi-task tritraining is often slightly more effective than asymmetric tri-training [reference]; however, improvements for both are not robust across domains, sometimes performance even drops. the model likely is too simplistic for such a high-data pos setup, and exploring shared-private models might prove more fruitful. on the test sets, tri-training performs consistently the best. section: pos analysis we analyze pos tagging accuracy with respect to word frequency 6 and unseen word-tag combinations (uwt) on the dev sets. known tags, oovs and unknown word-tag (uwt) rate. the sancl dataset is overall very challenging: oov rates are high (6.8-11% compared to 2.3% in wsj), so is the unknown word-tag (uwt) rate (answers and emails contain 2.91% and 3.47% uwt compared to 0.61% on wsj) and almost all target domains even contain unknown tags [reference]) (unknown tags: add, gw, nfp, xx), except for weblogs. email is the domain with the highest oov rate and highest unknown-tag-for-known-words rate. we plot accuracy with respect to word frequency on email in figure 3, analyzing how the three methods fare in comparison to the baseline on this difficult domain. regarding oovs, the results in table 5 (second part) show that classic tri-training outperforms the source model (trained on only source data) on 3/ 5 domains in terms of oov accuracy, except on two domains with high oov rate (newsgroups and weblogs). in general, we note that tri-training works best on oovs and on low-frequency tokens, which is also shown in figure 3 (leftmost bins). both other methods fall typically below the baseline in terms of oov accuracy, but mt-tri still outperforms asym in 4/ 5 cases. table 5 (last part) also shows that no bootstrapping method works well on unknown word-tag combinations. uwt tokens are very difficult to predict correctly using an unsupervised approach; the less lexicalized and more context-driven approach taken by flors is clearly superior for these cases, resulting in higher uwt accuracies for 4/ 5 domains. section: related work learning under domain shift there is a large body of work on domain adaptation. studies on unsupervised domain adaptation include early work on bootstrapping [reference][reference], shared feature representations [reference][reference] and instance weighting [reference]. recent approaches include adversarial learning [reference] and fine-tuning [reference]. there is almost no work on bootstrapping approaches for recent neural nlp, in particular under domain shift. tri-training is less studied, and only recently re-emerged in the vision community [reference], albeit is not compared to classic tri-training. neural network ensembling related work on self-ensembling approaches includes snapshot ensembling or temporal ensembling [reference]. in general, the line between\" explicit\" and\" implicit\" ensembling, like dropout [reference] or temporal ensembling [reference], is more fuzzy. as we noted earlier our multi-task learning setup can be seen as a form of self-ensembling. multi-task learning in nlp neural networks are particularly well-suited for mtl allowing for parameter sharing [reference]. recent nlp conferences witnessed a\" tsunami\" of deep learning papers [reference], followed by what we call a multi-task learning\" wave\": mtl has been successfully applied to a wide range of nlp tasks [reference][reference][reference][reference][reference][reference][reference]. related to it is the pioneering work on adversarial learning (dann) [reference]. for sentiment analysis we found tri-training and our mt-tri model to outperform dann. our mt-tri model lends itself well to shared-private models such as those proposed recently [reference], which extend upon [reference] by having separate source and target-specific encoders. section: conclusions we re-evaluate a range of traditional generalpurpose bootstrapping algorithms in the context of neural network approaches to semi-supervised learning under domain shift. for the two examined nlp tasks classic tri-training works the best and even outperforms a recent state-of-the-art method. the drawback of tri-training it its time and space complexity. we therefore propose a more efficient multi-task tri-training model, which outperforms both traditional tri-training and recent alternatives in the case of sentiment analysis. for pos tagging, classic tri-training is superior, performing especially well on oovs and low frequency tokens, which suggests it is less affected by error propagation. overall we emphasize the importance of comparing neural approaches to strong baselines and reporting results across several runs. section: section: acknowledgments we thank the anonymous reviewers for their valuable feedback. sebastian is supported by irish research council grant number ebppg/ 2014/ 30 and science foundation ireland grant number sfi/ 12/ rc/ 2289. barbara is supported by nvidia corporation and thanks the computing center of the university of groningen for hpc support. section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "ontonotes"
                    ]
                ],
                "Method": [
                    [
                        "multi task tri training"
                    ],
                    [
                        "multi task tri training method"
                    ],
                    [
                        "vfae"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "tri"
                    ],
                    [
                        "sentiment analysis"
                    ],
                    [
                        "parsing"
                    ],
                    [
                        "sentiment analysis"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "sancl dataset"
                    ]
                ],
                "Method": [
                    [
                        "multi-task tri-training method",
                        "multi-task model",
                        "multi-task learning"
                    ]
                ],
                "Metric": [
                    [
                        "global macro average",
                        "overall average accuracy"
                    ]
                ],
                "Task": [
                    [
                        "sentiment analysis"
                    ]
                ]
            }
        ]
    },
    "2a86bcdfb1d817ddb76ba202319f8267a36c0f62-42": {
        "doctext": "document: pcl: proposal cluster learning for weakly supervised object detection weakly supervised object detection (wsod), using only image-level annotations to train object detectors, is of growing importance in object recognition. in this paper, we propose a novel deep network for wsod. unlike previous networks that transfer the object detection problem to an image classification problem using multiple instance learning (mil), our strategy generates proposal clusters to learn refined instance classifiers by an iterative process. the proposals in the same cluster are spatially adjacent and associated with the same object. this prevents the network from concentrating too much on parts of objects instead of whole objects. we first show that instances can be assigned object or background labels directly based on proposal clusters for instance classifier refinement, and then show that treating each cluster as a small new bag yields fewer ambiguities than the directly assigning label method. the iterative instance classifier refinement is implemented online using multiple streams in convolutional neural networks, where the first is an mil network and the others are for instance classifier refinement supervised by the preceding one. experiments are conducted on the pascal voc, imagenet detection, and ms-coco benchmarks for wsod. results show that our method outperforms the previous state of the art significantly. object detection, weakly supervised learning, convolutional neural network, multiple instance learning, proposal cluster. section: introduction object detection is one of the most important problems in computer vision with many applications. recently, due to the development of convolutional neural network (cnn) and the availability of large scale datasets with detailed boundingbox-level annotations, there have been great leap forwards in object detection. however, it is very labor-intensive and time-consuming to collect detailed annotations, whereas acquiring images with only image-level annotations (i.e., image tags) indicating whether an object class exists in an image or not is much easier. for example, we can use image search queries to search on the internet (e.g., google and flickr) to obtain a mass of images with such image-level annotations. this fact inspires us to explore methods for the weakly supervised object detection (wsod) problem, i.e., training object detectors with only image tag supervisions. many previous methods follow the multiple instance learning (mil) pipeline for wsod. they treat images as bags and proposals as instances; then instance classifiers (object detectors) are trained under mil constraints (i.e., a positive bag contains at least one positive instance and all instances in negative bags are negative). in addition, inspired by the great success of cnn, recent efforts often combine mil and cnn to obtain better wsod performance. some researches have shown that treating cnns pre-trained on large scale datasets as off-the-shelf proposal feature extractors can obtain much better performance than traditional hand-designed features. moreover, many recent works have achieved even better results for wsod by an mil network using standard end-to-end training or a variant of end-to-end training. see section [reference] for this variant of end-to-end and how it differs from the standard one. we use the same strategy of training a variant of end-to-end mil network inspired by. although some promising results have been obtained by mil networks for wsod, they do not perform as well as fully supervised ones. as shown in fig. [reference] (a), previous mil networks integrate the mil constraints into the network training by transferring the instance classification (object detection) problem to a bag classification (image classification) problem, where the final image scores are the aggregation of the proposal scores. however, there is a big gap between image classification and object detection. for classification, even parts of objects can contribute to correct results (e.g., the red boxes in fig. [reference]), because important parts include many characteristics of the objects. many proposals only cover parts of objects, and\" seeing\" proposals only of parts may be enough to roughly localize the objects. but this may not localize objects well enough considering the performance requirement of high intersection-over-union (iou) between the resulting boxes and groundtruth boundingboxes: the top ranking proposals may only localize parts of objects instead of whole objects. recall that for detection, the resulting boxes should not only give correct classification, but also localize objects and have enough overlap with groundtruth boundingboxes (e.g., the green boxes in fig. [reference]). before presenting our solution of the problem referred above, we first introduce the concept of proposal cluster. object detection requires algorithms to generate multiple overlapping proposals closely surrounding objects to ensure high proposal recall (e.g., for each object, there are tens of proposals on average from selective search which have iou 0.5 with the groundtruth boundingbox on the pascal voc dataset). object proposals in an image can be grouped into different spatial clusters. except for one cluster for background proposals, each object cluster is associated with a single object and proposals in each cluster are spatially adjacent, as shown in fig. [reference]. for fully supervised object detection (i.e., training object detectors using boundingbox-level annotations), proposal clusters can be generated by treating the groundtruth boundingboxes as cluster centers. then object detectors are trained according to the proposal clusters (e.g., assigning all proposals the label of the corresponding object class for each cluster). this alleviates the problem that detectors may only focus on parts. but in the weakly supervised scenario, it is difficult to generate proposal clusters because groundtruth boundingboxes that can be used as cluster centers are not provided. to cope with this difficulty, we suggest to find proposal clusters as follows. first we generate proposal cluster centers from those proposals which have high classification scores during training, because these top ranking proposals can always detect at least parts of objects. that is, for each image, after obtaining proposal scores, we select some proposals with high scores as cluster centers, and then proposal clusters are generated based on spatial overlaps with the cluster centers. then the problem reduces to how to select proposals as centers, because many high scoring proposals may correspond to the same object. the most straightforward way is to choose the proposal with the highest score for each positive object class (i.e., the object class exists in the image) as the center. but such a method ignores the fact that there may exist more than one object with the same object category in natural images (e.g., the two motorbikes in fig. [reference]). therefore, we propose a graph-based method to find cluster centers. more specifically, we build a graph of top ranking proposals according to the spatial similarity for each positive object class. in the graph, two proposals are connected if they have enough spatial overlaps. then we greedily and iteratively choose the proposals which have most connections with others to estimate the centers. although a cluster center proposal may only capture an object partially, its adjacent proposals (i.e., other proposals in the cluster) can cover the whole object, or at worst contain larger parts of the object. based on these proposal clusters, we propose two methods to refine instance classifiers (object detectors) during training. we first propose to assign proposals object labels directly. that is, for each cluster, we assign its proposals the label of its corresponding object class, as in fig. [reference] (b). compared with the conventional mil network in fig. [reference] (a), this strategy forces network to\" see\" larger parts of objects by assigning object labels to proposals that cover larger parts of objects directly, which fills the gap between classification and detection to some extent. while effective, this strategy still has potential ambiguities, because assigning the same object label to proposals that cover different parts of objects simultaneously may confuse the network and will hurt the discriminative power of the detector. to address this problem, we propose to treat each proposal cluster as a small new bag to train refined instance classifiers, as in fig. [reference] (c). most of the proposals in these new bags should have relatively high classification scores because the cluster centers covers at least parts of objects and proposals in the same cluster are spatially adjacent (except for the background cluster). in the same time, not all proposals in the bags should have high classification scores. thus compared with the directly assigning label strategy, this strategy is more flexible and can reduce the ambiguities to some extent. we name our method proposal cluster learning (pcl) because it learns refined instance classifiers based on proposal clusters. to implement our idea effectively and efficiently, we further propose an online training approach. our network has multiple output streams as in fig. [reference]. the first stream is a basic mil network which aggregates proposal scores into final image scores to train basic instance classifiers, and the other streams refine the instance classifiers iteratively. during the forward process of training, proposal classification scores are obtained and proposal clusters are generated consequently for each stream. then based on these proposal clusters, supervisions are generated to compute losses for the next stream. according to the losses, these refined classifiers are trained during back-propagation. except for the first stream that is supervised by image labels, the other streams are supervised by the image labels as well as outputs from their preceding streams. as our method forces the network to\" see\" larger parts of objects, the detector can discover the whole object instead of parts gradually by performing refinement multiple times (i.e., multiple output streams). but at the start of training, all classifiers are almost untrained, which will result in very noisy proposal clusters, and so the training will deviate from the correct solutions a lot. thus we design a weighted loss further by associating different proposals with different weights in different training iterations. after that, all training procedures can thus be integrated into a single end-to-end network. this can improve the performance benefiting from our pcl-based classifier refinement procedure. it is also very computational efficient in both training and testing. in addition, performance can be improved by sharing proposal features among different output streams. we elaborately conduct many experiments on the challenging pascal voc, imagenet detection, and ms-coco datasets to confirm the effectiveness of our method. our method achieves map and corloc on voc 2007 which is more than absolute improvement compared with previous best performed methods. this paper is an extended version of our previous work. in particular, we give more analyses of our method and enrich literatures of most recent related works, making the manuscript more complete. in addition, we make two methodological improvements: the first one is to generate proposal clusters using graphs of top ranking proposals instead of using the highest scoring proposal, and the second one is to treat each proposal cluster as a small new bag. in addition, we provide more discussions of experimental results, and show the effectiveness of our method on the challenging imagenet detection and ms-coco datasets. the rest of our paper is organized as follows. in section [reference], some related works are introduced. in section [reference], the details of our method are described. elaborate experiments and analyses are conducted in section [reference]. finally, conclusions and future directions are presented in section [reference]. section: related work subsection: multiple instance learning mil, first proposed for drug activity prediction, is a classical weakly supervised learning problem. many variants have been proposed for mil. in mil, a set of bags are given, and each bag is associated with a collection of instances. it is natural to treat wsod as an mil problem. then the problem turns into finding instance classifiers only given bag labels. our method also follows the mil strategy and makes several improvements to wsod. in particular, we learn refined instance classifiers based on proposal clusters according to both instance scores and spatial relations in an online manner. mil has many applications to computer vision, such as image classification, weakly supervised semantic segmentation, object detection, object tracking, etc. the strategy of treating proposal clusters as bags was partly inspired by, where proposes to train mil for patches around groundtruth locations and proposes to train mil for patches around predicted object locations. however, they require groundtruth locations for either all training samples or the beginning time frames, whereas wsod does not have such annotations. therefore, it is much harder to generate proposal clusters only guided by image-level supervisions for wsod. in addition, we incorporate the strategy of treating proposal clusters as bags into the network training whereas do not. oquab et al. also train a cnn network using the max pooing mil strategy to localize objects. but their methods can only coarsely localize objects regardless of their sizes and aspect ratios, whereas our method can detect objects more accurately. subsection: weakly supervised object detection wsod has attracted great interests nowadays because the amount of data with image-level annotations is much bigger and is growing much faster than that with boundingbox-level annotations. many methods are emerging for the wsod problem. for example, chum and zisserman first initialize object locations by discriminative visual words and then introduce an exemplar model to measure similarity between image pairs for updating locations. deselaers et al. propose to initialize boxes by objectness and use a crf-based model to iteratively localize objects. pandey and lazebnik train a dpm model under weak supervisions for wsod. shi et al. use bayesian latent topic models to jointly model different object classes and background. song et al. develop a technology to discover frequent discriminative configurations of visual patterns for robust wsod. cinbis et al. iteratively train a multi-fold mil to avoid the detector being locked onto inaccurate local optima. wang et al. relax the mil constraints into a derivable loss function to train detectors more efficient. recently, with the revolution of cnns in computer vision, many works also try to combine the wsod with cnns. early works treat cnn models pre-trained on imagenet as off-the-shelf feature extractors. they extract cnn features for each candidate regions, and then train their own detectors on top of these features. these methods have shown that cnn descriptors can boost performance against traditional hand-designed features. more recent efforts tend to train end-to-end networks for wsod. they integrate the mil constraints into the network training by aggregating proposal classification scores into final image classification scores, and then image-level supervision can be directly added to image classification scores. for example, tang et al. propose to use max pooling for aggregation. bilen and vedaldi develop a weighted sum pooing strategy. building on, kantorov et al. argue that context information can improve the performance. diba et al. show that weakly supervised segmentation map can be used as guidance to filter proposals, and jointly train the weakly supervised segmentation network and wsod end-to-end. our method is built on these networks and any of them can be chosen as our basic network. our strategy proposes to learn refined instance classifiers based on proposal clusters, and propose a novel online approach to train our network effectively and efficiently. experimental results show our strategies can boost the results significantly. in addition to the weighted sum pooing, also proposes a\" spatial regulariser\" that forces features of the highest scoring proposal and its spatially adjacent proposals to be the same. unlike this, we show that finding proposal cluster centers using graph and treating proposal clusters as bags are more effective. the contemporary work uses a graph model to generate seed proposals. their network training has many steps: first, an mil network is trained; second, seed proposals are generated using the graph; third, based on these seed proposals, a fast r-cnn like detector is trained. our method differs from in many aspects: first, we propose to generate proposal clusters for each training iteration and thus our network is trained end-to-end instead of step-by-step, which is more efficient and can benefit from sharing proposal features among different streams; second, we propose to treat proposal clusters as bags for training better classifiers. as evidenced by experiments, our method obtains much better and more robust results. subsection: end-to-end and its variants in standard end-to-end training, the update requires optimizing losses w.r.t. all functions of network parameters. for example, the fast r-cnn optimizes their classification loss and boundingbox regression loss w.r.t. proposal classification and feature extraction for fully supervised object detection. the mil networks in optimize their mil loss w.r.t. proposal classification and feature extraction for wsod. unlike the standard end-to-end training, there exists a variant of end-to-end training. the variant contains functions which depend on network parameters, but losses are not optimized w.r.t. all these functions. as we described in section [reference], the\" spatial regulariser\" in forces features of the highest scoring proposal and its spatially adjacent proposals to be the same. they use a function of network parameters to compute the highest scoring proposal, and do not optimize their losses w.r.t. this function. diba et al. filter out background proposals using a function of network parameters and use these filtered proposals in their latter network computations. they also do not optimize their losses w.r.t. this function. inspired by, we use this variant of end-to-end training. more precisely, we do not optimize our losses w.r.t. the generated supervisions for instance classifier refinement. subsection: others there are many other important related works that do not focus on weakly supervised learning but should be discussed. similar to other end-to-end mil networks, our method is built on top of the region of interest (roi) pooling layer or spatial pyramid pooling (spp) layer to share convolutional computations among different proposals for model acceleration. but both and require boundingbox-level annotations to train their detectors. the sharing proposal feature strategy in our network is similar to multi-task learning. unlike the multi-task learning that each output stream has their own relatively independent external supervisions for different tasks, in our method, all streams have the same task and supervisions of later streams depend on the outputs from their preceding streams. section: method the overall architecture of our method is shown in fig. [reference]. given an image, about object proposals from selective search or edgebox are generated. during the forward process of training, the image and these proposals are fed into some convolutional (conv) layers with an spp layer to produce a fixed-size conv feature map per-proposal. after that, proposal feature maps are fed into two fully connected (fc) layers to produce proposal features. these features are branched into different streams: the first one is an mil network to train basic instance classifiers and the others refine the classifiers iteratively. for each stream, proposal classification scores are obtained and proposal clusters are generated consequently. then based on these proposal clusters, supervisions are generated to compute losses for the next stream. during the back-propagation process of training, the network losses are optimized to train proposal features and classifiers. as shown in the figure, supervisions of the-st refined classifier depend on the output from the basic classifier, and supervisions of-th refined classifier depend on outputs from-th refined classifier. in this section, we will introduce our method of learning refined instance classifiers based on proposal clusters in detail. subsection: notations before presenting our method, we first introduce some of the mostly used notations as follows. we have proposals with boxes for an given image and proposal features, where is the-th proposal box. the number of refined instance classifiers is (i.e., we refine instance classifier times), and thus there are streams. the number of object classes is. and are the parameters of the basic instance classifier and the-th refined instance classifier, respectively. and are the predicted score matrices of the basic instance classifier and the-th refined instance classifier, respectively, where indicates the object classes and background class. we use later for simplification, dropping the dependence on. is the predicted score of the-th proposal for class from the-th instance classifier. is the image label vector, where or indicates the image with or without object class. is the supervision of the-th instance classifier, where is the image label vector. is the loss function to train the-th instance classifier. we compute proposal cluster centers for the-th refinement. the-th cluster center consists of a proposal box, an object label (indicates the-th object class), and a confidence score indicating the confidence that covers at least part of an object of class. we have proposal clusters according to (for background and others for objects). for object clusters, the-th cluster consists of proposal boxes, an object label that is the same as the cluster center label, and a confidence score that is the same as the cluster center score, where indicates the confidence that corresponds to an object of class. unlike object clusters, the background cluster consists of proposals and a label indicating the background. the-th proposal consists of a proposal box and a confidence score indicating the confidence that is the background. subsection: basic mil network it is necessary to generate proposal scores and clusters to supervise refined instance classifiers. more specifically, the first refined classifier requires basic instance classifiers to generate proposal scores and clusters. therefore, we first introduce our basic mil network as the basic instance classifier. our overall network is independent of the specific mil methods, and thus any method that can be trained end-to-end could be used. there are many possible choices. here we choose the method by bilen and vedaldi which proposes a weighted sum pooling strategy to obtain the instance classifier, because of its effectiveness and implementation convenience. to make our paper self-contained, we briefly introduce as follows. given an input image and its proposal boxes, a set of proposal features are first generated by the network. then as shown in the\" basic mil network\" block of fig. [reference], there are two branches which process the proposal features to produce two matrices (we use later for simplification, dropping the dependence on) of an input image by two fc layers, where and denote the parameters of the fc layer for and the parameters of the fc layer for, respectively. then the two matrices are passed through two softmax layer along different directions: and. let us denote by. the proposal scores are generated by element-wise product. finally, the image score of the-th class is obtained by the sum over all proposals:. a simple interpretation of the two branches framework is as follows. is the probability of the-th proposal belonging to class. is the normalized weight that indicates the contribution of the-th proposal to image being classified to class. so is obtained by weighted sum pooling and falls in the range of. given the image label vector. we train the basic instance classifier by optimizing the multi-class cross entropy loss eq. ([reference]) w.r.t.. subsection: the overall training strategy to refine instance classifiers iteratively, we add multiple output streams in our network where each stream corresponds to a refined classifier, as shown in fig. [reference]. we integrate the basic mil network and the classifier refinement into an end-to-end network to learn the refined classifier online. unlike the basic instance classifier, for an input image the output score matrix of the-th refined classifier is a matrix and is obtained by passing the proposal features through a single fc layer (with parameters) as well as a softmax over-classes layer, i.e.,, as in the\" instance classifier refinement\" blocks of fig. [reference]. notice that we use the same proposal features for all classifiers. we use later for simplification, dropping the dependence on. as we stated before, supervisions to train the-th instance classifier are generated based on proposal scores and image label. thus we denote the supervisions by. then we train our overall network by optimizing the loss eq. ([reference]) w.r.t.. we do not optimize the loss w.r.t., which means that the supervisions are only computed in the forward process and we do not compute their gradients to train our network. the loss for the-th refined instance classifier is defined in later eq. ([reference])/ ([reference])/ ([reference]) which are loss functions with supervisions provided by. we will give details about how to get supervisions and loss functions in section [reference]. [t] the overall training procedure (one iteration) [1] an image, its proposal boxes, and its image label vector; refinement times. an updated network. feed the image and into the network to produce proposal score matrices (simplified as later). compute loss by eq. ([reference]), see section [reference]. generate supervisions, see section [reference]. compute loss by eq. ([reference])/ ([reference])/ ([reference]), see section [reference]. optimize, i.e., eq. ([reference]), w.r.t. (not w.r.t.). during the forward process of each stochastic gradient descent (sgd) training iteration, we obtain a set of proposal scores of an input image. accordingly, we generate the supervisions for the iteration to compute the loss eq. ([reference]). during the back-propagation process of each sgd training iteration, we optimize the loss eq. ([reference]) w.r.t. proposal features and classifiers. we summarize this procedure in algorithm [reference]. note that we do not use an alternating training strategy, i.e., fixing supervisions and training a complete model, fixing the model and updating supervisions. the reasons are that: 1) it is very time-consuming because it requires training models multiple times; 2) training different models in different refinement steps separately may harm the performance because it hinders the process to benefit from the shared proposal features (i.e.,). subsection: proposal cluster learning here we will introduce our methods to learn refined instance classifiers based on proposal clusters (i.e., proposal cluster learning). recall from section [reference] that we have a set of proposals with boxes. for the-th refinement, our goal is to generate supervisions for the loss functions using the proposal scores and image label in each training iteration. we use later for simplification, dropping the dependence on. we do this in three steps. 1) we find proposal cluster centers which are proposals corresponding to different objects. 2) we group the remaining proposals into different clusters, where each cluster is associated with a cluster center or corresponds to the background. 3) we generate the supervisions for the loss functions, enabling us to train the refined instance classifiers. for the first step, we compute proposal cluster centers based on and. the-th cluster center is defined in section [reference]. we propose two algorithms to find in section [reference] (1) and (2) (also algorithm [reference] and algorithm [reference]), where the first one was proposed in the conference version paper and the second one is proposed in this paper. for the second step, according to the proposal cluster centers, proposal clusters are generated (for background and others for objects). the-th object cluster and the background cluster are defined in section [reference]. we use the different notation for the background cluster because background proposals are scattered in each image, and thus it is hard to determine a cluster center and accordingly a cluster score. the method to generate was proposed in the conference version paper and is described in section [reference] (also algorithm [reference]). for the third step, supervisions to train the-th refined instance classifier are generated based on the proposal clusters. we use two strategies where are either proposal-level labels indicating whether a proposal belongs to an object class, or cluster-level labels that treats each proposal cluster as a bag. subsequently these are used to compute the loss functions. we propose two approaches to do this as described in section [reference] (1) and (2), where the first one was proposed in the conference version paper and the second one is proposed in this paper. subsubsection: finding proposal cluster centers in the following we introduce two algorithms to find proposal cluster centers. [t] finding proposal cluster centers using the highest scoring proposal [1] proposal boxes; image label vector; proposal score matrix. proposal cluster centers. initialize. choose the-th proposal by eq. ([reference]).. (1) finding proposal cluster centers using the highest scoring proposal. a solution for finding proposal cluster centers is to choose the highest scoring proposal, as in our conference version paper. as in algorithm [reference], suppose an image has object class label (i.e.,). for the-th refinement, we first select the-th proposal which has the highest score by eq. ([reference]), where is the predicted score of the-th proposal, as defined in section [reference]. then this proposal is chosen as the cluster center, i.e.,, where is the box of the-th proposal. is chosen as the confidence score that the-th proposal covers at least part of an object of class, because is the predicted score of the-th proposal been categorized to class. therefore, the highest scoring proposal can probably cover at least part of the object and thus be chosen as the cluster center. there is a potential problem that one proposal may be chosen as the cluster centers for multiple object classes. to avoid this problem, if one proposal corresponds to the cluster centers for multiple object classes, this proposal would be chosen as the cluster center only by the class with the highest predicted score and we re-choose cluster centers for other classes. (2) finding proposal cluster centers using graphs of top ranking proposals. as stated in section [reference], although we can find good proposal cluster centers using the highest scoring proposal, this ignores that in natural images there are often more than one object for each category. therefore, we propose a new method to find cluster centers using graphs of top ranking proposals. [t] finding proposal cluster centers using graphs of top ranking proposals [1] proposal boxes; image label vector; proposal score matrix. proposal cluster centers. initialize. select top ranking proposals with indexes. build a graph using the top ranking proposals. set. set.. remove the-th proposal box from, or. is empty. more specifically, suppose an image has object class label. we first select the top ranking proposals with indexes for the-th refinement. then we build an undirected unweighted graph of these proposals based on spatial similarity, where vertexes correspond to these top ranking proposals, and edges correspond to the connections between the vertexes. is determined according to the spatial similarity between two vertexes (i.e., proposals) as in eq. ([reference]), where is the iou between the-th and-th proposals and is a threshold (e.g.,). therefore, two vertexes are connected if they are spatially adjacent. after that, we greedily generate some cluster centers for class using this graph. that is, we iteratively select vertexes which have most connections to be the cluster centers, as in algorithm [reference]. the number of cluster centers (i.e.,) changes for each image in each training iteration because the top ranking proposals change. see section [reference] for some typical values of. we use the same method as in section [reference] (1) to avoid one proposal been chosen as the cluster centers for multiple object classes. the reasons for this strategy are as follows. first, according to our observation, the top ranking proposals can always cover at least parts of objects, thus generating centers from these proposals encourages the selected centers to meet our requirements. second, because these proposals cover objects well, better proposals (covering more parts of objects) should have more spatially overlapped proposals (i.e., have more connections). third, these centers are spatially far apart, and thus different centers can correspond to different objects. this method also has the attractive characteristic that it can generate adaptive number of proposals for each object class, which is desirable because in natural images there are arbitrary number of objects per-class. we set the score of the-th proposal cluster center by (see the-th line in algorithm [reference]) because if the adjacent proposals of a center proposal have high confidence to cover at least part of an object (i.e., have high classification scores) the center proposal should also have such high confidence. there is an important issue for the graph-based method: how to select the top ranking proposals? a simple method is to select proposals whose scores exceed a threshold. but in our case, proposal scores change in each training iteration, and thus it is hard to determine a threshold. instead, for each positive object class, we use the-means algorithm to divide proposal scores of an image into some clusters, and choose proposals in the cluster which has the highest score center to form the top ranking proposals. this method ensures that we can select the top ranking proposals although proposal scores change during training. other choices are possible, but this method works well in experiments. [t] generating proposal clusters [1] proposal boxes; proposal cluster centers. proposal clusters. initialize. set of to of,. initialize and set. compute ious. choose the most spatially adjacent center... subsubsection: generating proposal clusters after the cluster centers are found, we generate the proposal clusters as in our conference version paper. except for the cluster for background, good proposal clusters require that proposals in the same cluster are associated with the same object, and thus proposals in the same cluster should be spatially adjacent. specially, given the-th proposal, we compute a set of ious, where is the iou between the-th proposal and the box of the-th cluster center. then we assign the-th proposal to the-th object cluster if is larger than a threshold (e.g.,) and to the background cluster otherwise, where is the index of the most spatially adjacent cluster center as eq. ([reference]). the overall procedures to generate proposal clusters are summarized in algorithm [reference]. we set the proposal scores for the background cluster to the scores of their most spatially adjacent centers as the 10-the line in algorithm [reference], because if the cluster center has confidence that it covers an object, the proposal far away from should have confidence to be background. subsubsection: learning refined instance classifiers to get supervisions and loss functions to learn the-th refined instance classifier, we design two approaches as follows. (1) assigning proposals object labels. the most straightforward way to refine classifiers is to directly assign object labels to all proposals in object clusters because these proposals potentially correspond to whole objects, as in our conference version paper. as the cluster centers covers at least parts of objects, their adjacent proposals (i.e., proposals in the cluster) can contain larger parts of objects. accordingly, we can assign the cluster label to all proposals in the-th cluster. more specifically, the supervisions are proposal-level labels, i.e.,. is the label vector of the-th proposal for the-th refinement, where and if the-th proposal belongs to the-th clusters. consequently, we use the standard softmax loss function to train the refined classifiers as in eq. ([reference]), where is the predicted score of the-th proposal as defined in section [reference]. through iterative instance classifier refinement (i.e., multiple times of refinement as increase), the detector detects larger parts of objects gradually by forcing the network to\" see\" larger parts of objects. actually, the so learnt supervisions are very noisy, especially in the beginning of training. this results in unstable solutions. to solve this problem, we change the loss in eq. ([reference]) to a weighted version, as in eq. ([reference]). is the loss weight that is the same as the cluster confidence score for object clusters or proposal confidence score for the background cluster if the-th proposal belongs to the-th cluster. from algorithm [reference], we can observe that is the same as the cluster center confidence score. the reasons for this strategy are as follows. in the beginning of training, although we can not obtain good proposal clusters, each is small, hence each is small and the loss is also small. as a consequence, the performance of the network will not decrease a lot. during the training, the top ranking proposals will cover objects well, and thus we can generate good proposal clusters. then we can train satisfactory instance classifiers. (2) treating clusters as bags. as we stressed before, although directly assigning proposals object labels can boost the results, it may confuse the network because we simultaneously assign the same label to different parts of objects. focusing on this, we further propose to treat each proposal cluster as a small new bag and use the cluster label as the bag label. thus the supervisions for the-th refinement are bag-level (cluster-level) labels, i.e.,. is the label of the-th bag, i.e., the label of the-th proposal cluster, as defined in section [reference]. specially, for object clusters, we choose average mil pooling, because these proposals should cover at least parts of objects and thus should have relatively high prediction scores. for the background cluster, we assign the background label to all proposals in the cluster according to the mil constraints (all instances in negative bags are negative). then the loss function for refinement will be eq. ([reference]).,, and are the cluster confidence score of the-th object cluster, the number of proposals in the-th cluster, and the predicted score of the-th proposal, respectively, as defined in section [reference]. and indicate that the-th proposal belongs to the-th object cluster and the background cluster respectively. compared with the directly assigning label approach, this method tolerates some proposals to have low scores, which can reduce the ambiguities to some extent. subsection: testing during testing, the proposal scores of refined instance classifiers are used as the final detection scores, as the blue arrows in fig. [reference]. here the mean output of all refined classifiers is chosen. the non-maxima suppression (nms) is used to filter out redundant detections. section: experiments in this section, we first introduce our experimental setup including datasets, evaluation metrics, and implementation details. then we conduct elaborate experiments to discuss the influence of different settings. next, we compare our results with others to show the effectiveness of our method. after that, we show some qualitative results for further analyses. finally, we give some runtime analyses of our method. codes for reproducing our results are available at. subsection: experimental setup subsubsection: datasets and evaluation metrics we evaluate our method on four challenging datasets: the pascal voc 2007 and 2012 datasets, the imagenet detection dataset, and the ms-coco dataset. only image-level annotations are used to train our models. the pascal voc 2007 and 2012 datasets have and images respectively for object classes. these two datasets are divided into train, val, and test sets. here we choose the trainval set (images for 2007 and images for 2012) to train our network. for testing, there are two metrics for evaluation: map and corloc. following the standard pascal voc protocol, average precision (ap) and the mean of ap (map) is the evaluation metric to test our model on the testing set. correct localization (corloc) is to test our model on the training set measuring the localization accuracy. all these two metrics are based on the pascal criterion, i.e., iou 0.5 between groundtruth boundingboxes and predicted boxes. the imagenet detection dataset has hundreds of thousands of images with object classes. it is also divided into train, val, and test sets. following, we split the val set into val1 and val2, and randomly choose at most k images in the train set for each object class (we call it train). we train our model on the mixture of train and val1 sets, and test it on the val2 set, which will lead to images for training and images for testing. we also use the map for evaluation on the imagenet. the ms-coco dataset has object classes and is divided into train, val, and test sets. since the groundtruths on the test set are not released, we train our model on the ms-coco 2014 train set (about k images) and test it on the val set (about k images). for evaluation, we use two metrics map@0.5 and map@ [.5,.95] which are the standard pascal criterion (i.e., iou 0.5) and the standard ms-coco criterion (i.e., computing the average of map for iou [0.5: 0.05: 0.95]) respectively. subsubsection: implementation details our method is built on two pre-trained imagenet networks vgg m and vgg16, each of which has some conv layers with max-pooling layers and three fc layers. we replace the last max-pooling layer by the spp layer, and the last fc layer as well as the softmax loss layer by the layers described in section [reference]. to increase the feature map size from the last conv layer, we replace the penultimate max-pooling layer and its subsequent conv layers by the dilated conv layers. the newly added layers are initialized using gaussian distributions with-mean and standard deviations. biases are initialized to. during training, the mini-batch size for sgd is set to be,, and for pascal voc, imagenet, and ms-coco, respectively. the learning rate is set to for the first k, k, k, and k iterations for the pascal voc 2007, pascal voc 2012, imagenet, and ms-coco datasets, respectively. then we decrease the learning rate to in the following k, k, k, and k iterations for the pascal voc 2007, pascal voc 2012, imagenet, and ms-coco datasets, respectively. the momentum and weight decay are set to be and respectively. selective search, edgebox, and mcg are adopted to generate about proposals per-image for the pascal voc, imagenet, and ms-coco datasets, respectively. for data augmentation, we use five image scales (resize the shortest side to one of these scales) with horizontal flips for both training and testing. if not specified, the instance classifiers are refined three times, i.e., in section [reference], so there are four output streams; the iou threshold in section [reference] (2) (also eq. ([reference])) is set to; the number of-means clusters in the last paragraph of section [reference] (2) is set to; in section [reference] (also the-th line of algorithm [reference]) is set to. similar to other works, we train a supervised object detector through choosing the top-scoring proposals given by our method as pseudo groundtruths to further improve our results. here we train a fast r-cnn (frcnn) using the vgg16 model and the same five image scales (horizontal flips only in training). the same proposals are chosen to train and test the frcnn. nms (with iou threshold) is applied to compute ap. our experiments are implemented based on the caffe deep learning framework, using python and c++. the-means algorithm to produce top ranking proposals is implemented by scikit-learn. all of our experiments are running on an nvidia gtx titanx pascal gpu and intel (r) i7-6850 k cpu (3.60ghz). subsection: discussions we first conduct some experiments to discuss the influence of different components of our method (including instance classifier refinement, different proposal generation methods, different refinement strategies, and weighted loss) and different parameter settings (including the iou threshold defined in section [reference] (2), the number of-means clusters described in section [reference] (2), the iou threshold defined in section [reference], and multi-scale training and testing.) we also discuss the number of proposal cluster centers. without loss of generality, we only perform experiments on the voc 2007 dataset and use the vgg m model. subsubsection: the influence of instance classifier refinement as the five curves in fig. [reference] show, we observe that compared with the basic mil network, for both refinement methods, even refining instance classifier a single time boosts the performance a lot. this confirms the necessity of refinement. if we refine the classifier multiple times, the results are improved further. but when refinement is implemented too many times, the performance gets saturated (there are no obvious improvements from times to times). this is because the network tends to converge so that the supervision of the-th time is similar to the-rd time. in the rest of this paper we only refine classifiers times. notice that in fig. [reference], the\" 0 time\" is similar to the wsddn using selective search as proposals. subsubsection: the influence of different proposal cluster generation methods we discuss the influence of different proposal cluster generation methods. as shown in the fig. [reference] (green and purple solid curves for the highest scoring proposal based method, blue and red solid curves for the graph-based method), for all refinement times, the graph-based method obtains better performance, because it can generate better cluster centers. thus we choose the graph-based method in the rest of our paper. subsubsection: the influence of different refinement strategies we then show the influence of different refinement strategies. the directly assigning label method is replaced by treating clusters as bags (blue and green solid curves). from fig. [reference], it is obvious that the results by treating clusters as bags are better. in addition, compared with the alternating training strategy (blue dashed curve), our online training boosts the performance consistently and significantly, which confirms the necessity of sharing proposal features. online training also reduces the training time a lot, because it only requires training a single model instead of training models for times refinement in the alternating strategy. in the rest of our paper, we only report results by the\" pcl-ob-g\" method in fig. [reference] because it achieves the best performance. subsubsection: the influence of weighted loss we also study the influence of our weighted loss in eq. ([reference]). note that eq. ([reference]) can be easily changed to the unweighted version by simply setting and to be. here we train a network using the unweighted loss. the results of the unweighted loss are map and corloc. we see that if we use the unweighted loss, the improvement from refinement is very scant and the performance is even worse than the alternating strategy. using the weighted loss achieves much better performance (map and corloc), which confirms our theory in section [reference]. subsubsection: the influence of the iou threshold here we discuss the influence of the iou threshold defined in section [reference] (2) and eq. ([reference]). from fig. [reference], we see that setting to obtains the best performance. therefore, we set to for the other experiments. subsubsection: the influence of the number of-means clusters in previous experiments we set the number of-means clusters described in the last paragraph of section [reference] (2) to be. here we set it to other numbers to explore its influence. the results from other numbers of-means clusters are map and corloc for clusters, and map and corloc for clusters, which are a little worse than the results from cluster. therefore, we set the number of-means clusters to for the other experiments. subsubsection: the influence of the iou threshold we also analyse the influence of defined in section [reference] and the-th line of algorithm [reference]. as shown in fig. [reference], outperforms other choices. therefore, we set to for the other experiments. subsubsection: the influence of multi-scale training and testing previously our experiments are conducted based on five image scales for training and testing. here we show the influence of this multi-scale setting. we train and test our method using a single image scale as the default scale setting of frcnn. the single-scale results are map and corloc which are much worse than our multi-scale results (map and corloc). therefore, we use five image scales as many wsod networks. subsubsection: the number of proposal cluster centers as we stated in section [reference] (2), the number of proposal cluster centers (i.e.,) changes for each image in each training iteration. here we give some typical values of. in the beginning of training, the proposal scores are very noisy and thus the selected top ranking proposals to form graphs are scattered in images, which results in dozens of proposal cluster centers for each image. after some (about 3 k) training iterations, the proposal scores are more reliable and our method finds 1 3 proposal cluster centers for each positive object class. to make the training more stable in the beginning, for each positive object class we empirically select at most five proposal cluster centers which have higher scores, and the number of selected proposal cluster centers does not influence the performance much. subsection: comparison with other methods here we compare our best performed strategy pcl-ob-g, i.e., using graph-based method and treating clusters as bags to train the network online, with other methods. we first report our results for each class on voc 2007 and 2012 in table [reference], table [reference], table [reference], and table [reference]. it is obvious that our method outperforms other methods using single model vgg m or vgg16 (pcl-ob-g+ vgg m and pcl-ob-g+ vgg16 in tables.) our single model results even better than others by combining multiple different models (e.g., ensemble of models). specially, our method obtains much better results compared with other two methods also using the same basic mil network. importantly, also equips the weighted sum pooling with objectness measure of edgebox and the spatial regulariser, and adds context information into the network, both of which are more complicated than our basic mil network. we believe that our performance can be improved by choosing better basic mil networks, like the complete network in and using context information. as reimplementing their method completely is non-trivial, here we only choose the simplest architecture in. even in this simplified case, our method achieves very promising results. our results can also be improved by combing multiple models. as shown in the tables, there are little improvements from the ensemble of the vgg m and vgg16 models (pcl-ob-g-ens. in tables). here we do the ensemble by summing up the scores produced by the two models. also, as mentioned in section [reference], similar to, we train a frcnn detector using top-scoring proposals produced by pcl-ob-g-ens. as groundtruths (pcl-ob-g-ens.+ frcnn in tables). as we can see, the performance is improved further. we then show results of our method on the large scale imagenet detection dataset in table [reference]. we observe similar phenomenon that our method outperforms other methods by a large margin. we finally report results of our method on ms-coco in table [reference]. our method obtains better performance than the recent work. in particular, ge et al. use the method proposed in our conference version paper as a basic component. we can expect to obtain better detection performance through replacing our conference version method in by our newly proposed method here, which we would like to explore in the future. subsection: qualitative results we first show some proposal clusters generated by our method in fig. [reference]. as we can see, the cluster centers contain at least parts of objects and are able to cover adaptive number of objects for each class. we then show qualitative comparisons among the wsddn, the wsddn+ context, and our pcl method, both of which use the same basic mil network. as shown in fig. [reference], we can observe that for classes such as bike, car, cat, etc., our method tends to provide more accurate detections, whereas other two methods sometimes fails by producing boxes that are overlarge or only contain parts of objects (the first four rows in fig. [reference]). but for some classes such as person, our method sometimes fails by only detecting parts of objects such as the head of person (the fifth row in fig. [reference]). exploiting context information sometimes help the detection (as in wsddn+ context), we believe our method can be further improved by incorporating context information into our framework. all these three methods (actually almost all weakly supervised object detection methods) suffers from two problems: producing boxes that not only contain the target object but also include their adjacent similar objects, or only detecting parts of object for objects with deformation (the last row in fig. [reference]). we finally visualize some success and failure detection results on voc 2007 trainval by pcl-ens.+ frcnn, as in fig. [reference]. we observe similar phenomena as in fig. [reference]. our method is robust to the size and aspect of objects, especially for rigid objects. the main failures for these rigid objects are always due to overlarge boxes that not only contain objects, but also include adjacent similar objects. for non-rigid objects like\" cat\",\" dog\", and\" person\", they often have great deformations, but their parts (e.g., head of person) have much less deformation, so our detector is still inclined to find these parts. an ideal solution is yet wanted because there is still room for improvement. subsection: runtime the runtime comparisons between our method and our basic mil network are shown in table [reference], where the runtime of proposal generation is not considered. as we can see, although our method has more components than our basic mil network, our method takes almost the same testing time as it. this is because all our output streams share the same proposal feature computations. the small extra training computations of our method mainly come from the procedures to find proposal cluster centers and generate proposal clusters. although with small extra training computations, our method obtains much better detection results than the basic mil network. section: conclusion in this paper, we propose to generate proposal clusters to learn refined instance classifiers for weakly supervised object detection. we propose two strategies for proposal cluster generation and classifier refinement, both of which can boost the performance significantly. the classifier refinement is implemented by multiple output streams corresponding to some instance classifiers in multiple instance learning networks. an online training algorithm is introduced to train the proposed network end-to-end for effectiveness and efficiency. experiments show substantial and consistent improvements by our method. we observe that the most common failure cases of our algorithm are connected with the deformation of non-rigid objects. in the future, we will concentrate on this problem. in addition, we believe our learning algorithm has the potential to be applied in other weakly supervised visual learning tasks such as weakly supervised semantic segmentation. we will also explore how to apply our method to these related applications. section: acknowledgements this work was supported by nsfc (no. 61733007, no. 61572207, no. 61876212, no. 61672336, no. 61573160), onr with grant n00014-15-1-2356, hubei scientific and technical innovation key project, and the program for hust academic frontier youth team. the corresponding author of this paper is xinggang wang. bibliography: references [] peng tang received the b.s. degree in electronics and information engineering from huazhong university of science and technology (hust) in 2014. he is currently pursuing the ph.d. degree in the school of electronic information and communications at hust, and visiting the department of computer science at johns hopkins university. he was an intern at microsoft research asia in 2017. his research interests include image classification and object detection in images/ videos. [] xinggang wang is an assistant professor of school of electronics information and communications of huazhong university of science and technology (hust). he received his bachelor degree in communication and information system and ph.d. degree in computer vision both from hust. from may 2010 to july 2011, he was with the department of computer and information science, temple university, philadelphia, pa., as a visiting scholar. from february 2013 to september 2013, he was with the university of california, los angeles (ucla), as a visiting graduate researcher. he is a reviewer of ieee trans on pami, ieee trans on image processing, ieee trans. on cybernetics, pattern recognition, computer vision and image understanding, neurocomputing, nips, icml, cvpr, iccv and eccv etc. his research interests include computer vision and machine learning, especially object recognition. [] song bai received the b.s. and ph.d. degree in electronics and information engineering from huazhong university of science and technology (hust), wuhan, china in 2013 and 2018, respectively. he was with university of texas at san antonio (utsa) and johns hopkins university (jhu) as a research scholar. his research interests include image retrieval and classification, 3d shape recognition, person re-identification, semantic segmentation and deep learning. more information can be found in his homepage:. [] wei shen received his b.s. and ph.d. degree both in electronics and information engineering from the huazhong university of science and technology (hust), wuhan, china, in 2007 and in 2012. from april 2011 to november 2011, he worked in microsoft research asia as an intern. in 2012, he joined school of communication and information engineering, shanghai university as an assistant professor. from 2017, he became an associate professor. he is currently visiting department of computer science, johns hopkins university. his current research interests include random forests, deep learning, object detection and segmentation. [] xiang bai received his b.s., m.s., and ph.d. degrees from the huazhong university of science and technology (hust), wuhan, china, in 2003, 2005, and 2009, respectively, all in electronics and information engineering. he is currently a professor with the school of electronic information and communications, hust. he is also the vice-director of the national center of anti-counterfeiting technology, hust. his research interests include object recognition, shape analysis, scene text recognition and intelligent systems. he serves as an associate editor for pattern recognition, pattern recognition letters, neurocomputing and frontiers of computer science. [] wenyu liu received the b.s. degree in computer science from tsinghua university, beijing, china, in 1986, and the m.s. and ph.d. degrees, both in electronics and information engineering, from huazhong university of science and technology (hust), wuhan, china, in 1991 and 2001, respectively. he is now a professor and associate dean of the school of electronic information and communications, hust. his current research areas include computer vision, multimedia, and machine learning. he is a senior member of ieee. [] alan yuille received the b.a. degree in mathematics from the university of cambridge in 1976, and the ph.d. degree in theoretical physics from cambridge in 1980. he then held a post-doctoral position with the physics department, university of texas, austin, and the institute for theoretical physics, santa barbara. he then became a research scientists with the artificial intelligence laboratory, mit, from 1982 to 1986, and followed this with a faculty position in the division of applied sciences, harvard, from 1986 to 1995, rising to the position of an associate professor. from 1995 to 2002, he was a senior scientist with the smith-kettlewell eye research institute in san francisco. from 2002 to 2016, he was a full professor with the department of statistics, ucla, with joint appointments in psychology, computer science, and psychiatry. in 2016, he became a bloomberg distinguished professor of cognitive science and computer science with johns hopkins university. he received the marr prize and the helmholtz prize.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "pascal voc dataset"
                    ],
                    [
                        "imagenet detection dataset"
                    ],
                    [
                        "ms coco dataset"
                    ],
                    [
                        "voc 2007 dataset"
                    ]
                ],
                "Method": [
                    [
                        "pcl"
                    ],
                    [
                        "classifier"
                    ],
                    [
                        "classifier refinement"
                    ],
                    [
                        "pcl"
                    ],
                    [
                        "refined classifier"
                    ],
                    [
                        "mit"
                    ]
                ],
                "Metric": [
                    [
                        "average precision"
                    ],
                    [
                        "ap"
                    ]
                ],
                "Task": [
                    [
                        "weakly supervised object detection"
                    ],
                    [
                        "object detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "weakly supervised object detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "wsod"
                    ],
                    [
                        "wsod"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "imagenet",
                        "image"
                    ]
                ],
                "Method": [
                    [
                        "pcl-ob-g-ens."
                    ]
                ],
                "Metric": [
                    [
                        "map",
                        "multi-class cross entropy loss eq",
                        "mean of ap",
                        "map@0.5",
                        "map@ [.5"
                    ]
                ],
                "Task": [
                    [
                        "weakly supervised object detection",
                        "wsod",
                        "object detection",
                        "detection",
                        "weakly supervised scenario",
                        "wsod problem",
                        "robust wsod"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "pascal voc",
                        "voc 2007",
                        "pascal voc 2007"
                    ]
                ],
                "Method": [
                    [
                        "pcl-ob-g-ens."
                    ]
                ],
                "Metric": [
                    [
                        "map",
                        "multi-class cross entropy loss eq",
                        "mean of ap",
                        "map@0.5",
                        "map@ [.5"
                    ]
                ],
                "Task": [
                    [
                        "weakly supervised object detection",
                        "wsod",
                        "object detection",
                        "detection",
                        "weakly supervised scenario",
                        "wsod problem",
                        "robust wsod"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "pascal voc",
                        "2012 datasets",
                        "pascal voc 2012",
                        "2012"
                    ]
                ],
                "Method": [
                    [
                        "pcl-ob-g-ens."
                    ]
                ],
                "Metric": [
                    [
                        "map",
                        "multi-class cross entropy loss eq",
                        "mean of ap",
                        "map@0.5",
                        "map@ [.5"
                    ]
                ],
                "Task": [
                    [
                        "weakly supervised object detection",
                        "wsod",
                        "object detection",
                        "detection",
                        "weakly supervised scenario",
                        "wsod problem",
                        "robust wsod"
                    ]
                ]
            }
        ]
    },
    "2f04ba0f74df046b0080ca78e56898bd4847898b-43": {
        "doctext": "document: aggregate channel features for multi-view face detection face detection has drawn much attention in recent decades since the seminal work by viola and jones. while many subsequences have improved the work with more powerful learning algorithms, the feature representation used for face detection still ca n't meet the demand for effectively and efficiently handling faces with large appearance variance in the wild. to solve this bottleneck, we borrow the concept of channel features to the face detection domain, which extends the image channel to diverse types like gradient magnitude and oriented gradient histograms and therefore encodes rich information in a simple form. we adopt a novel variant called aggregate channel features, make a full exploration of feature design, and discover a multi-scale version of features with better performance. to deal with poses of faces in the wild, we propose a multi-view detection approach featuring score re-ranking and detection adjustment. following the learning pipelines in viola-jones framework, the multi-view face detector using aggregate channel features shows competitive performance against state-of-the-art algorithms on afw and fddb testsets, while runs at 42 fps on vga images. section: introduction human face detection have long been one of the most fundamental problems in computer vision and human-computer interaction. in the past decade, the most influential work should be the face detection framework proposed by viola and jones. the viola-jones (abbreviated as vj below) framework uses rectangular haar-like features and learns the hypothesis using adaboost algorithm. combined with the attentional cascade structure, the vj detector achieved real-time face detection at that time. despite the great success of the vj detector, the performance is still far from satisfactory due to the large appearance variance of faces in unconstrained settings. to handle faces in the wild, many subsequences of vj framework merged. these methods mainly get the performance gains in two aspects, more complicated features and (or) more powerful learning algorithms. as the combination of boosting and cascade has been proven to be quite effective in face detection, the bottleneck lies in the feature representation since complicated features adopted in the above literatures bring about limited performance gains at the cost of large computation cost. lately in another domain of pedestrian detection, a family of channel features has achieved record performances. channel features compute registered maps of the original images like gradients and histograms of oriented gradients and then extract features on these extended channels. the classifier learning process follows the vj framework pipeline. in this paper, we adopt a variant of channel features called aggregate channel features, which are extracted directly as pixel values on subsampled channels. channel extension offers rich representation capacity, while simple feature form guarantees fast computation. with these two superiorities, the aggregate channel features break through the bottleneck in vj framework and have the potential to make great advance in face detection. as we mainly concentrate our efforts to the feature representation rather than learning algorithms in this paper, we not only just adopt the aggregate channel features in face detection, but also try to explore the full potential of this novel representation. to do so, we make a deep and all-round investigation into the specific feature parameters concerning channel types, feature pool size, subsampling method, feature scale and so on, which gives insights into the feature design and hopefully provides helpful guidelines for practitioners. through the deep exploration, we find that: 1) multi-scaling the feature representation further enriches the representation capacity since original aggregate channel features have uniform feature scale; 2) different combinations of channel types impact the performance greatly, while for face detection the color channel in luv space, plus gradient magnitude channel and gradient histograms channels in rgb space show best result; 3) multi-view detection is proven to be a good match with aggregate channel features as the representation naturally encodes the facial structure (figure [reference]). although multi-view detection could effectively deal with diverse poses, additional issues come up as how to merge detections output by separately trained subview detectors, and how to deal with the offsets of location and scale between output detections and ground-truth. we solve these problems by carefully designed post-processing including score re-ranking, detection merging and bounding box adjustment. the detailed experimental exploration of aggregate channel features, along with our improvements on multi-view detection, leads to large performance gain in face detection in the wild. on two challenging face databases, afw and fddb, the proposed multi-view face detector shows competitive performance against state-of-the-art detectors in both detection accuracy and speed. the remaining parts of this paper are organized as follows. section 2 revisits related work in face detection. section 3 describes how we build the face detector using aggregate channel features. section 4 addresses problems concerning multi-view face detection. experimental results on afw and fddb are shown in section 5 and we conclude the paper in section 6. section: related work face detection has drawn much attention since the early time of computer vision. although many solutions had been put forward, it was not until viola and jones proposed their milestone work that face detection saw surprising progress in the past decades. the vj face detector features in three aspects: fast feature computation via integral image representation, classifier learning using adaboost, and the attentional cascade structure. one main drawback of the vj framework is that the features have limited representation capacity, while the feature pool size is quite large to compensate for that. typically, in a detection window, the number of haar-like features is 160, 000. to address the problem, efforts are made in two directions. some focus on more complicated features like hog, surf. some aim to speed up the feature selection in a heuristic way. however, the problem has n't been solved perfectly. in this paper, we mainly focus on the feature representation part and make a deep exploration into it, which is complementary to existing work on the learning algorithm and classifier structure in the vj framework. recently channel features have been proposed and shown record performance in pedestrian detection. due to the channel extension to diverse types like gradients and local histograms, the features show richer representation capacity for classification. however, the features are extracted as rectangular sums at various locations and scales which we believe leads to a redundant feature pool. during preparation of this paper, mathias independently discover the effectiveness of integral channel features in face detection domain. in this paper, we adopt a novel variant of channel features called aggregate channel features, which extract features directly as pixel values in extended channels without computing rectangular sums at various locations and scales. the feature has powerful representation capacity and the feature pool size is only several thousands. through careful design in section 3 and implementation of multi-view detection in section 4, the aggregate channel features based detector achieves state-of-the-art performance on challenging databases. section: proposed face detector in this section, we make a full exploration of the aggregate channel features in the context of face detection. we first give a brief introduction of the feature itself, including its computation, properties and advantages over traditional haar-like features used in vj framework. then the detailed experimental investigation is described in two parts, feature design and training design. before that, some guidelines concerning how we conduct the investigation are demonstrated. each design part is divided into several separate experiments ended with a summary explaining the specific parameters used in our proposed face detector. note that each experiment focuses on only one parameter and the others remain constant. through the well-designed experiments, the proposed face detector based on aggregate channel features is built step by step. issues concerning the implementation of multi-view face detection which further improves the performance are discussed in the next section. subsection: feature description channel extension: the basic structure of the aggregate channel features is channel. the application of channel has a long history since digital images were invented. the most common type of channel should be the color channels of the image, with gray-scale and rgb being typical ones. besides color channels, many different channel types have been invented to encode different types of information for more difficult problems. generally, channels can be defined as a registered map of the original image, whose pixels are computed from corresponding patches of original pixels. different channels can be computed with linear or non-linear transformation of the original image. to allow for sliding window detection, the transformations are constrained to be translationally invariant. feature computation: based on the definition of channels, the computation of aggregate channel features is quite simple. as shown in figure [reference], given a color image, all defined channels are computed and subsampled by a pre-set factor. the aggregate pixels in all subsampled channels are then vectorized into a pixel look-up table. note that an optional smoothing procedure can be done on each channel with a binomial filter both before computation and after subsampling. classifier learning: the learning process is quite simple. two changes are made compared with vj framework. first is that weak classifier is changed from decision stump to depth-2 decision tree. the more complex weak classifier shows stronger ability in seeking the discriminant intra and inter channel correlations for classification. second difference is that soft-cascade structure is used. unlike the attentional cascade structure in vj framework which has several cascade stages, a single-stage classifier is trained on the whole training data and a threshold is then set after each weak classifier picked by adaboost. these two changes lead to more efficient training and detection. overall superiority: compared with traditional haar-like features used in vj framework, aggregate channel features have the following differences and advantages: 1) the image channels are extended to more types in order to encode diverse information like color, gradients, local histograms and so on, therefore possess richer representation capacity. 2) features are extracted directly as pixel values on downsampled channels rather than computing rectangular sums with various locations and scales using integral images, leading to a faster feature computation and smaller feature pool size for boosting learning. with the help of cascade structure, detection speed is accelerated more. 3) due to its structure consistence with the overall image, when coupled with boosting method, the boosted classifier naturally encodes structured pattern information from large training data (see figure [reference] for an illustration), which gives more accurate localization of faces in the image. subsection: investigation guidelines all investigations are trained on the aflw face database and tested on the annotated faces in the wild (afw) testset. to make it clear, there are in total positive samples and negative samples selected from aflw which are kept constant in all investigations. testset contains natural images with faces that vary a lot in pose, appearance and illumination. to alleviate the ground-truth offset caused by different annotation styles (figure [reference]) in training and testing set and make the evaluation more comparable, a lower jaccard index with threshold is adopted in comparative evaluation. practically the lower threshold wo n't cause errors being mistakenly corrected. note that in final evaluation of the proposed face detector (section 5), the afw testset, together with another face benchmark fddb database, are used as testbed and the evaluation metric follows the database protocol. subsection: feature design to fully exploit the power of aggregate channel features in face detection domain, a deep investigation into the design of the feature is done mainly on channel types, window size, subsampling method and feature scale. results of comparative experiments are shown in figure [reference]. channel types: three types of channels are used, which are color channel (gray-scale, rgb, hsv and luv), gradient magnitude, and gradient histograms. the computation of the latter two channel types could be seen as a generalized version of hog features. specifically, gradient magnitude is the biggest response on all three color channels, and oriented gradient histograms follow the idea of hog in that: 1) rectangular cell size in hog equals the subsampling factor in aggregated channel features; 2) each orientation bin results in one feature channel (6 orientation bins are used in this paper). figure [reference] (a)~ (c) show how much each of these three types alone contributes to the performance of face detection. it can be seen that the gradient histograms contribute most to the performance among all three channel types. figure [reference] (d) shows the performances of combinations of these three types computed on different color channels. detection window size: detection window size is the scale to which we resize all face and non-face samples and then train our detector. larger window size includes more pixels in feature pool and thus may improve the face detection performance. on the other hand, too large window will miss some small faces and diminish the detection efficiency. figure [reference] (e) shows comparison of window size ranging from to with a stride of pixels. subsampling: the factor for subsampling can be regarded as the perceptive scale for that it controls the scale at which the aggregation is done. changing the factor from large to small leads to the feature representation shifting from coarse to fine and the feature pool size getting bigger. experiments on different subsampling factors are shown in figure [reference] (f). in original aggregate channel features, the way to do subsampling is average pooling. following the idea in convolutional neural networks, another two ways of subsampling, max pooling and stochastic pooling are tested in figure [reference] (g). smoothing: as described in feature description, both pre and post smoothing is done in default setting of aggregate channel features. a binomial filter with a radius of is used for smoothing. the smoothing procedure also has a great influence on the scale of the feature representation. concretely, pre-smoothing determines how far the local neighborhood is in which local correlations are encoded before channel computation, while post-smoothing determines the neighborhood size in which the computed channel features are integrated with each other. in, the former corresponds to the 'local scale' of the feature, while the latter represents the 'integration scale'. we vary the filter radius used in pre and post smoothing and find that both using a radius of gets the best results. figure [reference] (h)~ (i) present the comparative results. multi-scale: in aggregate channel features, although hidden information at different scale could be extracted at a cost of more weak classifiers, it would be better to make the integrated channel features multi-scaled and thus make themselves more discriminant. therefore the same or better classification performance can be achieved with fewer weak classifiers. in this part, we implement three multi-scale version of aggregate channel features in the aforementioned three kinds of scale, perceptive scale (subsampling), local scale (pre-smoothing) and integration scale (post-smoothing) and compare their performaces. see results in figure [reference] (j)~ (l). summary: the color channel, gradient magnitude and gradient histograms prove themselves a good match in aggregate channel features. however, different choices of color channel used and on which gradients are computed have a great impact on performance. according to the experiments, luv channel and gradient magnitude and 6-bin histograms computed on rgb color space (in total 10 channels) are the best choice for face detection. larger detection window size generally gets better performance, but will miss many small faces in testing and lead to inefficient detection. in this work, we set the size to as its optimal performance. a subsampling factor of is most reasonable according to the experiments, while different pooling methods show small differences. however, max pooling and stochastic pooling are much slower than average pooling, therefore the average pooling becomes the best match for the sake of efficiency. in this way, the resulting feature pool size of our face detector is, considerably smaller than that in vj framework. as for multi-scale version of aggregate channel features, multi-local-scale with an additional scale of radius shows the best performance. the probable reason is that pre-smoothing controls the local scale of the neighborhood feature correlations and therefore matches the intuition inside multi-scale best. compared with other fine-tuning, the multi-scale version has a notable performance gain for that it makes up for the scale uniformity caused by subsampling to some extent. one main drawback is that it doubles the feature pool size and as a result slows down the detection speed somewhat. based on the trade-off, we implement two face detectors with different scale settings, one is single-scaled with faster speed and the other is multi-scaled with better accuracy. we evaluate and discuss the performances of these two versions in detail in section 5. subsection: training design besides careful design of the aggregate channel features, experiments on the training process which is similar to that in vj framework are also carried out. the differences are that the weak classifier is changed into depth-2 decision tree and soft-cascade structure is used. details of the training design are as follows. number of weak classifiers: given a feature pool size of, we vary the number of weak classifiers contained in the soft-cascade. in figure [reference] performances of various numbers of weak classifiers ranging from to are displayed, which shows that apparently more classifiers generate better performance, and when the number gets larger the performance begins to saturate. since more classifiers slow down the detection speed, there's a trade-off between accuracy and speed. searching for the saturate point as the optimal is significant during training in such framework. training data: empirically, more training data will get better performance given powerful representation capacity. in this case, aflw database is used as the only positive training data. however, as images in aflw database are very salient and the background has very less variance, negative samples cropped from the aflw database ca n't represent the real world scenario well, which limits the face detection performance in the wild. in this part, we further use pascal voc database and randomly crop windows from images without person as the new negative samples. experiments show that the new training data containing cluttered background significantly improve the performance with. summary: based on observations above, we choose as the number of weak classifiers contained in the soft cascade. as each weak classifier is a depth-2 decision tree, it takes only two comparing operations to apply a weak classifier, which is quite fast. during training, as negative data is large, we adopt a standard bootstrap procedure to sample hard negative samples from pascal voc in the implementation of the proposed face detector. section: multi-view detection human faces in real world usually have highly varied poses. in aflw database, the human pose is divided into three aspects: 1 in-plane rotation 'roll' and 2 out-of-plane rotations 'yaw' and 'pitch'. because of this large variance in face pose, it is difficult to train a single view face detector to handle all the poses effectively. a multi-view detection is further examined in this part. due to the adoption of soft-cascade structure, a multi-view version of face detector wo n't cause too much computation burden. typically, we divide the out-of-plane rotation\u00a1\u00b0 yaw\u00a1\u00b1 into different views and let the classifier itself tolerate the pose variance in the other two types of rotations. adopting multi-view detection also brings about many troublesome issues. if handled improperly, the performance will differ greatly. first, detectors of different view will each produce a set of candidate positive windows followed with a set of confidence scores. for application purpose, we need to merge these detections from different views and also remove duplicated windows. a typical approach is non-maximum suppression (nms). an issue rises on how to compare confidence scores from different classifiers and how to do window merging in the trade-off between high precision rate and high detection rate. second, as for detection evaluation, usually the overlap of bounding boxes is used as the criterion. however, annotations in different data sets may not have a consistent style (figure [reference] (a)). this diversity suffers more in profile faces. since our face detector is trained and tested on different data sets, this issue impacts the performance a lot. third, detectors of different views need to be trained with different samples separately. how to divide the views therefore becomes another concerning problem. in this section, we address the above three issues successfully by careful designs and therefore fully exploit the advantage of multi-view detection. subsection: view partition in the scenario of detecting faces in the wild, pose variation caused by yaw is usually severer than pitch and roll. therefore we divide the faces in aflw database according to yaw angle. we have subviews which are horizontally symmetric (see figure. [reference] (b)) because we flip each image in the training set. specifically, there are,,,,, images in views from to. benefitting from the symmetry of our model, we can only train three subview detectors of the right side for simplicity, and use these trained right-side detectors to generate the left-side detectors. detections of all six detectors are then merged to get the final detections. though multi-view detection significantly improves the detection performance (especially the recall rate), the post-processing of detections from different detectors becomes a trouble. if handled improperly, the performance degrades a lot. subsection: post-processing difficulties in the post-processing of multi-view detection mainly reflect on the following aspects: 1) different score distributions and; 2) different bounding box styles. concretely, as each subview detector is trained separately, their output confidence scores usually have different distributions. what's more, due to the annotation rule in the aflw database that the face's nose is approximately at the center location of the bounding box ground-truth, as the subview changes, the bounding box shifts. this bounding box offset causes difficulty both in detection merging and final evaluation using jaccard index metric. to solve these annoying issues and make the best use of multi-view detection, we introduce the following methods for post-processing. score re-ranking: we propose the following three kinds of score re-ranking: 1) normalizing scores of different views to [0, 1]; 2) defining a new score that has uniform distribution and; 3) taking overlapping detections into consideration.: after training a classifier, calculate the output range of the classifier and use the range to do normalization later so that output score has a range of [0, 1].: originally, each weak classifier in the soft-cascade owns a score and final score is the sum of all scores. instead, we use the number of weak classifier that the image patch passed positively as the new score. therefore the upper limit of the new score is in our case.: given an image, multiple detections from multi-view detectors exist each with a score. for each detection, we first calculate the number of overlapped detection it has (overlap threshold is) and then multiply score of each detection with a factor of its overlapping number ranking.: instead of using overlapping as a multiply factor, here we use the sum of overlapped detections' scores as the current detection's new score. detection merging: apart from the version of non maximum suppression, we also use the detection combination introduced in. it averages the locations of overlapped detections rather than suppresses them. detection adjustment: as shown in figure [reference] (a), different databases have different annotation styles of ground-truth. specifically, aflw has square annotations with nose located approximately at the center. afw uses tight rectangular bounding boxes as annotations with the eye-brow being the approximate upper bound. fddb uses elliptical annotations bounding the whole head. as our detector is trained on aflw and tested on afw and fddb, there exist offsets in both detection position and scale. according to observations, the offsets vary as face pose changes. therefore we adopt a view-specific detection adjustment to alleviate the offsets. note that the adjustment is constant for all images and faces in the same database, see figure [reference] (b) for details. summary: according to experimental results (table [reference]), seems to be the best score re-ranking method. the underlying reason may be that true positives usually have many overlapped detections, while the false positives would only get a few responses. therefore leveraging this overlapping information in score re-ranking can reduce many false positives. however, in practice, overlap related methods and detection combination both cost much time to process, which is infeasible in a large majority of applications. we finally adopt score re-ranking combined with non maximum suppression for the sake of detection speed. section: experiments in this section, we compare our method with state-of-the-art methods on afw and fddb databases which contain challenging faces in the wild. in afw, we compare with three commercial systems (google picasa, face.com and face++) and five academic methods (shen, zhu, dpm, multihog and kalal). in fddb, we compare with one commercial system (olaworks) and six academic methods (yan, boosted exemplar, surf multiview, pep-adapt, xzjy and zhu) listed on fddb results page. subsection: evaluation on benchmark face database as shown in figure [reference], in afw, our multi-scale detector achieves an ap value of, outperforming other academic methods by a large margin. when it comes to commercial systems, ours is better than face.com and almost equal to face++ and google picasa. note that most of our false positives on afw database are faces that have n't been annotated (small, seriously occluded or artificial faces like mask and cartoon character). when evaluated on fddb database, we follow the evaluation protocol in and report the average discrete and continuous roc of the ten subfolders. for equality, we fix the number of false positives to (equivalent to an average of false positive per image) and compare the true positive rate. in discrete score where evaluation metric is the same as in afw, our detector achieves, which is a little better than yan. note that the ground-truth in fddb are elliptical faces, therefore the evaluation metric of an overlap ratio bigger than can not reveal the true performance of the proposed detector well. when using continuous score which takes the overlap ratio as the score, our method gets true positive rate at fppi for multi-scale version, surpassing other methods which output rectangular detections by a notable margin (the yan detector outputs the same elliptical detections as the ground-truth, therefore having advantages with this metric). our detector using single-scale features performs a little worse with the benefit of faster detection speed. subsection: discussion training efficiency: we implement the method with piotr's matlab toolbox on a pc with intel core i7-3770 cpu and 16 gb ram. with positive images and negative images in total 6 views, the training process takes about mins for a single-scale subview detector containing weak classifiers and mins for multi-scale version. note that we use much fewer training data than surf multiview whilst still outperforming their performance. comparative results: when inspecting detections of the proposed face detector and other algorithms on the testsets, some patterns can be found to explain why our detector outperforms others. one evident strength lies in detecting faces with extreme poses. because we adopt multi-view detection and train each subview detector separately, our detector handles pose variations very well. second is the outstanding illumination invariance of our detector, which is mainly owing to the extension of channel types to luv color space and gradient-related channels. detection speed: due to the simple form of aggregate channel features and fast computation of feature pyramid, detection is quite efficient. for full yaw pose face detection in vga image, the proposed detector using single-scale features runs at fps on a single thread and fps if threads are used. if only frontal faces are concerned, the detector runs at fps and fps after parallelization. when it comes to the proposed detector using multi-scale features, the above four indices reduce to,, and fps. considering the large performance gain and similar speed, the proposed method can replace viola-jones detector for face detection in the wild. section: conclusion a novel feature representation called aggregate channel features possesses the merits of fast feature extraction and powerful representation capacity. in this paper, we successfully apply the feature representation to face detection domain through a deep investigation into the feature design, and propose a multi-scale version of feature which further enriches the representation capacity. combined with our efforts into solving issues concerning multi-view detection, the proposed multi-view face detector shows state-of-the-art performance in both effectiveness and efficiency on faces in the wild. the proposed method appeals to real world application demands and has the potential to be embedded into low power devices. section: acknowledgement this work was supported by the chinese national natural science foundation projects# 61105023,# 61103156,# 61105037,# 61203267,# 61375037, national science and technology support program project# 2013bak02b01, chinese academy of sciences project no. kgzd-ew-102-2, and authenmetric r& d funds. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "face detection domain"
                    ],
                    [
                        "afw"
                    ],
                    [
                        "aflw database"
                    ]
                ],
                "Method": [
                    [
                        "aggregate channel features"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "multi view face detection"
                    ],
                    [
                        "face detection"
                    ],
                    [
                        "face detection face detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "detection face detection"
                    ],
                    [
                        "face detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "multi view detection"
                    ],
                    [
                        "detecting faces"
                    ],
                    [
                        "full yaw pose face detection"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "afw"
                    ]
                ],
                "Metric": [
                    [
                        "representation capacity",
                        "feature pool size",
                        "classification performance",
                        "false positives"
                    ]
                ],
                "Task": [
                    [
                        "multi-view face detection"
                    ]
                ]
            }
        ]
    },
    "2f56b1ac5b9faac9527b6814778925e9242cf5fd-44": {
        "doctext": "document: training region-based object detectors with online hard example mining the field of object detection has made significant advances riding on the wave of region-based convnets, but their training procedure still includes many heuristics and hyperparameters that are costly to tune. we present a simple yet surprisingly effective online hard example mining (ohem) algorithm for training region-based convnet detectors. our motivation is the same as it has always been- detection datasets contain an overwhelming number of easy examples and a small number of hard examples. automatic selection of these hard examples can make training more effective and efficient. ohem is a simple and intuitive algorithm that eliminates several heuristics and hyperparameters in common use. but more importantly, it yields consistent and significant boosts in detection performance on benchmarks like pascal voc 2007 and 2012. its effectiveness increases as datasets become larger and more difficult, as demonstrated by the results on the ms coco dataset. moreover, combined with complementary advances in the field, ohem leads to state-of-the-art results of 78.9% and 76.3% map on pascal voc 2007 and 2012 respectively. section: introduction image classification and object detection are two fundamental computer vision tasks. object detectors are often trained through a reduction that converts object detection into an image classification problem. this reduction introduces a new challenge that is not found in natural image classification tasks: the training set is distinguished by a large imbalance between the number of annotated objects and the number of background examples (image regions not belonging to any object class of interest). in the case of sliding-window object detectors, such as the deformable parts model (dpm), this imbalance may be as extreme as 100, 000 background examples to every one object. the recent trend towards object-proposal-based detectors mitigates this issue to an extent, but the imbalance ratio may still be high (, 70:1). this challenge opens space for learning techniques that cope with imbalance and yield faster training, higher accuracy, or both. unsurprisingly, this is not a new challenge and a standard solution, originally called bootstrapping (and now often called hard negative mining), has existed for at least 20 years. bootstrapping was introduced in the work of sung and poggio in the mid-1990's (if not earlier) for training face detection models. their key idea was to gradually grow, or bootstrap, the set of background examples by selecting those examples for which the detector triggers a false alarm. this strategy leads to an iterative training algorithm that alternates between updating the detection model given the current set of examples, and then using the updated model to find new false positives to add to the bootstrapped training set. the process typically commences with a training set consisting of all object examples and a small, random set of background examples. bootstrapping has seen widespread use in the intervening decades of object detection research. dalal and triggs used it when training svms for pedestrian detection. felzenszwalb later proved that a form of bootstrapping for svms converges to the global optimal solution defined on the entire dataset. their algorithm is often referred to as hard negative mining and is frequently used when training svms for object detection. bootstrapping was also successfully applied to a variety of other learning models, including shallow neural networks and boosted decision trees. even modern detection methods based on deep convolutional neural networks (convnets), such as r-cnn and sppnet, still employ svms trained with hard negative mining. it may seem odd then that the current state-of-the-art object detectors, embodied by fast r-cnn and its descendants, do not use bootstrapping. the underlying reason is a technical difficulty brought on by the shift towards purely online learning algorithms, particularly in the context of deep convnets trained with stochastic gradient descent (sgd) on millions of examples. bootstrapping, and its variants in the literature, rely on the aforementioned alternation template: (a) for some period of time a fixed model is used to find new examples to add to the active training set; (b) then, for some period of time the model is trained on the fixed active training set. training deep convnet detectors with sgd typically requires hundreds of thousands of sgd steps and freezing the model for even a few iterations at a time would dramatically slow progress. what is needed, instead, is a purely online form of hard example selection. in this paper, we propose a novel bootstrapping technique called online hard example mining (ohem) for training state-of-the-art detection models based on deep convnets. the algorithm is a simple modification to sgd in which training examples are sampled according to a non-uniform, non-stationary distribution that depends on the current loss of each example under consideration. the method takes advantage of detection-specific problem structure in which each sgd mini-batch consists of only one or two images, but thousands of candidate examples. the candidate examples are subsampled according to a distribution that favors diverse, high loss instances. gradient computation (backpropagation) is still efficient because it only uses a small subset of all candidates. we apply ohem to the standard fast r-cnn detection method and show three benefits compared to the baseline training algorithm: it removes the need for several heuristics and hyperparameters commonly used in region-based convnets. it yields a consistent and significant boosts in mean average precision. its effectiveness increases as the training set becomes larger and more difficult, as demonstrated by results on the ms coco dataset. moreover, the gains from ohem are complementary to recent improvements in object detection, such as multi-scale testing and iterative bounding-box regression. combined with these tricks, ohem gives state-of-the-art results of 78.9% and 76.3% map on pascal voc 2007 and 2012, respectively. section: related work object detection is one of the oldest and most fundamental problems in computer vision. the idea of dataset bootstrapping, typically called hard negative mining in recent work, appears in the training of most successful object detectors. many of these approaches use svms as the detection scoring function, even after training a deep convolutional neural network (convnet) for feature extraction. one notable exception is the fast r-cnn detector and its descendants, such as faster r-cnn. since these models do not use svms, and are trained purely online with sgd, existing hard example mining techniques can not be immediately applied. this work addresses that problem by introducing an online hard example mining algorithm that improves optimization and detection accuracy. we briefly review hard example mining, modern convnet-based object detection, and relationships to concurrent works using hard example selection for training deep networks. paragraph: hard example mining. there are two hard example mining algorithms in common use. the first is used when optimizing svms. in this case, the training algorithm maintains a working set of examples and alternates between training an svm to convergence on the working set, and updating the working set by removing some examples and adding others according to a specific rule. the rule removes examples that are\" easy\" in the sense that they are correctly classified beyond the current model's margin. conversely, the rule adds new examples that are hard in the sense that they violate the current model's margin. applying this rule leads to the global svm solution. importantly, the working set is usually a small subset of the entire training set. the second method is used for non-svms and has been applied to a variety of models including shallow neural networks and boosted decision trees. this algorithm usually starts with a dataset of positive examples and a random set of negative examples. the machine learning model is then trained to convergence on that dataset and subsequently applied to a larger dataset to harvest false positives. the false positives are then added to the training set and then the model is trained again. this process is usually iterated only once and does not have any convergence proofs. paragraph: convnet-based object detection. in the last three years significant gains have been made in object detection. these improvements were made possible by the successful application of deep convnets to imagenet classification. the r-cnn and overfeat detectors lead this wave with impressive results on pascal voc and imagenet detection. overfeat is based on the sliding-window detection method, which is perhaps the most intuitive and oldest search method for detection. r-cnn, in contrast, uses region proposals, a method that was made popular by the selective search algorithm. since r-cnn, there has been rapid progress in region-based convnets, including sppnet, mr-cnn, and fast r-cnn, which our work builds on. paragraph: hard example selection in deep learning. there is recent work concurrent to our own that selects hard examples for training deep networks. similar to our approach, all these methods base their selection on the current loss for each datapoint. independently selects hard positive and negative example from a larger set of random examples based on their loss to learn image descriptors. given a positive pair of patches, finds hard negative patches from a large set using triplet loss. akin to our approach, investigates online selection of hard examples for mini-batch sgd methods. their selection is also based on loss, but the focus is on convnets for image classification. complementary to, we focus on online hard example selection strategy for region-based object detectors. section: overview of fast r-cnn we first summarize the fast r-cnn (frcn) framework. frcn takes as input an image and a set of object proposal regions of interest (rois). the frcn network itself can be divided into two sequential parts: a convolutional (conv) network with several convolution and max-pooling layers (figure [reference],\" convolutional network\"); and an roi network with an roi-pooling layer, several fully-connected (fc) layers and two loss layers (figure [reference],\" roi network\"). during inference, the conv network is applied to the given image to produce a conv feature map, size of which depends on the input image dimensions. then, for each object proposal, the roi-pooling layer projects the proposal onto the conv feature map and extracts a fixed-length feature vector. each feature vector is fed into the fc layers, which finally give two outputs: (1) a softmax probability distribution over the object classes and background; and (2) regressed coordinates for bounding-box relocalization. there are several reasons for choosing frcn as our base object detector, apart from it being a fast end-to-end system. firstly, the basic two network setup (conv and roi) is also used by other recent detectors like sppnet and mr-cnn; therefore, our proposed algorithm is more broadly applicable. secondly, though the basic setup is similar, frcn also allows for training the entire conv network, as opposed to both sppnet and mr-cnn which keep the conv network fixed. and finally, both sppnet and mr-cnn require features from the roi network to be cached for training a separate svm classifier (using hard negative mining). frcn uses the roi network itself to train the desired classifiers. in fact, shows that in the unified system using the svm classifiers at later stages was unnecessary. subsection: training like most deep networks, frcn is trained using stochastic gradient descent (sgd). the loss per example roi is the sum of a classification log loss that encourages predicting the correct object (or background) label and a localization loss that encourages predicting an accurate bounding box (see for details). to share conv network computation between rois, sgd mini-batches are created hierarchically. for each mini-batch, images are first sampled from the dataset, and then rois are sampled from each image. setting and works well in practice. the roi sampling procedure uses several heuristics, which we describe briefly below. one contribution of this paper is to eliminate some of these heuristics and their hyperparameters. paragraph: foreground rois. for an example roi to be labeled as foreground (fg), its intersection over union (iou) overlap with a ground-truth bounding box should be at least. this is a fairly standard design choice, in part inspired by the evaluation protocol of the pascal voc object detection benchmark. the same criterion is used in the svm hard mining procedures of r-cnn, sppnet, and mr-cnn. we use the same setting. paragraph: background rois. a region is labeled background (bg) if its maximum iou with ground truth is in the interval bg_lo, 0.5). a lower threshold of bg_lo is used by both frcn and sppnet, and is hypothesized in to crudely approximate hard negative mining; the assumption is that regions with some overlap with the ground truth are more likely to be the confusing or hard ones. we show in section [reference] that although this heuristic helps convergence and detection accuracy, it is suboptimal because it ignores some infrequent, but important, difficult background regions. our method removes the bg_lo threshold. paragraph: balancing fg-bg rois: to handle the data imbalance described in section [reference], designed heuristics to rebalance the foreground-to-background ratio in each mini-batch to a target of by undersampling the background patches at random, thus ensuring that of a mini-batch is fg rois. we found that this is an important design decision for the training frcn. removing this ratio (randomly sampling rois), or increasing it, decreases accuracy by points map. with our proposed method, we can remove this ratio hyperparameter with no ill effect. section: our approach we propose a simple yet effective online hard example mining algorithm for training fast r-cnn (or any fast r-cnn style object detector). we argue that the current way of creating mini-batches for sgd (section [reference]) is inefficient and suboptimal, and we demonstrate that our approach leads to better training (lower training loss) and higher testing performance (map). subsection: online hard example mining recall the alternating steps that define a hard example mining algorithm: (a) for some period of time a fixed model is used to find new examples to add to the active training set; (b) then, for some period of time the model is trained on the fixed active training set. in the context of svm-based object detectors, such as the svms trained in r-cnn or sppnet, step (a) inspects a variable number of images (often 10's or 100's) until the active training set reaches a threshold size, and then in step (b) the svm is trained to convergence on the active training set. this process repeats until the active training set contains all support vectors. applying an analogous strategy to frcn convnet training slows learning because no model updates are made while selecting examples from the 10's or 100's of images. our main observation is that these alternating steps can be combined with how frcn is trained using online sgd. the key is that although each sgd iteration samples only a small number of images, each image contains thousands of example rois from which we can select the hard examples rather than a heuristically sampled subset. this strategy fits the alternation template to sgd by\" freezing\" the model for only one mini-batch. thus the model is updated exactly as frequently as with the baseline sgd approach and therefore learning is not delayed. more specifically, the online hard example mining algorithm (ohem) proceeds as follows. for an input image at sgd iteration, we first compute a conv feature map using the conv network. then the roi network uses this feature map and the all the input rois, instead of a sampled mini-batch, to do a forward pass. recall that this step only involves roi pooling, a few fc layers, and loss computation for each roi. the loss represents how well the current network performs on each roi. hard examples are selected by sorting the input rois by loss and taking the examples for which the current network performs worst. most of the forward computation is shared between rois via the conv feature map, so the extra computation needed to forward all rois is relatively small. moreover, because only a small number of rois are selected for updating the model, the backward pass is no more expensive than before. however, there is a small caveat: co-located rois with high overlap are likely to have correlated losses. moreover, these overlapping rois can project onto the same region in the conv feature map, because of resolution disparity, thus leading to loss double counting. to deal with these redundant and correlated regions, we use standard non-maximum suppression (nms) to perform deduplication (the implementation from). given a list of rois and their losses, nms works by iteratively selecting the roi with the highest loss, and then removing all lower loss rois that have high overlap with the selected region. we use a relaxed iou threshold of to suppress only highly overlapping rois. we note that the procedure described above does not need a fg-bg ratio for data balancing. if any class were neglected, its loss would increase until it has a high probability of being sampled. there can be images where the fg rois are easy (canonical view of a car), so the network is free to use only bg regions in a mini-batch; and vice-versa when bg is trivial (sky, grass), the mini-batch can be entirely fg regions. subsection: implementation details there are many ways to implement ohem in the frcn detector, each with different trade-offs. an obvious way is to modify the loss layers to do the hard example selection. the loss layer can compute loss for all rois, sort them based on this loss to select hard rois, and finally set the loss of all non-hard rois to. though straightforward, this implementation is inefficient as the roi network still allocates memory and performs backward pass for all rois, even though most rois have loss and hence no gradient updates (a limitation of current deep learning toolboxes). to overcome this, we propose the architecture presented in figure [reference]. our implementation maintains two copies of the roi network, one of which is readonly. this implies that the readonly roi network (figure [reference] (a)) allocates memory only for forward pass of all rois as opposed to the standard roi network, which allocates memory for both forward and backward passes. for an sgd iteration, given the conv feature map, the readonly roi network performs a forward pass and computes loss for all input rois (figure [reference], green arrows). then the hard roi sampling module uses the procedure described in section [reference] to select hard examples, which are input to the regular roi network (figure [reference] (b), red arrows)). this network computes forward and backward passes only for, accumulates the gradients and passes them to the conv network. in practice, we use all rois from all images as, therefore the effective batch size for the readonly roi network is and for the regular roi network is the standard from section [reference]. we implement both options described above using the caffe framework (see). our implementation uses gradient accumulation with forward-backward passes of single image mini-batches. following frcn, we use (which results in) and. under these settings, the proposed architecture (figure [reference]) has similar memory footprint as the first option, but is faster. unless specified otherwise, the architecture and settings described above will be used throughout this paper. section: analyzing online hard example mining this section compares frcn training with online hard example mining (ohem) to the baseline heuristic sampling approach. we also compare frcn with ohem to a less efficient approach that uses all available example rois in each mini-batch, not just the hardest examples. subsection: experimental setup we conduct experiments with two standard convnet architectures: vgg_cnn_m_1024 (vggm, for short) from, which is a wider version of alexnet, and vgg16 from. all experiments in this section are performed on the pascal voc07 dataset. training is done on the trainval set and testing on the test set. unless specified otherwise, we will use the default settings from frcn. we train all methods with sgd for 80k mini-batch iterations, with an initial learning rate of 0.001 and we decay the learning rate by 0.1 every 30k iterations. the baseline numbers reported in table [reference] (row 1-2) were reproduced using our training schedule and are slightly higher than the ones reported in. subsection: ohem vs. heuristic sampling standard frcn, reported in table [reference] (rows), uses as a heuristic for hard mining (section [reference]). to test the importance of this heuristic, we ran frcn with. table [reference] (rows) shows that for vggm, map drops by points, whereas for vgg16 it remains roughly the same. now compare this to training frcn with ohem (rows). ohem improves map by points compared to frcn with the heuristic for vggm, and points without the heuristic. this result demonstrates the sub-optimality of these heuristics and the effectiveness of our hard mining approach. subsection: robust gradient estimates one concern over using only images per batch is that it may cause unstable gradients and slow convergence because rois from an image may be highly correlated. frcn reports that this was not a practical issue for their training. but this detail might raise concerns over our training procedure because we use examples with high loss from the same image and as a result they may be more highly correlated. to address this concern, we experiment with in order to increase correlation in an effort to break our method. as seen in table [reference] (rows), performance of the original frcn drops by point with, but when using our training procedure, map remains approximately the same. this shows that ohem is robust in case one needs fewer images per batch in order to reduce gpu memory usage. subsection: why just hard examples, when you can use all? online hard example mining is based on the hypothesis that it is important to consider all rois in an image and then select hard examples for training. but what if we train with all the rois, not just the hard ones? the easy examples will have low loss, and wo n't contribute much to the gradient; training will automatically focus on the hard examples. to compare this option, we ran standard frcn training with a large mini-batch size of, using, and with other hyperparameters fixed. because this experiment uses a large mini-batch, it's important to tune the learning rate to adjust for this change. we found optimal results by increasing it to for vgg16 and for vggm. the outcomes are reported in table [reference] (rows). using these settings, map of both vgg16 and vggm increased by point compared to, but the improvement from our approach is still points over using all rois. moreover, because we compute gradients with a smaller mini-batch size training is faster. removing hard mining heuristic (section [reference]) fewer images per batch (section [reference]) bigger batch, high lr (section [reference]) our approach subsection: better optimization finally, we analyze the training loss for the various frcn training methods discussed above. it's important to measure training loss in a way that does not depend on the sampling procedure and thus results in a valid comparison between methods. to achieve this goal, we take model snapshots from each method every 20k steps of optimization and run them over the entire voc07 trainval set to compute the average loss over all rois. this measures the training set loss in a way that does not depend on the example sampling scheme. figure [reference] shows the average loss per roi for vgg16 with the various hyperparameter settings discussed above and presented in table [reference]. we see that results in the highest training loss, while using the heuristic results in a much lower training loss. increasing the mini-batch size to and increasing the learning rate lowers the training loss below the heuristic. our proposed online hard example mining method achieves the lowest training loss of all methods, validating our claims that ohem leads to better training for frcn.*: uses gradient accumulation over two forward/ backward passes subsection: computational cost ohem adds reasonable computational and memory overhead, as reported in table [reference]. ohem costs 0.09s per training iteration for vggm network (0.43s for vgg16) and requires 1 g more memory (2.3 g for vgg16). given that frcn is a fast detector to train, the increase in training time is likely acceptable to most users., 2http:// host.robots.ox.ac.uk:8080/ anonymous/ h49ptt.html, 3http:// host.robots.ox.ac.uk:8080/ anonymous/ lsantb.html, 4http:// host.robots.ox.ac.uk:8080/ anonymous/ r7eamx.html section: pascal voc and ms coco results in this section, we evaluate our method on voc 2012 as well as the more challenging ms coco dataset. we demonstrate consistent and significant improvement in frcn performance when using the proposed ohem approach. per-class results are also presented on voc 2007 for comparison with prior work. paragraph: experimental setup. we use vgg16 for all experiments. when training on voc07 trainval, we use the sgd parameters as in section [reference] and when using extra data (07+ 12 and 07++ 12, see table [reference] and [reference]), we use 200k mini-batch iterations, with an initial learning rate of 0.001 and decay step size of 40k. when training on ms coco, we use 240k mini-batch iterations, with an initial learning rate of 0.001 and decay step size of 160k, owing to a larger epoch size. subsection: voc 2007 and 2012 results table [reference] shows that on voc07, ohem improves the map of frcn from 67.2% to 69.9% (and 70.0% to 74.6% with extra data). on voc12, ohem leads to an improvement of 4.1 points in map (from 65.7% to 69.8%). with extra data, we achieve an map of 71.9% as compared to 68.4% map of frcn, an improvement of 3.5 points. interestingly the improvements are not uniform across categories. bottle, chair, and tvmonitor show larger improvements that are consistent across the different pascal splits. why these classes benefit the most is an interesting and open question. subsection: ms coco results to test the benefit of using ohem on a larger and more challenging dataset, we conduct experiments on ms coco and report numbers from test-dev 2015 evaluation server (table [reference]). on the standard coco evaluation metric, frcn scores 19.7% ap, and ohem improves it to 22.6% ap. using the voc overlap metric of, ohem gives a 6.6 points boost in ap. it is also interesting to note that ohem helps improve the ap of medium sized objects by 4.9 points on the strict coco ap evaluation metric, which indicates that the proposed hard example mining approach is helpful when dealing with smaller sized objects. note that frcn with and without ohem were trained on ms coco train set. section: adding bells and whistles we' ve demonstrated consistent gains in detection accuracy by applying ohem to frcn training. in this section, we show that these improvements are orthogonal to recent bells and whistles that enhance object detection accuracy. ohem with the following two additions yields state-of-the-art results on voc and competitive results on ms coco. paragraph: multi-scale (m). we adopt the multi-scale strategy from sppnet (and used by both frcn and mr-cnn). scale is defined as the size of the shortest side () of an image. during training, one scale is chosen at random, whereas at test time inference is run on all scales. for vgg16 networks, we use for training, and during testing, with the max dimension capped at 1000. the scales and caps were chosen because of gpu memory constraints. paragraph: iterative bounding-box regression (b). we adopt the iterative localization and bounding-box (bbox) voting scheme from. the network evaluates each proposal roi to get scores and relocalized boxes. high-scoring boxes are the rescored and relocalized, yielding boxes. union of and is used as the final set for post-processing, where is obtained using nms on with an iou threshold of 0.3 and weighted voting is performed on each box in using boxes in with an iou of 0.5 with (see for details). from the leaderboard,* trained on trainval set subsection: voc 2007 and 2012 results we report the results on voc benchmarks in table [reference] and [reference]. on voc07, frcn with the above mentioned additions achieves 72.4% map and ohem improves it to 75.1%, which is currently the highest reported score under this setting (07 data). when using extra data (07+ 12), ohem achieves 78.9% map, surpassing the current state-of-the-art mr-cnn (78.2% map). we note that mr-cnn uses selective search and edge boxes during training, whereas we only use selective search boxes. our multi-scale implementation is also different, using fewer scales than mr-cnn. on voc12 (table [reference]), we consistently perform better than mr-cnn. when using extra data, we achieve state-of-the-art map of 76.3% (73.9% map of mr-cnn). paragraph: ablation analysis. we now study in detail the impact of these two additions and whether ohem is complementary to them, and report the analysis in table [reference]. baseline frcn map improves from 67.2% to 68.6% when using multi-scale during both training and testing (we refer to this as m). however, note that there is only a marginal benefit of using it at training time. iterative bbox regression (b) further improves the frcn map to 72.4%. but more importantly, using ohem improves it to 75.1% map, which is state-of-the-art for methods trained on voc07 data (see table [reference]). in fact, using ohem consistently results in higher map for all variants of these two additions (see table [reference]). iterative bbox reg. (b) subsection: ms coco results ms coco test-dev 2015 evaluation server results are reported in table [reference]. using multi-scale improves the performance of our method to 24.4% ap on the standard coco metric and to 44.4% ap on the voc metric. this again shows the complementary nature of using multi-scale and ohem. finally, we train our method using the entire ms coco trainval set, which further improves performance to 25.5% ap (and 45.9% ap). in the 2015 ms coco detection challenge, a variant of this approach finished place overall. section: conclusion we presented an online hard example mining (ohem) algorithm, a simple and effective method to train region-based convnet detectors. ohem eliminates several heuristics and hyperparameters in common use by automatically selecting hard examples, thus simplifying training. we conducted extensive experimental analysis to demonstrate the effectiveness of the proposed algorithm, which leads to better training convergence and consistent improvements in detection accuracy on standard benchmarks. we also reported state-of-the-art results on pascal voc 2007 and 2012 when using ohem with other orthogonal additions. though we used fast r-cnn throughout this paper, ohem can be used for training any region-based convnet detector. our experimental analysis was based on the overall detection accuracy, however it will be an interesting future direction to study the impact of various training methodologies on individual category performance. paragraph: acknowledgment. this project started as an intern project at microsoft research and continued at cmu. we thank larry zitnick, ishan misra and sean bell for many helpful discussions. as was supported by the microsoft research phd fellowship. this work was also partially supported by onr muri n000141612007. we thank nvidia for donating gpus. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "ms coco dataset"
                    ],
                    [
                        "ms coco dataset"
                    ],
                    [
                        "voc07"
                    ],
                    [
                        "voc07 trainval set"
                    ],
                    [
                        "voc07"
                    ],
                    [
                        "voc07 frcn"
                    ]
                ],
                "Method": [
                    [
                        "ohem"
                    ],
                    [
                        "frcn"
                    ],
                    [
                        "frcn framework"
                    ]
                ],
                "Metric": [
                    [
                        "map"
                    ]
                ],
                "Task": [
                    [
                        "object detectors"
                    ],
                    [
                        "detectors"
                    ],
                    [
                        "object detection"
                    ],
                    [
                        "detection"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "pascal voc 2007",
                        "pascal voc",
                        "pascal voc07 dataset",
                        "voc 2007",
                        "voc07 trainval",
                        "voc07",
                        "voc",
                        "voc07 data"
                    ]
                ],
                "Method": [
                    [
                        "online hard example mining",
                        "ohem",
                        "online hard example selection strategy",
                        "iterative localization and bounding-box (bbox) voting scheme"
                    ]
                ],
                "Metric": [
                    [
                        "map",
                        "mean average precision",
                        "points map",
                        "baseline frcn map"
                    ]
                ],
                "Task": [
                    [
                        "object detection",
                        "object detection research",
                        "convnet-based object detection",
                        "imagenet detection",
                        "detection",
                        "region-based object detectors"
                    ]
                ]
            }
        ]
    },
    "2f97ee95cad6a1f13596b108072b846c6f747d4e-45": {
        "doctext": "document: the microsoft 2016 conversational speech recognition system we describe microsoft's conversational speech recognition system, in which we combine recent developments in neural-network-based acoustic and language modeling to advance the state of the art on the switchboard recognition task. inspired by machine learning ensemble techniques, the system uses a range of convolutional and recurrent neural networks. i-vector modeling and lattice-free mmi training provide significant gains for all acoustic model architectures. language model rescoring with multiple forward and backward running rnnlms, and word posterior-based system combination provide a 20% boost. the best single system uses a resnet architecture acoustic model with rnnlm rescoring, and achieves a word error rate of 6.9% on the nist 2000 switchboard task. the combined system has an error rate of 6.2%, representing an improvement over previously reported results on this benchmark task. w.xiong, j.droppo, x.huang, f.seide, m.seltzer, a.stolcke, d.yuandg.zweig microsoftresearch conversational speech recognition, convolutional neural networks, recurrent neural networks, vgg, resnet, lace, blstm. section: introduction recent years have seen a rapid reduction in speech recognition error rates as a result of careful engineering and optimization of convolutional and recurrent neural networks. while the basic structures have been well known for a long period, it is only recently that they have dominated the field as the best models for speech recognition. surprisingly, this is the case for both acoustic modeling and language modeling. in comparison to standard feed-forward mlps or dnns, these acoustic models have the ability to model a large amount of acoustic context with temporal invariance, and in the case of convolutional models, with frequency invariance as well. in language modeling, recurrent models appear to improve over classical n-gram models through the generalization ability of continuous word representations. in the meantime, ensemble learning has become commonly used in several neural models, to improve robustness by reducing bias and variance. in this paper, we use ensembles of models extensively, as well as improvements to individual component models, to to advance the state-of-the-art in conversational telephone speech recognition (cts), which has been a benchmark speech recognition task since the 1990s. the main features of this system are: an ensemble of two fundamental acoustic model architectures, convolutional neural nets (cnns) and long-short-term memory nets (lstms), with multiple variants of each an attention mechanism in the lace cnn which differentially weights distant context lattice-free mmi training the use of i-vector based adaptation in all models language model (lm) rescoring with multiple, recurrent neural net lms running in both forward and reverse direction confusion network system combination coupled with search for best system subset, as necessitated by the large number of candidate systems. the remainder of this paper describes our system in detail. section [reference] describes the cnn and lstm models. section [reference] describes our implementation of i-vector adaptation. section [reference] presents out lattice-free mmi training process. language model rescoring is a significant part of our system, and described in section [reference]. experimental results are presented in section [reference], followed by a discussion of related work and conclusions. section: convolutional and lstm neural networks we use three cnn variants. the first is the vgg architecture of. compared to the networks used previously in image recognition, this network uses small (3x3) filters, is deeper, and applies up to five convolutional layers before pooling. the second network is modeled on the resnet architecture, which adds highway connections, i.e. a linear transform of each layer's input to the layer's output. the only difference is that we move the batch normalization node to the place right before each relu activation. the last cnn variant is the lace (layer-wise context expansion with attention) model. lace is a tdnn variant in which each higher layer is a weighted sum of nonlinear transformations of a window of lower layer frames. in other words, each higher layer exploits broader context than lower layers. lower layers focus on extracting simple local patterns while higher layers extract complex patterns that cover broader contexts. since not all frames in a window carry the same importance, an attention mask is applied. the lace model differs from the earlier tdnn models e.g. in the use of a learned attention mask and resnet like linear pass-through. as illustrated in detail in figure [reference], the model is composed of 4 blocks, each with the same architecture. each block starts with a convolution layer with stride 2 which sub-samples the input and increases the number of channels. this layer is followed by 4 relu-convolution layers with jump links similar to those used in resnet. table [reference] compares the layer structure and parameters of the three cnn architectures. while our best performing models are convolutional, the use of long short-term memory networks is a close second. we use a bidirectional architecture without frame-skipping. the core model structure is the lstm defined in. we found that using networks with more than six layers did not improve the word error rate on the development set, and chose 512 hidden units, per direction, per layer, as that provided a reasonable trade-off between training time and final model accuracy. network parameters for different configurations of the lstm architecture are summarized in table [reference]. section: speaker adaptive modeling speaker adaptive modeling in our system is based on conditioning the network on an i-vector characterization of each speaker. a 100-dimensional i-vector is generated for each conversation side. for the lstm system, the conversation-side i-vector is appended to each frame of input. for convolutional networks, this approach is inappropriate because we do not expect to see spatially contiguous patterns in the input. instead, for the cnns, we add a learnable weight matrix to each layer, and add to the activation of the layer before the nonlinearity. thus, in the cnn, the i-vector essentially serves as an additional bias to each layer. note that the i-vectors are estimated using mfcc features; by using them subsequently in systems based on log-filterbank features, we may benefit from a form of feature combination. section: lattice-free sequence training after standard cross-entropy training, we optimize the model parameters using the maximum mutual information (mmi) objective function. denoting a word sequence by and its corresponding acoustic realization by, the training criterion is as noted in, the necessary gradient for use in backpropagation is a simple function of the posterior probability of a particular acoustic model state at a given time, as computed by summing over all possible word sequences in an unconstrained manner. as first done in, and more recently in, this can be accomplished with a straightforward alpha-beta computation over the finite state acceptor representing the decoding search space. in, the search space is taken to be an acceptor representing the composition for a unigram language model on words. in, a language model on phonemes is used instead. in our implementation, we use a mixed-history acoustic unit language model. in this model, the probability of transitioning into a new context-dependent phonetic state (senone) is conditioned both the senone and phone history. we found this model to perform better than either purely word-based or phone-based models. based on a set of initial experiments, we developed the following procedure: perform a forced alignment of the training data to select lexical variants and determine frame-aligned senone sequences. compress consecutive framewise occurrences of a single senone into a single occurrence. estimate an unsmoothed, variable-length n-gram language model from this data, where the history state consists of the previous phone and previous senones within the current phone. to illustrate this, consider the sample senone sequence {s_ s2.1288, s_ s3.1061, s_ s4.1096}, {eh_ s2.527, eh_ s3.128, eh_ s4.66}, {t_ s2.729, t_ s3.572, t_ s4.748}. when predicting the state following eh_ s4.66 the history consists of (s, eh_ s2.527, eh_ s3.128, eh_ s4.66), and following t_ s2.729, the history is (eh, t_ s2.729). we construct the denominator graph from this language model, and hmm transition probabilities as determined by transition-counting in the senone sequences found in the training data. our approach not only largely reduces the complexity of building up the language model but also provides very reliable training performance. we have found it convenient to do the full computation, without pruning, in a series of matrix-vector operations on the gpu. the underlying acceptor is represented with a sparse matrix, and we maintain a dense likelihood vector for each time frame. the alpha and beta recursions are implemented with cusparse level-2 routines: sparse-matrix, dense vector multiplies. run time is about 100 times faster than real time. as in, we use cross-entropy regularization. in all the lattice-free mmi (lfmmi) experiments mentioned below we use a trigram language model. most of the gain is usually obtained after processing 24 to 48 hours of data. section: lm rescoring and system combination an initial decoding is done with a wfst decoder, using the architecture described in. we use an n-gram language model trained and pruned with the srilm toolkit. the first-pass lm has approximately 15.9 million bigrams, trigrams, and 4grams, and a vocabulary of 30, 500 words. it gives a perplexity of 69 on the 1997 cts evaluation transcripts. the initial decoding produces a lattice with the pronunciation variants marked, from which 500-best lists are generated for rescoring purposes. subsequent n-best rescoring uses an unpruned lm comprising 145 million n-grams. all n-gram lms were estimated by a maximum entropy criterion as described in. subsection: rnnlm setup the n-best hypotheses are then rescored using a combination of the large n-gram lm and several rnnlms, trained and evaluated using the cued-rnnlm toolkit. our rnnlm configuration has several distinctive features, as described below. 1) we trained both standard, forward-predicting rnnlms and backward rnnlms that predict words in reverse temporal order. the log probabilities from both models are added. 2) as is customary, the rnnlm probability estimates are interpolated at the word-level with corresponding n-gram lm probabilities (separately for the forward and backward models). in addition, we trained a second rnnlm for each direction, obtained by starting with different random initial weights. the two rnnlms and the n-gram lm for each direction are interpolated with weights of (0.375, 0.375, 0.25). 3) in order to make use of lm training data that is not fully matched to the target conversational speech domain, we start rnnlm training with the union of in-domain (here, cts) and out-of-domain (e.g., web) data. upon convergence, the network undergoes a second training phase using the in-domain data only. both training phases use in-domain validation data to regulate the learning rate schedule and termination. because the size of the out-of-domain data is a multiple of the in-domain data, a standard training on a simple union of the data would not yield a well-matched model, and have poor perplexity in the target domain. 4) we found best results with an rnnlm configuration that had a second, non-recurrent hidden layer. this produced lower perplexity and word error than the standard, single-hidden-layer rnnlm architecture. the overall network architecture thus had two hidden layers with 1000 units each, using relu nonlinearities. training used noise-contrastive estimation (nce). 5) the rnnlm output vocabulary consists of all words occurring more than once in the in-domain training set. while the rnnlm estimates a probability for unknown words, we take a different approach in rescoring: the number of out-of-set words is recorded for each hypothesis and a penalty for them is estimated for them when optimizing the relative weights for all model scores (acoustic, lm, pronunciation), using the srilm nbest-optimize tool. subsection: training data the 4-gram language model for decoding was trained on the available cts transcripts from the darpa ears program: switchboard (3 m words), bbn switchboard-2 transcripts (850k), fisher (21 m), english callhome (200k), and the university of washington conversational web corpus (191 m). a separate model was trained from each source and interpolated with weights optimized on rt-03 transcripts. for the unpruned large rescoring 4-gram, an additional lm component was added, trained on 133 m word of ldc broadcast news texts. the n-gram lm configuration is modeled after that described in, except that maxent smoothing was used. the rnnlms were trained on switchboard and fisher transcripts as in-domain data (20 m words for gradient computation, 3 m for validation). to this we added 62 m words of uw web data as out-of-domain data, for use in the two-phase training procedure described above. subsection: rnnlm performance table [reference] gives perplexity and word error performance for various rnnlm setups, from simple to more complex. the acoustic model used was the resnet cnn. as can be seen, each of the measures described earlier adds incremental gains, which, while small individually, add up to a 9% relative error reduction over a plain rnnlm. subsection: system combination the lm rescoring is carried out separately for each acoustic model. the rescored n-best lists from each subsystem are then aligned into a single confusion network using the srilm nbest-rover tool. however, the number of potential candidate systems is too large to allow an all-out combination, both for practical reasons and due to overfitting issues. instead, we perform a greedy search, starting with the single best system, and successively adding additional systems, to find a small set of systems that are maximally complementary. the rt-02 switchboard set was used for this search procedure. the relative weighting (for confusion-network mediated voting) of the different systems is optimized using an em algorithm, using the same data, and smoothed hierarchically by interpolating each set of system weights with the preceding one in the search. section: experimental setup and results subsection: speech corpora we train with the commonly used english cts (switchboard and fisher) corpora. evaluation is carried out on the nist 2000 cts test set, which comprises both switchboard (swb) and callhome (ch) subsets. the switchboard-1 portion of the nist 2002 cts test set was used for tuning and development. the acoustic training data is comprised by ldc corpora 97s62, 2004s13, 2005s13, 2004s11 and 2004s09; see for a full description. subsection: 1-bit sgd training all presented models are costly to train. to make training feasible, we parallelize training with our previously proposed 1-bit sgd parallelization technique. this data-parallel method distributes minibatches over multiple worker nodes, and then aggregates the sub-gradients. while the necessary communication time would otherwise be prohibitive, the 1-bit sgd method eliminates the bottleneck by two techniques: 1-bit quantization of gradients and automatic minibatch-size scaling. in, we showed that gradient values can be quantized to just a single bit, if one carries over the quantization error from one minibatch to the next. each time a sub-gradient is quantized, the quantization error is computed and remembered, and then added to the next minibatch's sub-gradient. this reduces the required bandwidth 32-fold with minimal loss in accuracy. secondly, automatic minibatch-size scaling progressively decreases the frequency of model updates. at regular intervals (e.g. every 72h of training data), the trainer tries larger minibatch sizes on a small subset of data and picks the largest that maintains training loss. subsection: acoustic model details forty-dimensional log-filterbank features were extracted every 10 milliseconds, using a 25-millisecond analysis window. the cnn models used window sizes as indicated in table [reference], and the lstms processed one frame of input at a time. the bulk of our models use three state left-to-right triphone models with 9000 tied states. additionally, we have trained several models with 27k tied states. the phonetic inventory includes special models for noise, vocalized-noise, laughter and silence. we use a 30k-vocabulary derived from the most common words in the switchboard and fisher corpora. the decoder uses a statically compiled unigram graph, and dynamically applies the language model score. the unigram graph has about 300k states and 500k arcs. all acoustic models were trained using the open-source computational network toolkit (cntk). table [reference] shows the result of i-vector adaptation and lfmmi training on several of our systems. we achieve a 5-8% relative improvement from i-vectors, including on cnn systems. the last row of table [reference] shows the effect of lfmmi training on the different models. we see a consistent 7-10% further relative reduction in error rate for all models. considering the great increase in procedural simplicity of lfmmi over the previous practice of writing lattices and post-processing them, we consider lfmmi to be a significant advance in technology. subsection: comparative system performance model performance for our individual models as well as relevant comparisons from the literature are shown in table [reference]. out of the 15 models built, only models given non-zero weight in the final system combination are shown. section: relation to prior work compared to earlier applications of cnns to speech recognition, our networks are much deeper, and use linear bypass connections across convolutional layers. they are similar in spirit to those studied more recently by. we improve on these architectures with the lace model, which iteratively expands the effective window size, layer-by-layer, and adds an attention mask to differentially weight distant context. our use of lattice-free mmi is distinctive, and extends previous work by proposing the use of a mixed triphone/ phoneme history in the language model. on the language modeling side, we achieve a performance boost by combining multiple rnnlms in both forward and backward directions, and by using a two-phase training regimen to get best results from out-of-domain data. for our best cnn system, rnnlm rescoring yields a relative word error reduction of 20%, and a 16% relative gain for the combined recognition system. (elsewhere we report further improvements, using lstm-based lms.) section: conclusions we have described microsoft's conversational speech recognition system for 2016. the use of cnns in the acoustic model has proved singularly effective, as has the use of rnn language models. our best single system achieves an error rate of 6.9% on the nist 2000 switchboard set. we believe this is the best performance reported to date for a recognition system not based on system combination. an ensemble of acoustic models advances the state of the art to 6.2% on the switchboard test data. acknowledgments. we thank x. chen from cued for valuable assistance with the cued-rnnlm toolkit, and icsi for compute and data resources. bibliography: references",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "cnn and lstm models"
                    ]
                ],
                "Metric": [
                    [
                        "word error"
                    ],
                    [
                        "word error rate"
                    ],
                    [
                        "error rate"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "switchboard"
                    ]
                ],
                "Method": [
                    [
                        "microsoft's conversational speech recognition system",
                        "neural-network-based acoustic and language modeling",
                        "forward and backward running rnnlms",
                        "rnnlm rescoring",
                        "recurrent neural net lms",
                        "unsmoothed, variable-length n-gram language model",
                        "rnnlm setup",
                        "cued-rnnlm toolkit",
                        "rnnlm configuration",
                        "forward-predicting rnnlms",
                        "backward rnnlms",
                        "rnnlm probability estimates",
                        "rnnlm",
                        "rnnlm training",
                        "single-hidden-layer rnnlm architecture",
                        "rnnlm setups"
                    ]
                ],
                "Metric": [
                    [
                        "word error rate",
                        "error rate",
                        "word error",
                        "word error performance",
                        "relative error reduction"
                    ]
                ],
                "Task": [
                    [
                        "microsoftresearch conversational speech recognition",
                        "speech recognition",
                        "conversational telephone speech recognition",
                        "speech recognition task",
                        "image recognition"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "switchboard"
                    ]
                ],
                "Method": [
                    [
                        "n-gram models",
                        "tdnn models",
                        "unigram language model",
                        "trigram language model",
                        "n-gram language model",
                        "decoding",
                        "training",
                        "lm rescoring",
                        "cnn models",
                        "decoder",
                        "language model score"
                    ]
                ],
                "Metric": [
                    [
                        "word error rate",
                        "error rate",
                        "word error",
                        "word error performance",
                        "relative error reduction"
                    ]
                ],
                "Task": [
                    [
                        "microsoftresearch conversational speech recognition",
                        "speech recognition",
                        "conversational telephone speech recognition",
                        "speech recognition task",
                        "image recognition"
                    ]
                ]
            }
        ]
    },
    "322a7dad274f440a92548faa8f2b2be666b2d01f-46": {
        "doctext": "document: pyramid scene parsing network scene parsing is challenging for unrestricted open vocabulary and diverse scenes. in this paper, we exploit the capability of global context information by different-region-based context aggregation through our pyramid pooling module together with the proposed pyramid scene parsing network (pspnet). our global prior representation is effective to produce good quality results on the scene parsing task, while pspnet provides a superior framework for pixel-level prediction. the proposed approach achieves state-of-the-art performance on various datasets. it came first in imagenet scene parsing challenge 2016, pascal voc 2012 benchmark and cityscapes benchmark. a single pspnet yields the new record of miou accuracy 85.4% on pascal voc 2012 and accuracy 80.2% on cityscapes. section: introduction scene parsing, based on semantic segmentation, is a fundamental topic in computer vision. the goal is to assign each pixel in the image a category label. scene parsing provides complete understanding of the scene. it predicts the label, location, as well as shape for each element. this topic is of broad interest for potential applications of automatic driving, robot sensing, to name a few. difficulty of scene parsing is closely related to scene and label variety. the pioneer scene parsing task is to classify 33 scenes for 2, 688 images on lmo dataset. more recent pascal voc semantic segmentation and pascal context datasets include more labels with similar context, such as chair and sofa, horse and cow, etc. the new ade20 k dataset is the most challenging one with a large and unrestricted open vocabulary and more scene classes. a few representative images are shown in fig. [reference]. to develop an effective algorithm for these datasets needs to conquer a few difficulties. state-of-the-art scene parsing frameworks are mostly based on the fully convolutional network (fcn). the deep convolutional neural network (cnn) based methods boost dynamic object understanding, and yet still face challenges considering diverse scenes and unrestricted vocabulary. one example is shown in the first row of fig. [reference], where a boat is mistaken as a car. these errors are due to similar appearance of objects. but when viewing the image regarding the context prior that the scene is described as boathouse near a river, correct prediction should be yielded. towards accurate scene perception, the knowledge graph relies on prior information of scene context. we found that the major issue for current fcn based models is lack of suitable strategy to utilize global scene category clues. for typical complex scene understanding, previously to get a global image-level feature, spatial pyramid pooling was widely employed where spatial statistics provide a good descriptor for overall scene interpretation. spatial pyramid pooling network further enhances the ability. different from these methods, to incorporate suitable global features, we propose pyramid scene parsing network (pspnet). in addition to traditional dilated fcn for pixel prediction, we extend the pixel-level feature to the specially designed global pyramid pooling one. the local and global clues together make the final prediction more reliable. we also propose an optimization strategy with deeply supervised loss. we give all implementation details, which are key to our decent performance in this paper, and make the code and trained models publicly available. our approach achieves state-of-the-art performance on all available datasets. it is the champion of imagenet scene parsing challenge 2016, and arrived the 1st place on pascal voc 2012 semantic segmentation benchmark, and the 1st place on urban scene cityscapes data. they manifest that pspnet gives a promising direction for pixel-level prediction tasks, which may even benefit cnn-based stereo matching, optical flow, depth estimation, etc. in follow-up work. our main contributions are threefold. we propose a pyramid scene parsing network to embed difficult scenery context features in an fcn based pixel prediction framework. we develop an effective optimization strategy for deep resnet based on deeply supervised loss. we build a practical system for state-of-the-art scene parsing and semantic segmentation where all crucial implementation details are included. section: related work in the following, we review recent advances in scene parsing and semantic segmentation tasks. driven by powerful deep neural networks, pixel-level prediction tasks like scene parsing and semantic segmentation achieve great progress inspired by replacing the fully-connected layer in classification with the convolution layer. to enlarge the receptive field of neural networks, methods of used dilated convolution. noh proposed a coarse-to-fine structure with deconvolution network to learn the segmentation mask. our baseline network is fcn and dilated network. other work mainly proceeds in two directions. one line is with multi-scale feature ensembling. since in deep networks, higher-layer feature contains more semantic meaning and less location information. combining multi-scale features can improve the performance. the other direction is based on structure prediction. the pioneer work used conditional random field (crf) as post processing to refine the segmentation result. following methods refined networks via end-to-end modeling. both of the two directions ameliorate the localization ability of scene parsing where predicted semantic boundary fits objects. yet there is still much room to exploit necessary information in complex scenes. to make good use of global image-level priors for diverse scene understanding, methods of extracted global context information with traditional features not from deep neural networks. similar improvement was made under object detection frameworks. liu proved that global average pooling with fcn can improve semantic segmentation results. however, our experiments show that these global descriptors are not representative enough for the challenging ade20 k data. therefore, different from global pooling in, we exploit the capability of global context information by different-region-based context aggregation via our pyramid scene parsing network. section: pyramid scene parsing network we start with our observation and analysis of representative failure cases when applying fcn methods to scene parsing. they motivate proposal of our pyramid pooling module as the effective global context prior. our pyramid scene parsing network (pspnet) illustrated in fig. [reference] is then described to improve performance for open-vocabulary object and stuff identification in complex scene parsing. subsection: important observations the new ade20 k dataset contains 150 stuff/ object category labels (, wall, sky, and tree) and 1, 038 image-level scene descriptors (, airport_terminal, bedroom, and street). so a large amount of labels and vast distributions of scenes come into existence. inspecting the prediction results of the fcn baseline provided in, we summarize several common issues for complex-scene parsing. paragraph: mismatched relationship context relationship is universal and important especially for complex scene understanding. there exist co-occurrent visual patterns. for example, an airplane is likely to be in runway or fly in sky while not over a road. for the first-row example in fig. [reference], fcn predicts the boat in the yellow box as a\" car\" based on its appearance. but the common knowledge is that a car is seldom over a river. lack of the ability to collect contextual information increases the chance of misclassification. paragraph: confusion categories there are many class label pairs in the ade20 k dataset that are confusing in classification. examples are field and earth; mountain and hill; wall, house, building and skyscraper. they are with similar appearance. the expert annotator who labeled the entire dataset, still makes 17.60% pixel error as described in. in the second row of fig. [reference], fcn predicts the object in the box as part of skyscraper and part of building. these results should be excluded so that the whole object is either skyscraper or building, but not both. this problem can be remedied by utilizing the relationship between categories. paragraph: inconspicuous classes scene contains objects/ stuff of arbitrary size. several small-size things, like streetlight and signboard, are hard to find while they may be of great importance. contrarily, big objects or stuff may exceed the receptive field of fcn and thus cause discontinuous prediction. as shown in the third row of fig. [reference], the pillow has similar appearance with the sheet. overlooking the global scene category may fail to parse the pillow. to improve performance for remarkably small or large objects, one should pay much attention to different sub-regions that contain inconspicuous-category stuff. to summarize these observations, many errors are partially or completely related to contextual relationship and global information for different receptive fields. thus a deep network with a suitable global-scene-level prior can much improve the performance of scene parsing. subsection: pyramid pooling module with above analysis, in what follows, we introduce the pyramid pooling module, which empirically proves to be an effective global contextual prior. in a deep neural network, the size of receptive field can roughly indicates how much we use context information. although theoretically the receptive field of resnet is already larger than the input image, it is shown by zhou that the empirical receptive field of cnn is much smaller than the theoretical one especially on high-level layers. this makes many networks not sufficiently incorporate the momentous global scenery prior. we address this issue by proposing an effective global prior representation. global average pooling is a good baseline model as the global contextual prior, which is commonly used in image classification tasks. in, it was successfully applied to semantic segmentation. but regarding the complex-scene images in ade20 k, this strategy is not enough to cover necessary information. pixels in these scene images are annotated regarding many stuff and objects. directly fusing them to form a single vector may lose the spatial relation and cause ambiguity. global context information along with sub-region context is helpful in this regard to distinguish among various categories. a more powerful representation could be fused information from different sub-regions with these receptive fields. similar conclusion was drawn in classical work of scene/ image classification. in, feature maps in different levels generated by pyramid pooling were finally flattened and concatenated to be fed into a fully connected layer for classification. this global prior is designed to remove the fixed-size constraint of cnn for image classification. to further reduce context information loss between different sub-regions, we propose a hierarchical global prior, containing information with different scales and varying among different sub-regions. we call it pyramid pooling module for global scene prior construction upon the final-layer-feature-map of the deep neural network, as illustrated in part (c) of fig. [reference]. the pyramid pooling module fuses features under four different pyramid scales. the coarsest level highlighted in red is global pooling to generate a single bin output. the following pyramid level separates the feature map into different sub-regions and forms pooled representation for different locations. the output of different levels in the pyramid pooling module contains the feature map with varied sizes. to maintain the weight of global feature, we use convolution layer after each pyramid level to reduce the dimension of context representation to of the original one if the level size of pyramid is. then we directly upsample the low-dimension feature maps to get the same size feature as the original feature map via bilinear interpolation. finally, different levels of features are concatenated as the final pyramid pooling global feature. noted that the number of pyramid levels and size of each level can be modified. they are related to the size of feature map that is fed into the pyramid pooling layer. the structure abstracts different sub-regions by adopting varying-size pooling kernels in a few strides. thus the multi-stage kernels should maintain a reasonable gap in representation. our pyramid pooling module is a four-level one with bin sizes of,, and respectively. for the type of pooling operation between max and average, we perform extensive experiments to show the difference in section [reference]. subsection: network architecture with the pyramid pooling module, we propose our pyramid scene parsing network (pspnet) as illustrated in fig. [reference]. given an input image in fig. [reference] (a), we use a pretrained resnet model with the dilated network strategy to extract the feature map. the final feature map size is of the input image, as shown in fig. [reference] (b). on top of the map, we use the pyramid pooling module shown in (c) to gather context information. using our 4-level pyramid, the pooling kernels cover the whole, half of, and small portions of the image. they are fused as the global prior. then we concatenate the prior with the original feature map in the final part of (c). it is followed by a convolution layer to generate the final prediction map in (d). to explain our structure, pspnet provides an effective global contextual prior for pixel-level scene parsing. the pyramid pooling module can collect levels of information, more representative than global pooling. in terms of computational cost, our pspnet does not much increase it compared to the original dilated fcn network. in end-to-end learning, the global pyramid pooling module and the local fcn feature can be optimized simultaneously. section: deep supervision for resnet-based fcn deep pretrained networks lead to good performance. however, increasing depth of the network may introduce additional optimization difficulty as shown in for image classification. resnet solves this problem with skip connection in each block. latter layers of deep resnet mainly learn residues based on previous ones. we contrarily propose generating initial results by supervision with an additional loss, and learning the residue afterwards with the final loss. thus, optimization of the deep network is decomposed into two, each is simpler to solve. an example of our deeply supervised resnet101 model is illustrated in fig. [reference]. apart from the main branch using softmax loss to train the final classifier, another classifier is applied after the fourth stage, i.e., the res4b22 residue block. different from relay backpropagation that blocks the backward auxiliary loss to several shallow layers, we let the two loss functions pass through all previous layers. the auxiliary loss helps optimize the learning process, while the master branch loss takes the most responsibility. we add weight to balance the auxiliary loss. in the testing phase, we abandon this auxiliary branch and only use the well optimized master branch for final prediction. this kind of deeply supervised training strategy for resnet-based fcn is broadly useful under different experimental settings and works with the pre-trained resnet model. this manifests the generality of such a learning strategy. more details are provided in section [reference]. section: experiments our proposed method is successful on scene parsing and semantic segmentation challenges. we evaluate it in this section on three different datasets, including imagenet scene parsing challenge 2016, pascal voc 2012 semantic segmentation and urban scene understanding dataset cityscapes. subsection: implementation details for a practical deep learning system, devil is always in the details. our implementation is based on the public platform caffe. inspired by, we use the\" poly\" learning rate policy where current learning rate equals to the base one multiplying. we set base learning rate to 0.01 and power to 0.9. the performance can be improved by increasing the iteration number, which is set to 150 k for imagenet experiment, 30 k for pascal voc and 90 k for cityscapes. momentum and weight decay are set to 0.9 and 0.0001 respectively. for data augmentation, we adopt random mirror and random resize between 0.5 and 2 for all datasets, and additionally add random rotation between-10 and 10 degrees, and random gaussian blur for imagenet and pascal voc. this comprehensive data augmentation scheme makes the network resist overfitting. our network contains dilated convolution following. during the course of experiments, we notice that an appropriately large\" cropsize\" can yield good performance and\" batchsize\" in the batch normalization layer is of great importance. due to limited physical memory on gpu cards, we set the\" batchsize\" to 16 during training. to achieve this, we modify caffe from together with branch and make it support batch normalization on data gathered from multiple gpus based on openmpi. for the auxiliary loss, we set the weight to 0.4 in experiments. subsection: imagenet scene parsing challenge 2016 paragraph: dataset and evaluation metrics the ade20 k dataset is used in imagenet scene parsing challenge 2016. different from other datasets, ade20 k is more challenging for the up to 150 classes and diverse scenes with a total of 1, 038 image-level labels. the challenge data is divided into 20k/ 2k/ 3 k images for training, validation and testing. also, it needs to parse both objects and stuff in the scene, which makes it more difficult than other datasets. for evaluation, both pixel-wise accuracy (pixel acc.) and mean of class-wise intersection over union (mean iou) are used. paragraph: ablation study for pspnet to evaluate pspnet, we conduct experiments with several settings, including pooling types of max and average, pooling with just one global feature or four-level features, with and without dimension reduction after the pooling operation and before concatenation. as listed in table [reference], average pooling works better than max pooling in all settings. pooling with pyramid parsing outperforms that using global pooling. with dimension reduction, the performance is further enhanced. with our proposed pspnet, the best setting yields results 41.68/ 80.04 in terms of mean iou and pixel acc. (%), exceeding global average pooling of 40.07/ 79.52 as idea in liu by 1.61/ 0.52. and compared to the baseline, pspnet outperforming it by 4.45/ 2.03 in terms of absolute improvement and 11.95/ 2.60 in terms of relative difference. paragraph: ablation study for auxiliary loss the introduced auxiliary loss helps optimize the learning process while not influencing learning in the master branch. we experiment with setting the auxiliary loss weight between 0 and 1 and show the results in table [reference]. the baseline uses resnet50-based fcn with dilated network, with the master branch's softmax loss for optimization. adding the auxiliary loss branch,= 0.4 yields the best performance. it outperforms the baseline with an improvement of 1.41/ 0.94 in terms of mean iou and pixel acc. (%). we believe deeper networks will benefit more given the new augmented auxiliary loss. paragraph: ablation study for pre-trained model deeper neural networks have been shown in previous work to be beneficial to large scale data classification. to further analyze pspnet, we conduct experiments for different depths of pre-trained resnet. we test four depths of {50, 101, 152, 269}. as shown in fig. [reference], with the same setting, increasing the depth of resnet from 50 to 269 can improve the score of (mean iou+ pixel acc.)/ 2 (%) from 60.86 to 62.35, with 1.49 absolute improvement. detailed scores of pspnet pre-trained from different depth resnet models are listed in table [reference]. paragraph: more detailed performance analysis we show our more detailed analysis on the validation set of ade20 k in table [reference]. all our results except the last-row one use single-scale test.\" resnet269+ da+ al+ psp+ ms\" uses multi-scale testing. our baseline is adapted from resnet50 with dilated network, which yields meaniou 34.28 and pixel acc. 76.35. it already outperforms other prior systems possibly due to the powerful resnet. our proposed architecture makes further improvement compared to the baseline. using data augmentation, our result exceeds the baseline by 1.54/ 0.72 and reaches 35.82/ 77.07. using the auxiliary loss can further improve it by 1.41/ 0.94 and reaches 37.23/ 78.01. with pspnet, we notice relatively more significant progress for improvement of 4.45/ 2.03. the result reaches 41.68/ 80.04. the difference from the baseline result is 7.40/ 3.69 in terms of absolute improvement and 21.59/ 4.83 (%) in terms of relativity. a deeper network of resnet269 yields even higher performance up to 43.81/ 80.88. finally, the multi-scale testing scheme moves the scores to 44.94/ 81.69. paragraph: results in challenge using the proposed architecture, our team came in the 1st place in imagenet scene parsing challenge 2016. table [reference] shows a few results in this competition. our ensemble submission achieves score 57.21% on the testing set. our single-model yields score 55.38%, which is even higher than a few other multi-model ensemble submissions. this score is lower than that on the validation set possibly due to the difference of data distributions between validation and testing sets. as shown in column (d) of fig. [reference], pspnet solves the common problems in fcn. fig. [reference] shows another few parsing results on validation set of ade20k. our results contain more accurate and detailed structures compared to the baseline. subsection: pascal voc 2012 our pspnet also works satisfyingly on semantic segmentation. we carry out experiments on the pascal voc 2012 segmentation dataset, which contains 20 object categories and one background class. following the procedure of, we use augmented data with the annotation of resulting 10, 582, 1, 449 and 1, 456 images for training, validation and testing. results are shown in table [reference], we compare pspnet with previous best-performing methods on the testing set based on two settings, i.e., with or without pre-training on ms-coco dataset. methods pre-trained with ms-coco are marked by '\u2020'. for fair comparison with current resnet based frameworks in scene parsing/ semantic segmentation task, we build our architecture based on resnet101 while without post-processing like crf. we evaluate pspnet with several-scale input and use the average results following. as shown in table [reference], pspnet outperforms prior methods on both settings. trained with only voc 2012 data, we achieve 82.6% accuracy- we get the highest accuracy on all 20 classes. when pspnet is pre-trained with ms-coco dataset, it reaches 85.4% accuracy where 19 out of the 20 classes receive the highest accuracy. intriguingly, our pspnet trained with only voc 2012 data outperforms existing methods trained with the ms-coco pre-trained model. one may argue that our based classification model is more powerful than several prior methods since resnet was recently proposed. to exhibit our unique contribution, we show that our method also outperforms state-of-the-art frameworks that use the same model, including fcrns, lrr, and deeplab. in this process, we even do not employ time-consuming but effective post-processing, such as crf, as that in. several examples are shown in fig. [reference]. for\" cows\" in row one, our baseline model treats it as\" horse\" and\" dog\" while pspnet corrects these errors. for\" aeroplane\" and\" table\" in the second and third rows, pspnet finds missing parts. for\" person\",\" bottle\" and\" plant\" in following rows, pspnet performs well on these small-size-object classes in the images compared to the baseline model. more visual comparisons between pspnet and other methods are included in fig. [reference]. subsection: cityscapes cityscapes is a recently released dataset for semantic urban scene understanding. it contains 5, 000 high quality pixel-level finely annotated images collected from 50 cities in different seasons. the images are divided into sets with numbers 2, 975, 500, and 1, 525 for training, validation and testing. it defines 19 categories containing both stuff and objects. also, 20, 000 coarsely annotated images are provided for two settings in comparison, i.e., training with only fine data or with both the fine and coarse data. methods trained using both fine and coarse data are marked with ''. detailed results are listed in table [reference]. our base model is resnet101 as in deeplab for fair comparison and the testing procedure follows section [reference]. statistics in table [reference] show that pspnet outperforms other methods with notable advantage. using both fine and coarse data for training makes our method yield 80.2 accuracy. several examples are shown in fig. [reference]. detailed per-class results on testing set are shown in table [reference]. section: concluding remarks we have proposed an effective pyramid scene parsing network for complex scene understanding. the global pyramid pooling feature provides additional contextual information. we have also provided a deeply supervised optimization strategy for resnet-based fcn network. we hope the implementation details publicly available can help the community adopt these useful strategies for scene parsing and semantic segmentation and advance related techniques. section: acknowledgements we would like to thank gang sun and tong xiao for their help in training the basic classification models, qun luo for technical support. this work is supported by a grant from the research grants council of the hong kong sar (project no. 2150760). bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "imagenet"
                    ],
                    [
                        "pascal voc 2012 benchmark"
                    ],
                    [
                        "cityscapes"
                    ],
                    [
                        "cityscapes benchmark"
                    ]
                ],
                "Method": [
                    [
                        "pyramid scene parsing"
                    ],
                    [
                        "pyramid scene parsing network"
                    ],
                    [
                        "pspnet"
                    ],
                    [
                        "pyramid scene parsing network"
                    ],
                    [
                        "pspnet"
                    ],
                    [
                        "pyramid scene parsing network"
                    ],
                    [
                        "resnet101"
                    ]
                ],
                "Metric": [
                    [
                        "miou"
                    ],
                    [
                        "miou accuracy"
                    ],
                    [
                        "mean of class wise intersection over union"
                    ],
                    [
                        "class wise intersection over union"
                    ]
                ],
                "Task": [
                    [
                        "scene parsing"
                    ],
                    [
                        "parsing"
                    ],
                    [
                        "network scene parsing"
                    ],
                    [
                        "scene parsing"
                    ],
                    [
                        "parsing"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "ade20 k dataset",
                        "ade20 k",
                        "ade20k."
                    ]
                ],
                "Method": [
                    [
                        "pyramid scene parsing network",
                        "pspnet"
                    ]
                ],
                "Metric": [
                    [
                        "score"
                    ]
                ],
                "Task": [
                    [
                        "semantic segmentation",
                        "segmentation",
                        "data augmentation"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "cityscapes benchmark",
                        "cityscapes"
                    ]
                ],
                "Method": [
                    [
                        "pyramid scene parsing network",
                        "pspnet"
                    ]
                ],
                "Metric": [
                    [
                        "mean iou"
                    ]
                ],
                "Task": [
                    [
                        "semantic segmentation",
                        "segmentation",
                        "data augmentation"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "cityscapes benchmark",
                        "cityscapes"
                    ]
                ],
                "Method": [
                    [
                        "pyramid scene parsing network",
                        "pspnet"
                    ]
                ],
                "Metric": [],
                "Task": []
            },
            {
                "Material": [
                    [
                        "cityscapes benchmark",
                        "cityscapes"
                    ]
                ],
                "Method": [
                    [
                        "pyramid scene parsing network",
                        "pspnet"
                    ]
                ],
                "Metric": [
                    [
                        "miou accuracy",
                        "meaniou 34.28"
                    ]
                ],
                "Task": []
            },
            {
                "Material": [
                    [
                        "pascal voc 2012 benchmark",
                        "pascal voc 2012",
                        "pascal context datasets",
                        "pascal voc 2012 semantic segmentation",
                        "pascal voc",
                        "pascal voc 2012 segmentation dataset",
                        "voc 2012 data"
                    ]
                ],
                "Method": [
                    [
                        "pyramid scene parsing network",
                        "pspnet"
                    ]
                ],
                "Metric": [
                    [
                        "mean iou"
                    ]
                ],
                "Task": [
                    [
                        "semantic segmentation",
                        "segmentation",
                        "data augmentation"
                    ]
                ]
            }
        ]
    },
    "325af39d281d5903a269c01fab8f53d7400a4c49-47": {
        "doctext": "document: arttrack: articulated multi-person tracking in the wild in this paper we propose an approach for articulated tracking of multiple people in unconstrained videos. our starting point is a model that resembles existing architectures for single-frame pose estimation but is substantially faster. we achieve this in two ways: (1) by simplifying and sparsifying the body-part relationship graph and leveraging recent methods for faster inference, and (2) by offloading a substantial share of computation onto a feed-forward convolutional architecture that is able to detect and associate body joints of the same person even in clutter. we use this model to generate proposals for body joint locations and formulate articulated tracking as spatio-temporal grouping of such proposals. this allows to jointly solve the association problem for all people in the scene by propagating evidence from strong detections through time and enforcing constraints that each proposal can be assigned to one person only. we report results on a public\" mpii human pose\" benchmark and on a new\" mpii video pose\" dataset of image sequences with multiple people. we demonstrate that our model achieves state-of-the-art results while using only a fraction of time and is able to leverage temporal information to improve state-of-the-art for crowded scenes. section: introduction this paper addresses the task of articulated human pose tracking in monocular video. we focus on scenes of realistic complexity that often include fast motions, large variability in appearance and clothing, and person-person occlusions. a successful approach must thus identify the number of people in each video frame, determine locations of the joints of each person and associate the joints over time. one of the key challenges in such scenes is that people might overlap and only a subset of joints of the person might be visible in each frame either due to person-person occlusion or truncation by image boundaries (. fig. [reference]). arguably, resolving such cases correctly requires reasoning beyond purely geometric information on the arrangement of body joints in the image, and requires incorporation of a variety of image cues and joint modeling of several persons. the design of our model is motivated by two factors. we would like to leverage bottom-up end-to-end learning to directly capture image information. at the same time we aim to address a complex multi-person articulated tracking problem that does not naturally lend itself to an end-to-end prediction task and for which training data is not available in the amounts usually required for end-to-end learning. to leverage the available image information we learn a model for associating a body joint to a specific person in an end-to-end fashion relying on a convolutional network. we then incorporate these part-to-person association responses into a framework for jointly reasoning about assignment of body joints within the image and over time. to that end we use the graph partitioning formulation that has been used for people tracking and pose estimation in the past, but has not been shown to enable articulated people tracking. to facilitate efficient inference in video we resort to fast inference methods based on local combinatorial optimization and aim for a sparse model that keeps the number of connections between variables to a minimum. as we demonstrate, in combination with feed-forward reasoning for joint-to-person association this allows us to achieve substantial speed-ups compared to state-of-the-art while maintaining the same level of accuracy. the main contribution of this work is a new articulated tracking model that operates by bottom-up assembly of part detections within each frame and over time. in contrast to this model is suitable for scenes with an unknown number of subjects and reasons jointly across multiple people incorporating inter-person exclusion constraints and propagating strong observations to neighboring frames. our second contribution is a formulation for single-frame pose estimation that relies on a sparse graph between body parts and a mechanism for generating body-part proposals conditioned on a person's location. this is in contrast to state-of-the-art approaches that perform expensive inference in a full graph and rely on generic bottom-up proposals. we demonstrate that a sparse model with a few spatial edges performs competitively with a fully-connected model while being much more efficient. notably, a simple model that operates in top-down/ bottom-up fashion exceeds the performance of a fully-connected model while being x faster at inference time (cf. tab. [reference]). this is due to offloading of a large share of the reasoning about body-part association onto a feed-forward convolutional architecture. finally, we contribute a new challenging dataset for evaluation of articulated body joint tracking in crowded realistic environments with multiple overlapping people. related work. convolutional networks have emerged as an effective approach to localizing body joints of people in images and have also been extended for joint estimation of body configurations over time, and 3d pose estimation in outdoor environments in multi-camera setting. current approaches are increasingly effective for estimating body configurations of single people achieving high accuracies on this task, but are still failing on fast moving and articulated limbs. more complex recent models jointly reason about entire scenes, but are too complex and inefficient to directly generalize to image sequences. recent feed-forward models are able to jointly infer body joints of the same person and even operate over time but consider isolated persons only and do not generalize to the case of multiple overlapping people. similarly, consider a simplified task of tracking upper body poses of isolated upright individuals. we build on recent cnn detectors that are effective in localizing body joints in cluttered scenes and explore different mechanisms for assembling the joints into multiple person configurations. to that end we rely on a graph partitioning approach closely related to. in contrast to who focus on pedestrian tracking, and who perform single frame multi-person pose estimation, we solve a more complex problem of articulated multi-person pose tracking. earlier approaches to articulated pose tracking in monocular videos rely on hand-crafted image representations and focus on simplified tasks, such as tracking upper body poses of frontal isolated people, or tracking walking pedestrians with little degree of articulation. in contrast, we address a harder problem of multi-person articulated pose tracking and do not make assumptions about the type of body motions or activities of people. our approach is closely related to who propose a similar formulation based on graph partitioning. our approach differs from primarily in the type of body-part proposals and the structure of the spatio-temporal graph. in our approach we introduce a person-conditioned model that is trained to associate body parts of a specific person already at the detection stage. this is in contrast to the approach of that relies on the generic body-part detectors. overview. our model consists of the two components: (1) a convolutional network for generating body part proposals and (2) an approach to group the proposals into spatio-temporal clusters. in sec. [reference] we introduce a general formulation for multi-target tracking that follows and allows us to define pose estimation and articulated tracking in a unified framework. we then describe the details of our articulated tracking approach in sec. [reference], and introduce two variants of our formulation: bottom-up (bu) and top-down/ bottom-up (td/ bu). we present experimental results in sec. [reference]. section: tracking by spatio-temporal grouping our body part detector generates a set of proposals for each frame of the video. each proposal is given by, where denotes the index of the video frame, is the spatial location of the proposal in image coordinates, is the probability of correct detection, and is the type of the body joint (ankle or shoulder). let be a graph whose nodes are the joint detections in a video and whose edges connect pairs of detections that hypothetically correspond to the same target. the output of the tracking algorithm is a subgraph of, where is a subset of nodes after filtering redundant and erroneous detections and are edges linking nodes corresponding to the same target. we specify via binary variables and that define subsets of edges and nodes included in. in particular each track will correspond to a connected component in. as a general way to introduce constraints on edge configurations that correspond to a valid tracking solution we introduce a set and define a combination of edge and node indicator variables to be feasible if and only if. an example of a constraint encoded through is that endpoint nodes of an edge included by must also be included by. note that the variables and are coupled though. moreover, assuming that we are free to set components of and independently to maximize the tracking objective. given image observations we compute a set of features for each node and edge in the graph. we denote such node and edge features as and respectively. assuming independence of the feature vectors the conditional probability of indicator functions of nodes and of edges given features and and given a feasible set is given by where assigns a constant non-zero probability to every feasible solution and is equal to zero otherwise. minimizing the negative log-likelihood of eq. [reference] is equivalent to solving the following integer-linear program: where is the cost of retaining as part of the solution, and is the cost of assigning the detections linked by an edge to the same track. we define the set of constraints as in: jointly with the objective in eq. [reference] the constraints ([reference])-([reference]) define an instance of the minimum cost subgraph multicut problem. the constraints ([reference]) and ([reference]) ensure that assignment of node and edge variables is consistent. the constraint ([reference]) ensures that for every two nodes either all or none of the paths between these nodes in graph are contained in one of the connected components of subgraph. this constraint is necessary to unambigously assign person identity to a body part proposal based on its membership in a specific connnected component of. section: articulated multi-person tracking in sec. [reference] we introduced a general framework for multi-object tracking by solving an instance of the subgraph multicut problem. the subgraph multicut problem is np-hard, but recent work has shown that efficient approximate inference is possible with local search methods. the framework allows for a variety of graphs and connectivity patterns. simpler connectivity allows for faster and more efficient processing at the cost of ignoring some of the potentially informative dependencies between model variables. our goal is to design a model that is efficient, with as few edges as possible, yet effective in crowded scenes, and that allows us to model temporal continuity and inter-person exclusion. our articulated tracking approach proceeds by constructing a graph that couples body part proposals within the same frame and across neighboring frames. in general the graph will have three types of edges: (1) cross-type edges shown in fig. [reference] (a) and fig. [reference] (b) that connect two parts of different types, (2) same-type edges shown in fig. [reference] (b) that connect two nodes of the same type in the same image, and (3) temporal edges shown in fig. [reference] (c) that connect nodes in the neighboring frames. we now define two variants of our model that we denote as bottom-up (bu) and top-down/ bottom-up (td/ bu). in the bu model the body part proposals are generated with our publicly available convolutional part detector. in the td/ bu model we substitute these generic part detectors with a new convolutional body-part detector that is trained to output consistent body configurations conditioned on the person location. this alows to further reduce the complexity of the model graph since the task of associating body parts is addressed within the proposal mechanism. as we show in sec. [reference] this leads to considerable gains in performance and allows for faster inference. note that the bu and td/ bu models have identical same-type and temporal pairwise terms, but differ in the form of cross-type pairwise terms, and the connectivity of the nodes in. for both models we rely on the solver from for inference. subsection: bottom-up model (bu). for each body part proposal the detector outputs image location, probability of detection, and a label that indicates the type of the detected part (shoulder or ankle). we directly use the probability of detection to derive the unary costs in eq. [reference] as. image features in this case correspond to the image representation generated by the convolutional network. we consider two connectivity patterns for nodes in the graph. we either define edges for every pair of proposals which results in a fully connected graph in each image. alternatively we obtain a sparse version of the model by defining edges for a subset of part types only as is shown in fig. [reference] (a). the rationale behind the sparse version is to obtain a simpler and faster version of the model by omitting edges between parts that carry little information about each other's image location (left ankle and right arm). edge costs. in our bottom-up model the cost of the edges connecting two body part detections and is defined as a function of the detection types and. following we thus train for each pair of part types a regression function that predicts relative image location of the parts in the pair. the cost is given by the output of the logistic regression given the features computed from offset and angle of the predicted and actual location of the other joint in the pair. we refer to for more details on these pairwise terms. note that our model generalizes in that the edge cost depends on the type of nodes linked by the edge. it also generalizes by allowing to be sparse. this is achieved by reformulating the model with a more general type of cycle constraint ([reference]), in contrast to simple triangle inequalities used in. subsection: top-down/ bottom-up model (td/ bu) we now introduce a version of our model that operates by first generating body part proposals conditioned on the locations of people in the image and then performing joint reasoning to group these proposals into spatio-temporal clusters corresponding to different people. we follow the intuition that it is considerably easier to identify and detect individual people (e.g. by detecting their heads) compared to correctly associating body parts such as ankles and wrists to each person. we select person's head as a root part that is responsible for representing the person location, and delegate the task of identifying body parts of the person corresponding to a head location to a convolutional network. the structure of td/ bu model is illustrated in fig. [reference] (b) for the simplified case of two distinct head detections. let us denote the set of all root part detections as. for each pair of the root nodes we explicitly set the corresponding edge indicator variables. this implements a\" must-not-link\" constraint between these nodes, and in combination with the cycle inequality ([reference]) implies that each proposal can be connected to one of the\" person nodes\" only. the cost for an edge connecting detection proposal and a\" person node\" is based on the conditional distribution generated by the convolutional network. the output of such network is a set of conditional distributions, one for each node type. we augment the graph with attractive/ repulsive and temporal terms as described in sec. [reference] and sec. [reference] and set the unary costs for all indicator variables to a constant. any proposal not connected to any of the root nodes is excluded from the final solution. we use the solver from for consistency, but a simpler kl-based solver as in could be used as well since the td/ bu model effectively ignores the unary variables. the processing stages of td/ bu model are shown in fig. [reference]. note that the body-part heatmaps change depending on the person-identity signal provided by the person's neck, and that the bottom-up step was able to correct the predictions on the forearms of the front person. implementation details. for head detection, we use a version of our model that contains the two head parts (neck and head top). this makes our td/ bu model related to the hierarchical model defined in that also uses easier-to-detect parts to guide the rest of the inference process. however here we replace all the stages in the hierarchical inference except the first one with a convolutional network. the structure of the convolutional network used to generate person-conditioned proposals is shown on fig. [reference]. the network uses the resnet-101 from that we modify to bring the stride of the network down to 8 pixels. the network generates predictions for all body parts after the conv4_4 block. we use the cross-entropy binary classification loss at this stage to predict the part heatmaps. at each training iteration we forward pass an image with multiple people potentially in close proximity to each other. we select a single person from the image and condition the network on the person's neck location by zeroing out the heatmap of the neck joint outside the ground-truth region. we then pass the neck heatmap through a convolutional layer to match the dimensionality of the feature channels and add them to the main stream of the resnet. we finally add a joint prediction layer at the end of the network with a loss that considers predictions to be correct only if they correspond to the body joints of the selected person. spatial propagation (sp). in our network the person identity signal is provided by the location of the head. in principle the receptive field size of the network is large enough to propagate this signal to all body parts. however we found that it is useful to introduce an additional mechanism to propagate the person identity signal. to that end we inject intermediate supervision layers for individual body parts arranged in the order of kinematic proximity to the root joint (fig. [reference]). we place prediction layers for shoulders at conv4_8, for elbows and hips at conv4_14 and for knees at conv4_18. we empirically found that such an explicit form of spatial propagation significantly improves performance on joints such as ankles, that are typically far from the head in the image space (see tab. [reference] for details). training. we use caffe's resnet implementation and initialize from the imagenet-pre-trained models. networks are trained on the mpii human pose dataset with sgd for 1 m iterations with stepwise learning rate (lr=0.002 for 400k, lr=0.0002 for 300k and lr=0.0001 for 300k). subsection: attractive/ repulsive edges attractive/ repulsive edges are defined between two proposals of the same type within the same image. the costs of these edges is inversely-proportional to distance. the decision to group two nodes is made based on the evidence from the entire image, which is in contrast to typical non-maximum suppression based on the state of just two detections. inversely, these edges prevent grouping of multiple distant hypothesis of the same type, prevent merging two heads of different people. subsection: temporal model regardless of the type of within frame model (bu or td/ bu) we rely on the same type of temporal edges that connect nodes of the same type in adjacent frames. we derive the costs for such temporal edges via logistic regression. given the feature vector the probability that the two proposals and in adjacent frames correspond to the same body part is given by:, where, and -, is euclidean distance between the sift descriptors computed at and, and and measure the agreement with the dense motion field computed with the deepmatching approach of. for sift features we specify the location of the detection proposal, but rely on sift to identify the local orientation. in cases with multiple local maxima in orientation estimation we compute sift descriptor for each orientation and set to the minimal distance among all pairs of descriptors. we found that this makes the sift distance more robust in the presence of rotations of the body limbs. we define the features and as in. let be an squared image region centered on the part proposal. we define as a ratio of the number of point correspondences between the regions and and the total number of point correspondences in either of them. specifically, let be a set of point correspondences between the two images computed with deepmatching, where and and denote the corresponding points in the first and second image respectively. using this notation we define: the rationale behind computing by aggregating across multiple correspondences is to make the feature robust to outliers and to inaccuracies in body part detection. is defined analogously, but using the deepmatching correspondences obtained by inverting the order of images. discussion. as we demonstrate in sec. [reference], we found the set of features described above to be complementary to each other. euclidean distance between proposals is informative for finding correspondences for slow motions, but fails for faster motions and in the presence of multiple people. deepmatching is usually effective in finding corresponding regions between the two images, but occasionally fails in the case of sudden background changes due to fast motion or large changes in body limb orientation. in these cases sift is often still able to provide a meaningful measure of similarity due to its rotation invariance. section: experiments subsection: datasets and evaluation measure single frame. we evaluate our single frame models on the mpii multi-person dataset. we report all intermediate results on a validation set of images sampled uniformly at random (mpii multi-person val), while major results and comparison to the state of the art are reported on the test set. video. in order to evaluate video-based models we introduce a novel\" mpii video pose\" dataset. to this end we manually selected challenging keyframes from mpii multi-person dataset. selected keyframes represent crowded scenes with highly articulated people engaging in various dynamic activities. in addition to each keyframe, we include+/- neighboring frames from the corresponding publicly available video sequences, and annotate every second frame. each body pose was annotated following the standard annotation procedure, while maintaining person identity throughout the sequence. in contrast to mpii multi-person where some frames may contain non-annotated people, we annotate all people participating in the activity captured in the video, and add ignore regions for areas that contain dense crowds (e.g. static spectators in the dancing sequences). in total, our dataset consists of sequences with over annotated poses. evaluation details. the average precision (ap) measure is used for evaluation of pose estimation accuracy. for each algorithm we also report run time of the proposal generation and of the graph partitioning stages. all time measurements were conducted on a single core intel xeon ghz. finally we also evaluate tracking perfomance using standard mota metric. evaluation on our\" mpii video pose\" dataset is performed on the full frames using the publicly available evaluation kit of. on mpii multi-person we follow the official evaluation protocol and evaluate on groups using the provided rough group location and scale. subsection: single-frame models we compare the performance of different variants of our bottom-up (bu) and top-down/ bottom-up (td/ bu) models introduced in sec. [reference] and sec. [reference]. for bu we consider a model that (1) uses a fully-connected graph with up to detection proposals and jointly performs partitioning and body-part labeling similar to (bu-full, label); (2) is same as (1), but labeling of detection proposals is done based on detection score (bu-full); (3) is same as (2), but uses a sparsely-connected graph (bu-sparse). the results are shown in tab. [reference]. bu-full, label achieves% ap with a median inference run-time of s/ f. bu-full achieves run-time reduction (vs. s/ f): pre-labeling detection candidates based on detection score significantly reduces the number of variables in the problem graph. interestingly, pre-labeling also improves the performance (vs.% ap): some of the low-scoring detections may complicate the search for an optimal labeling. bu-sparse further reduces run-time (vs. s/ f), as it reduces the complexity of the initial problem by sparsifying the graph, at a price of a drop in performance (vs.% ap). in tab. [reference] we compare the variants of the td/ bu model. our td approach achieves% ap, performing on par with a more complex bu-full. explicit spatial propagation (td+ sp) further improves the results (vs.% ap). the largest improvement is observed for ankles: progressive prediction that conditions on the close-by parts in the tree hierarchy reduces the distance between the conditioning signal and the location of the predicted body part and simplifies the prediction task. performing inference (td/ bu+ sp) improves the performance to% ap, due to more optimal assignment of part detection candidates to corresponding persons. graph simplification in td/ bu allows to further reduce the inference time for graph partitioning (vs. for bu-sparse). single frame tracking single frame tracking comparison to the state of the art. we compare the proposed single-frame approaches to the state of the art on mpii multi-person test and waf datasets. comparison on mpii is shown in tab. [reference]. both bu-full and td/ bu improve over the best published result of deepercut, achieving and% ap respectively vs.% ap by deepercut. for the td/ bu the improvements on articulated parts (elbows, wrists, ankles, knees) are particularly pronounced. we argue that this is due to using the network that is directly trained to disambiguate body parts of different people, instead of using explicit geometric pairwise terms that only serve as a proxy to person's identity. overall, the performance of our best td/ bu method is noticeably higher (vs.% ap). remarkably, its run-time of graph partitioning stage is orders of magnitude faster compared to deepercut. this speed-up is due to two factors. first, td/ bu relies on a faster solver that tackles the graph-partitioning problem via local search, in contrast to the exact solver used in. second, in the case of td/ bu model the graph is sparse and a large portion of the computation is performed by the feed-forward cnn introduced in sec. [reference]. on waf dataset td/ bu substantially improves over the best published result (vs.% ap by). we refer to supplemental material for details. subsection: multi-frame models comparison of video-based models. performance of the proposed video-based models is compared in tab. [reference]. video-based models outperform single-frame models in each case. bu-full+ temporal slightly outperforms bu-full, where improvements are noticeable for ankle, knee and head. bu-sparse+ temporal noticeably improves over bu-sparse (vs.% ap). we observe significant improvements on the most difficult parts such as ankles (% ap) and wrists (% ap). interestingly, bu-sparse+ temporal outperforms: longer-range connections such as,, head to ankle, may introduce additional confusion when information is propagated over time. finally, td/ bu+ temporal improves over td/ bu (% ap). similarly to bu-sparse+ temporal, improvement is most prominent on ankles (% ap) and wrists (% ap). note that even the single-frame td/ bu outperforms the best temporal bu model. we show examples of articulated tracking on\" mpii video pose\" in fig. [reference]. temporal reasoning helps in cases when image information is ambiguous due to close proximity of multiple people. for example the video-based approach succeeds in correctly localizing legs of the person in fig. [reference] (d) and (h). temporal features. we perform an ablative experiment on the\" mpii video pose\" dataset to evaluate the individual contribution of the temporal features introduced in sec. [reference]. the euclidean distance alone achieves ap, adding deepmatching features improves the resuls to ap, whereas the combination of all features achieves the best result of ap (details in supplemental material). tracking evaluation. in tab. [reference] we present results of the evaluation of multi-person articulated body tracking. we treat each body joint of each person as a tracking target and measure tracking performance using a standard multiple object tracking accuracy (mota) metric that incorporates identity switches, false positives and false negatives. we experimentally compare to a baseline model that first tracks people across frames and then performs per-frame pose estimation. to track a person we use a reduced version of our algorithm that operates on the two head joints only. this allows to achieve near perfect person tracking results in most cases. our tracker still fails when the person head is occluded for multiple frames as it does not incorporate long-range connectivity between target hypothesis. we leave handling of long-term occlusions for the future work. for full-body tracking we use the same inital head tracks and add them to the set of body part proposals, while also adding must-link and must-cut constraints for the temporal edges corresponding to the head parts detections. the rest of the graph remains unchanged so that at inference time the body parts can be freely assigned to different person tracks. for the bu-sparse the full body tracking improves performance by and mota on wrists and ankles, and by and mota on elbows and knees respectively. td/ bu benefits from adding temporal connections between body parts as well, but to a lesser extent than bu-sparse. the most significant improvement is for ankles (mota). bu-sparse also achieves the best overall score of compared to by td/ bu. this is surprising since td/ bu outperformed bu-sparse on the pose estimation task (see tab. [reference] and [reference]). we hypothesize that limited improvement of td/ bu could be due to balancing issues between the temporal and spatial pairwise terms that are estimated independently of each other. section: conclusion in this paper we introduced an efficient and effective approach to articulated body tracking in monocular video. our approach defines a model that jointly groups body part proposals within each video frame and across time. grouping is formulated as a graph partitioning problem that lends itself to efficient inference with recent local search techniques. our approach improves over state-of-the-art while being substantially faster compared to other related work. acknowledgements. this work has been supported by the max planck center for visual computing and communication. the authors thank varvara obolonchykova and bahar tarakameh for their help in creating the video dataset. section: additional results on the mpii multi-person dataset we perform qualitative comparison of the proposed single-frame based td/ bu and bu-full methods on challenging scenes containing highly articulated and strongly overlapping individuals. results are shown in fig. [reference] and figure [reference]. the bu-full works well when persons are sufficiently separated (images 11 and 12). however, it fails on images where people significantly overlap (images 1-3, 5-10) or exhibit high degree of articulation (image 4). this is due to the fact that geometric image-conditioned pairwise may get confused in the presence of multiple overlapping individuals and thus mislead post-cnn bottom-up assembling of body poses. in contrast, td/ bu performs explicit modeling of person identity via top-dop bottom-up reasoning while offloading the larger share of the reasoning about body-part association onto feed-forward convolutional architecture, and thus is able to resolve such challenging cases. interestingly, td/ bu is able to correctly predict lower limbs of people in the back through partial occlusion (image 3, 5, 7, 10). td/ bu model occasionally incorrectly assembles body parts in kinematically implausible manner (image 12), as it does not explicitly model geometric body part relations. finally, both models fail in presense of high variations in scale (image 13). we envision that reasoning over multiple scales is likely to improve the results. bu td/ bu bu td/ bu bu td/ bu bu td/ bu section: results on the we are family dataset we compare our proposed td/ bu model to the state-of-the-art methods on the\" we are family\" (waf) dataset and present results in table [reference]. we use evaluation protocol from and report the ap evaluation measure. td/ bu model outperforms the best published results across all body parts (vs% ap) as well improves on articulated parts such as wrists (% ap) and elbows (% ap). we attribute that to the ability of top-down model to better learn part associations compared to explicit modeling geometric pairwise relations as in. section: evaluation of temporal features. we evaluate the importance of combining temporal features introduced in sec. 3.4 of the paper on our multi-person video dataset. to that end, we consider bu-sparse+ temporal model and compare results to bu-sparse in tab. [reference]. single-frame bu-sparse achieves% ap. it can be seen that using geometry based det-distance features slightly improves the results to% ap, as it enables the propagation of information from neighboring frames. using deepmatch features slightly improves the performance further as it helps to link the same body part of the same person over time based on the body part appearance. it is especially helpful in the case of fast motion where det-distance may fail. the combination of both geometry and appearance based features further improves the performance to%, which shows their complementarity. finally, adding the sift-distance feature improves the results to%, since it copes better with the sudden changes in background and body part orientations. overall, using a combination of temporal features in bu-sparse+ temporal results in a% ap improvement over the single-frame bu-sparse. this demonstrates the advantages of the proposed approach to improve pose estimation performance using temporal information. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "mpii"
                    ],
                    [
                        "mpii human pose"
                    ],
                    [
                        "mpii human pose benchmark"
                    ],
                    [
                        "mpii video pose"
                    ],
                    [
                        "mpii video pose dataset"
                    ],
                    [
                        "mpii multi person dataset"
                    ],
                    [
                        "mpii video pose dataset"
                    ],
                    [
                        "mpii video pose"
                    ],
                    [
                        "mpii video pose dataset"
                    ],
                    [
                        "we are family dataset"
                    ],
                    [
                        "we are family waf dataset"
                    ]
                ],
                "Method": [
                    [
                        "arttrack"
                    ]
                ],
                "Metric": [
                    [
                        "average precision"
                    ],
                    [
                        "ap"
                    ]
                ],
                "Task": [
                    [
                        "articulated multi person tracking"
                    ],
                    [
                        "multi person tracking"
                    ],
                    [
                        "person tracking"
                    ],
                    [
                        "tracking"
                    ],
                    [
                        "single frame pose estimation"
                    ],
                    [
                        "single frame pose estimation"
                    ],
                    [
                        "multi person articulated body tracking"
                    ],
                    [
                        "articulated body tracking"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "mpii human pose dataset",
                        "mpii multi-person test",
                        "mpii",
                        "multi-person video dataset"
                    ]
                ],
                "Method": [
                    [
                        "arttrack",
                        "articulated multi-person tracking",
                        "articulated tracking model",
                        "articulated tracking approach"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy",
                        "tracking perfomance",
                        "ap",
                        "false positives"
                    ]
                ],
                "Task": [
                    [
                        "single-frame pose estimation",
                        "3d pose estimation",
                        "single frame multi-person pose estimation",
                        "pose estimation",
                        "per-frame pose estimation",
                        "mota",
                        "pose estimation task"
                    ]
                ]
            }
        ]
    },
    "33261d252218007147a71e40f8367ed152fa2fe0-48": {
        "doctext": "question answering with subgraph embeddings section: abstract. this paper presents a system which learns to answer questions on a broad range of topics from a knowledge base using few handcrafted features. our model learns low-dimensional embeddings of words and knowledge base constituents; these representations are used to score natural language questions against candidate answers. training our system using pairs of questions and structured representations of their answers, and pairs of question paraphrases, yields competitive results on a recent benchmark of the literature. section: introduction teaching machines how to automatically answer questions asked in natural language on any topic or in any domain has always been a long standing goal in artificial intelligence. with the rise of large scale structured knowledge bases (kbs), this problem, known as open-domain question answering (or open qa), boils down to being able to query efficiently such databases with natural language. these kbs, such as freebase [reference] encompass huge ever growing amounts of information and ease open qa by organizing a great variety of answers in a structured format. however, the scale and the difficulty for machines to interpret natural language still makes this task a challenging problem. the state-of-the-art techniques in open qa can be classified into two main classes, namely, information retrieval based and semantic parsing based. information retrieval systems first retrieve a broad set of candidate answers by querying the search api of kbs with a transformation of the question into a valid query and then use fine-grained detection heuristics to identify the exact answer [reference][reference][reference]. on the other hand, semantic parsing methods focus on the correct interpretation of the meaning of a question by a semantic parsing system. a correct interpretation converts a question into the exact database query that returns the correct answer. interestingly, recent works [reference][reference][reference][reference] have shown that such systems can be efficiently trained under indirect and imperfect supervision and hence scale to large-scale regimes, while bypassing most of the annotation costs. yet, even if both kinds of system have shown the ability to handle largescale kbs, they still require experts to hand-craft lexicons, grammars, and kb schema to be effective. this non-negligible human intervention might not be generic enough to conveniently scale up to new databases with other schema, broader vocabularies or languages other than english. in contrast, [reference] proposed a framework for open qa requiring almost no human annotation. despite being an interesting approach, this method is outperformed by other competing methods. [reference] introduced an embedding model, which learns low-dimensional vector representations of words and symbols (such as kbs constituents) and can be trained with even less supervision than the system of [reference] while being able to achieve better prediction performance. however, this approach is only compared with [reference] which operates in a simplified setting and has not been applied in more realistic conditions nor evaluated against the best performing methods. in this paper, we improve the model of [reference] by providing the ability to answer more complicated questions. sthe main contributions of the paper are: (1) a more sophisticated inference procedure that is both efficient and can consider longer paths ([reference] considered only answers directly connected to the question in the graph); and (2) a richer representation of the answers which encodes the question-answer path and surrounding subgraph of the kb. our approach is competitive with the current state-of-the-art on the recent benchmark webquestions [reference] without using any lexicon, rules or additional system for partof-speech tagging, syntactic or dependency parsing during training as most other systems do. section: task definition our main motivation is to provide a system for open qa able to be trained as long as it has access to: (1) a training set of questions paired with answers and (2) a kb providing a structure among answers. we suppose that all potential answers are entities in the kb and that questions are sequences of words that include one identified kb entity. when this entity is not given, plain string matching is used to perform entity resolution. smarter methods could be used but this is not our focus. we use webquestions [1] as our evaluation bemchmark. since it contains few training samples, it is impossible to learn on it alone, and this section describes the various data sources that were used for training. these are similar to those used in [reference]. webquestions this dataset is built using freebase as the kb and contains 5, 810 question-answer pairs. it was created by crawling questions through the google suggest api, and then obtaining answers using amazon mechanical turk. we used the original split (3, 778 examples for training and 2, 032 for testing), and isolated 1k questions from the training set for validation. webquestions is built on freebase since all answers are defined as freebase entities. in each question, we identified one freebase entity using string matching between words of the question and entity names in freebase. when the same string matches multiple entities, only the entity appearing in most triples, i.e. the most popular in freebase, was kept. example questions (answers) in the dataset include\" where did edgar allan poe died?\" (baltimore) or\" what degrees did barack obama get?\" (bachelor of arts, juris doctor). freebase freebase [reference] is a huge and freely available database of general facts; data is organized as triplets (subject, type1.type2.predicate, object), where two entities subject and object (identified by mids) are connected by the relation type type1.type2.predicate. we used a subset, created by only keeping triples where one of the entities was appearing in either the webquestions training/ validation set or in clueweb extractions. we also removed all entities appearing less than 5 times and finally obtained a freebase set containing 14 m triples made of 2.2 m entities and 7k relation types. section: webquestions 1 since the format of triples does not correspond to any structure one could find in language, we decided to transform them into automatically generated questions. hence, all triples were converted into questions\" what is the predicate of the type2 subject?\" (using the mid of the subject) with the answer being object. an example is\" what is the nationality of the person barack obama?\" (united states). more examples and details are given in a longer version of this paper [reference]. section: clueweb extractions freebase data allows to train our model on 14 m questions but these have a fixed lexicon and vocabulary, which is not realistic. following [reference], we also created questions using clueweb extractions provided by [reference]. using string matching, we ended up with 2 m extractions structured as (subject,\" text string\", object) with both subject and object linked to freebase. we also converted these triples into questions by using simple patterns and freebase types. an example of generated question is\" where barack obama was allegedly bear in?\" (hawaii). paraphrases the automatically generated questions that are useful to connect freebase triples and natural language, do not provide a satisfactory modeling of natural language because of their semi-automatic wording and rigid syntax. to overcome this issue, we follow [reference] table 2. examples of questions, answer paths and paraphrases used in this paper. as rephrasings of each other: [reference] harvested a set of 2 m distinct questions from wikianswers, which were grouped into 350k paraphrase clusters. section: embedding questions and answers inspired by [reference], our model works by learning low-dimensional vector embeddings of words appearing in questions and of entities and relation types of freebase, so that representations of questions and of their corresponding answers are close to each other in the joint embedding space. let q denote a question and a a candidate answer. learning embeddings is achieved by learning a scoring function s (q, a), so that s generates a high score if a is the correct answer to the question q, and a low score otherwise. note that both q and a are represented as a combination of the embeddings of their individual words and/ or symbols; hence, learning s essentially involves learning these embeddings. in our model, the form of the scoring function is: let w be a matrix of r k\u00d7n, where k is the dimension of the embedding space which is fixed a-priori, and n is the dictionary of embeddings to be learned. let n w denote the total number of words and n s the total number of entities and relation types. with n= n w+ n s, the i-th column of w is the embedding of the i-th element (word, entity or relation type) in the dictionary. the function f (.), which maps the questions into the embedding space r k is defined as f (q)= w\u03c6 (q), where\u03c6 (q)\u2208 n n, is a sparse vector indicating the number of times each word appears in the question q (usually 0 or 1). likewise the function g (.) which maps the answer into the same embedding space r k as the questions, is given by g (a)= w\u03c8 (a). here\u03c8 (a)\u2208 n n is a sparse vector representation of the answer a, which we now detail. section: embedding model freebase subgraph section: binary encoding of the subgraph\u03c8 (a) section: embedding of the subgraph g (a) binary encoding of the ques0on\u03c6 (q) section: embedding of the ques0on f (q) ques0on q subgraph of a candidate answer a (here k. preston) section: score s (q, a) how the candidate answer fits the ques0on section: dot product embedding matrix w fig. 1. illustration of the subgraph embedding model scoring a candidate answer: (i) locate entity in the question; (ii) compute path from entity to answer; (iii) represent answer as path plus all connected entities to the answer (the subgraph); (iv) embed both the question and the answer subgraph separately using the learnt embedding vectors, and score the match via their dot product. section: representing candidate answers we now describe possible feature representations for a single candidate answer. (when there are multiple correct answers, we average these representations, see section 3.4.) we consider three different types of representation, corresponding to different subgraphs of freebase around it. (i) single entity. the answer is represented as a single entity from freebase:\u03c8 (a) is a 1-of-n s coded vector with 1 corresponding to the entity of the answer, and 0 elsewhere. (ii) path representation. the answer is represented as a path from the entity mentioned in the question to the answer entity. in our experiments, we considered 1-or 2-hops paths (i.e. with either 1 or 2 edges to traverse): (barack obama, people.person.place of birth, honolulu) is a 1-hop path and (barack obama, people.person.place of birth, location. location.containedby, hawaii) a 2-hops path. this results in a\u03c8 (a) which is a 3-of-n s or 4-of-n s coded vector, expressing the start and end entities of the path and the relation types (but not entities) in-between. (iii) subgraph representation. we encode both the path representation from (ii), and the entire subgraph of entities connected to the candidate answer entity. that is, for each entity connected to the answer we include both the relation type and the entity itself in the representation\u03c8 (a). in order to represent the answer path differently to the surrounding subgraph (so the model can differentiate them), we double the dictionary size for entities, and use one embedding representation if they are in the path and another if they are in the subgraph. thus we now learn a parameter matrix r k\u00d7n where n= n w+ 2n s (n s is the total number of entities and relation types). if there are c connected entities with d relation types to the candidate answer, its representation is a 3+ c+ d or 4+ c+ d-of-n s coded vector, depending on the path length. our hypothesis is that including more information about the answer in its representation will lead to improved results. while it is possible that all required information could be encoded in the k dimensional embedding of the single entity (i), it is unclear what dimension k should be to make this possible. for example the embedding of a country entity encoding all of its citizens seems unrealistic. similarly, only having access to the path ignores all the other information we have about the answer entity, unless it is encoded in the embeddings of either the entity of the question, the answer or the relations linking them, which might be quite complicated as well. we thus adopt the subgraph approach. figure 1 illustrates our model. section: training and loss function as in [reference], we train our model using a margin-based ranking loss function. let d= {(q i, a i): i= 1,...,|d|} be the training set of questions q i paired with their correct answer a i. the loss function we minimize is where m is the margin (fixed to 0.1). minimizing eq. (2) learns the embedding matrix w so that the score of a question paired with a correct answer is greater than with any incorrect answer\u0101 by at least m.\u0101 is sampled from a set of incorrect candidates\u0101. this is achieved by sampling 50% of the time from the set of entities connected to the entity of the question (i.e. other candidate paths), and by replacing the answer entity by a random one otherwise. optimization is accomplished using stochastic gradient descent, multi-threaded with hogwild! [reference], with the constraint that the columns w i of w remain within the unit-ball, i.e.,\u2200 i,||w i|| 2\u2264 1. section: multitask training of embeddings since a large number of questions in our training datasets are synthetically generated, they do not adequately cover the range of syntax used in natural language. hence, we also multi-task the training of our model with the task of paraphrase prediction. we do so by alternating the training of s with that of a scoring function s prp (q 1, q 2)= f (q 1) f (q 2), which uses the same embedding matrix w and makes the embeddings of a pair of questions (q 1, q 2) similar to each other if they are paraphrases (i.e. if they belong to the same paraphrase cluster), and make them different otherwise. training s prp is similar to that of s except that negative samples are obtained by sampling a question from another paraphrase cluster. we also multitask the training of the embeddings with the mapping of the mids of freebase entities to the actual words of their names, so that the model learns that the embedding of the mid of an entity should be similar to the embedding of the word (s) that compose its name (s). section: inference once w is trained, at test time, for a given question q the model predicts the answer with:\u00e2= argmax a\u2208a (q) s (q, a) where a (q) is the candidate answer set. this candidate set could be the whole kb but this has both speed and potentially precision issues. instead, we create a candidate set a (q) for each question. we recall that each question contains one identified freebase entity. a (q) is first populated with all triples from freebase involving this entity. this allows to answer simple factual questions whose answers are directly connected to them (i.e. 1-hop paths). this strategy is denoted c 1. since a system able to answer only such questions would be limited, we supplement a (q) with examples situated in the kb graph at 2-hops from the entity of the question. we do not add all such quadruplets since this would lead to very large candidate sets. instead, we consider the following general approach: given that we are predicting a path, we can predict its elements in turn using a beam search, and hence avoid scoring all candidates. specifically, our model first ranks relation types using eq. (1), i.e. selects which relation types are the most likely to be expressed in q. we keep the top 10 types (10 was selected on the validation set) and only add 2-hops candidates to a (q) when these relations appear in their path. scores of 1-hop triples are weighted by 1.5 since they have one less element than 2-hops quadruplets. this strategy, denoted c 2, is used by default. a prediction a can commonly actually be a set of candidate answers, not just one answer, for example for questions like\" who are david beckham's children?\". this is achieved by considering a prediction to be all the entities that lie on the same 1-hop or 2-hops path from the entity found in the question. hence, all answers to the above question are connected to david beckham via the same path (david beckham, people.person.children,*). the feature representation of the prediction is then the average over each candidate entity's features (see section 3.1), i.e.\u03c8 all (a)= 1|a| a j: a\u03c8 (a j) where a j are the individual entities in the overall prediction a. in the results, we compare to a baseline method that can only predict single candidates, which understandly performs poorly. section: experiments we compare our system in terms of f1 score as computed by the official evaluation script 2 (f1 (berant)) but also with a slightly different f1 definition, termed f1 (yao) which was used in [reference] (the difference being the way that questions with no answers are dealt with), and precision@ 1 (p@1) of the first candidate entity (even when there are a set of correct answers), comparing to recently published systems. 3 the upper part of table 3 indicates that our approach outperforms [reference], [reference] and [reference], and performs similarly as [reference]. the lower part of table 3 compares various versions of our model. our default approach uses the subgraph representation for answers and c 2 as the candidate answers set. replacing c 2 by c 1 induces a large drop in performance because many questions do not have answers thatare directly connected to their inluded entity (not in c 1). however, using all 2-hops connections as a candidate set is also detrimental, because the larger number of candidates confuses (and slows a lot) our ranking based inference. our results also verify our hypothesis of section 3.1, that a richer representation for answers (using the local subgraph) can store more pertinent information. finally, we demonstrate that we greatly improve upon the model of [reference], which actually corresponds to a setting with the path representation and c 1 as candidate set. we also considered an ensemble of our approach and that of [reference]. as we only had access to their test predictions we used the following combination method. our approach gives a score s (q, a) for the answer it predicts. we chose a threshold such that our approach predicts 50% of the time (when s (q, a) is above its value), and the other 50% of the time we use the prediction of [reference] instead. we aimed for a 50/ 50 ratio because both methods perform similarly. the ensemble improves the state-of-the-art, and indicates that our models are significantly different in their design. section: conclusion this paper presented an embedding model that learns to perform open qa using training data made of questions paired with their answers and of a kb to provide a structure among answers, and can achieve promising performance on the competitive benchmark webquestions. section:",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "embeddings"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "question answering"
                    ],
                    [
                        "answering"
                    ],
                    [
                        "open domain question answering"
                    ],
                    [
                        "open qa"
                    ],
                    [
                        "qa"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "webquestions"
                    ]
                ],
                "Method": [
                    [
                        "subgraph embeddings",
                        "embedding model",
                        "subgraph embedding model",
                        "s"
                    ]
                ],
                "Metric": [
                    [
                        "f1 score",
                        "f1"
                    ]
                ],
                "Task": [
                    [
                        "question answering",
                        "open-domain question answering",
                        "open qa"
                    ]
                ]
            }
        ]
    },
    "3448e6a5039417dc1ae890efeca3bef5390ace7c-49": {
        "doctext": "document: [combinatorial features are essential for the success of many commercial models. manually crafting these features usually comes with high cost due to the variety, volume and velocity of raw data in web-scale systems. factorization based models, which measure interactions in terms of vector product, can learn patterns of combinatorial features automatically and generalize to unseen features as well. with the great success of deep neural networks (dnns) in various fields, recently researchers have proposed several dnn-based factorization model to learn both low-and high-order feature interactions. despite the powerful ability of learning an arbitrary function from data, plain dnns generate feature interactions implicitly and at the bit-wise level. in this paper, we propose a novel compressed interaction network (cin), which aims to generate feature interactions in an explicit fashion and at the vector-wise level. we show that the cin share some functionalities with convolutional neural networks (cnns) and recurrent neural networks (rnns). we further combine a cin and a classical dnn into one unified model, and named this new model extreme deep factorization machine (xdeepfm). on one hand, the xdeepfm is able to learn certain bounded-degree feature interactions explicitly; on the other hand, it can learn arbitrary low-and high-order feature interactions implicitly. we conduct comprehensive experiments on three real-world datasets. our results demonstrate that xdeepfm outperforms state-of-the-art models. we have released the source code of xdeepfm at. combining explicit and implicit feature interactions for recommender systems] xdeepfm: combining explicit and implicit feature interactions for recommender systems j. lian] jianxun lian x. zhou] xiaohuan zhou f. zhang] fuzheng zhang z. chen] zhongxia chen x. xie] xing xie g. sun] guangzhong sun\u00a1 ccs2012\u00bf\u00a1 concept\u00bf\u00a1/ concept_id\u00bf\u00a1 concept_desc\u00bfinformation systems personalization\u00a1/ concept_desc\u00bf\u00a1 concept_significance\u00bf500\u00a1/ concept_significance\u00bf\u00a1/ concept\u00bf\u00a1 concept\u00bf\u00a1/ concept_id\u00bf\u00a1 concept_desc\u00bfcomputing methodologies neural networks\u00a1/ concept_desc\u00bf\u00a1 concept_significance\u00bf500\u00a1/ concept_significance\u00bf\u00a1/ concept\u00bf\u00a1 concept\u00bf\u00a1/ concept_id\u00bf\u00a1 concept_desc\u00bfcomputing methodologies factorization methods\u00a1/ concept_desc\u00bf\u00a1 concept_significance\u00bf500\u00a1/ concept_significance\u00bf\u00a1/ concept\u00bf\u00a1/ ccs2012\u00bf [500] information systems personalization [500] computing methodologies neural networks [500] computing methodologies factorization methods 2018 2018 acmcopyright [kdd' 18] the 24th acm sigkdd international conference on knowledge discovery& data miningaugust 19-23, 2018london, united kingdom kdd' 18: the 24th acm sigkdd international conference on knowledge discovery& data mining, august 19-23, 2018, london, united kingdom 15.00 10.1145/ 3219819.3220023 978-1-4503-5552-0/ 18/ 08 section: introduction features play a central role in the success of many predictive systems. because using raw features can rarely lead to optimal results, data scientists usually spend a lot of work on the transformation of raw features in order to generate best predictive systems or to win data mining games. one major type of feature transformation is the cross-product transformation over categorical features. these features are called cross features or multi-way features, they measure the interactions of multiple raw features. for instance, a 3-way feature and (user_organization= msra, item_category= deeplearning, time= monday) has value 1 if the user works at microsoft research asia and is shown a technical article about deep learning on a monday. there are three major downsides for traditional cross feature engineering. first, obtaining high-quality features comes with a high cost. because right features are usually task-specific, data scientists need spend a lot of time exploring the potential patterns from the product data before they become domain experts and extract meaningful cross features. second, in large-scale predictive systems such as web-scale recommender systems, the huge number of raw features makes it infeasible to extract all cross features manually. third, hand-crafted cross features do not generalize to unseen interactions in the training data. therefore, learning to interact features without manual engineering is a meaningful task. factorization machines (fm) embed each feature to a latent factor vector, and pairwise feature interactions are modeled as the inner product of latent vectors:. in this paper we use the term bit to denote a element (such as) in latent vectors. the classical fm can be extended to arbitrary higher-order feature interactions, but one major downside is that, proposes to model all feature interactions, including both useful and useless combinations. as revealed in, the interactions with useless features may introduce noises and degrade the performance. in recent years, deep neural networks (dnns) have become successful in computer vision, speech recognition, and natural language processing with their great power of feature representation learning. it is promising to exploit dnns to learn sophisticated and selective feature interactions. proposes a factorisation-machine supported neural network (fnn) to learn high-order feature interactions. it uses the pre-trained factorization machines for field embedding before applying dnn. further proposes a product-based neural network (pnn), which introduces a product layer between embedding layer and dnn layer, and does not rely on pre-trained fm. the major downside of fnn and pnn is that they focus more on high-order feature interactions while capture little low-order interactions. the wide& deep and deepfm models overcome this problem by introducing hybrid architectures, which contain a shallow component and a deep component with the purpose of learning both memorization and generalization. therefore they can jointly learn low-order and high-order feature interactions. all the abovementioned models leverage dnns for learning high-order feature interactions. however, dnns model high-order feature interactions in an implicit fashion. the final function learned by dnns can be arbitrary, and there is no theoretical conclusion on what the maximum degree of feature interactions is. in addition, dnns model feature interactions at the bit-wise level, which is different from the traditional fm framework which models feature interactions at the vector-wise level. thus, in the field of recommender systems, whether dnns are indeed the most effective model in representing high-order feature interactions remains an open question. in this paper, we propose a neural network-based model to learn feature interactions in an explicit, vector-wise fashion. our approach is based on the deep& cross network (dcn), which aims to efficiently capture feature interactions of bounded degrees. however, we will argue in section [reference] that dcn will lead to a special format of interactions. we thus design a novel compressed interaction network (cin) to replace the cross network in the dcn. cin learns feature interactions explicitly, and the degree of interactions grows with the depth of the network. following the spirit of the wide& deep and deepfm models, we combine the explicit high-order interaction module with implicit interaction module and traditional fm module, and name the joint model extreme deep factorization machine (xdeepfm). the new model requires no manual feature engineering and release data scientists from tedious feature searching work. to summarize, we make the following contributions: we propose a novel model, named extreme deep factorization machine (xdeepfm), that jointly learns explicit and implicit high-order feature interactions effectively and requires no manual feature engineering. we design a compressed interaction network (cin) in xdeepfm that learns high-order feature interactions explicitly. we show that the degree of feature interactions increases at each layer, and features interact at the vector-wise level rather than the bit-wise level. we conduct extensive experiments on three real-world dataset, and the results demonstrate that our xdeepfm outperforms several state-of-the-art models significantly. the rest of this paper is organized as follows. section [reference] provides some preliminary knowledge which is necessary for understanding deep learning-based recommender systems. section [reference] introduces our proposed cin and xdeepfm model in detail. we will present experimental explorations on multiple datasets in section [reference]. related works are discussed in section [reference]. section [reference] concludes this paper. section: preliminaries subsection: embedding layer in computer vision or natural language understanding, the input data are usually images or textual signals, which are known to be spatially and/ or temporally correlated, so dnns can be applied directly on the raw feature with dense structures. however, in web-scale recommender systems, the input features are sparse, of huge dimension, and present no clear spatial or temporal correlation. therefore, multi-field categorical form is widely used by related works. for example, one input instance [user_id= s02, gender= male, organization= msra, interests= comedy& rock] is normally transformed into a high-dimensional sparse features via field-aware one-hot encoding: an embedding layer is applied upon the raw feature input to compress it to a low dimensional, dense real-value vector. if the field is univalent, the feature embedding is used as the field embedding. take the above instance as an example, the embedding of feature male is taken as the embedding of field gender. if the field is multivalent, the sum of feature embedding is used as the field embedding. the embedding layer is illustrated in figure [reference]. the result of embedding layer is a wide concatenated vector: where denotes the number of fields, and denotes the embedding of one field. although the feature lengths of instances can be various, their embeddings are of the same length, where is the dimension of field embedding. subsection: implicit high-order interactions fnn, deep crossing, and the deep part in wide& deep exploit a feed-forward neural network on the field embedding vector to learn high-order feature interactions. the forward process is: where is the layer depth, is an activation function, and is the output of the-th layer. the visual structure is very similar to what is shown in figure [reference], except that they do not include the fm or product layer. this architecture models the interaction in a bit-wise fashion. that is to say, even the elements within the same field embedding vector will influence each other. pnn and deepfm modify the above architecture slightly. besides applying dnns on the embedding vector, they add a two-way interaction layer in the architecture. therefore, both bit-wise and vector-wise interaction is included in their model. the major difference between pnn and deepfm, is that pnn connects the outputs of product layer to the dnns, whereas deepfm connects the fm layer directly to the output unit (refer to figure [reference]). subsection: explicit high-order interactions proposes the cross network (crossnet) whose architecture is shown in figure [reference]. it aims to explicitly model the high-order feature interactions. unlike the classical fully-connected feed-forward network, the hidden layers are calculated by the following cross operation: where are weights, bias and output of the-th layer, respectively. we argue that the crossnet learns a special type of high-order feature interactions, where each hidden layer in the crossnet is a scalar multiple of. consider a-layer cross network with the (i+ 1)- th layer defined as. then, the output of the cross network is a scalar multiple of. when= 1, according to the associative law and distributive law for matrix multiplication, we have: where the scalar is actually a linear regression of. thus, is a scalar multiple of. suppose the scalar multiple statement holds for=. for=, we have: where, is a scalar. thus is still a scalar multiple of. by induction hypothesis, the output of cross network is a scalar multiple of. note that the scalar multiple does not mean is linear with. the coefficient is sensitive with. the crossnet can learn feature interactions very efficiently (the complexity is negligible compared with a dnn model), however the downsides are: (1) the output of crossnet is limited in a special form, with each hidden layer is a scalar multiple of; (2) interactions come in a bit-wise fashion. section: our proposed model.33.32.32 subsection: compressed interaction network we design a new cross network, named compressed interaction network (cin), with the following considerations: (1) interactions are applied at vector-wise level, not at bit-wise level; (2) high-order feature interactions is measured explicitly; (3) the complexity of network will not grow exponentially with the degree of interactions. since an embedding vector is regarded as a unit for vector-wise interactions, hereafter we formulate the output of field embedding as a matrix, where the-th row in is the embedding vector of the-th field:, and is the dimension of the field embedding. the output of the-th layer in cin is also a matrix, where denotes the number of (embedding) feature vectors in the-th layer and we let. for each layer, are calculated via: where, is the parameter matrix for the-th feature vector, and denotes the hadamard product, for example,. note that is derived via the interactions between and, thus feature interactions are measured explicitly and the degree of interactions increases with the layer depth. the structure of cin is very similar to the recurrent neural network (rnn), where the outputs of the next hidden layer are dependent on the last hidden layer and an additional input. we hold the structure of embedding vectors at all layers, thus the interactions are applied at the vector-wise level. it is interesting to point out that equation [reference] has strong connections with the well-known convolutional neural networks (cnns) in computer vision. as shown in figure [reference], we introduce an intermediate tensor, which is the outer products (along each embedding dimension) of hidden layer and original feature matrix. then can be regarded as a special type of image and is a filter. we slide the filter across along the embedding dimension (d) as shown in figure [reference], and get an hidden vector, which is usually called a feature map in computer vision. therefore, is a collection of different feature maps. the term\" compressed\" in the name of cin indicates that the-th hidden layer compress the potential space of vectors down to vectors. figure [reference] provides an overview of the architecture of cin. let t denotes the depth of the network. every hidden layer has a connection with output units. we first apply sum pooling on each feature map of the hidden layer: for. thus, we have a pooling vector with length for the-th hidden layer. all pooling vectors from hidden layers are concatenated before connected to output units:. if we use cin directly for binary classification, the output unit is a sigmoid node on: where are the regression parameters. subsection: cin analysis we analyze the proposed cin to study the model complexity and the potential effectiveness. subsubsection: space complexity the-th feature map at the-th layer contains parameters, which is exactly the size of. thus, there are parameters at the-th layer. considering the last regression layer for the output unit, which has parameters, the total number of parameters for cin is. note that cin is independent of the embedding dimension. in contrast, a plain-layers dnn contains parameters, and the number of parameters will increase with the embedding dimension. usually and will not be very large, so the scale of is acceptable. when necessary, we can exploit a-order decomposition and replace with two smaller matrices and: where and. hereafter we assume that each hidden layer has the same number (which is) of feature maps for simplicity. through the-order decomposition, the space complexity of cin is reduced from to. in contrast, the space complexity of the plain dnn is, which is sensitive to the dimension (d) of field embedding. subsubsection: time complexity the cost of computing tensor (as shown in figure [reference]) is time. because we have feature maps in one hidden layer, computing a-layers cin takes time. a-layers plain dnn, by contrast, takes time. therefore, the major downside of cin lies in the time complexity. subsubsection: polynomial approximation next we examine the high-order interaction properties of cin. for simplicity, we assume that numbers of feature maps at hidden layers are all equal to the number of fields. let denote the set of positive integers that are less than or equal to. the-th feature map at the first layer, denoted as, is calculated via: therefore, each feature map at the first layer models pair-wise interactions with coefficients. similarly, the-th feature map at the second layer is: note that all calculations related to the subscript and is already finished at the previous hidden layer. we expand the factors in equation [reference] just for clarity. we can observe that each feature map at the second layer models 3-way interactions with new parameters. a classical-order polynomial has coefficients. we show that cin approximate this class of polynomial with only parameters in terms of a chain of feature maps. by induction hypothesis, we can prove that the-th feature map at the-th layer is: for better illustration, here we borrow the notations from. let denote a multi-index, and. we omit the original superscript from, and use to denote it since we only we the feature maps from the-th layer (which is exactly the field embeddings) for the final expanded expression (refer to eq. [reference]). now a superscript is used to denote the vector operation, such as. let denote a multi-vector polynomial of degree: each vector polylnomial in this class has coefficients. then, our cin approaches the coefficient with: where, is a multi-index, and is the set of all the permutations of the indices. subsection: combination with implicit networks as discussed in section [reference], plain dnns learn implicit high-order feature interactions. since cin and plain dnns can complement each other, an intuitive way to make the model stronger is to combine these two structures. the resulting model is very similar to the wide& deep or deepfm model. the architecture is shown in figure [reference]. we name the new model extreme deep factorization machine (xdeepfm), considering that on one hand, it includes both low-order and high-order feature interactions; on the other hand, it includes both implicit feature interactions and explicit feature interactions. its resulting output unit becomes: where is the sigmoid function, is the raw features. are the outputs of the plain dnn and cin, respectively. and are learnable parameters. for binary classifications, the loss function is the log loss: where is the total number of training instances. the optimization process is to minimize the following objective function: where denotes the regularization term and denotes the set of parameters, including these in linear part, cin part, and dnn part. subsubsection: relationship with fm and deepfm suppose all fields are univalent. it's not hard to observe from figure [reference] that, when the depth and feature maps of the cin part are both set to 1, xdeepfm is a generalization of deepfm by learning the linear regression weights for the fm layer (note that in deepfm, units of fm layer are directly linked to the output unit without any coefficients). when we further remove the dnn part, and at the same time use a constant sum filter (which simply takes the sum of inputs without any parameter learning) for the feature map, then xdeepfm is downgraded to the traditional fm model. section: experiments in this section, we conduct extensive experiments to answer the following questions: (q1) how does our proposed cin perform in high-order feature interactions learning? (q2) is it necessary to combine explicit and implicit high-order feature interactions for recommender systems? (q3) how does the settings of networks influence the performance of xdeepfm? we will answer these questions after presenting some fundamental experimental settings. subsection: experiment setup subsubsection: datasets. we evaluate our proposed models on the following three datasets: 1. criteo dataset. it is a famous industry benchmarking dataset for developing models predicting ad click-through rate, and is publicly accessible. given a user and the page he is visiting, the goal is to predict the probability that he will clik on a given ad. 2. dianping dataset. dianping.com is the largest consumer review site in china. it provides diverse functions such as reviews, check-ins, and shops' meta information (including geographical messages and shop attributes). we collect 6 months' users check-in activities for restaurant recommendation experiments. given a user's profile, a restaurant's attributes and the user's last three visited pois (point of interest), we want to predict the probability that he will visit the restaurant. for each restaurant in a user's check-in instance, we sample four restaurants which are within 3 kilometers as negative instances by poi popularity. 3. bing news dataset. bing news is part of microsoft's bing search engine. in order to evaluate the performance of our model in a real commercial dataset, we collect five consecutive days' impression logs on news reading service. we use the first three days' data for training and validation, and the next two days for testing. for the criteo dataset and the dianping dataset, we randomly split instances by 8:1:1 for training, validation and test. the characteristics of the three datasets are summarized in table [reference]. subsubsection: evaluation metrics. we use two metrics for model evaluation: auc (area under the roc curve) and logloss (cross entropy). these two metrics evaluate the performance from two different angels: auc measures the probability that a positive instance will be ranked higher than a randomly chosen negative one. it only takes into account the order of predicted instances and is insensitive to class imbalance problem. logloss, in contrast, measures the distance between the predicted score and the true label for each instance. sometimes we rely more on logloss because we need to use the predicted probability to estimate the benefit of a ranking strategy (which is usually adjusted as ctr bid). subsubsection: baselines. we compare our xdeepfm with lr (logistic regression), fm, dnn (plain deep neural network), pnn (choose the better one from ipnn and opnn), wide& deep, dcn (deep& cross network) and deepfm. as introduced and discussed in section [reference], these models are highly related to our xdeepfm and some of them are state-of-the-art models for recommender systems. note that the focus of this paper is to learn feature interactions automatically, so we do not include any hand-crafted cross features. subsubsection: reproducibility we implement our method using tensorflow. hyper-parameters of each model are tuned by grid-searching on the validation set, and the best settings for each model will be shown in corresponding sections. learning rate is set to 0.001. for optimization method, we use the adam with a mini-batch size of 4096. we use a l2 regularization with for dnn, dcn, wide& deep, deepfm and xdeepfm, and use dropout 0.5 for pnn. the default setting for number of neurons per layer is: (1) 400 for dnn layers; (2) 200 for cin layers on criteo dataset, and 100 for cin layers on dianping and bing news datasets. since we focus on neural networks structures in this paper, we make the dimension of field embedding for all models be a fixed value of 10. we conduct experiments of different settings in parallel with 5 tesla k80 gpus. the source code is available at. subsection: performance comparison among individual neural components (q1) we want to know how cin performs individually. note that fm measures 2-order feature interactions explicitly, dnn model high-order feature interactions implicitly, crossnet tries to model high-order feature interactions with a small number of parameters (which is proven not effective in section [reference]), and cin models high-order feature interactions explicitly. there is no theoretic guarantee of the superiority of one individual model over the others, due to that it really depends on the dataset. for example, if the practical dataset does not require high-order feature interactions, fm may be the best individual model. thus we do not have any expectation for which model will perform the best in this experiment. table [reference] shows the results of individual models on the three practical datasets. surprisingly, our cin outperform the other models consistently. on one hand, the results indicate that for practical datasets, higher-order interactions over sparse features are necessary, and this can be verified through the fact that dnn, crossnet and cin outperform fm significantly on all the three datasets. on the other hand, cin is the best individual model, which demonstrates the effectiveness of cin on modeling explicit high-order feature interactions. note that a-layer cin can model-degree feature interactions. it is also interesting to see that it take 5 layers for cin to yield the best result on the bing news dataset. subsection: performance of integrated models (q2) xdeepfm integrates cin and dnn into an end-to-end model. while cin and dnn covers two distinct properties in learning feature interactions, we are interested to know whether it is indeed necessary and effective to combine them together for jointly explicit and implicit learning. here we compare several strong baselines which are not limited to individual models, and the results are shown in table [reference]. we observe that lr is far worse than all the rest models, which demonstrates that factorization-based models are essential for measuring sparse features. wide& deep, dcn, deepfm and xdeepfm are significantly better than dnn, which directly reflects that, despite their simplicity, incorporating hybrid components are important for boosting the accuracy of predictive systems. our proposed xdeepfm achieves the best performance on all datasets, which demonstrates that combining explicit and implicit high-order feature interaction is necessary, and xdeepfm is effective in learning this class of combination. another interesting observation is that, all the neural-based models do not require a very deep network structure for the best performance. typical settings for the depth hyper-parameter are 2 and 3, and the best depth setting for xdeepfm is 3, which indicates that the interactions we learned are at most 4-order. subsection: hyper-parameter study (q3) we study the impact of hyper-parameters on xdeepfm in this section, including (1) the number of hidden layers; (2) the number of neurons per layer; and (3) activation functions. we conduct experiments via holding the best settings for the dnn part while varying the settings for the cin part..32.32.32.32.32.32 depth of network. figure [reference] and [reference] demonstrate the impact of number of hidden layers. we can observe that the performance of xdeepfm increases with the depth of network at the beginning. however, model performance degrades when the depth of network is set greater than 3. it is caused by overfitting evidenced by that we notice that the loss of training data still keeps decreasing when we add more hidden layers. number of neurons per layer. adding the number of neurons per layer indicates increasing the number of feature maps in cin. as shown in figure [reference] and [reference], model performance on bing news dataset increases steadily when we increase the number of neurons from to, while on dianping dataset, is a more suitable setting for the number of neurons per layer. in this experiment we fix the depth of network at 3. activation function. note that we exploit the identity as activation function on neurons of cin, as shown in eq. [reference]. a common practice in deep learning literature is to employ non-linear activation functions on hidden neurons. we thus compare the results of different activation functions on cin (for neurons in dnn, we keep the activation function with relu). as shown in figure [reference] and [reference], identify function is indeed the most suitable one for neurons in cin. section: related work subsection: classical recommender systems subsubsection: non-factorization models for web-scale recommender systems (rss), the input features are usually sparse, categorical-continuous-mixed, and high-dimensional. linear models, such as logistic regression with ftrl, are widely adopted as they are easy to manage, maintain, and deploy. because linear models lack the ability of learning feature interactions, data scientists have to spend a lot of work on engineering cross features in order to achieve better performance. considering that some hidden features are hard to design manually, some researchers exploit boosting decision trees to help build feature transformations. subsubsection: factorization models a major downside of the aforementioned models is that they can not generalize to unseen feature interactions in the training set. factorization machines overcome this problem via embedding each feature into a low dimension latent vector. matrix factorization (mf), which only considers ids as features, can be regarded as a special kind of fm. recommendations are made via the product of two latent vectors, thus it does not require the co-occurrence of user and item in the training set. mf is the most popular model-based collaborative filtering method in the rs literature. extend mf to leveraging side information, in which both a linear model and a mf model are included. on the other hand, for many recommender systems, only implicit feedback datasets such as users' watching history and browsing activities are available. thus researchers extend the factorization models to a bayesian personalized ranking (bpr) framework for implicit feedback. subsection: recommender systems with deep learning deep learning techniques have achieved great success in computer vision, speech recognition and natural language understanding. as a result, an increasing number of researchers are interested in employing dnns for recommender systems. subsubsection: deep learning for high-order interactions to avoid manually building up high-order cross features, researchers apply dnns on field embedding, thus patterns from categorical feature interactions can be learned automatically. representative models include fnn, pnn, deepcross, nfm, dcn, wide& deep, and deepfm. these models are highly related to our proposed xdeepfm. since we have reviewed them in section [reference] and section [reference], we do not further discuss them in detail in this section. we have demonstrated that our proposed xdeepfm has two special properties in comparison with these models: (1) xdeepfm learns high-order feature interactions in both explicit and implicit fashions; (2) xdeepfm learns feature interactions at the vector-wise level rather than at the bit-wise level. subsubsection: deep learning for elaborate representation learning we include some other deep learning-based rss in this section due to that they are less focused on learning feature interactions. some early work employs deep learning mainly to model auxiliary information, such as visual data and audio data. recently, deep neural networks are used to model the collaborative filtering (cf) in rss. proposes a neural collaborative filtering (ncf) so that the inner product in mf can be replaced with an arbitrary function via a neural architecture. model cf base on the autoencoder paradigm, and they have empirically demonstrated that autoencoder-based cf outperforms several classical mf models. autoencoders can be further employed for jointly modeling cf and side information with the purpose of generating better latent factors. employ neural networks to jointly train multiple domains' latent factors. proposes the attentive collaborative filtering (acf) to learn more elaborate preference at both item-level and component-level. shows tha traditional rss can not capture interest diversity and local activation effectively, so they introduce a deep interest network (din) to represent users' diverse interests with an attentive activation mechanism. section: conclusions in this paper, we propose a novel network named compressed interaction network (cin), which aims to learn high-order feature interactions explicitly. cin has two special virtues: (1) it can learn certain bounded-degree feature interactions effectively; (2) it learns feature interactions at a vector-wise level. following the spirit of several popular models, we incorporate a cin and a dnn in an end-to-end framework, and named the resulting model extreme deep factorization machine (xdeepfm). thus xdeepfm can automatically learn high-order feature interactions in both explicit and implicit fashions, which is of great significance to reducing manual feature engineering work. we conduct comprehensive experiments and the results demonstrate that our xdeepfm outperforms state-of-the-art models consistently on three real-world datasets. there are two directions for future work. first, currently we simply employ a sum pooling for embedding multivalent fields. we can explore the usage of the din mechanism to capture the related activation according to the candidate item. second, as discussed in section [reference], the time complexity of the cin module is high. we are interested in developing a distributed version of xdeepfm which can be trained efficiently on a gpu cluster. section: acknowledgements the authors would like to thank the anonymous reviewers for their insightful reviews, which are very helpful on the revision of this paper. this work is supported in part by youth innovation promotion association of cas. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "criteo"
                    ],
                    [
                        "criteo dataset"
                    ],
                    [
                        "criteo dataset"
                    ]
                ],
                "Method": [
                    [
                        "compressed interaction network"
                    ],
                    [
                        "cin"
                    ],
                    [
                        "factorisation machine supported neural network"
                    ],
                    [
                        "product based neural network"
                    ]
                ],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "bing news dataset",
                        "bing news",
                        "bing news datasets"
                    ]
                ],
                "Method": [
                    [
                        "deep factorization machine",
                        "xdeepfm",
                        "xdeepfm model"
                    ]
                ],
                "Metric": [
                    [
                        "auc",
                        "area under the roc curve",
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "predicting ad click-through rate",
                        "ctr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "bing news dataset",
                        "bing news",
                        "bing news datasets"
                    ]
                ],
                "Method": [
                    [
                        "deep factorization machine",
                        "xdeepfm",
                        "xdeepfm model"
                    ]
                ],
                "Metric": [
                    [
                        "loss function",
                        "log loss",
                        "logloss"
                    ]
                ],
                "Task": [
                    [
                        "predicting ad click-through rate",
                        "ctr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "criteo dataset"
                    ]
                ],
                "Method": [
                    [
                        "deep factorization machine",
                        "xdeepfm",
                        "xdeepfm model"
                    ]
                ],
                "Metric": [
                    [
                        "auc",
                        "area under the roc curve",
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "predicting ad click-through rate",
                        "ctr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "criteo dataset"
                    ]
                ],
                "Method": [
                    [
                        "deep factorization machine",
                        "xdeepfm",
                        "xdeepfm model"
                    ]
                ],
                "Metric": [
                    [
                        "loss function",
                        "log loss",
                        "logloss"
                    ]
                ],
                "Task": [
                    [
                        "predicting ad click-through rate",
                        "ctr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "dianping dataset",
                        "dianping"
                    ]
                ],
                "Method": [
                    [
                        "deep factorization machine",
                        "xdeepfm",
                        "xdeepfm model"
                    ]
                ],
                "Metric": [
                    [
                        "auc",
                        "area under the roc curve",
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "predicting ad click-through rate",
                        "ctr"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "dianping dataset",
                        "dianping"
                    ]
                ],
                "Method": [
                    [
                        "deep factorization machine",
                        "xdeepfm",
                        "xdeepfm model"
                    ]
                ],
                "Metric": [
                    [
                        "loss function",
                        "log loss",
                        "logloss"
                    ]
                ],
                "Task": [
                    [
                        "predicting ad click-through rate",
                        "ctr"
                    ]
                ]
            }
        ]
    },
    "35734e8724559fb0d494e5cba6a28ad7a3d5dd4d-50": {
        "doctext": "document: explaining and harnessing adversarial examples several machine learning models, including neural networks, consistently misclassify adversarial examples\u2014inputs formed by applying small but intentionally worst-case perturbations to examples from the dataset, such that the perturbed input results in the model outputting an incorrect answer with high confidence. early attempts at explaining this phenomenon focused on nonlinearity and overfitting. we argue instead that the primary cause of neural networks' vulnerability to adversarial perturbation is their linear nature. this explanation is supported by new quantitative results while giving the first explanation of the most intriguing fact about them: their generalization across architectures and training sets. moreover, this view yields a simple and fast method of generating adversarial examples. using this approach to provide examples for adversarial training, we reduce the test set error of a maxout network on the mnist dataset.* section: 0pt1pt1pt section: introduction szegedy-iclr2014 made an intriguing discovery: several machine learning models, including state-of-the-art neural networks, are vulnerable to adversarial examples. that is, these machine learning models misclassify examples that are only slightly different from correctly classified examples drawn from the data distribution. in many cases, a wide variety of models with different architectures trained on different subsets of the training data misclassify the same adversarial example. this suggests that adversarial examples expose fundamental blind spots in our training algorithms. the cause of these adversarial examples was a mystery, and speculative explanations have suggested it is due to extreme nonlinearity of deep neural networks, perhaps combined with insufficient model averaging and insufficient regularization of the purely supervised learning problem. we show that these speculative hypotheses are unnecessary. linear behavior in high-dimensional spaces is sufficient to cause adversarial examples. this view enables us to design a fast method of generating adversarial examples that makes adversarial training practical. we show that adversarial training can provide an additional regularization benefit beyond that provided by using dropout dropout alone. generic regularization strategies such as dropout, pretraining, and model averaging do not confer a significant reduction in a model's vulnerability to adversarial examples, but changing to nonlinear model families such as rbf networks can do so. our explanation suggests a fundamental tension between designing models that are easy to train due to their linearity and designing models that use nonlinear effects to resist adversarial perturbation. in the long run, it may be possible to escape this tradeoff by designing more powerful optimization methods that can succesfully train more nonlinear models. section: related work szegedy-iclr2014 demonstrated a variety of intriguing properties of neural networks and related models. those most relevant to this paper include: box-constrained l-bfgs can reliably find adversarial examples. on some datasets, such as imagenet imagenet, the adversarial examples were so close to the original examples that the differences were indistinguishable to the human eye. the same adversarial example is often misclassified by a variety of classifiers with different architectures or trained on different subsets of the training data. shallow softmax regression models are also vulnerable to adversarial examples. training on adversarial examples can regularize the model\u2014 however, this was not practical at the time due to the need for expensive constrained optimization in the inner loop. these results suggest that classifiers based on modern machine learning techniques, even those that obtain excellent performance on the test set, are not learning the true underlying concepts that determine the correct output label. instead, these algorithms have built a potemkin village that works well on naturally occuring data, but is exposed as a fake when one visits points in space that do not have high probability in the data distribution. this is particularly disappointing because a popular approach in computer vision is to use convolutional network features as a space where euclidean distance approximates perceptual distance. this resemblance is clearly flawed if images that have an immeasurably small perceptual distance correspond to completely different classes in the network's representation. these results have often been interpreted as being a flaw in deep networks in particular, even though linear classifiers have the same problem. we regard the knowledge of this flaw as an opportunity to fix it. indeed, luca and causal have already begun the first steps toward designing models that resist adversarial perturbation, though no model has yet succesfully done so while maintaining state of the art accuracy on clean inputs. section: the linear explanation of adversarial examples we start with explaining the existence of adversarial examples for linear models. in many problems, the precision of an individual input feature is limited. for example, digital images often use only 8 bits per pixel so they discard all information below of the dynamic range. because the precision of the features is limited, it is not rational for the classifier to respond differently to an input than to an adversarial input if every element of the perturbation is smaller than the precision of the features. formally, for problems with well-separated classes, we expect the classifier to assign the same class to and so long as, where is small enough to be discarded by the sensor or data storage apparatus associated with our problem. consider the dot product between a weight vector and an adversarial example: the adversarial perturbation causes the activation to grow by. we can maximize this increase subject to the max norm constraint on by assigning. if has dimensions and the average magnitude of an element of the weight vector is, then the activation will grow by. since does not grow with the dimensionality of the problem but the change in activation caused by perturbation by can grow linearly with, then for high dimensional problems, we can make many infinitesimal changes to the input that add up to one large change to the output. we can think of this as a sort of\" accidental steganography,\" where a linear model is forced to attend exclusively to the signal that aligns most closely with its weights, even if multiple signals are present and other signals have much greater amplitude. this explanation shows that a simple linear model can have adversarial examples if its input has sufficient dimensionality. previous explanations for adversarial examples invoked hypothesized properties of neural networks, such as their supposed highly non-linear nature. our hypothesis based on linearity is simpler, and can also explain why softmax regression is vulnerable to adversarial examples. section: linear perturbation of non-linear models the linear view of adversarial examples suggests a fast way of generating them. we hypothesize that neural networks are too linear to resist linear adversarial perturbation. lstms lstm, relus jarrett-iccv2009, glorot+ al-ai-2011, and maxout networks goodfellow-et-al-icml2013 are all intentionally designed to behave in very linear ways, so that they are easier to optimize. more nonlinear models such as sigmoid networks are carefully tuned to spend most of their time in the non-saturating, more linear regime for the same reason. this linear behavior suggests that cheap, analytical perturbations of a linear model should also damage neural networks. let be the parameters of a model, the input to the model, the targets associated with (for machine learning tasks that have targets) and be the cost used to train the neural network. we can linearize the cost function around the current value of, obtaining an optimal max-norm constrained pertubation of we refer to this as the\" fast gradient sign method\" of generating adversarial examples. note that the required gradient can be computed efficiently using backpropagation. we find that this method reliably causes a wide variety of models to misclassify their input. see fig. [reference] for a demonstration on imagenet. we find that using, we cause a shallow softmax classifier to have an error rate of 99.9% with an average confidence of 79.3% on the mnist lecun+ 98 test set. in the same setting, a maxout network misclassifies 89.4% of our adversarial examples with an average confidence of 97.6%. similarly, using, we obtain an error rate of 87.15% and an average probability of 96.6% assigned to the incorrect labels when using a convolutional maxout network on a preprocessed version of the cifar-10 krizhevskyhinton2009 test set. other simple methods of generating adversarial examples are possible. for example, we also found that rotating by a small angle in the direction of the gradient reliably produces adversarial examples. the fact that these simple, cheap algorithms are able to generate misclassified examples serves as evidence in favor of our interpretation of adversarial examples as a result of linearity. the algorithms are also useful as a way of speeding up adversarial training or even just analysis of trained networks. section: adversarial training of linear models versus weight decay perhaps the simplest possible model we can consider is logistic regression. in this case, the fast gradient sign method is exact. we can use this case to gain some intuition for how adversarial examples are generated in a simple setting. see fig. [reference] for instructive images. if we train a single model to recognize labels with where is the logistic sigmoid function, then training consists of gradient descent on where is the softplus function. we can derive a simple analytical form for training on the worst-case adversarial perturbation of rather than itself, based on gradient sign perturbation. note that the sign of the gradient is just, and that. the adversarial version of logistic regression is therefore to minimize this is somewhat similar to regularization. however, there are some important differences. most significantly, the penalty is subtracted off the model's activation during training, rather than added to the training cost. this means that the penalty can eventually start to disappear if the model learns to make confident enough predictions that saturates. this is not guaranteed to happen\u2014 in the underfitting regime, adversarial training will simply worsen underfitting. we can thus view weight decay as being more\" worst case\" than adversarial training, because it fails to deactivate in the case of good margin. if we move beyond logistic regression to multiclass softmax regression, weight decay becomes even more pessimistic, because it treats each of the softmax's outputs as independently perturbable, when in fact it is usually not possible to find a single that aligns with all of the class's weight vectors. weight decay overestimates the damage achievable with perturbation even more in the case of a deep network with multiple hidden units. because weight decay overestimates the amount of damage an adversary can do, it is necessary to use a smaller weight decay coefficient than the associated with the precision of our features. when training maxout networks on mnist, we obtained good results using adversarial training with. when applying weight decay to the first layer, we found that even a coefficient of.0025 was too large, and caused the model to get stuck with over 5% error on the training set. smaller weight decay coefficients permitted succesful training but conferred no regularization benefit. section: adversarial training of deep networks the criticism of deep networks as vulnerable to adversarial examples is somewhat misguided, because unlike shallow linear models, deep networks are at least able to represent functions that resist adversarial perturbation. the universal approximator theorem hornik89 guarantees that a neural network with at least one hidden layer can represent any function to an arbitary degree of accuracy so long as its hidden layer is permitted to have enough units. shallow linear models are not able to become constant near training points while also assigning different outputs to different training points. of course, the universal approximator theorem does not say anything about whether a training algorithm will be able to discover a function with all of the desired properties. obviously, standard supervised training does not specify that the chosen function be resistant to adversarial examples. this must be encoded in the training procedure somehow. szegedy-iclr2014 showed that by training on a mixture of adversarial and clean examples, a neural network could be regularized somewhat. training on adversarial examples is somewhat different from other data augmentation schemes; usually, one augments the data with transformations such as translations that are expected to actually occur in the test set. this form of data augmentation instead uses inputs that are unlikely to occur naturally but that expose flaws in the ways that the model conceptualizes its decision function. at the time, this procedure was never demonstrated to improve beyond dropout on a state of the art benchmark. however, this was partially because it was difficult to experiment extensively with expensive adversarial examples based on l-bfgs. we found that training with an adversarial objective function based on the fast gradient sign method was an effective regularizer: in all of our experiments, we used. other values may work better; our initial guess of this hyperparameter worked well enough that we did not feel the need to explore more. this approach means that we continually update our supply of adversarial examples, to make them resist the current version of the model. using this approach to train a maxout network that was also regularized with dropout, we were able to reduce the error rate from 0.94% without adversarial training to 0.84% with adversarial training. we observed that we were not reaching zero error rate on adversarial examples on the training set. we fixed this problem by making two changes. first, we made the model larger, using 1600 units per layer rather than the 240 used by the original maxout network for this problem. without adversarial training, this causes the model to overfit slightly, and get an error rate of 1.14% on the test set. with adversarial training, we found that the validation set error leveled off over time, and made very slow progress. the original maxout result uses early stopping, and terminates learning after the validation set error rate has not decreased for 100 epochs. we found that while the validation set error was very flat, the adversarial validation set error was not. we therefore used early stopping on the adversarial validation set error. using this criterion to choose the number of epochs to train for, we then retrained on all 60, 000 examples. five different training runs using different seeds for the random number generators used to select minibatches of training examples, initialize model weights, and generate dropout masks result in four trials that each had an error rate of 0.77% on the test set and one trial that had an error rate of 0.83%. the average of 0.782% is the best result reported on the permutation invariant version of mnist, though statistically indistinguishable from the result obtained by fine-tuning dbms with dropout dropout at 0.79%. the model also became somewhat resistant to adversarial examples. recall that without adversarial training, this same kind of model had an error rate of 89.4% on adversarial examples based on the fast gradient sign method. with adversarial training, the error rate fell to 17.9%. adversarial examples are transferable between the two models but with the adversarially trained model showing greater robustness. adversarial examples generated via the original model yield an error rate of 19.6% on the adversarially trained model, while adversarial examples generated via the new model yield an error rate of 40.9% on the original model. when the adversarially trained model does misclassify an adversarial example, its predictions are unfortunately still highly confident. the average confidence on a misclassified example was 81.4%. we also found that the weights of the learned model changed significantly, with the weights of the adversarially trained model being significantly more localized and interpretable (see fig. [reference]). the adversarial training procedure can be seen as minimizing the worst case error when the data is perturbed by an adversary. that can be interpreted as learning to play an adversarial game, or as minimizing an upper bound on the expected cost over noisy samples with noise from added to the inputs. adversarial training can also be seen as a form of active learning, where the model is able to request labels on new points. in this case the human labeler is replaced with a heuristic labeler that copies labels from nearby points. we could also regularize the model to be insensitive to changes in its features that are smaller than the precision simply by training on all points within the max norm box, or sampling many points within this box. this corresponds to adding noise with max norm during training. however, noise with zero mean and zero covariance is very inefficient at preventing adversarial examples. the expected dot product between any reference vector and such a noise vector is zero. this means that in many cases the noise will have essentially no effect rather than yielding a more difficult input. in fact, in many cases the noise will actualy result in a lower objective function value. we can think of adversarial training as doing hard example mining among the set of noisy inputs, in order to train more efficiently by considering only those noisy points that strongly resist classification. as control experiments, we trained training a maxout network with noise based on randomly adding to each pixel, or adding noise in to each pixel. these obtained an error rate of 86.2% with confidence 97.3% and an error rate of 90.4% with a confidence of 97.8% respectively on fast gradient sign adversarial examples. because the derivative of the sign function is zero or undefined everywhere, gradient descent on the adversarial objective function based on the fast gradient sign method does not allow the model to anticipate how the adversary will react to changes in the parameters. if we instead adversarial examples based on small rotations or addition of the scaled gradient, then the perturbation process is itself differentiable and the learning can take the reaction of the adversary into account. however, we did not find nearly as powerful of a regularizing result from this process, perhaps because these kinds of adversarial examples are not as difficult to solve. one natural question is whether it is better to perturb the input or the hidden layers or both. here the results are inconsistent. szegedy-iclr2014 reported that adversarial perturbations yield the best regularization when applied to the hidden layers. that result was obtained on a sigmoidal network. in our experiments with the fast gradient sign method, we find that networks with hidden units whose activations are unbounded simply respond by making their hidden unit activations very large, so it is usually better to just perturb the original input. on saturating models such as the rust model we found that perturbation of the input performed comparably to perturbation of the hidden layers. perturbations based on rotating the hidden layers solve the problem of unbounded activations growing to make additive perturbations smaller by comparison. we were able to succesfully train maxout networks with rotational perturbations of the hidden layers. however, this did not yield nearly as strong of a regularizing effect as additive perturbation of the input layer. our view of adversarial training is that it is only clearly useful when the model has the capacity to learn to resist adversarial examples. this is only clearly the case when a universal approximator theorem applies. because the last layer of a neural network, the linear-sigmoid or linear-softmax layer, is not a universal approximator of functions of the final hidden layer, this suggests that one is likely to encounter problems with underfitting when applying adversarial perturbations to the final hidden layer. we indeed found this effect. our best results with training using perturbations of hidden layers never involved perturbations of the final hidden layer. section: different kinds of model capacity one reason that the existence of adversarial examples can seem counter-intuitive is that most of us have poor intuitions for high dimensional spaces. we live in three dimensions, so we are not used to small effects in hundreds of dimensions adding up to create a large effect. there is another way that our intuitions serve us poorly. many people think of models with low capacity as being unable to make many different confident predictions. this is not correct. some models with low capacity do exhibit this behavior. for example shallow rbf networks with are only able to confidently predict that the positive class is present in the vicinity of. elsewhere, they default to predicting the class is absent, or have low-confidence predictions. rbf networks are naturally immune to adversarial examples, in the sense that they have low confidence when they are fooled. a shallow rbf network with no hidden layers gets an error rate of 55.4% on mnist using adversarial examples generated with the fast gradient sign method and. however, its confidence on mistaken examples is only. its average confidence on clean test examples is%. we ca n't expect a model with such low capacity to get the right answer at all points of space, but it does correctly respond by reducing its confidence considerably on points it does not\" understand.\" rbf units are unfortunately not invariant to any significant transformations so they can not generalize very well. we can view linear units and rbf units as different points on a precision-recall tradeoff curve. linear units achieve high recall by responding to every input in a certain direction, but may have low precision due to responding too strongly in unfamiliar situations. rbf units achieve high precision by responding only to a specific point in space, but in doing so sacrifice recall. motivated by this idea, we decided to explore a variety of models involving quadratic units, including deep rbf networks. we found this to be a difficult task\u2014 very model with sufficient quadratic inhibition to resist adversarial perturbation obtained high training set error when trained with sgd. section: why do adversarial examples generalize? an intriguing aspect of adversarial examples is that an example generated for one model is often misclassified by other models, even when they have different architecures or were trained on disjoint training sets. moreover, when these different models misclassify an adversarial example, they often agree with each other on its class. explanations based on extreme non-linearity and overfitting can not readily account for this behavior\u2014 why should multiple extremely non-linear model with excess capacity consistently label out-of-distribution points in the same way? this behavior is especially surprising from the view of the hypothesis that adversarial examples finely tile space like the rational numbers among the reals, because in this view adversarial examples are common but occur only at very precise locations. under the linear view, adversarial examples occur in broad subspaces. the direction need only have positive dot product with the gradient of the cost function, and need only be large enough. fig. [reference] demonstrates this phenomenon. by tracing out different values of we see that adversarial examples occur in contiguous regions of the 1-d subspace defined by the fast gradient sign method, not in fine pockets. this explains why adversarial examples are abundant and why an example misclassified by one classifier has a fairly high prior probability of being misclassified by another classifier. to explain why mutiple classifiers assign the same class to adversarial examples, we hypothesize that neural networks trained with current methodologies all resemble the linear classifier learned on the same training set. this reference classifier is able to learn approximately the same classification weights when trained on different subsets of the training set, simply because machine learning algorithms are able to generalize. the stability of the underlying classification weights in turn results in the stability of adversarial examples. to test this hypothesis, we generated adversarial examples on a deep maxout network and classified these examples using a shallow softmax network and a shallow rbf network. on examples that were misclassified by the maxout network, the rbf network predicted the maxout network's class assignment only 16.0% of the time, while the softmax classifier predict the maxout network's class correctly 54.6% of the time. these numbers are largely driven by the differing error rate of the different models though. if we exclude our attention to cases where both models being compared make a mistake, then softmax regression predict's maxout's class 84.6% of the time, while the rbf network is able to predict maxout's class only 54.3% of the time. for comparison, the rbf network can predict softmax regression's class 53.6% of the time, so it does have a strong linear component to its own behavior. our hypothesis does not explain all of the maxout network's mistakes or all of the mistakes that generalize across models, but clearly a significant proportion of them are consistent with linear behavior being a major cause of cross-model generalization. section: alternative hypotheses we now consider and refute some alternative hypotheses for the existence of adversarial examples. first, one hypothesis is that generative training could provide more constraint on the training process, or cause the model to learn what to distinguish\" real\" from\" fake\" data and be confident only on\" real\" data. the mp-dbm mpdbm provides a good model to test this hypothesis. its inference procedure gets good classification accuracy (an 0.88% error rate) on mnist. this inference procedure is differentiable. other generative models either have non-differentiable inference procedures, making it harder to compute adversarial examples, or require an additional non-generative discriminator model to get good classification accuracy on mnist. in the case of the mp-dbm, we can be sure that the generative model itself is responding to adversarial examples, rather than the non-generative classifier model on top. we find that the model is vulnerable to adversarial examples. with an of 0.25, we find an error rate of 97.5% on adversarial examples generated from the mnist test set. it remains possible that some other form of generative training could confer resistance, but clearly the mere fact of being generative is not alone sufficient. another hypothesis about why adversarial examples exist is that individual models have strange quirks but averaging over many models can cause adversarial examples to wash out. to test this hypothesis, we trained an ensemble of twelve maxout networks on mnist. each network was trained using a different seed for the random number generator used to initialize the weights, generate dropout masks, and select minibatches of data for stochastic gradient descent. the ensemble gets an error rate of 91.1% on adversarial examples designed to perturb the entire ensemble with. if we instead use adversarial examples designed to perturb only one member of the ensemble, the error rate falls to 87.9%. ensembling provides only limited resistance to adversarial perturbation. section: summary and discussion as a summary, this paper has made the following observations: adversarial examples can be explained as a property of high-dimensional dot products. they are a result of models being too linear, rather than too nonlinear. the generalization of adversarial examples across different models can be explained as a result of adversarial perturbations being highly aligned with the weight vectors of a model, and different models learning similar functions when trained to perform the same task. the direction of perturbation, rather than the specific point in space, matters most. space is not full of pockets of adversarial examples that finely tile the reals like the rational numbers. because it is the direction that matters most, adversarial perturbations generalize across different clean examples. we have introduced a family of fast methods for generating adversarial examples. we have demonstrated that adversarial training can result in regularization; even further regularization than dropout. we have run control experiments that failed to reproduce this effect with simpler but less efficient regularizers including weight decay and adding noise. models that are easy to optimize are easy to perturb. linear models lack the capacity to resist adversarial perturbation; only structures with a hidden layer (where the universal approximator theorem applies) should be trained to resist adversarial perturbation. rbf networks are resistant to adversarial examples. models trained to model the input distribution are not resistant to adversarial examples. ensembles are not resistant to adversarial examples. some further observations concerning rubbish class examples are presented in the appendix: rubbish class examples are ubiquitous and easily generated. shallow linear models are not resistant to rubbish class examples. rbf networks are resistant to rubbish class examples. gradient-based optimization is the workhorse of modern ai. using a network that has been designed to be sufficiently linear- whether it is a relu or maxout network, an lstm, or a sigmoid network that has been carefully configured not to saturate too much- we are able to fit most problems we care about, at least on the training set. the existence of adversarial examples suggests that being able to explain the training data or even being able to correctly label the test data does not imply that our models truly understand the tasks we have asked them to perform. instead, their linear responses are overly confident at points that do not occur in the data distribution, and these confident predictions are often highly incorrect. this work has shown we can partially correct for this problem by explicitly identifying problematic points and correcting the model at each of these points. however, one may also conclude that the model families we use are intrinsically flawed. ease of optimization has come at the cost of models that are easily misled. this motivates the development of optimization procedures that are able to train models whose behavior is more locally stable. subsubsection: acknowledgments we would like to thank geoffrey hinton and ilya sutskever for helpful discussions. we would also like to thank jeff dean, greg corrado, and oriol vinyals for their feedback on drafts of this article. we would like to thank the developers of theano bergstra+ al:2010-scipy, bastien-theano-2012, pylearn2 pylearn2_arxiv_2013, and distbelief distbelief. plus 0.3ex bibliography: references appendix: rubbish class examples a concept related to adversarial examples is the concept of examples drawn from a\" rubbish class.\" these examples are degenerate inputs that a human would classify as not belonging to any of the categories in the training set. if we call these classes in the training set\" the positive classes,\" then we want to be careful to avoid false positives on rubbish inputs- i.e., we do not want to classify a degenerate input as being something real. in the case of separate binary classifiers for each class, we want all classes output near zero probability of the class being present, and in the case of a multinoulli distribution over only the positive classes, we would prefer that the classifier output a high-entropy (nearly uniform) distribution over the classes. the traditional approach to reducing vulnerability to rubbish inputs is to introduce an extra, constant output to the model representing the rubbish class lecun+ 98. fool recently re-popularized the concept of the rubbish class in the context of computer vision under the name fooling images. as with adversarial examples, there has been a misconception that rubbish class false positives are hard to find, and that they are primarily a problem faced by deep networks. our explanation of adversarial examples as the result of linearity and high dimensional spaces also applies to analyzing the behavior of the model on rubbish class examples. linear models produce more extreme predictions at points that are far from the training data than at points that are near the training data. in order to find high confidence rubbish false positives for such a model, we need only generate a point that is far from the data, with larger norms yielding more confidence. rbf networks, which are not able to confidently predict the presence of any class far from the training data, are not fooled by this phenomenon. we generated 10, 000 samples from and fed them into various classifiers on the mnist dataset. in this context, we consider assigning a probability greater than 0.5 to any class to be an error. a naively trained maxout network with a softmax layer on top had an error rate of 98.35% on gaussian rubbish examples with an average confidence of 92.8% on mistakes. changing the top layer to independent sigmoids dropped the error rate to 68% with an average confidence on mistakes of 87.9%. on cifar-10, using 1, 000 samples from, a convolutional maxout net obtains an error rate of 93.4%, with an average confidence of 84.4%. these experiments suggest that the optimization algorithms employed by fool are overkill (or perhaps only needed on imagenet), and that the rich geometric structure in their fooling images are due to the priors encoded in their search procedures, rather than those structures being uniquely able to cause false positives. though fool focused their attention on deep networks, shallow linear models have the same problem. a softmax regression model has an error rate of 59.8% on the rubbish examples, with an average confidence on mistakes of 70.8%. if we use instead an rbf network, which does not behave like a linear function, we find an error rate of 0%. note that when the error rate is zero the average confidence on a mistake is undefined. fool focused on the problem of generating fooling images for a specific class, which is a harder problem than simply finding points that the network confidently classifies as belonging to any one class despite being defective. the above methods on mnist and cifar-10 tend to have a very skewed distribution over classes. on mnist, 45.3% of a naively trained maxout network's false positives were classified as 5s, and none were classified as 8s. likewise, on cifar-10, 49.7% of the convolutional network's false positives were classified as frogs, and none were classified as airplanes, automobiles, horses, ships, or trucks. to solve the problem introduced by fool of generating a fooling image for a particular class, we propose adding to a gaussian sample as a fast method of generating a fooling image classified as class. if we repeat this sampling process until it succeeds, we a randomized algorithm with variable runtime. on cifar-10, we found that one sampling step had a 100% success rate for frogs and trucks, and the hardest class was airplanes, with a success rate of 24.7% per sampling step. averaged over all ten classes, the method has an average per-step success rate of 75.3%. we can thus generate any desired class with a handful of samples and no special priors, rather than tens of thousands of generations of evolution. to confirm that the resulting examples are indeed fooling images, and not images of real classes rendered by the gradient sign method, see fig. [reference]. the success rate of this method in terms of generating members of class may degrade for datasets with more classes, since the risk of inadvertently increasing the activation of a different class increases in that case. we found that we were able to train a maxout network to have a zero percent error rate on gaussian rubbish examples (it was still vulnerable to rubbish examples generated by applying a fast gradient sign step to a gaussian sample) with no negative impact on its ability to classify clean examples. unfortunately, unlike training on adversarial examples, this did not result in any significant reduction of the model's test set error rate. in conclusion, it appears that a randomly selected input to deep or shallow models built from linear parts is overwhelmingly likely to be processed incorrectly, and that these models only behave reasonably on a very thin manifold encompassing the training data.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "mnist"
                    ],
                    [
                        "mnist dataset"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "classification accuracy"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "mnist dataset",
                        "mnist"
                    ]
                ],
                "Method": [
                    [
                        "adversarial training",
                        "linear explanation of adversarial examples",
                        "linear view of adversarial examples",
                        "sgd"
                    ]
                ],
                "Metric": [
                    [
                        "test set error",
                        "error",
                        "adversarial validation set error"
                    ]
                ],
                "Task": [
                    [
                        "classification"
                    ]
                ]
            }
        ]
    },
    "364c1a3df58d87cb40ab33fdf3831cf2862f3570-51": {
        "doctext": "document: anmm: ranking short answer texts with attention-based neural matching model as an alternative to question answering methods based on feature engineering, deep learning approaches such as convolutional neural networks (cnns) and long short-term memory models (lstms) have recently been proposed for semantic matching of questions and answers. to achieve good results, however, these models have been combined with additional features such as word overlap or bm25 scores. without this combination, these models perform significantly worse than methods based on linguistic feature engineering. in this paper, we propose an attention based neural matching model for ranking short answer text. we adopt value-shared weighting scheme instead of position-shared weighting scheme for combining different matching signals and incorporate question term importance learning using question attention network. using the popular benchmark trec qa data, we show that the relatively simple anmm model can significantly outperform other neural network models that have been used for the question answering task, and is competitive with models that are combined with additional features. when anmm is combined with additional features, it outperforms all baselines. 2016, october 24-28, 2016, indianapolis, in, usa\u00a1 ccs2012\u00bf\u00a1 concept\u00bf\u00a1/ concept_id\u00bf\u00a1 concept_desc\u00bfinformation systems retrieval models and ranking\u00a1/ concept_desc\u00bf\u00a1 concept_significance\u00bf500\u00a1/ concept_significance\u00bf\u00a1/ concept\u00bf\u00a1 concept\u00bf\u00a1/ concept_id\u00bf\u00a1 concept_desc\u00bfinformation systems question answering\u00a1/ concept_desc\u00bf\u00a1 concept_significance\u00bf500\u00a1/ concept_significance\u00bf\u00a1/ concept\u00bf\u00a1/ ccs2012\u00bf [500] information systems retrieval models and ranking systems question answering section: introduction question answering (qa), which returns exact answers as either short facts or long passages to natural language questions issued by users, is a challenging task and plays a central role in the next generation of advanced web search. many of current qa systems use a learning to rank approach that encodes question/ answer pairs with complex linguistic features including lexical, syntactic and semantic features. for instance, surdeanu et al. investigated a wide range of feature types including similarity features, translation features, density/ frequency features and web correlation features for learning to rank answers and show improvements in accuracy. however, such methods rely on manual feature engineering, which is often time-consuming and requires domain dependent expertise and experience. moreover, they may need additional nlp parsers or external knowledge sources that may not be available for some languages. recently, researchers have been studying deep learning approaches to automatically learn semantic match between questions and answers. such methods are built on the top of neural network models such as convolutional neural networks (cnns) and long short-term memory models (lstms). the proposed models have the benefit of not requiring hand-crafted linguistic features and external resources. some of them achieve state-of-the art performance for the answer sentence selection task benchmarked by the trec qa track. however, the weakness of the existing studies is that the proposed deep models, either based on cnns or lstms, need to be combined with additional features such as word overlap features and bm25 to perform well. without combining these additional features, their performance is significantly worse than the results obtained by the state-of-the-art methods based on linguistic feature engineering. this led us to propose the following research questions: rq1 without combining additional features, could we build deep learning models that can achieve comparable or even better performance than methods using feature engineering? rq2 by combining additional features, could our model outperform state-of-the-art models for question answering? to address these research questions, we analyze the existing current deep learning architectures for answer ranking and make the following two key observations: architectures not specifically designed for question/ answer matching: some methods employ cnns for question/ answer matching. however, cnns are originally designed for computer vision (cv), which uses position-shared weights with local perceptive filters, to learn spatial regularities in many cv tasks. however, such spatial regularities may not exist in semantic matching between questions and answers, since important similarity signals between question and answer terms could appear in any position due to the complex linguistic property of natural languages. meanwhile, models based on lstms view the question/ answer matching problem in a sequential way. without direct interactions between question and answer terms, the model may not be able to capture sufficiently detailed matching signals between them. lack of modeling question focus: understanding the focus of questions, e.g., important terms in a question, is helpful for ranking the answers correctly. for example, given a question like\" where was the first burger king restaurant opened?\", it is critical for the answer to talk about\" burger\",\" king\",\" open\", etc. most existing text matching models do not explicitly model question focus. for example, models based on cnns treat all the question terms as equally important when matching to answer terms. models based on lstms usually model question terms closer to the end to be more important. to handle these issues in the existing deep learning architectures for ranking answers, we propose an attention based neural matching model (anmm). the novel properties of the proposed model and our contributions can be summarized as follows: deep neural network with value-shared weights: we introduce a novel value-shared weighting scheme in deep neural networks as a counterpart of the position-shared weighting scheme in cnns, based on the idea that semantic matching between a question and answer is mainly about the (semantic similarity) value regularities rather than spatial regularities. incorporate attention scheme over question terms: we incorporate the attention scheme over the question terms using a gating function, so that we can explicitly discriminate the question term importance. extensive experimental evaluation and promising results. we perform a thorough experimental study based on the trec qa dataset from trec qa tracks 8-13, which appears to be one of the most widely used benchmarks for answer re-ranking. unlike previous methods using cnns and lstms, which showed inferior results without combining additional features, our model can achieve better performance than a state-of-art method using linguistic feature engineering and comparable performance with previous deep learning models with combined additional features. if we combine our model with a simple additional feature like ql, our method can achieve the state-of-the-art performance among current existing methods for ranking answers under multiple metrics. roadmap. the rest of our paper is organized as follows. we will review related work in section [reference]. in section [reference], we will present the proposed anmm model with two components: value-shared weights and question attention network with gating functions. two different architectures will be presented and analyzed. section [reference] is a systematic experimental analysis using the trec qa benchmark dataset. finally, we conclude our paper and discuss future work in section [reference]. section: related work our work is related to several research areas, including deep learning models for text matching, factoid question answering, answer ranking in cqa and answer passage/ sentence retrieval. deep learning models for text matching. recently there have been many deep learning models proposed for text matching and ranking. such deep learning models include dssm, cdssm, arc-i/ arc-ii, dcnn, deepmatch, multigrancnn and matchpyramid. dssm performs a non-linear projection to map the query and the documents to a common semantic space. the neural network models are trained using clickthrough data such that the conditional likelihood of the clicked document given the query is maximized. deepmatch uses a topic model to construct the interactions between two texts and then makes different levels of abstractions with a deep architecture to model the relationships between topics. arc-i and arc-ii are two different architectures proposed by hu et. al. for matching natural language sentences. arc-i firstly finds the representation of each sentence and then compares the representations of the two sentences with a multi-layer perceptron (mlp). the drawback of arc-i is that it defers the interaction between two sentences until their individual representation matures in the convolution model, and therefore has the risk of losing details, which could be important for the matching task. on the other hand, arc-ii is built directly on the interaction space between two sentences. thus arc-ii makes two sentences meet before their own high-level representations mature, while still retaining the space for individual development of abstraction of each sentence. our anmm architecture adopts a similar design with arc-ii in the qa matching matrix where we build neural networks directly on the interaction of sentence term pairs. however, we adopt value-shared weights instead of position-shared weights as in the cnn used by arc-ii. we also add attention scheme to learn question term importance. factoid question answering. there have been many previous studies on factoid question answering, most of which use the benchmark data from trec qa track. yih et. al. formulated answer sentence selection as a semantic matching problem with a latent word-alignment structure and conducted a series of experimental studies on leveraging proposed lexical semantic models. iyyer et. al. introduced a recursive neural network (rnn) model that can reason over text that contains very few individual words by modeling textual compositionality. yu et al. proposed an approach for answer sentence selection via distributed representations, and learned to match questions with answers by considering their semantic encoding. they combined the learning results of their model with word overlap features by training a logistic regression classifier. wang and nyberg proposed a method which uses a stacked bidirectional long-short term memory (blstm) network to sequentially read words from question and answer sentences, and then output their relevance scores. their system needs to combine the stacked blstm relevance model with a bm25 score to achieve good performance. severyn and moschitti presented a convolutional neural network architecture for re-ranking pairs of short texts, where they learned the optimal representation of text pairs and a similarity function to relate them in a supervised way from the available training data. they also need to combine additional features into their model to outperform previous methods. unlike the previous research, our method can outperform previous methods using feature engineering without combining any additional features. with an additional simple feature like ql, our model is significantly better than the previous state-of-the-art methods including deep learning methods. answer ranking in cqa. there is also previous research on ranking answers from community question answering (cqa) sites. surdeanu et al. investigated a wide range of feature types such as similarity features, translation features, density/ frequency features for ranking answers to non-factoid questions in yahoo! answers. jansen et al. presented an answer re-ranking model for non-factoid questions that integrate lexical semantics with discourse information driven by two representations of discourse. xue et al. proposed a retrieval model that combines a translation-based language model for the question part with a query likelihood approach for the answer part. questions from cqa sites are mostly non-factoid questions. our research is closer to factoid questions such as questions in trec qa data. answer passage/ sentence retrieval. our work is also related to previous research on answer passage/ sentence retrieval. tymoshenko and moschitti studied the use of syntactic and semantic structures obtained with shallow and deeper syntactic parsers in the answer passage re-ranking task. keikha et al. developed an annotated data set for non-factoid answer finding using trec gov2 collections and topics. they annotated passage-level answers, revisited several passage retrieval models with this data, and came to the conclusion that the current methods are not effective for this task. yang et al. developed effective methods for answer sentence retrieval using this annotated data by combining semantic features, context features and basic text matching features with a learning to rank approach. our model is built on attention-based neural matching model with value-shared weighting schema. unlike learning to rank approaches with feature engineering, our model can achieve good performance for ranking answers without any additional manual feature engineering, preprocessing of nlp parsers and external resources like knowledge bases. section: attention-based neural matching model in this section we present the proposed model referred as anmm (attention-based neural matching model), which is shown in figure [reference]. before we introduce our model, we firstly define some terminologies. subsection: terminology short answer text: we use short answer text to refer to a short fact, answer sentences or answer passages that can address users' information needs in the issued questions. this is the ranking object in this paper and includes answers in various lengths. in the experiments of this paper, we mainly focus on ranking answer sentences that contain correct answer facts as in trec qa data. qa matching matrix: we use qa matching matrix to refer to a matrix which represents the semantic matching information of term pairs from a question and answer pair. given a question with length and an answer with length, a qa matching matrix is an by matrix, where denote the semantic similarity between term and term measured by the cosine similarity of the corresponding word embeddings of terms. if and are the same term, we assign as. qa matching vector: we use qa matching vector to refer to a row in the qa matching matrix. as presented before, the-th row of the qa matching matrix contains the semantic similarity between and all terms in answer. subsection: model overview our method contains three steps as follows: we construct qa matching matrix for each question and answer pair with pre-trained word embeddings. we then employ a deep neural network with value-shared weighting scheme in the first layer, and fully connected layers in the rest to learn hierarchical abstraction of the semantic matching between question and answer terms. finally, we employ a question attention network to learn question term importance and produce the final ranking score. we propose two neural matching model architectures and compare the effectivenesses of them. we firstly describe a basic version of the architecture, which is referred to as anmm-1. in the following sections, we will explain in detail the two major designs of anmm-1, i.e., value-shared weights and question attention network. subsection: value-shared weighting we first train word embeddings with the word2vec tool by mikolov et al. with the english wikipedia dump to construct qa matching matrices. given a question sentence and an answer sentence, we compute the dot product of the normalized word embeddings of all term pairs to construct the qa matching matrix as defined in section [reference]. a major problem with the qa matching matrix is the variable size due to the different lengths of answers for a given question. to solve this problem, one can use cnn with pooling strategy to handle the variable size. however, as we have mentioned before, cnns basically use position-shared weighting scheme which may not fit semantic matching between questions and answers. important question terms and semantically similar answer words could appear anywhere in questions/ answers due to the complex linguistic property of natural languages. thus we adopt the following method to handle the various length problem: value-shared weights: for this method, the assumption is that matching signals in different ranges play different roles in deciding the final ranking score. thus we introduce the value-shared weighting scheme to learn the importance of different levels of matching signals. the comparison between the position-shared weight and value-shared weight is shown in figure [reference]. we can see that for position-shared weights, the weight associated with a node only depends on its position or relative location as specified by the filters in cnn. however in our model, the weight associated with a node depends on its value. the value of a node denotes the strength of the matching signal between term pairs of questions and answers from the qa matching matrix, as explained in section [reference]. such a setting enables us to use the learned weights to encode how to combine different levels of matching signals. after this step, the size of the hidden representation becomes fixed and we can use normal fully connected layers to learn higher level representations. we use the term bin to denote a specific range of matching signals. since, if we set the size of bins as, then we have bins where there is a separate bin for to denote exact match of terms. specifically, value-shared weights are adopted in the forward propagation prediction process from the input layer to the hidden layer over each question term in anmm-1 as follows: input layer to hidden layer. let denote a dimensional model parameter from input layer to hidden layer. denotes the sum of all matching signals within the-th value range or bin. for each qa matching vector of a given query, the combined score after the activation function of the-th node in hidden layer is defined as where is the index of question words in. we use the sigmoid function as the activation function, which is commonly adopted in many neural network architectures. subsection: question attention network in addition to value-shared weighting, another model component of anmm-1 is the question attention network. in a committee of neural networks which consists of multiple networks, we need to combine the output of these networks to output a final decision vector. the question attention network uses the gating function to control the output of each network in this process. specifically, in anmm-1 we use the softmax gate function to combine the output of multiple networks where each network corresponds to a question term as shown in figure [reference]. we feed the dot product of query word embedding and model parameter to the softmax function to represent the query term importance. in this setting, we can directly compare the relative term importance of query words within the same query with softmax function. we also tried sigmoid gate function, but this did not perform as well as softmax gate function. softmax gate function is used in the forward propagation process from the hidden layer to the output layer as follows: hidden layer to output layer. from the hidden layer to the output layer, we add a softmax gate function to learn question attention. let denote a dimensional vector which is a model parameter. we feed the dot product of query word embedding and to the softmax function to represent the query term importance as shown in equation [reference]. note that we normalize the query word embedding before computing the dot product. unlike previous models like cnns and blstm, which learn the semantic match score between questions and answers through representation learning from matching matrix or question/ answer pair sequences, anmm achieves this by combining semantic matching signals of term pairs in questions and answers weighted by the output of question attention network, where softmax gate functions help discriminate the term importance or attention on different question terms. subsection: model training for anmm-1, the model parameters contain two sets: 1) the value-shared weights for combining matching signals from the input layer to the hidden layer. 2) the parameters in the gating function from the hidden layer to the output layer. to learn the model parameters from the training data, we adopt a pair-wise learning strategy with a large margin objective. firstly we construct triples from the training data, with matched with better than with. we have the ranking-based loss as the objective function as following: where denote the predicted matching score for qa pair. during training stage, we will scan all the triples in training data. given a triple, we will compute. if, we will skip this triple. otherwise, we need to update model parameters with back propagation algorithm to minimize the objective function. under softmax gate function setting, the gradients of w.r.t. from hidden layer to the output layer is shown in equation [reference] where can be derived as the gradient of w.r.t. from input layer to hidden layer is shown in equation [reference]. with the formulas of gradients, we can perform stochastic gradient descent to learn model parameters. we use mini-batch gradient descent to achieve more robust performance on the ranking task. for the learning rate, we adopt adaptive learning rate:, where will approach with more iterations. such a setting has better guarantee for convergence. subsection: extension to deep neural networks with multiple sets of value-shared weights in anmm-1, we can only use one set of value-shared weights for each qa matching vector. we further propose a more flexible neural network architecture which could enable us to use multiple sets of value-shared weights for each qa matching vector, leading to multiple intermediate nodes in the first hidden layer, as shown in figure [reference] by the yellow color. we refer to this extended model as anmm-2. the model architecture shown in figure [reference] is corresponding to anmm-2. subsubsection: forward propagation prediction for anmm-2, we add a hidden layer in the neural network where we learn multiple combined scores from the input layer. with this hidden layer, we define multiple weight vectors as. thus becomes a two dimensional matrix. the formula for the forward propagation prediction is as follows: where and denote the softmax gate function. is the number of nodes in hidden layer 1. is the model parameter from hidden layer 1 to hidden layer 2, where we feed the linear combination of outputs of nodes in hidden layer 1 to an extra activation function comparing with equation [reference]. then from hidden layer 2 to output layer, we sum over all outputs of nodes in hidden layer 2 weighted by the outputs of softmax gate functions, which also form the question attention network. subsubsection: back propagation for model training for anmm-2, we have three sets of model parameters: 1) from input layer to hidden layer 1; 2) from hidden layer 1 to hidden layer 2; 3) from hidden layer 2 to output layer. all three sets of parameters are updated through back propagation. the definition of the objective function is the same as equation [reference]. the back propagation process for model parameter learning is described as follows: from hidden layer 2 to output layer. the gradients of the objective function w.r.t. is as following: where from hidden layer 1 to hidden layer 2. the gradients of the objective function w.r.t. is as following: where. from input layer to hidden layer 1. the gradients of the objective function w.r.t. is as following: where initially we will randomly give the values of model parameters. then we will use back propagation to update the model parameters. when the learning process converge, we use the learned model parameters for prediction to rank short answer texts. section: experiments subsection: data set and experiment settings we use the trec qa data set created by wang et. al. from trec qa track 8-13 data, with candidate answers automatically selected from each question's document pool using a combination of overlapping non-stop word counts and pattern matching. this data set is one of the most widely used benchmarks for answer re-ranking. table [reference] shows the statistics of this data set. the dataset contains a set of factoid questions with candidate answers which are limited to a single sentence. there are two training data sets: train and train-all. answers in train have manual judgments for the answer correctness. the manual judgment of candidate answer sentences is provided for the entire trec 13 set and for a part of questions from trec 8-12. train-all is another training set with much larger number of questions. the correctness of candidate answer sentences in train-all is identified by matching answer sentences with answer pattern regular expressions provided by trec. this data set is more noisy, however it provides many more qa pairs for model training. there is a dev set for hyper-parameter optimization and test set for model testing. we use the same train/ dev/ test partition in our experiments to directly compare our results with previous works. for data preprocess, we perform tokenization without stemming. we maintain stop words during the model training stage. word embeddings. we obtain pre-trained word embeddings with the word2vec tool by mikolov et al. with the english wikipedia dump. we use the skip-gram model with window size and filter words with frequency less than following the common practice in many neural embedding models. for the word vector dimension, we tune it as a hyper-parameter on the validation data starting from to. embeddings for words not present are randomly initialized with sampled numbers from uniform distribution u [- 0.25, 0.25], which follows the same setting as. model hyper-parameters. for the setting of hyper-parameters, we set the number of bins as, word embedding dimension as for annm-1, the number of bins as, word embedding dimension as for annm-2 after we tune hyper-parameters on the provided dev set of trec qa data. subsection: evaluation and metrics for evaluation, we rank answer sentences with the predicted score of each method and compare the rank list with the ground truth to compute metrics. we choose mean average precision (map) and mean reciprocal rank (mrr), which are commonly used in information retrieval and question answering, as the metric to evaluate our model. the definition of mrr is as follows: where is the position of the first correct answer in the rank list. thus mrr is only based on the rank of the first correct answer. it is more suitable for the cases where the rank of the first correct answer is emphasized or each question only have one correct answer. on the other hand, map looks at the ranks of all correct answers. it is computed as following: where is the average precision for each query. thus map is the average performance on all correct answers. we use the official scripts for computing these metrics. subsection: model learning results in this section, we give some qualitative analysis and visualization of our model learning results. specifically, we analyze the learned value-shard weights and question term importance by anmm. subsubsection: value-shared weight we take the learned value-shared weights of anmm-1 as the example. figure [reference] shows the learned value-shared weights by anmm-1. in anmm-1, for each qa matching vector, there is only one bin node. thus the learned value-shared weights for anmm-1 is a one dimension vector. for anmm-1, we set the number of bins as as presented in section [reference]. note that the x-axis is the index of bin range and the y-axis is the value-shared weights corresponding to each bin range. the range of match signals is [- 1, 1] from the left to the right. we make the following observations: (1) the exact match signal which is corresponding to in the last bin is tied with a very large weight, which shows that exact match information is very important. (2) for positive matching score from, which is corresponding to bin index, the learned value-shared weights are different for matching score range (bin index) and matching score range (bin index). we can observe many positive value-shared weights for matching score range and negative value-shared weights for matching score range. this makes sense since high semantic matching scores are positive indicators on answer correctness, whereas low semantic matching scores indicate that the candidate answer sentences contain irrelevant terms. (3) for negative matching scores from, we can see there is not a lot of differences between value-shared weights for different ranges. a major reason is that most similarity scores based on word embeddings are positive. therefore, we can remove bins corresponding to negative matching scores to reduce the dimension of value-shared weight vectors, which can help improve the efficiency of the model training process. we will show more quantitative results on the comparison between value-shared weights and position-shared weights in cnn in section [reference]. subsubsection: question term importance next we analyze the learned question term importance of our model. due to the space limit, we also use the learned question term importance of anmm-1 as an example. table [reference] shows the examples of learned question term importance by anmm-1. we also visualize the question term importance in figure [reference]. based on the results in the table and the figure, we can clearly see that anmm-1 learns reasonable term importance. for instance, with the question attention network, anmm-1 discovers important terms like\" khmer\",\" rouge\",\" power\" as for the question\" when did the khmer rouge come into power?\". terms like\" age\",\" rossinin\",\" stop\",\" writing\",\"opera\" are highlighted for the question\" at what age did rossini stop writing opera?\". for the question\" where was the first burger king restaurant opened?\" mentioned in section [reference],\" burger\",\" king\",\" opened\" are treated as important question terms. an interesting question is how the learned term importance compare with traditional ir term weighting methods such as idf. we design an experiment to compare anmm-1/ anmm-2 with anmm-idf, which is a degenerate version of our model where we use idf to directly replace the output of question attention network. in this case, in equation [reference] is replaced by the idf of the j-th question term. table [reference] shows the results. we find that if we replace the output of question attention network of anmm with idf, it will decrease the answer ranking performance, especially on train data. thus, we can see that with the optimization process in the back propagation training process, anmm can learn better question term weighting score than heuristic term weighting functions like idf. subsection: experimental results for ranking answers subsubsection: learning without combining additional features our first experimental setting is ranking answer sentences directly by the predicted score from anmm without combining any additional features. this will enable us to answer rq1 proposed in section [reference]. table [reference] shows the results of trec qa on train and train-all without combining additional features. in this table, we compare the results of anmm with other previous deep learning methods including cnn and lstm. we summarize our observations as follows: (1) both anmm-1 and anmm-2 show significant improvements for map and mrr on train and train-all data sets comparing with previous deep learning methods. specifically, if we compare the results of anmm-1 with the strongest deep learning baseline method by severyn et al. based on cnn, we can see anmm-1 outperform cnn for% in map on train,% in map on train-all. for mrr, we can also observe similar significant improvements of anmm-1. these results show that with the value-shared weight scheme instead of the position-shared weight scheme in cnn and term importance learning with question attention network, anmm can predict ranking scores with much higher accuracy comparing with previous deep learning models for ranking answers. (2) if we compare the results of anmm-1 and anmm-2, we can see their results are very close. anmm-1 has slightly better performance than anmm-2. this result indicates that adding one more hidden layer to incorporate multiple bin nodes does not necessarily increase the performance for answer ranking in trec qa data. from the perspective of model efficiency, anmm-1 could be a better choice since it can be trained much faster with good prediction accuracy. however, for larger training data sets than trec qa data, anmm-2 could have better performance since it has more model parameters and is suitable for fitting larger training data set. we leave the study of impact of the number of hidden layers in anmm to future work. table [reference] shows the comparison between anmm with previous methods using feature engineering on train-all without combining additional features. we find that both anmm-1 and anmm-2 achieve better performance comparing with other methods using feature engineering. specifically, comparing the results of anmm-1 with the strongest baseline by yih et al. based on enhanced lexical semantic models, anmm-1 achieves% gain for map and% gain for mrr. these results show that it is possible to build a uniform deep learning model such that it can achieve better performance than methods using feature engineering. to the best of our knowledge, anmm is the first deep learning model that can achieve good performance comparing with previous methods either based on deep learning models or feature engineering for ranking answers without any additional features, syntactic parsers and external resources except for pre-trained word embeddings. subsubsection: learning with combining additional features our second experimental setting is to address rq2 proposed in section [reference], where we ask whether our model can outperform the state-of-the-art performance achieved by cnn and lstm for answer ranking when combining additional features. we combine the predicted score from anmm-1 and anmm-2 with the query likelihood (ql) score using lambdamart following a similar approach to. we use the implementation of lambdamart in jforests we compare the results with previous deep learning models with additional features. table [reference] shows the results on train and train-all when combining additional features. we can see that with combined features, both anmm-1 and anmm-2 have better performance. anmm-1 also outperforms cnn by severyn et al. which is the current state-of-the-art method for ranking answers in terms of both map and mrr on train and train-all. we also tried to combine anmm score with other additional features such as word overlap features, idf weighted word overlap features and bm25 as in previous research. the results were either similar or worse than combining anmm score with ql. for anmm, the gains after combining additional features are not as large as neural network models like cnn in and lstm in. we think the reasons for this are two-fold: (1) the qa matching matrix in anmm model can capture exact match information by assigning to matrix elements if the corresponding answer term and question term are the same. this exact match information include match between numbers and proper nouns, which are highlighted in previous research work as especially important for factoid questions answering, where most of the questions are of type what, when, who that are looking for answers containing numbers or proper nouns. within anmm architecture, this problem has already been handled with qa matching matrix. thus incorporating word overlap features will not help much for improving the performance of anmm. (2) in addition to exact match information, anmm could also learn question term importance like idf information through question attention network. instead of empirically designing heuristic functions like idf, anmm can get learning based question term importance score. as analyzed in section [reference], with the optimization process in the back propagation training process, anmm can learn similar or even better term weighting score than idf. thus combining anmm score with features like idf weighted word overlap features and bm25 may not increase the performance of anmm by a large margin as the case in related research works. subsubsection: results summary [b] 0.48 [b] 0.48 finally we summarize the results of previously published systems on the qa answer ranking task in table [reference]. we can see anmm trained with train-all set beats all the previous state-of-the art systems including both methods using feature engineering and deep learning models. these results are very promising since anmm requires no manual feature engineering, no expensive processing by various nlp parsers and no external results like large scale knowledge base except for pre-trained word embeddings. furthermore, even without combining additional features, anmm still performs well for answer ranking, showing significant improvements over previous deep learning model with no additional features and linguistic feature engineering methods. subsection: parameter sensitivity analysis we perform parameter sensitivity analysis of our proposed model anmm. we focus on anmm-1 as the example due to the space limitation. for anmm-1, we fix the number of bins as and change the dimension of word vectors. similarly, we fix the dimension of word vectors as and vary the number of bins. figure [reference] shows the change of map and mrr on the validation data as we vary the hyper-parameters. we summarize our observations as follows: (1) for word vector dimension, the range is a good choice as much lower or higher word vector dimensions will hurt the performance. the choice of word vector dimension also depends on the size of training corpus. larger corpus requires higher dimension of word vectors to embed terms in vocabulary. (2) for the number of bins, we can see that map and mrr will decrease as the bin number increase. too many bins will increase the model complexity, which leads anmm to be more likely to overfit the training data. thus choosing suitable number of bins by optimizing hyper-parameter on validation data can help improve the performance of anmm. section: conclusions and future work in this paper, we propose an attention based neural matching model for ranking short answer text. we adopt value-shared weighting scheme instead of position-shared weighting scheme for combing different matching signals and incorporate question term importance learning using a question attention network. we perform a thorough experimental study with the trec qa dataset from trec qa tracks 8-13 and show promising results. unlike previous methods including cnn as in and lstm as in, which only show inferior results without combining additional features, our model can achieve better performance than the state-of-art method using linguistic feature engineering without additional features. with a simple additional feature, our method can achieve the new state-of-the-art performance among current existing methods. for further work, we will study other deep learning architectures for answer ranking and extend our work to include non-factoid question answering data sets. section: acknowledgments this work was supported in part by the center for intelligent information retrieval, in part by nsf iis-1160894, and in part by nsf grant# iis-1419693. any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect those of the sponsor. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "trec qa"
                    ],
                    [
                        "trec qa data"
                    ],
                    [
                        "trec qa dataset"
                    ],
                    [
                        "trec 13 set"
                    ],
                    [
                        "english wikipedia dump"
                    ],
                    [
                        "trec qa data"
                    ]
                ],
                "Method": [
                    [
                        "anmm"
                    ],
                    [
                        "attention based neural matching"
                    ],
                    [
                        "attention based neural matching model"
                    ],
                    [
                        "lstms"
                    ],
                    [
                        "attention based neural matching model"
                    ],
                    [
                        "anmm-1"
                    ],
                    [
                        "question attention network"
                    ]
                ],
                "Metric": [
                    [
                        "mean average precision"
                    ],
                    [
                        "mrr"
                    ]
                ],
                "Task": [
                    [
                        "short answer texts"
                    ],
                    [
                        "ranking short answer text"
                    ],
                    [
                        "question answering task"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "trec qa dataset",
                        "trec qa"
                    ]
                ],
                "Method": [
                    [
                        "attention-based neural matching model",
                        "attention based neural matching model",
                        "anmm"
                    ]
                ],
                "Metric": [
                    [
                        "map"
                    ]
                ],
                "Task": [
                    [
                        "question answering\u00a1",
                        "ranking systems question answering",
                        "question answering",
                        "qa",
                        "question/ answer matching",
                        "question/ answer matching problem",
                        "factoid question answering",
                        "factoid questions answering",
                        "non-factoid question answering"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "trec qa dataset",
                        "trec qa"
                    ]
                ],
                "Method": [
                    [
                        "attention-based neural matching model",
                        "attention based neural matching model",
                        "anmm"
                    ]
                ],
                "Metric": [
                    [
                        "mean average precision",
                        "mean reciprocal rank",
                        "mrr"
                    ]
                ],
                "Task": [
                    [
                        "question answering\u00a1",
                        "ranking systems question answering",
                        "question answering",
                        "qa",
                        "question/ answer matching",
                        "question/ answer matching problem",
                        "factoid question answering",
                        "factoid questions answering",
                        "non-factoid question answering"
                    ]
                ]
            }
        ]
    },
    "3842ee1e0fdfeff936b5c49973ff21adfaaf3929-52": {
        "doctext": "document: adversarial discriminative domain adaptation adversarial learning methods are a promising approach to training robust deep networks, and can generate complex samples across diverse domains. they also can improve recognition despite the presence of domain shift or dataset bias: several adversarial approaches to unsupervised domain adaptation have recently been introduced, which reduce the difference between the training and test domain distributions and thus improve generalization performance. prior generative approaches show compelling visualizations, but are not optimal on discriminative tasks and can be limited to smaller shifts. prior discriminative approaches could handle larger domain shifts, but imposed tied weights on the model and did not exploit a gan-based loss. we first outline a novel generalized framework for adversarial adaptation, which subsumes recent state-of-the-art approaches as special cases, and we use this generalized view to better relate the prior approaches. we propose a previously unexplored instance of our general framework which combines discriminative modeling, untied weight sharing, and a gan loss, which we call adversarial discriminative domain adaptation (adda). we show that adda is more effective yet considerably simpler than competing domain-adversarial methods, and demonstrate the promise of our approach by exceeding state-of-the-art unsupervised adaptation results on standard cross-domain digit classification tasks and a new more difficult cross-modality object classification task. section: introduction deep convolutional networks, when trained on large-scale datasets, can learn representations which are generically usefull across a variety of tasks and visual domains. however, due to a phenomenon known as dataset bias or domain shift, recognition models trained along with these representations on one large dataset do not generalize well to novel datasets and tasks. the typical solution is to further fine-tune these networks on task-specific datasets\u2014 however, it is often prohibitively difficult and expensive to obtain enough labeled data to properly fine-tune the large number of parameters employed by deep multilayer networks. domain adaptation methods attempt to mitigate the harmful effects of domain shift. recent domain adaptation methods learn deep neural transformations that map both domains into a common feature space. this is generally achieved by optimizing the representation to minimize some measure of domain shift such as maximum mean discrepancy or correlation distances. an alternative is to reconstruct the target domain from the source representation. adversarial adaptation methods have become an increasingly popular incarnation of this type of approach which seeks to minimize an approximate domain discrepancy distance through an adversarial objective with respect to a domain discriminator. these methods are closely related to generative adversarial learning, which pits two networks against each other\u2014 a generator and a discriminator. the generator is trained to produce images in a way that confuses the discriminator, which in turn tries to distinguish them from real image examples. in domain adaptation, this principle has been employed to ensure that the network can not distinguish between the distributions of its training and test domain examples. however, each algorithm makes different design choices such as whether to use a generator, which loss function to employ, or whether to share weights across domains. for example, share weights and learn a symmetric mapping of both source and target images to the shared feature space, while decouple some layers thus learning a partially asymmetric mapping. in this work, we propose a novel unified framework for adversarial domain adaptation, allowing us to effectively examine the different factors of variation between the existing approaches and clearly view the similarities they each share. our framework unifies design choices such as weight-sharing, base models, and adversarial losses and subsumes previous work, while also facilitating the design of novel instantiations that improve upon existing ones. in particular, we observe that generative modeling of input image distributions is not necessary, as the ultimate task is to learn a discriminative representation. on the other hand, asymmetric mappings can better model the difference in low level features than symmetric ones. we therefore propose a previously unexplored unsupervised adversarial adaptation method, adversarial discriminative domain adaptation (adda), illustrated in figure [reference]. adda first learns a discriminative representation using the labels in the source domain and then a separate encoding that maps the target data to the same space using an asymmetric mapping learned through a domain-adversarial loss. our approach is simple yet surprisingly powerful and achieves state-of-the-art visual adaptation results on the mnist, usps, and svhn digits datasets. we also test its potential to bridge the gap between even more difficult cross-modality shifts, without requiring instance constraints, by transferring object classifiers from rgb color images to depth observations. section: related work there has been extensive prior work on domain transfer learning, see e.g.,. recent work has focused on transferring deep neural network representations from a labeled source datasets to a target domain where labeled data is sparse or non-existent. in the case of unlabeled target domains (the focus of this paper) the main strategy has been to guide feature learning by minimizing the difference between the source and target feature distributions. several methods have used the maximum mean discrepancy (mmd) loss for this purpose. mmd computes the norm of the difference between two domain means. the ddc method used mmd in addition to the regular classification loss on the source to learn a representation that is both discriminative and domain invariant. the deep adaptation network (dan) applied mmd to layers embedded in a reproducing kernel hilbert space, effectively matching higher order statistics of the two distributions. in contrast, the deep correlation alignment (coral) method proposed to match the mean and covariance of the two distributions. other methods have chosen an adversarial loss to minimize domain shift, learning a representation that is simultaneously discriminative of source labels while not being able to distinguish between domains. proposed adding a domain classifier (a single fully connected layer) that predicts the binary domain label of the inputs and designed a domain confusion loss to encourage its prediction to be as close as possible to a uniform distribution over binary labels. the gradient reversal algorithm (reversegrad) proposed in also treats domain invariance as a binary classification problem, but directly maximizes the loss of the domain classifier by reversing its gradients. drcn takes a similar approach but also learns to reconstruct target domain images. in related work, adversarial learning has been explored for generative tasks. the generative adversarial network (gan) method is a generative deep model that pits two networks against one another: a generative model g that captures the data distribution and a discriminative model d that distinguishes between samples drawn from g and images drawn from the training data by predicting a binary label. the networks are trained jointly using backprop on the label prediction loss in a mini-max fashion: simultaneously update g to minimize the loss while also updating d to maximize the loss (fooling the discriminator). the advantage of gan over other generative methods is that there is no need for complex sampling or inference during training; the downside is that it may be difficult to train. gans have been applied to generate natural images of objects, such as digits and faces, and have been extended in several ways. the bigan approach extends gans to also learn the inverse mapping from the image data back into the latent space, and shows that this can learn features useful for image classification tasks. the conditional generative adversarial net (cgan) is an extension of the gan where both networks g and d receive an additional vector of information as input. this might contain, say, information about the class of the training example. the authors apply cgan to generate a (possibly multi-modal) distribution of tag-vectors conditional on image features. recently the cogan approach applied gans to the domain transfer problem by training two gans to generate the source and target images respectively. the approach achieves a domain invariant feature space by tying the high-level layer parameters of the two gans, and shows that the same noise input can generate a corresponding pair of images from the two distributions. domain adaptation was performed by training a classifier on the discriminator output and applied to shifts between the mnist and usps digit datasets. however, this approach relies on the generators finding a mapping from the shared high-level layer feature space to full images in both domains. this can work well for say digits which can be difficult in the case of more distinct domains. in this paper, we observe that modeling the image distributions is not strictly necessary to achieve domain adaptation, as long as the latent feature space is domain invariant, and propose a discriminative approach. section: generalized adversarial adaptation we present a general framework for adversarial unsupervised adaptation methods. in unsupervised adaptation, we assume access to source images and labels drawn from a source domain distribution, as well as target images drawn from a target distribution, where there are no label observations. our goal is to learn a target representation, and classifier that can correctly classify target images into one of categories at test time, despite the lack of in domain annotations. since direct supervised learning on the target is not possible, domain adaptation instead learns a source representation mapping,, along with a source classifier,, and then learns to adapt that model for use in the target domain. in adversarial adaptive methods, the main goal is to regularize the learning of the source and target mappings, and, so as to minimize the distance between the empirical source and target mapping distributions: and. if this is the case then the source classification model,, can be directly applied to the target representations, elimating the need to learn a separate target classifier and instead setting,. the source classification model is then trained using the standard supervised loss below: we are now able to describe our full general framework view of adversarial adaptation approaches. we note that all approaches minimize source and target representation distances through alternating minimization between two functions. first a domain discriminator,, which classifies whether a data point is drawn from the source or the target domain. thus, is optimized according to a standard supervised loss, where the labels indicate the origin domain, defined below: second, the source and target mappings are optimized according to a constrained adversarial objective, whose particular instantiation may vary across methods. thus, we can derive a generic formulation for domain adversarial techniques below: in the next sections, we demonstrate the value of our framework by positioning recent domain adversarial approaches within our framework. we describe the potential mapping structure, mapping optimization constraints () choices and finally choices of adversarial mapping loss,. subsection: source and target mappings in the case of learning a source mapping alone it is clear that supervised training through a latent space discriminative loss using the known labels results in the best representation for final source recognition. however, given that our target domain is unlabeled, it remains an open question how best to minimize the distance between the source and target mappings. thus the first choice to be made is in the particular parameterization of these mappings. because unsupervised domain adaptation generally considers target discriminative tasks such as classification, previous adaptation methods have generally relied on adapting discriminative models between domains. with a discriminative base model, input images are mapped into a feature space that is useful for a discriminative task such as image classification. for example, in the case of digit classification this may be the standard lenet model. however, liu and tuzel achieve state of the art results on unsupervised mnist-usps using two generative adversarial networks. these generative models use random noise as input to generate samples in image space\u2014 generally, an intermediate feature of an adversarial discriminator is then used as a feature for training a task-specific classifier. once the mapping parameterization is determined for the source, we must decide how to parametrize the target mapping. in general, the target mapping almost always matches the source in terms of the specific functional layer (architecture), but different methods have proposed various regularization techniques. all methods initialize the target mapping parameters with the source, but different methods choose different constraints between the source and target mappings,. the goal is to make sure that the target mapping is set so as to minimize the distance between the source and target domains under their respective mappings, while crucially also maintaining a target mapping that is category discriminative. consider a layered representations where each layer parameters are denoted as, or, for a given set of equivalent layers,. then the space of constraints explored in the literature can be described through layerwise equality constraints as follows: where each individual layer can be constrained independently. a very common form of constraint is source and target layerwise equality: it is also common to leave layers unconstrained. these equality constraints can easily be imposed within a convolutional network framework through weight sharing. for many prior adversarial adaptation methods, all layers are constrained, thus enforcing exact source and target mapping consistency. learning a symmetric transformation reduces the number of parameters in the model and ensures that the mapping used for the target is discriminative at least when applied to the source domain. however, this may make the optimization poorly conditioned, since the same network must handle images from two separate domains. an alternative approach is instead to learn an asymmetric transformation with only a subset of the layers constrained, thus enforcing partial alignment. rozantsev et al. showed that partially shared weights can lead to effective adaptation in both supervised and unsupervised settings. as a result, some recent methods have favored untying weights (fully or partially) between the two domains, allowing models to learn parameters for each domain individually. subsection: adversarial losses once we have decided on a parametrization of, we employ an adversarial loss to learn the actual mapping. there are various different possible choices of adversarial loss functions, each of which have their own unique use cases. all adversarial losses train the adversarial discriminator using a standard classification loss,, previously stated in equation [reference]. however, they differ in the loss used to train the mapping,. the gradient reversal layer of optimizes the mapping to maximize the discriminator loss directly: this optimization corresponds to the true minimax objective for generative adversarial networks. however, this objective can be problematic, since early on during training the discriminator converges quickly, causing the gradient to vanish. when training gans, rather than directly using the minimax loss, it is typical to train the generator with the standard loss function with inverted labels. this splits the optimization into two independent objectives, one for the generator and one for the discriminator, where remains unchanged, but becomes: this objective has the same fixed-point properties as the minimax loss but provides stronger gradients to the target mapping. we refer to this modified loss function as the\" gan loss function\" for the remainder of this paper. note that, in this setting, we use independent mappings for source and target and learn only adversarially. this mimics the gan setting, where the real image distribution remains fixed, and the generating distribution is learned to match it. the gan loss function is the standard choice in the setting where the generator is attempting to mimic another unchanging distribution. however, in the setting where both distributions are changing, this objective will lead to oscillation\u2014 when the mapping converges to its optimum, the discriminator can simply flip the sign of its prediction in response. tzeng et al. instead proposed the domain confusion objective, under which the mapping is trained using a cross-entropy loss function against a uniform distribution: this loss ensures that the adversarial discriminator views the two domains identically. section: adversarial discriminative domain adaptation the benefit of our generalized framework for domain adversarial methods is that it directly enables the development of novel adaptive methods. in fact, designing a new method has now been simplified to the space of making three design choices: whether to use a generative or discriminative base model, whether to tie or untie the weights, and which adversarial learning objective to use. in light of this view we can summarize our method, adversarial discriminative domain adaptation (adda), as well as its connection to prior work, according to our choices (see table [reference]\" adda\"). specifically, we use a discriminative base model, unshared weights, and the standard gan loss. we illustrate our overall sequential training procedure in figure [reference]. first, we choose a discriminative base model, as we hypothesize that much of the parameters required to generate convincing in-domain samples are irrelevant for discriminative adaptation tasks. most prior adversarial adaptive methods optimize directly in a discriminative space for this reason. one counter-example is cogans. however, this method has only shown dominance in settings where the source and target domain are very similar such as mnist and usps, and in our experiments we have had difficulty getting it to converge for larger distribution shifts. next, we choose to allow independent source and target mappings by untying the weights. this is a more flexible learing paradigm as it allows more domain specific feature extraction to be learned. however, note that the target domain has no label access, and thus without weight sharing a target model may quickly learn a degenerate solution if we do not take care with proper initialization and training procedures. therefore, we use the pre-trained source model as an intitialization for the target representation space and fix the source model during adversarial training. in doing so, we are effectively learning an asymmetric mapping, in which we modify the target model so as to match the source distribution. this is most similar to the original generative adversarial learning setting, where a generated space is updated until it is indistinguishable with a fixed real space. therefore, we choose the inverted label gan loss described in the previous section. our proposed method, adda, thus corresponds to the following unconstrained optimization: we choose to optimize this objective in stages. we begin by optimizing over and by training using the labeled source data, and. because we have opted to leave fixed while learning, we can thus optimize and without revisiting the first objective term. a summary of this entire training process is provided in figure [reference]. we note that the unified framework presented in the previous section has enabled us to compare prior domain adversarial methods and make informed decisions about the different factors of variation. through this framework we are able to motivate a novel domain adaptation method, adda, and offer insight into our design decisions. in the next section we demonstrate promising results on unsupervised adaptation benchmark tasks, studying adaptation across digits and across modalities. section: experiments we now evaluate adda for unsupervised classification adaptation across four different domain shifts. we explore three digits datasets of varying difficulty: mnist, usps, and svhn. we additionally evaluate on the nyud dataset to study adaptation across modalities. example images from all experimental datasets are provided in figure [reference]. for the case of digit adaptation, we compare against multiple state-of-the-art unsupervised adaptation methods, all based upon domain adversarial learning objectives. in 3 of 4 of our experimental setups, our method outperforms all competing approaches, and in the last domain shift studied, our approach outperforms all but one competing approach. we also validate our model on a real-world modality adaptation task using the nyu depth dataset. despite a large domain shift between the rgb and depth modalities, adda learns a useful depth representation without any labeled depth data and improves over the nonadaptive baseline by over 50% (relative). subsection: mnist, usps, and svhn digits datasets we experimentally validate our proposed method in an unsupervised adaptation task between the mnist, usps, and svhn digits datasets, which consist 10 classes of digits. example images from each dataset are visualized in figure [reference] and table [reference]. for adaptation between mnist and usps, we follow the training protocol established in, sampling 2000 images from mnist and 1800 from usps. for adaptation between svhn and mnist, we use the full training sets for comparison against. all experiments are performed in the unsupervised settings, where labels in the target domain are withheld, and we consider adaptation in three directions: mnist usps, usps mnist, and svhn mnist. for these experiments, we use the simple modified lenet architecture provided in the caffe source code. when training with adda, our adversarial discriminator consists of 3 fully connected layers: two layers with 500 hidden units followed by the final discriminator output. each of the 500-unit layers uses a relu activation function. results of our experiment are provided in table [reference]. on the easier mnist and usps shifts adda achieves comparable performance to the current state-of-the-art, cogans, despite being a considerably simpler model. this provides compelling evidence that the machinery required to generate images is largely irrelevant to enabling effective adaptation. additionally, we show convincing results on the challenging svhn and mnist task in comparison to other methods, indicating that our method has the potential to generalize to a variety of settings. in contrast, we were unable to get cogans to converge on svhn and mnist\u2014 because the domains are so disparate, we were unable to train coupled generators for them. subsection: modality adaptation bathtub bed bookshelf box chair counter desk door dresser garbage bin lamp monitor night stand pillow sink sofa table television toilet overall we use the nyu depth dataset, which contains bounding box annotations for 19 object classes in 1449 images from indoor scenes. the dataset is split into a train (381 images), val (414 images) and test (654) sets. to perform our cross-modality adaptation, we first crop out tight bounding boxes around instances of these 19 classes present in the dataset and evaluate on a 19-way classification task over object crops. in order to ensure that the same instance is not seen in both domains, we use the rgb images from the train split as the source domain and the depth images from the val split as the target domain. this corresponds to 2, 186 labeled source images and 2, 401 unlabeled target images. figure [reference] visualizes samples from each of the two domains. we consider the task of adaptation between these rgb and hha encoded depth images, using them as source and target domains respectively. because the bounding boxes are tight and relatively low resolution, accurate classification is quite difficult, even when evaluating in-domain. in addition, the dataset has very few examples for certain classes, such as toilet and bathtub, which directly translates to reduced classification performance. for this experiment, our base architecture is the vgg-16 architecture, initializing from weights pretrained on imagenet. this network is then fully fine-tuned on the source domain for 20, 000 iterations using a batch size of 128. when training with adda, the adversarial discriminator consists of three additional fully connected layers: 1024 hidden units, 2048 hidden units, then the adversarial discriminator output. with the exception of the output, these additionally fully connected layers use a relu activation function. adda training then proceeds for another 20, 000 iterations, again with a batch size of 128. we find that our method, adda, greatly improves classification accuracy for this task. for certain categories, like counter, classification accuracy goes from 2.9% under the source only baseline up to 44.7% after adaptation. in general, average accuracy across all classes improves significantly from 13.9% to 21.1%. however, not all classes improve. three classes have no correctly labeled target images before adaptation, and adaptation is unable to recover performance on these classes. additionally, the classes of pillow and nightstand suffer performance loss after adaptation. for additional insight on what effect adda has on classification, figure [reference] plots confusion matrices before adaptation, after adaptation, and in the hypothetical best-case scenario where the target labels are present. examining the confusion matrix for the source only baseline reveals that the domain shift is quite large\u2014 as a result, the network is poorly conditioned and incorrectly predicts pillow for the majority of the dataset. this tendency to output pillow also explains why the source only model achieves such abnormally high accuracy on the pillow class, despite poor performance on the rest of the classes. in contrast, the classifier trained using adda predicts a much wider variety of classes. this leads to decreased accuracy for the pillow class, but significantly higher accuracies for many of the other classes. additionally, comparison with the\" train on target\" model reveals that many of the mistakes the adda model makes are reasonable, such as confusion between the chair and table classes, indicating that the adda model is learning a useful representation on depth images. section: conclusion we have proposed a unified framework for unsupervised domain adaptation techniques based on adversarial learning objectives. our framework provides a simplified and cohesive view by which we may understand and connect the similarities and differences between recently proposed adaptation methods. through this comparison, we are able to understand the benefits and key ideas from each approach and to combine these strategies into a new adaptation method, adda. we present evaluation across four domain shifts for our unsupervised adaptation approach. our method generalizes well across a variety of tasks, achieving strong results on benchmark adaptation datasets as well as a challenging cross-modality adaptation task. additional analysis indicates that the representations learned via adda resemble features learned with supervisory data in the target domain much more closely than unadapted features, providing further evidence that adda is effective at partially undoing the effects of domain shift. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "svhn"
                    ]
                ],
                "Method": [
                    [
                        "adversarial discriminative domain adaptation"
                    ],
                    [
                        "adda"
                    ]
                ],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "svhn and mnist",
                        "svhn mnist"
                    ]
                ],
                "Method": [
                    [
                        "adversarial discriminative domain adaptation",
                        "adda",
                        "adversarial adaptation methods",
                        "adversarial unsupervised adaptation methods"
                    ]
                ],
                "Metric": [
                    [
                        "classification performance",
                        "classification accuracy",
                        "accuracy",
                        "accuracies"
                    ]
                ],
                "Task": [
                    [
                        "unsupervised adaptation"
                    ]
                ]
            }
        ]
    },
    "38cc89399dd6f5aaab1654f27ab3c9eeade12a36-53": {
        "doctext": "document: exploiting temporal information for 3d human pose estimation in this work, we address the problem of 3d human pose estimation from a sequence of 2d human poses. although the recent success of deep networks has led many state-of-the-art methods for 3d pose estimation to train deep networks end-to-end to predict from images directly, the top-performing approaches have shown the effectiveness of dividing the task of 3d pose estimation into two steps: using a state-of-the-art 2d pose estimator to estimate the 2d pose from images and then mapping them into 3d space. they also showed that a low-dimensional representation like 2d locations of a set of joints can be discriminative enough to estimate 3d pose with high accuracy. however, estimation of 3d pose for individual frames leads to temporally incoherent estimates due to independent error in each frame causing jitter. therefore, in this work we utilize the temporal information across a sequence of 2d joint locations to estimate a sequence of 3d poses. we designed a sequence-to-sequence network composed of layer-normalized lstm units with shortcut connections connecting the input to the output on the decoder side and imposed temporal smoothness constraint during training. we found that the knowledge of temporal consistency improves the best reported result on human3.6 m dataset by approximately and helps our network to recover temporally consistent 3d poses over a sequence of images even when the 2d pose detector fails. section: introduction the task of estimating 3d human pose from 2d representations like monocular images or videos is an open research problem among the computer vision and graphics community for a long time. an understanding of human posture and limb articulation is important for high level computer vision tasks such as human action or activity recognition, sports analysis, augmented and virtual reality. a 2d representation of human pose, which is considered to be much easier to estimate, can be used for these tasks. however, 2d poses can be ambiguous because of occlusion and foreshortening. additionally poses that are totally different can appear to be similar in 2d because of the way they are projected as shown in figure [reference]. the depth information in 3d representation of human pose makes it free from such ambiguities and hence can improve performance for higher level tasks. moreover, 3d pose can be very useful in computer animation, where the articulated pose of a person in 3d can be used to accurately model human posture and movement. however, 3d pose estimation is an ill-posed problem because of the inherent ambiguity in back-projecting a 2d view of an object to the 3d space maintaining its structure. since the 3d pose of a person can be projected in an infinite number of ways on a 2d plane, the mapping from a 2d pose to 3d is not unique. moreover, obtaining a dataset for 3d pose is difficult and expensive. unlike the 2d pose datasets where the users can manually label the keypoints by mouse clicks, 3d pose datasets require a complicated laboratory setup with motion capture sensors and cameras. hence, there is a lack of motion capture datasets for images in-the-wild. over the years, different techniques have been used to address the problem of 3d pose estimation. earlier methods used to focus on extracting features, invariant to factors such as background scenes, lighting, and skin color from images and mapping them into 3d human pose. with the success of deep networks, recent methods tend to focus on training a deep convolutional neural network (cnn) end-to-end to estimate 3d poses from images directly. some approaches divided the 3d pose estimation task into first predicting the joint locations in 2d using 2d pose estimators and then back-projecting them to estimate the 3d joint locations. these results suggest the effectiveness of decoupling the task of 3d pose estimation where 2d pose estimator abstracts the complexities in the image. in this paper, we also adopt the decoupled approach to 3d pose estimation. however, predicting 3d pose for each frame individually can lead to jitter in videos because the errors in each frame are independent of each other. therefore, we designed a sequence-to-sequence network with shortcut connections on the decoder side that predicts a sequence of temporally consistent 3d poses given a sequence of 2d poses. each unit of our network is a long short-term memory (lstm) unit with layer normalization and recurrent dropout. we also imposed a temporal smoothness constraint on the predicted 3d poses during training to ensure that our predictions are smooth over a sequence. our network achieves the state-of-the-art result on the human3.6 m dataset improving the previous best result by approximately. we also obtained the lowest error for every action class in human3.6 m dataset. moreover, we observed that our network predicted meaningful 3d poses on youtube videos, even when the detections from the 2d pose detector were extremely noisy or meaningless. this shows the effectiveness of using temporal information. in short our contributions in this work are: designing an efficient sequence-to-sequence network that achieves the state-of-the-art results for every action class of human3.6 m dataset and can be trained very fast. exploiting the ability of sequence-to-sequence networks to take into account the events in the past, to predict temporally consistent 3d poses. effectively imposing temporal consistency constraint on the predicted 3d poses during training so that the errors in the predictions are distributed smoothly over the sequence. using only the previous frames to understand temporal context so that it can be deployed online and real-time. section: related work paragraph: representation of 3d pose both model-based and model-free representations of 3d human pose have been used in the past. the most common model-based representation is a skeleton defined by a kinematic tree of a set of joints, parameterized by the offset and rotational parameters of each joint relative to its parent. several 3d pose methods have used this representation. others model 3d pose as a sparse linear combination of an over-complete dictionary of basis poses. however, we have chosen a model-free representation of 3d pose, where a 3d pose is simply a set of 3d joint locations relative to the root node like several recent approaches. this representation is much simpler and low-dimensional. paragraph: estimating 3d pose from 2d joints lee and chen were the first to infer 3d joint locations from their 2d projections given the bone lengths using a binary decision tree where each branch corresponds to two possible states of a joint relative to its parent. jiang used the 2d joint locations to estimate a set of hypothesis 3d poses using taylor's algorithm and used them to query a large database of motion capture data to find the nearest neighbor. gupta et al. and chen and ramanan also used this idea of using the detected 2d pose to query a large database of exemplar poses to find the nearest nearest neighbor 3d pose. another common approach to estimating 3d joint locations given the 2d pose is to separate the camera pose variability from the intrinsic deformation of the human body, the latter of which is modeled by learning an over-complete dictionary of basis 3d poses from a large database of motion capture data. a valid 3d pose is defined by a sparse linear combination of the bases and by transforming the points using transformation matrix representing camera extrinsic parameters. moreno-nouguer used the pair-wise distance matrix of 2d joints to learn a distance matrix for 3d joints, which they found invariant up to a rigid similarity transform with the ground truth 3d and used multi-dimensional scaling (mds) with pose-priors to rule out the ambiguities. martinez et al. designed a fully connected network with shortcut connections every two linear layers to estimate 3d joint locations relative to the root node in the camera coordinate space. paragraph: deep network based methods with the success of deep networks, many have designed networks that can be trained end-to-end to predict 3d poses from images directly. li et al. and park et al. designed cnns to jointly predict 2d and 3d poses. mehta et al. and sun et al. used transfer learning to transfer the knowledge learned for 2d human pose estimation to the task of 3d pose estimation. pavlakos et al. extended the stacked-hourglass network originally designed to predict 2d heatmaps of each joint to make it predict 3d volumetric heatmaps. tome et al. also extended a 2d pose estimator called convolutional pose machine (cpm) to make it predict 3d pose. rogesz and schmid and varol et al. augmented the training data with synthetic images and trained cnns to predict 3d poses from real images. sun et al. designed a unified network that can regress both 2d and 3d poses at the same time given an image. hence during training time, in-the-wild images which do not have any ground truth 3d poses can be combined with the data with ground truth 3d poses. a similar idea of exploiting in-the-wild images to learn pose structure was used by fang et al.. they learned a pose grammar that encodes the possible human pose configurations. paragraph: using temporal information since estimating poses for each frame individually leads to incoherent and jittery predictions over a sequence, many approaches tried to exploit temporal information. andriluka et al. used tracking-by-detection to associate 2d poses detected in each frame individually and used them to retrieve 3d pose. tekin et al. used a cnn to first align bounding boxes of successive frames so that the person in the image is always at the center of the box and then extracted 3d hog features densely over the spatio-temporal volume from which they regress the 3d pose of the central frame. mehta et al. implemented a real-time system for 3d pose estimation that applies temporal filtering across 2d and 3d poses from previous frames to predict a temporally consistent 3d pose. lin et al. performed a multi-stage sequential refinement using lstms to predict 3d pose sequences using previously predicted 2d pose representations and 3d pose. we focus on predicting temporally consistent 3d poses by learning the temporal context of a sequence using a form of sequence-to-sequence network. unlike lin et al. our method does not need multiple stages of refinement. it is simpler and requires fewer parameters to train, leading to much improved performance. section: our approach paragraph: network design we designed a sequence-to-sequence network with lstm units and residual connections on the decoder side to predict a temporally coherent sequence of 3d poses given a sequence of 2d joint locations. figure [reference] shows the architecture of our network. the motivation behind using a sequence-to-sequence network comes from its application on the task of neural machine translation (nmt) by sutskever et al., where their model translates a sentence in one language to a sentence in another language e.g. english to french. in a language translation model, the input and output sentences can have different lengths. although our case is analogous to the nmt, the input and output sequences always have the same length while the input vectors to the encoder and decoder have different dimensions. the encoder side of our network takes a sequence of 2d poses and encodes them in a fixed size high dimensional vector in the hidden state of its final lstm unit. since the lstms are excellent in memorizing events and information from the past, the encoded vector stores the 2d pose information of all the frames. the initial state of the decoder is initialized by the final state of the encoder. a token is passed as initial input to the decoder, which in our case is a vector of ones, telling it to start decoding. given a 3d pose estimate at a time step each decoder unit predicts the 3d pose for next time step. note that the order of the input sequence is reversed as recommended by sutskever et al.. the shortcut connections on the decoder side cause each decoder unit to estimate the amount of perturbation in the 3d pose from the previous frame instead of having to estimate the actual 3d pose for each frame. as suggested by he et al., such a mapping is easier to learn for the network. we use layer normalization and recurrent dropout to regularize our network. ba et al. came up with the idea of layer normalization which estimates the normalization statistics (mean and standard deviation) from the summed inputs to the recurrent neurons of hidden layer on a single training example to regularize the rnn units. similarly, zaremba et al. proposed the idea of applying dropout only on the non-recurrent connections of the network with a certain probability while always keeping the recurrent connections intact because they are necessary for the recurrent units to remember the information from the past. paragraph: loss function given a sequence of 2d joint locations as input, our network predicts a sequence of 3d joint locations relative to the root node (central hip). we predict each 3d pose in the camera coordinate space instead of predicting them in an arbitrary global frame as suggested by martinez et al.. we impose a temporal smoothness constraint on the predicted 3d joint locations to ensure that the prediction of each joint in one frame does not differ too much from its previous frame. because the 2d pose detectors work on individual frames, even with the minimal movement of the subject in the image, the detections from successive frames may vary, particularly for the joints which move fast or are prone to occlusion. hence, we made an assumption that the subject does not move too much in successive frames given the frame rate is high enough. therefore, we added the l2 norm of the first order derivative on the 3d joint locations with respect to time to our loss function during training. this constraint helps us to estimate 3d poses reliably even when the 2d pose detector fails for a few frames within the temporal window without any post-processing. empirically we found that certain joints are more difficult to estimate accurately e.g. wrist, ankle, elbow compared to others. to address this issue, we partitioned the joints into three disjoint sets, and based on their contribution to overall error. we observed that the joints connected to the torso and the head e.g. hips, shoulders, neck are always predicted with high accuracy compared to those joints belonging to the limbs and therefore put them in the set. the joints of the limbs, especially the joints on the arms, are always more difficult to predict due to their high range of motion and occlusion. we put the knees and the ankles in the set and the elbow and wrist in. we multiply the derivatives of each set of joints with different scalar values based on their contribution to the overall error. therefore our loss function consists of the sum of two separate terms: mean squared error (mse) of different sequences of 3d joint locations; and the mean of the l2 norm of the first order derivative of sequences of 3d joint locations with respect to time, where the joints are divided into three disjoint sets. the mse over sequences, each of time-steps, of 3d joint locations is given by here, denotes the estimated 3d joint locations while denotes 3d ground truth. the mean of l2 norm of the first order derivative of sequences of 3d joint locations, each of length, with respect to time is given by in the above equation,, and denotes the predicted 3d locations of joints belonging to the sets, and respectively. the and are scalar hyper-parameters to control the significance of the derivatives of 3d locations of each of the three set of joints. a higher weight is assigned to the set of joints which are generally predicted with higher error. the overall loss function for our network is given as here and are scalar hyper-parameters regulating the importance of each of the two terms in the loss function. section: experimental evaluation paragraph: datasets and protocols we perform quantitative evaluation on the human 3.6 m dataset and on the humaneva dataset. human 3.6 m, to the best of our knowledge, is the largest publicly available dataset for human 3d pose estimation. the dataset contains 3.6 million images of 7 different professional actors performing 15 everyday activities like walking, eating, sitting, making a phone call. the dataset consists of 2d and 3d joint locations for each corresponding image. each video is captured using 4 different calibrated high resolution cameras. in addition to 2d and 3d pose ground truth, the dataset also provides ground truth for bounding boxes, the camera parameters, the body proportion of all the actors and high resolution body scans or meshes of each actor. humaneva, on the other hand, is a much smaller dataset. it has been largely used to benchmark previous work over the last decade. most of the methods report results on two different actions and on three actors. for qualitative evaluation, we used the some videos from youtube and the human3.6 m dataset. we follow the standard protocols of the human3.6 m dataset used in the literature. we used subjects 1, 5, 6, 7, and 8 for training, and subjects 9 and 11 for testing and the error is evaluated on the predicted 3d pose without any transformation. we refer this as protocol# 1. another common approach used by many to evaluate their methods is to align the predicted 3d pose with the ground truth using a similarity transformation (procrustes analysis). we refer this as protocol# 2. we use the average error per joint in millimeters between the estimated and the ground truth 3d pose relative to the root node as the error metric. for the humaneva dataset, we report results on each subject and action separately after performing rigid alignment with the ground truth data, following the protocol used by the previous methods. paragraph: 2d detections we fine-tuned a model of stacked-hourglass network, initially trained on the mpii dataset (a benchmark dataset for 2d pose estimation), on the images of the human3.6 m dataset to obtain 2d pose estimations for each image. we used the bounding box information provided with the dataset to first compute the center of the person in the image and then cropped a region across the person and resized it to. we fine-tuned the network for 250 iterations and used a batch size of 3 and a learning rate of. paragraph: baselines since many of the previous methods are based on single frame predictions, we used two baselines for comparison. to show that our method is much better than naive post processing, we applied a mean filter and a median filter on the 3d pose predictions of martinez et al.. we used a window size of 5 frames and a stride length of 1 to apply the filters. although non-rigid structure from motion (nrsfm) is one of the most general approaches for any 3d reconstruction problem from a sequence of 2d correspondences, we did not use it as a baseline because zhou et al. did not find nrsfm techniques to be effective for 3d human pose estimation. they found that the nrsfm techniques do not work well with slow camera motion. since the videos in the human3.6 m dataset are captured by stationary cameras, the subjects in the dataset do not rotate that much to provide alternative views for nrsfm algorithm to perform well. another reason is that human pose reconstruction is a specialized problem in which constraints from human body structure apply. paragraph: data pre-processing we normalized the 3d ground truth poses, the noisy 2d pose estimates from stacked-hourglass network and the 2d ground truth by subtracting the mean and dividing by standard deviation. we do not predict the 3d location of the root joint i.e. central hip joint and hence zero center the 3d joint locations relative to the global position of the root node. to obtain the ground truth 3d poses in camera coordinate space, an inverse rigid body transformation is applied on the the ground truth 3d poses in global coordinate space using the given camera parameters. to generate both training and test sequences, we translated a sliding window of length by one frame. hence there is an overlap between the sequences. this gives us more data to train on, which is always an advantage for deep learning systems. during test time, we initially predict the first frames of the sequence and slide the window by a stride length of 1 to predict the next frame using the previous frames. paragraph: training details we trained our network for 100 epochs, where each epoch makes a complete pass over the entire human 3.6 m dataset. we used the adam optimizer for training the network with a learning rate of which is decayed exponentially per iteration. the weights of the lstm units are initialized by xavier uniform initializer. we used a mini-batch batch size of 32 i.e. 32 sequences. for most of our experiments we used a sequence length of 5, because it allows faster training with high accuracy. we experimented with different sequence lengths and found sequence length 4, 5 and 6 to generally give better results, which we will discuss in detail in the results section. we trained a single model for all the action classes. our code is implemented in tensorflow. we perform cross-validation on the training set to select the hyper-parameter values and of our loss function to and respectively. similarly, using cross-validation, the three hyper-parameters of the temporal consistency constraint and, are set to and respectively. a single training step for sequences of length 5 takes only 34 ms approximately, while a forward pass takes only about 16ms on nvidia titan x gpu. therefore given the 2d joint locations from a pose detector, our network takes about 3.2ms to predict 3d pose per frame. subsection: quantitative results paragraph: evaluation on estimated 2d pose as mentioned before, we used a sequence length of 5 to perform both qualitative and quantitative evaluation of our network. the results on human3.6 m dataset under protocol# 1 are shown in table [reference]. from the table we observe that our model achieves the lowest error for every action class under protocol# 1, unlike many of the previous state-of-the-art methods. note that we train a single model for all the action classes unlike many other methods which trained a model for each action class. our network significantly improves the state-of-the-art result of sun et al. by approximately (by mm). the results under protocol# 2, which aligns the predictions to the ground truth using a rigid body similarity transform before computing the error, is reported in table [reference]. our network improves the reported state-of-the-art results by (by mm) and achieves the lowest error for each action in protocol# 2 as well. from the results, we observe the effectiveness of exploiting temporal information across multiple sequences. by using the information of temporal context, our network reduced the overall error in estimating 3d joint locations, especially on actions like phone, photo, sit and sitting down on which most previous methods did not perform well due to heavy occlusion. we also observe that our method outperforms both the baselines by a large margin on both the protocols. this shows that our method learned the temporal context of the sequences and predicted temporally consistent 3d poses, which naive post-processing techniques like temporal mean and median filters over frame-wise prediction failed to do. like most previous methods, we report the results on action classes walking and jogging of the humaneva dataset in table [reference]. we obtained the lowest error in four of the six cases and the lowest average error for the two actions. we also obtained the second best result on subject 2 of action walking. however, humaneva is a smaller dataset than human3.6 m and the same subjects appear in both training and testing. paragraph: evaluation on 2d ground truth as suggested by martinez et al., we also found that the more accurate the 2d joint locations are, the better are the estimates for 3d pose. we trained our model on ground truth 2d poses for a sequence length of 5. the results under protocol# 1 are reported in table [reference]. as seen from the table, our model improves the lower bound error of martinez et al. by almost. the results on ground truth 2d joint input for protocol# 2 are reported in table [reference]. when there is no noise in 2d joint locations, our network performs better than the models by martinez et al. and moreno-nouguer. these results suggest that the information of temporal consistency from previous frames is a valuable cue for the task of estimating 3d pose even when the detections are noise free. paragraph: robustness to noise we carried out some experiments to test the tolerance of our model to different levels of noise in the input data by training our network on 2d ground truth poses and testing on inputs corrupted by different levels of gaussian noise. table [reference] shows how our final model compares against the models by moreno-nouguer and martinez et al.. our network is significantly more robust than moreno-nouguer's model. when compared against martinez et al. our network performs better when the level of input noise is low i.e. standard deviation less than or equal to 10. however, for higher levels of noise our network performs slightly worse than martinez et al.. we would like to attribute the cause of this to the temporal smoothness constraint imposed during training which distributes the error of individual frames over the entire sequence. however, its usefulness can be observed in the qualitative results (see figure [reference] and figure [reference]). paragraph: ablative analysis to show the usefulness of each component and design decision of our network, we perform an ablative analysis. we follow protocol# 1 for performing ablative analysis and trained a single model for all the actions. the results are reported in table [reference]. we observe that the biggest improvement in result is due the the residual connections on the decoder side, which agrees with the hypothesis of he et al.. removing the residual connections massively increases the error by mm. when we do not apply layer normalization on lstm units, the error increases by mm. on the other hand when dropout is not performed, the error raises by mm. when both layer normalization and recurrent dropout are not used the results get worse by mm. although the temporal consistency constraint may seem to have less impact (only mm) quantitatively on the performance of our network, it ensures that the predictions over a sequence are smooth and temporally consistent which is apparent from our qualitative results as seen in figure [reference] and figure [reference]. to show the effectiveness of our model on detections from different 2d pose detectors, we also experimented with the detections from cpm and from stacked-hourglass (sh) module which is not fine-tuned on human3.6 m dataset. we observe that even for the non-fine tuned stacked hourglass detections, our model achieves the state-of-the-art results. for detections from cpm, our model achieves competitive accuracy for the predictions. paragraph: performance on different sequence lengths the results reported so far have been for input and output sequences of length 5. we carried out experiments to see how our network performs for different sequence lengths ranging from 2 to 10. the results are shown in figure [reference]. as can be seen, the performance of our network remains stable for sequences of varying lengths. even for a sequence length of 2, which only considers the previous and the current frame, our model generates very good results. particularly the best results were obtained for length 4, 5 and 6. however, we chose sequence length 5 for carrying out our experiments as a compromise between training time and accuracy. subsection: qualitative analysis we provide qualitative results on some videos of human3.6 m and youtube. we apply the model trained on the human3.6 m dataset on some videos gathered from youtube, the bounding box for each person in the youtube video is labeled manually and for human3.6 m the ground truth bounding box is used. the 2d poses are detected using the stacked-hourglass model fine-tuned on human3.6 m data. the qualitative result for youtube videos is shown in figure [reference] and for human3.6 m in figure [reference]. the real advantage of using the temporal smoothness constraint during training is apparent in these figures. for figure [reference], we can see that even when the 2d pose estimator breaks or generates extremely noisy detections, our system can recover temporally coherent 3d poses by exploiting the temporal consistency information. a similar trend can also be found for human3.6 m videos in figure [reference], particularly for the action sitting down of subject 11. we have provided more qualitative results in the supplementary material. section: conclusion both the quantitative and qualitative results for our network show the effectiveness of exploiting temporal information over multiple sequences to estimate 3d poses which are temporally smooth. our network achieved the best accuracy till date on all of the 15 action classes in the human3.6 m dataset. particularly, most of the previous methods struggled with actions which have a high degree of occlusion like taking photo, talking on the phone, sitting and sitting down. our network has significantly better results on these actions. additionally we found that our network is reasonably robust to noisy 2d poses. although the contribution of temporal smoothness constraint is not apparent in the ablative analysis in table [reference], its effectiveness is clearly visible in the qualitative results, particularly on challenging youtube videos (see figure [reference]). our network effectively demonstrates the power of using temporal context information which we achieved using a sequence-to-sequence network that can be trained efficiently in a reasonably quick time. also our network makes predictions from 2d poses at 3ms per frame on average which suggests that, given the 2d pose detector is real time, our network can be applied in real-time scenarios. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "human 3.6 m dataset"
                    ],
                    [
                        "humaneva dataset"
                    ],
                    [
                        "humaneva dataset human 3.6 m"
                    ],
                    [
                        "human 3.6 m"
                    ]
                ],
                "Method": [
                    [
                        "convolutional pose machine"
                    ]
                ],
                "Metric": [
                    [
                        "mean squared error"
                    ],
                    [
                        "average error"
                    ]
                ],
                "Task": [
                    [
                        "3d human pose estimation"
                    ],
                    [
                        "human pose estimation"
                    ],
                    [
                        "pose estimation"
                    ],
                    [
                        "estimation"
                    ],
                    [
                        "3d human pose estimation"
                    ],
                    [
                        "2d human poses"
                    ],
                    [
                        "nmt"
                    ],
                    [
                        "2d detections"
                    ],
                    [
                        "2d pose estimations"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "human3.6 m dataset",
                        "human 3.6 m dataset",
                        "human 3.6 m",
                        "human3.6 m"
                    ]
                ],
                "Method": [
                    [
                        "sequence-to-sequence network",
                        "sequence-to-sequence networks"
                    ]
                ],
                "Metric": [
                    [
                        "average error"
                    ]
                ],
                "Task": [
                    [
                        "3d human pose estimation",
                        "estimating 3d human pose",
                        "3d poses",
                        "2d human pose estimation",
                        "2d pose estimation",
                        "2d pose estimations"
                    ]
                ]
            }
        ]
    },
    "38e2f851b705faa0d0a698ed9885bd6834440073-54": {
        "doctext": "probabilistic model-agnostic meta-learning section: abstract meta-learning for few-shot learning entails acquiring a prior over previous tasks and experiences, such that new tasks be learned from small amounts of data. however, a critical challenge in few-shot learning is task ambiguity: even when a powerful prior can be meta-learned from a large number of prior tasks, a small dataset for a new task can simply be too ambiguous to acquire a single model (e.g., a classifier) for that task that is accurate. in this paper, we propose a probabilistic meta-learning algorithm that can sample models for a new task from a model distribution. our approach extends model-agnostic meta-learning, which adapts to new tasks via gradient descent, to incorporate a parameter distribution that is trained via a variational lower bound. at meta-test time, our algorithm adapts via a simple procedure that injects noise into gradient descent, and at meta-training time, the model is trained such that this stochastic adaptation procedure produces samples from the approximate model posterior. our experimental results show that our method can sample plausible classifiers and regressors in ambiguous few-shot learning problems. section: introduction learning from a few examples is a key aspect of human intelligence. one way to make it possible to acquire solutions to complex tasks from only a few examples is to leverage past experience to learn a prior over tasks. the process of learning this prior entails discovering the shared structure across different tasks from the same family, such as commonly occurring visual features or semantic cues. structure is useful insofar as it yields efficient learning of new tasks-a mechanism known as learning-to-learn, or meta-learning [reference]. however, when the end goal of few-shot meta-learning is to learn solutions to new tasks from small amounts of data, a critical issue that must be dealt with is task ambiguity: even with the best possible prior, there might simply not be enough information in the examples for a new task to resolve that task with high certainty. it is therefore quite desireable to develop few-shot meta-learning methods that can propose multiple potential solutions to an ambiguous few-shot learning problem. such a method could be used to evaluate uncertainty (by measuring agreement between the samples), perform active learning, or elicit direct human supervision about which sample is preferable. for example, in safety-critical applications, such as few-shot medical image classification, uncertainty is crucial for determining if the learned classifier should be trusted. when learning from such small amounts of data, uncertainty estimation can also help predict if additional data would be beneficial for learning and improving the estimate of the rewards. finally, while we do not experiment with this in this paper, we expect that modeling this ambiguity will be helpful for reinforcement learning problems, where it can be used to aid in exploration. while recognizing and accounting for ambiguity is an important aspect of the few-shot learning problem, it is particularly challenging to model when scaling to high-dimensional data, large function approximators, and multimodal task structure. representing distributions over functions is relatively straightforward when using simple function approximators, such as linear functions, and has been done extensively in early few-shot learning approaches using bayesian models [reference][reference]. but this problem becomes substantially more challenging when reasoning over high-dimensional function approximators such as deep neural networks, since explicitly representing expressive distributions over thousands or millions of parameters if often intractable. as a result, recent more scalable approaches to few-shot learning have focused on acquiring deterministic learning algorithms that disregard ambiguity over the underlying function. can we develop an approach that has the benefits of both classes of few-shot learning methods-scalability and uncertainty awareness? to do so, we build upon tools in amortized variational inference for developing a probabilistic meta-learning approach. in particular, our method builds on model-agnostic meta-learning (maml) [reference], a few shot metalearning algorithm that uses standard gradient descent to adapt the model at meta-test time to a new few-shot task, and trains the model parameters at meta-training time to enable rapid adaptation, essentially optimizing for a neural network initialization that is well-suited for few shot learning. maml can be shown to retain the generality of black-box meta-learners such as rnns [reference], while being applicable to standard neural network architectures. our approach extends maml to model a distribution over prior model parameters, which leads to an appealing simple stochastic adaptation procedure that simply injects noise into gradient descent at meta-test time. the meta-training procedure then optimizes for this simple inference process to produce samples from an approximate model posterior. the primary contribution of this paper is a reframing of maml as a graphical model inference problem, where variational inference can provide us with a principled and natural mechanism for modeling uncertainty and ambiguity. our approach enables sampling multiple potential solutions to a few-shot learning problem at meta-test time, and our experiments show that this ability can be utilized to sample multiple possible regressors for an ambiguous regression problem, as well as multiple possible classifiers for ambiguous few-shot attribute classification tasks. section: related work hierarchical bayesian models are a long-standing approach for few-shot learning that naturally allow for the ability to reason about uncertainty over functions [reference][reference][reference][reference][reference][reference][reference]. while these approaches have been demonstrated on simple few-shot image classification datasets [reference], they have yet to scale to the more complex problems, such as the experiments in this paper. a number of works have approached the problem of few-shot learning from a meta-learning perspective [reference][reference], including black-box [reference][reference][reference] and optimization-based approaches [reference][reference]. while these approaches scale to large-scale image datasets [reference] and visual reinforcement learning problems [reference], they typically lack the ability to reason about uncertainty. our work is most related to methods that combine deep networks and probabilistic methods for few-shot learning [reference][reference][reference]. one approach that considers hierarchical bayesian models for few-shot learning is the neural statistician [reference], which uses an explicit task variable to model task distributions. our method is fully model agnostic, and directly samples model weights for each task for any network architecture. our experiments show that our approach improves on maml [reference], which outperforms the model by edwards and storkey [reference]. other work that considers model uncertainty in the few-shot learning setting is the llama method [reference], which also builds on the maml algorithm. llama makes use of a local laplace approximation for modeling the task parameters (post-update parameters), which introduces the need to approximate a high dimensional covariance matrix. we instead propose a method that approximately infers the pre-update parameters, which we make tractable through a choice of approximate posterior parameterized by gradient operations. bayesian neural networks [reference][reference][reference][reference] have been studied extensively as a way to incorporate uncertainty into deep networks. although exact inference in bayesian neural networks is impractical, approximations based on backpropagation and sampling [reference][reference][reference][reference] have been effective in incorporating uncertainty into the weights of generic networks. our approach differs from these methods in that we explicitly train a hierarchical bayesian model over weights, where a posterior task-specific parameter distribution is inferred at meta-test time conditioned on a learned weight prior and a (few-shot) training set, while conventional bayesian neural networks directly learn only the posterior weight distribution for a single task. our method draws on amortized variational inference methods [reference][reference][reference] to make this possible, but the key modification is that the model and inference networks share the same parameters. the resulting method corresponds structurally to a bayesian version of model-agnostic meta-learning [reference]. into the center model after performing inference over\u03c6i. we find it beneficial to introduce additional dependencies of the prior on the training data to compensate for using the map estimate to approximate p (\u03c6i), as shown on the right. section: preliminaries in the meta-learning problem setting that we consider, the goal is to learn models that can learn new tasks from small amounts of data. to do so, meta-learning algorithms require a set of meta-training and meta-testing tasks drawn from some distribution p (t). the key assumption of learning-to-learn is that the tasks in this distribution share common structure that can be exploited for faster learning of new tasks. thus, the goal of the meta-learning process is to discover that structure. in this section, we will introduce notation and overview the model-agnostic meta-learning (maml) algorithm [reference]. meta-learning algorithms proceed by sampling data from a given task, and splitting the sampled data into a set of a few datapoints, d where\u03c6 i is used to denote the parameters updated by gradient descent and where the loss corresponds to negative log likelihood of the data. in particular, in the case of supervised classification with inputs {x j}, their corresponding labels {y j}, and a classifier f\u03b8, we will denote the negative log likelihood of the data under the classifier as l (\u03b8, d)=\u2212 (xj, yj)\u2208d log p (y j|x j,\u03b8). this corresponds to the cross entropy loss function. section: method our goal is to build a meta-learning method that can handle the uncertainty and ambiguity that occurs when learning from small amounts of data, while scaling to highly-expressive function approximators such as neural networks. to do so, we set up a graphical model for the few-shot learning problem. in particular, we want a hierarchical bayesian model that includes random variables for the prior distribution over function parameters,\u03b8, the distribution over parameters for a particular task,\u03c6 i, and the task training and test datapoints. this graphical model is illustrated in figure 1 (left), where tasks are indexed over i and datapoints are indexed over j. we will use the shorthand x. therefore, posterior inference over\u03c6 i must take into account both the evidence (training set) and the prior imposed by p (\u03b8) and p (\u03c6 i|\u03b8). conventional maml can be interpreted as approximating maximum a posteriori inference under a simplified model where p (\u03b8) is a delta function, and inference is performed by running gradient descent on log p (y tr|x tr,\u03c6 i) for a fixed number of iterations starting from\u03c6 [reference]. the corresponding distribution p (\u03c6 i|\u03b8) is approximately gaussian, with a mean that depends on the step size and number of gradient steps. when p (\u03b8) is not deterministic, we must make a further approximation to account for the random variable\u03b8. one way we can do this is by using structured variational inference. in structured variational inference, we approximate the distribution over the hidden variables\u03b8 and\u03c6 i for each task with some approximate distribution q i (\u03b8,\u03c6 i). there are two reasonable choices we can make for q i (\u03b8,\u03c6 i). first, we can approximate it as a product of independent marginals, according to however, this approximation does not permit uncertainty to propagate effectively from\u03b8 to\u03c6 i. a more expressive approximation is the structured variational approximation we can further avoid storing a separate variational distribution q i (\u03c6 i|\u03b8) and q i (\u03b8) for each task t i by employing an amortized variational inference technique [reference][reference][reference], where we instead set, where q\u03c8 is defined by some function approximator with parameters\u03c8 that takes x tr i, y tr i as input, and the same q\u03c8 is used for all tasks. similarly, we can define we can now write down the variational lower bound on the log-likelihood as the likelihood terms on the first line can be evaluated efficiently: given a sample\u03b8,\u03c6 i\u223c q (\u03b8,\u03c6 i|x, the training and test likelihoods simply correspond to the loss of the network with parameters\u03c6 i. the prior p (\u03b8) can be chosen to be gaussian, with a learned mean and (diagonal) covariance to provide for flexibility to choose the prior parameters. this corresponds to a bayesian version of the maml algorithm. we will define these parameters as\u00b5\u03b8 and\u03c3 2\u03b8. lastly, p (\u03c6 i|\u03b8) must be chosen. this choice is more delicate. one way to ensure a tractable likelihood is to use a gaussian with mean\u03b8. this choice is reasonable, because it encourages\u03c6 i to stay close to the prior parameters\u03c6 i, but we will see in the next section how a more expressive implicit conditional can be obtained using gradient descent, resulting in a procedure that more closely resembles the original maml algorithm while still modeling the uncertainty. lastly, we must choose a form for the inference networks q\u03c8 (\u03c6 i|\u03b8, they must be chosen so that their entropies on the second line of the above equation are tractable. furthermore, note that both of these distributions model very high-dimensional random variables: a deep neural network can have hundreds of thousands or millions of parameters. so while we can use an arbitrary function approximator, we would like to find a scalable solution. one convenient solution is to allow q\u03c8 to reuse the learned mean of the prior\u00b5\u03b8. we observe that adapting the parameters with gradient descent is a good way to update them to a given training set x where v q is a learned (diagonal) covariance, and the mean has an additional parameter beyond\u00b5\u03b8, which is a\" learning rate\" vector\u03b3 q that is pointwise multiplied with the gradient. while this choice may at first seem arbitrary, there is a simple intuition: the inference network should produce a sample of\u03b8 that is close to the posterior p (\u03b8|x a reasonable way to arrive at a value of\u03b8 close to this posterior is to adapt it to both the training set and test set. [reference] note that this is only done during meta-training. it remains to choose q\u03c8 (\u03c6 i|\u03b8,, which can also be formulated as a conditional gaussian with mean given by applying gradient descent. although this variational distribution is substantially more compact in terms of parameters than a separate neural network, it only provides estimates of the posterior during meta-training. at meta-test time, we must obtain the posterior p (\u03c6 i|x. we can train a separate set of inference networks to perform this operation, potentially also using gradient descent within the inference network. however, these networks do not receive any gradient information during meta-training, and may not work well in practice. in the next section we propose an even simpler and more practical approach that uses only a single inference network during meta-training, and none during meta-testing. section: algorithm 1 meta-training, differences from maml in red require: p (t): distribution over tasks 1: initialize\u03b8:= {\u00b5\u03b8,\u03c3 2\u03b8, vq,\u03b3p,\u03b3q} 2: while not done do 3: sample batch of tasks ti\u223c p (t) 4: for all ti do 5: evaluate compute adapted parameters with gradient descent: compute\u2207\u03b8 update\u03b8 using adam section: algorithm 2 meta-testing section: probabilistic model-agnostic meta-learning approach with hybrid inference to formulate a simpler variational meta-learning procedure, we recall the probabilistic interpretation of maml: as discussed by grant et al. [reference], maml can be interpreted as approximate inference for the posterior p (y where we use the maximum a posteriori (map) value\u03c6 i. it can be shown that, for likelihoods that are gaussian in\u03c6 i, gradient descent for a fixed number of iterations using x tr i, y tr i corresponds exactly to maximum a posteriori inference under a gaussian prior p (\u03c6 i|\u03b8) [reference]. in the case of non-gaussian likelihoods, the equivalence is only locally approximate, and the exact form of the prior p (\u03c6 i|\u03b8) is intractable. however, in practice this implicit prior can actually be preferable to an explicit (and simple) gaussian prior, since it incorporates the rich nonlinear structure of the neural network parameter manifold, and produces good performance in practice [reference][reference]. we can interpret this map approximation as inferring an approximate posterior on\u03c6 i of the form p (\u03c6 i|x where\u03c6 i is obtained via gradient descent on the training set x tr i, y tr i starting from\u03b8. incorporating this approximate inference procedure transforms the graphical model in figure 1 (a) into the one in figure 1 (b), where there is now a factor over p (\u03c6 i|x tr i, y tr i,\u03b8). while this is a crude approximation to the likelihood, it provides us with an empirically effective and simple tool that greatly simplifies the variational inference procedure described in the previous section, in the case where we aim to model a distribution over the global parameters p (\u03b8). after using gradient descent to estimate p (\u03c6 i| x is not observed. thus, we can now write down a variational lower bound for the logarithm of the approximate likelihood on the second line, which is given by in this bound, we essentially perform approximate inference via map on\u03c6 i to obtain p (\u03c6 i|x to evaluate the variational lower bound during training, we can use the following procedure: first, we evaluate the mean by starting from\u00b5\u03b8 and taking one (or more) gradient steps on log p (y test i|x test i,\u03b8 current), where\u03b8 current starts at\u00b5\u03b8. we then add noise with variance v q, which is made differentiable via the reparameterization trick [reference]. we then take additional gradient steps on the training likelihood log p (y tr i|x tr i,\u03b8 current). this accounts for the map inference procedure on\u03c6 i. training of\u00b5\u03b8,\u03c3 2\u03b8, and v q is performed by backpropagating gradients through this entire procedure with respect to the variational lower bound, which includes a term for the likelihood tr, y tr,\u03c6 i) and the kl-divergence between the sample\u03b8\u223c q\u03c8 and the prior p (\u03b8). this meta-training procedure is detailed in algorithm 1. at meta-test time, the inference procedure is much simpler. the test labels are not available, so we simply sample\u03b8\u223c p (\u03b8) and perform map inference on\u03c6 i using the training set, which corresponds to gradient steps on log p (y tr i|x tr i,\u03b8 current), where\u03b8 current starts at the sampled\u03b8. this meta-testing procedure is detailed in algorithm 2. section: adding additional dependencies in the transformed graphical model, the training data x tr i, y tr i and the prior\u03b8 are conditionally independent. however, since we have only a crude approximation to p (\u03c6 i| x tr i, y tr i,\u03b8), this independence often does n't actually hold. we can allow the model to compensate for this approximation by additionally conditioning the learned prior p (\u03b8) on the training data. in this case, the learned\" prior\" has the form p (\u03b8 i|x tr i, y tr i), where\u03b8 i is now task-specific, but with global parameters\u00b5\u03b8 and\u03c3 2\u03b8. we thus obtain the modified graphical model in figure 1 (c). similarly to the inference network q\u03c8, we parameterize the learned prior as follows: with this new form for distribution over\u03b8, the variational training objective uses the likelihood term log p (\u03b8 i|x in our experiments, we find that this more expressive distribution often leads to better performance. section: experiments the goal of our experimental evaluation is to answer the following questions: (1) can our approach enable sampling from the distribution over potential functions underlying the training data?, (2) does our approach improve upon the maml algorithm when there is ambiguity over the class of functions?, and (3) can our approach scale to deep convolutional networks? we study two illustrative toy examples and a realistic ambiguous few-shot image classification problem. for the both experimental domains, we compare maml to our probabilistic approach. we will refer to our version of maml as a platipus (probabilistic latent model for incorporating priors and uncertainty in few-shot learning), due to its unusual combination of two approximate inference methods: amortized inference and map. both platipus and maml use the same neural network architecture and the same number of inner gradient steps. we additionally provide a comparison on the miniimagenet benchmark and specify the hyperparameters in the supplementary appendix., and gaussian noise with a standard deviation of 0.3 is added to the labels. we trained both maml and platipus for 5-shot regression. in figure 2, we show the qualitative performance of both methods, where the ground truth underlying function is shown in gray and the datapoints in d tr are shown as purple triangles. we show the function f\u03c6i learned by maml in black. for platipus, we sample 10 sets of parameters from p (\u03c6 i|\u03b8) and plot the resulting functions in different colors. in the top row, we can see that platipus allows the model to effectively reason over the set of functions underlying the provided datapoints, with increased variance in parts of the function where there is more uncertainty. further, we see that platipus is able to capture the multimodal structure, as the curves are all linear or sinusoidal. a particularly useful application of uncertainty estimates in few-shot learning is estimating when more data would be helpful. in particular, seeing a large variance in a particular part of the input space suggests that more data would be helpful for learning the function in that part of the input space. on the bottom of figure 2, we show the results for a single task at meta-test time with increasing numbers of training datapoints. even though the model was only trained on training set sizes of 5 datapoints, we observe that platipus is able to effectively reduce its uncertainty as more and more datapoints are available. this suggests that the uncertainty provided by platipus can be used for approximately gauging when more data would be helpful for learning a new task. consisting of both positive and negative examples. we plot the results using the same scheme as before, except that we plot the decision boundary (rather than the regression function) and visualize the single positive datapoint with a green plus. as seen in figure 3, we see that platipus captures a broad distribution over possible decision boundaries, all of which are roughly circular. maml provides a single decision boundary of average size. ambiguous image classification. the ambiguity illustrated in the previous settings is common in real world tasks where images can share multiple attributes. we study an ambiguous extension to the celeba attribute classification task. our meta-training dataset is formed by sampling two attributes at random to form a positive class and taking the same number of random examples without either attribute to from the negative classes. to evaluate the ability to capture multiple decision boundaries while simultaneously obtaining good performance, we evaluate our method as follows: we sample from a test set of three attributes and a corresponding set of images with those attributes. since the tasks involve classifying images that have two attributes, this task is ambiguous, and there are three possible combinations of two attributes that explain the training set. we sample models from our prior as described in section 4 and assign each of the sampled models to one of the three possible tasks based on its log-likelihood. if each of the three possible tasks is assigned a nonzero number of samples, this means that the model effectively covers all three possible modes that explain the ambiguous training set. we can measure coverage and accuracy from this protocol. the coverage score indicates the average number of tasks (between 1 and 3) that receive at least one sample for each ambiguous training set, and the accuracy score is the average number of correct classifications on these tasks (according to the sampled models assigned to them). a highly random method will achieve good coverage but poor accuracy, while a deterministic method will have a coverage of 1. our results are summarized in table 5 and fig. 4. the accuracy of our method is comparable to standard, deterministic maml. however, the deterministic algorithm only ever captures one mode observes five positives that share three attributes, and five negatives. a classifier that uses any two attributes can correctly classify the training set. on the right, we show each of the possible two-attribute tasks that this training set can correspond to, and illustrate the labels (positive indicated by red border) assigned by the best sample for that task. we see that the different samples are able to make reasonable predictions with no hats (2nd column) or pay attention to them (1st and 3rd column), and can effectively capture the three possible explanations. for each ambiguous task, where the maximum is three. our method on average captures between two and three modes. the qualitative analysis in figure 4 illustrates 3 an example ambiguous training set, example images for the three possible two-attribute pairs that can correspond to this training set, and the classifications made by different sampled classifiers trained on the ambiguous training set. note that the different samples each pay attention to different attributes, indicating that platipus is effective at capturing the different modes of the task. section: discussion and future work we introduced an algorithm for few-shot meta-learning that enables simple and effective sampling of models for new tasks at meta-test time. our algorithm, platipus, adapts to new tasks by running gradient descent with injected noise. during meta-training, the model parameters are optimized with respect to a variational lower bound on the likelihood for the meta-training tasks, so as to enable this simple adaptation procedure to produce approximate samples from the model posterior when conditioned on a few-shot training set. this approach has a number of benefits. the adaptation procedure is exceedingly simple, and the method can be applied to any standard model architecture. the algorithm introduces a modest number of additional parameters: besides the initial model weights, we must learn a variance on each parameter for the inference network and prior, and the number of parameters scales only linearly with the number of model weights. our experimental results show that our method can be used to effectively sample diverse solutions to both regression and classification tasks at meta-test time, including for task families that have multi-modal task distributions. although our approach is simple and broadly applicable, it has a number of potential limitations that could be addressed in future work. first, the current form of the method provides a relatively impoverished estimator of posterior variance, which might be less effective at gauging uncertainty in settings where different tasks have very different degrees of ambiguity. in these cases, finding a way to make the variance dependent on the few-shot training set might produce better results, and investigating how to do this without adding a large number of additional parameters would be an interesting direction for future work. another exciting direction for future research would be to study how our approach could be applied in settings where ambiguity and uncertainty can directly guide data acquisition, so as to devise better few-shot active learning and reinforcement learning algorithms. section: appendix a ambiguous celeba details to construct our ambiguous few-shot variant of celeba, we take the entire base set of attributes holding out 10 attributes for testing. we consider every combination of 2 attributes, discarding those with insufficient numbers of examples. this leave us with a total of 387 training tasks and 43 testing attributes. we partition our meta-training set and meta-validation set to 337/ 50 respectively. during meta-training, we sample 2 random attributes to construct a positive class and randomly sample examples with neither attribute as negative examples. during testing of our approach, we sample 3 attributes from the test set, and sample the 3 corresponding 2-uples to form the test task. the training attributes are: section: b experimental details in the illustrative experiments, we use a fully connected network with 3 relu layers of size 100. for celeba, we adapt the base convolutional architecture described in finn et al. [reference] which we refer the readers to for more detail. our approximate posterior and prior have dimensionality matching the underlying model. we tune our approach over the inner learning rate\u03b1, a weight on the d kl, the scale of the initialization of\u00b5\u03b8,\u03c3 2\u03b8, v q,\u03b3 p,\u03b3 q, with early stopping on the validation set. at meta-test time, we evaluate our approach by taking 10 samples from the prior before determining the assignments. the assignments are made based on the complete likelihood of the testing examples (including the negatives). section: c miniimagenet comparison we provide an additional comparison on the miniimagenet dataset. since this benchmark does not contain a large amount of ambiguity, we do not aim to show state-of-the-art performance. instead, our goal with this experiment is to compare our approach on to maml and prior methods that build upon maml on this standard benchmark. since our goal is to compare algorithms, rather than achieving maximal performance, we decouple the effect of the meta-learning algorithm and the architecture used by using the standard 4-block convolutional architecture used by vinyals et al. [reference], ravi and larochelle [reference], finn et al. [reference] and others. we note that better performance can likely be achieved by tuning the architecture. the results, in table 2 indicate that our method slightly outperforms maml and achieves comparable performance to a number of other prior methods. miniimagenet 5-way, 1-shot accuracy maml [reference] 48.70\u00b1 1.84% llama [reference] 49.40\u00b1 1.83% reptile [reference] 49.97\u00b1 0.32% platipus (ours) 50.13\u00b1 1.86% meta-sgd [reference] 50.71\u00b1 1.87% matching nets [reference] 43.56\u00b1 0.84% meta-learner lstm [reference] 43.44\u00b1 0.77% snail [reference]* 45.10\u00b1 0.00% prototypical networks [reference] 46.61\u00b1 0.78% map-dlm [reference] 49.82\u00b1 0.78% gnn [reference] 50.33\u00b1 0.36% relation net [reference] 50.44\u00b1 0.82% table 2: comparison between our approach and prior maml-based methods (top), and other prior few-shot learning techniques on the 5-way, 1-shot miniimagenet benchmark. our approach gives a small boost over maml, and is comparable to other approaches. we bold the approaches that are above the highest confidence interval lower-bound.* accuracy using comparable network architecture. section: section: acknowledgments we thank marvin zhang and dibya ghosh for comments on an earlier draft of this paper. this research was supported by an nsf graduate research fellowship, nsf iis-1651843, the office of naval research, and nvidia. section:",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "probabilistic model agnostic meta learning"
                    ],
                    [
                        "model agnostic meta learning"
                    ],
                    [
                        "meta learning"
                    ],
                    [
                        "classifier"
                    ],
                    [
                        "maml"
                    ],
                    [
                        "model agnostic meta learning maml algorithm"
                    ]
                ],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "miniimagenet benchmark",
                        "miniimagenet dataset",
                        "miniimagenet 5-way",
                        "5-way, 1-shot miniimagenet benchmark"
                    ]
                ],
                "Method": [
                    [
                        "platipus",
                        "probabilistic latent model for incorporating priors and uncertainty in few-shot learning"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": [
                    [
                        "few-shot medical image classification",
                        "ambiguous few-shot attribute classification tasks",
                        "few-shot image classification datasets",
                        "ambiguous few-shot image classification problem"
                    ]
                ]
            }
        ]
    },
    "3aa21de1a7c97e0458e10ed5730ce160bb436caa-55": {
        "doctext": "document: pixel2mesh: generating 3d mesh models from single rgb images we propose an end-to-end deep learning architecture that produces a 3d shape in triangular mesh from a single color image. limited by the nature of deep neural network, previous methods usually represent a 3d shape in volume or point cloud, and it is non-trivial to convert them to the more ready-to-use mesh model. unlike the existing methods, our network represents 3d mesh in a graph-based convolutional neural network and produces correct geometry by progressively deforming an ellipsoid, leveraging perceptual features extracted from the input image. we adopt a coarse-to-fine strategy to make the whole deformation procedure stable, and define various of mesh related losses to capture properties of different levels to guarantee visually appealing and physically accurate 3d geometry. extensive experiments show that our method not only qualitatively produces mesh model with better details, but also achieves higher 3d shape estimation accuracy compared to the state-of-the-art. indicates equal contributions. indicates corresponding author. section: introduction inferring 3d shape from a single perspective is a fundamental human vision functionality but is extremely challenging for computer vision. recently, great success has been achieved for 3d shape generation from a single color image using deep learning techniques. taking advantage of convolutional layers on regular grids or multi-layer perception, the estimated 3d shape, as the output of the neural network, is represented as either a volume or point cloud. however, both representations lose important surface details, and is non-trivial to reconstruct a surface model (fig. [reference]), i.e. a mesh, which is more desirable for many real applications since it is lightweight, capable of modelling shape details, easy to deform for animation, to name a few. in this paper, we push along the direction of single image reconstruction, and propose an algorithm to extract a 3d triangular mesh from a single color image. rather than directly synthesizing, our model learns to deform a mesh from a mean shape to the target geometry. this benefits us from several aspects. first, deep network is better at predicting residual, e.g. a spatial deformation, rather than structured output, e.g. a graph. second, a series of deformations can be added up together, which allows shape to be gradually refined in detail. it also enables the control of the trade-off between the complexity of the deep learning model and the quality of the result. lastly, it provides the chance to encode any prior knowledge to the initial mesh, e.g. topology. as a pioneer study, in this work, we specifically work on objects that can be approximated using 3d mesh with genus 0 by deforming an ellipsoid with a fixed size. in practice, we found most of the commonly seen categories can be handled well under this setting, e.g. car, plane, table, etc. to achieve this goal, there are several inherent challenges. the first challenge is how to represent a mesh model, which is essentially an irregular graph, in a neural network and still be capable of extracting shape details effectively from a given color image represented in a 2d regular grid. it requires the integration of the knowledge learned from two data modalities. on the 3d geometry side, we directly build a graph based fully convolutional network (gcn) on the mesh model, where the vertices and edges in the mesh are directly represented as nodes and connections in a graph. network feature encoding information for 3d shape is saved on each vertex. through forward propagation, the convolutional layers enable feature exchanging across neighboring nodes, and eventually regress the 3d location for each vertex. on the 2d image side, we use a vgg-16 like architecture to extract features as it has been demonstrated to be successful for many tasks. to bridge these two, we design a perceptual feature pooling layer which allows each node in the gcn to pool image features from its 2d projection on the image, which can be readily obtained by assuming known camera intrinsic matrix. the perceptual feature pooling is enabled once after several convolutions (i.e. a deformation block described in sec. [reference]) using updated 3d locations, and hence the image features from correct locations can be effectively integrated with 3d shapes. given the graph representation, the next challenge is how to update the vertex location effectively towards ground truth. in practice, we observe that network trained to directly predict mesh with a large number of vertices is likely to make mistake in the beginning and hard to fix later. one reason is that a vertex can not effectively retrieve features from other vertices with a number of edges away, i.e. the limited receptive field. to solve this problem, we design a graph unpooling layer, which allows the network to initiate with a smaller number of vertices and increase during the forward propagation. with fewer vertices at the beginning stages, the network learns to distribute the vertices around to the most representative location, and then add local details as the number of vertices increases later. besides the graph unpooling layer, we use a deep gcn enhanced by shortcut connections as the backbone of our architecture, which enables large receptive fields for global context and more steps of movements. representing the shape in graph also benefits the learning procedure. the known connectivity allows us to define higher order loss functions across neighboring nodes, which are important to regularize 3d shapes. specifically, we define a surface normal loss to favor smooth surface; an edge loss to encourage uniform distribution of mesh vertices for high recall; and a laplacian loss to prevent mesh faces from intersecting each other. all of these losses are essential to generate quality appealing mesh model, and none of them can be trivially defined without the graph representation. the contributions of this paper are mainly in three aspects. first, we propose a novel end-to-end neural network architecture that generates a 3d mesh model from a single rgb image. second, we design a projection layer which incorporates perceptual image features into the 3d geometry represented by gcn. third, our network predict 3d geometry in a coarse to fine fashion, which is more reliable and easy to learn. section: related work 3d reconstruction has been well studied based on the multi-view geometry (mvg) in the literature. the major research directions include structure from motion (sfm) for large-scale high-quality reconstruction and simultaneous localization and mapping (slam) for navigation. though they are very successful in these scenarios, they are restricted by 1) the coverage that the multiple views can give and 2) the appearance of the object that wants to reconstruct. the former restriction means mvg can not reconstruct unseen parts of the object, and thus it usually takes a long time to get enough views for a good reconstruction; the latter restriction means mvg can not reconstruct non-lambertian (e.g. reflective or transparent) or textureless objects. these restrictions lead to the trend of resorting to learning based approaches. learning based approaches usually consider single or few images, as it largely relies on the shape priors that it can learn from data. early works can be traced back to hoiem et al. and saxena et al.. most recently, with the success of deep learning architectures and the release of large-scale 3d shape datasets such as shapenet, learning based approaches have achieved great progress. huang et al. and su et al. retrieve shape components from a large dataset, assemble them and deform the assembled shape to fit the observed image. however, shape retrieval from images itself is an ill-posed problem. to avoid this problem, kar et al. learns a 3d deformable model for each object category and capture the shape variations in different images. however, the reconstruction is limited to the popular categories and its reconstruction result is usually lack of details. another line of research is to directly learn 3d shapes from single images. restricted by the prevalent grid-based deep learning architectures, most works outputs 3d voxels, which are usually with low resolutions due to the memory constraint on a modern gpu. most recently, tatarchenko et al. have proposed an octree representation, which allows to reconstructing higher resolution outputs with a limited memory budget. however, a 3d voxel is still not a popular shape representation in game and movie industries. to avoid drawbacks of the voxel representation, fan et al. propose to generate point clouds from single images. the point cloud representation has no local connections between points, and thus the point positions have a very large degree of freedom. consequently, the generated point cloud is usually not close to a surface and can not be used to recover a 3d mesh directly. besides these typical 3d representations, there is an interesting work which uses a so-called\" geometry image\" to represent a 3d shape. thus, their network is a 2d convolutional neural network which conducts an image to image mapping. our works are mostly related to the two recent works and. however, the former adopts simple silhouette supervision, and hence does not perform well for complicated objects such as car, lamp, etc; the latter needs a large model repository to generate a combined model. our base network is a graph neural network; this architecture has been adopted for shape analysis. in the meanwhile, there are charting-based methods which directly apply convolutions on surface manifolds for shape analysis. as far as we know, these architectures have never been adopted for 3d reconstruction from single images, though graph and surface manifold are natural representations for meshed objects. for a comprehensive understanding of the graph neural network, the charting-based methods and their applications, please refer to this survey. section: method subsection: preliminary: graph-based convolution we first provide some background about graph based convolution; more detailed introduction can be found in. a 3d mesh is a collection of vertices, edges and faces that defines the shape of a 3d object; it can be represented by a graph, where is the set of vertices in the mesh, is the set of edges with each connecting two vertices, and are the feature vectors attached on vertices. a graph based convolutional layer is defined on irregular graph as: where are the feature vectors on vertex before and after the convolution, and is the neighboring vertices of; and are the learnable parameter matrices of that are applied to all vertices. note that is shared for all edges, and thus ([reference]) works on nodes with different vertex degrees. in our case, the attached feature vector is the concatenation of the 3d vertex coordinate, feature encoding 3d shape, and feature learned from the input color image (if they exist). running convolutions updates the features, which is equivalent as applying a deformation. subsection: system overview our model is an end-to-end deep learning framework that takes a single color image as input and produces a 3d mesh model in camera coordinate. the overview of our framework is illustrated in fig. [reference]. the whole network consists an image feature network and a cascaded mesh deformation network. the image feature network is a 2d cnn that extract perceptual feature from the input image, which is leveraged by the mesh deformation network to progressively deform an ellipsoid mesh into the desired 3d model. the cascaded mesh deformation network is a graph-based convolution network (gcn), which contains three deformation blocks intersected by two graph unpooling layers. each deformation block takes an input graph representing the current mesh model with the 3d shape feature attached on vertices, and produces new vertices locations and features. whereas the graph unpooling layers increase the number of vertices to increase the capacity of handling details, while still maintain the triangular mesh topology. starting from a smaller number of vertices, our model learns to gradually deform and add details to the mesh model in a coarse-to-fine fashion. in order to train the network to produce stable deformation and generate an accurate mesh, we extend the chamfer distance loss used by fan et al. with three other mesh specific loss- surface normal loss, laplacian regularization loss, and edge length loss. the remaining part of this section describes details of these components. subsection: initial ellipsoid our model does not require any prior knowledge of the 3d shape, and always deform from an initial ellipsoid with average size placed at the common location in the camera coordinate. the ellipsoid is centered at 0.8 m in front of the camera with 0.2 m, 0.2 m, 0.4 m as the radius of three axis. the mesh model is generated by implicit surface algorithm in meshlab and contains 156 vertices. we use this ellipsoid to initialize our input graph, where the initial feature contains only the 3d coordinate of each vertex. subsection: mesh deformation block the architecture of mesh deformation block is shown in fig. [reference] (a). in order to generate 3d mesh model that is consistent with the object shown in the input image, the deformation block need to pool feature () from the input image. this is done in conjunction with the image feature network and a perceptual feature pooling layer given the location of vertex () in the current mesh model. the pooled perceptual feature is then concatenated with the 3d shape feature attached on the vertex from the input graph () and fed into a series of graph based resnet (g-resnet). the g-resnet produces, also as the output of the mesh deformation block, the new coordinates () and 3d shape feature () for each vertex. subsubsection: perceptual feature pooling layer we use a vgg-16 architecture up to layer conv5_3 as the image feature network as it has been widely used. given the 3d coordinate of a vertex, we calculate its 2d projection on input image plane using camera intrinsics, and then pool the feature from four nearby pixels using bilinear interpolation. in particular, we concatenate feature extracted from layer 'conv3_3', 'conv4_3', and 'conv5_3', which results in a total dimension of 1280. this perceptual feature is then concatenated with the 128-dim 3d feature from the input mesh, which results in a total dimension of 1408. this is illustrated in fig. [reference] (b). note that in the first block, the perceptual feature is concatenated with the 3-dim feature (coordinate) since there is no learnt shape feature at the beginning. subsubsection: g-resnet after obtaining 1408-dim feature for each vertex representing both 3d shape and 2d image information, we design a graph based convolutional neural network to predict new location and 3d shape feature for each vertex. this requires efficient exchange of the information between vertices. however, as defined in ([reference]), each convolution only enables the feature exchanging between neighboring pixels, which severely impairs the efficiency of information exchanging. this is equivalent as the small receptive field issue on 2d cnn. to solve this issue, we make a very deep network with shortcut connections and denote it as g-resnet (fig. [reference] (a)). in this work, the g-resnet in all blocks has the same structure, which consists of 14 graph residual convolutional layers with 128 channels. the serial of g-resnet block produces a new 128-dim 3d feature. in addition to the feature output, there is a branch which applies an extra graph convolutional layer to the last layer features and outputs the 3d coordinates of the vertex. subsection: graph unpooling layer the goal of unpooling layer is to increase the number of vertex in the gcnn. it allows us to start from a mesh with fewer vertices and add more only when necessary, which reduces memory costs and produces better results. a straightforward approach is to add one vertex in the center of each triangle and connect it with the three vertices of the triangle (fig. [reference] (b) face-based). however, this causes imbalanced vertex degrees, i.e. number of edges on vertex. inspired by the vertex adding strategy of the mesh subdivision algorithm prevalent in computer graphics, we add a vertex at the center of each edge and connect it with the two end-point of this edge (fig. [reference] (a)). the 3d feature for newly added vertex is set as the average of its two neighbors. we also connect three vertices if they are added on the same triangle (dashed line.) consequently, we create 4 new triangles for each triangle in the original mesh, and the number of vertex is increased by the number of edges in the original mesh. this edge-based unpooling uniformly upsamples the vertices as shown in fig. [reference] (b) edge-based. subsection: losses we define four kinds of losses to constrain the property of the output shape and the deformation procedure to guarantee appealing results. we adopt the chamfer loss to constrain the location of mesh vertices, a normal loss to enforce the consistency of surface normal, a laplacian regularization to maintain relative location between neighboring vertices during deformation, and an edge length regularization to prevent outliers. these losses are applied with equal weight on both the intermediate and final mesh. unless otherwise stated, we use for a vertex in the predicted mesh, for a vertex in the ground truth mesh, for the neighboring pixel of, till the end of this section. subsubsection: chamfer loss the chamfer distance measures the distance of each point to the other set: it is reasonably good to regress the vertices close to its correct position, however is not sufficient to produce nice 3d mesh (see the result of fan et al. in fig. [reference]). subsubsection: normal loss we further define loss on surface normal to characterize high order properties: where is the closest vertex for that is found when calculating the chamfer loss, is the neighboring pixel of, is the inner product of two vectors, and is the observed surface normal from ground truth. essentially, this loss requires the edge between a vertex with its neighbors to perpendicular to the observation from the ground truth. one may find that this loss does not equal to zero unless on a planar surface. however, optimizing this loss is equivalent as forcing the normal of a locally fitted tangent plane to be consistent with the observation, which works practically well in our experiment. moreover, this normal loss is fully differentiable and easy to optimize. subsubsection: regularization even with the chamfer loss and normal loss, the optimization is easily stucked in some local minimum. more specifically, the network may generate some super large deformation to favor some local consistency, which is especially harmful at the beginning when the estimation is far from ground truth, and causes flying vertices (fig. [reference]). paragraph: laplacian regularization to handle these problem, we first propose a laplacian term to prevent the vertices from moving too freely, which potentially avoids mesh self-intersection. the laplaician term serves as a local detail preserving operator, that encourages neighboring vertices to have the same movement. in the first deformation block, it acts like a surface smoothness term since the input to this block is a smooth-everywhere ellipsoid; starting from the second block, it prevents the 3d mesh model from deforming too much, so that only fine-grained details are added to the mesh model. to calculate this loss, we first define a laplacian coordinate for each vertex as and the laplacian regularization is defined as: where and are the laplacian coordinate of a vertex after and before a deformation block. paragraph: edge length regularization. to penalize flying vertices, which ususally cause long edge, we add an edge length regularization loss: the overall loss is a weighted sum of all four losses,, where, and are the hyperparameters which balance the losses and fixed for all the experiments. section: experiment in this section, we perform an extensive evaluation on our model. in addition to comparing with previous 3d shape generation works for evaluating the reconstruction accuracy, we also analyse the importance of each component in our model. qualitative results on both synthetic and real-world images further show that our model produces triangular meshes with smooth surfaces and still maintains details depicted in the input images. subsection: experimental setup subsubsection: data. we use the dataset provided by choy et al.. the dataset contains rendering images of 50k models belonging to 13 object categories from shapenet, which is a collection of 3d cad models that are organized according to the wordnet hierarchy. a model is rendered from various camera viewpoints, and camera intrinsic and extrinsic matrices are recorded. for fair comparison, we use the same training/ testing split as in choy et. al.. subsubsection: evaluation metric. we adopt the standard 3d reconstruction metric. we first uniformly sample points from our result and ground truth. we calculate precision and recall by checking the percentage of points in prediction or ground truth that can find a nearest neighbor from the other within certain threshold. a f-score as the harmonic mean of precision and recall is then calculated. following fan et. al., we also report the chamfer distance (cd) and earth mover's distance (emd). for f-score, larger is better. for cd and emd, smaller is better. on the other hand, we realize that the commonly used evaluation metrics for shape generation may not thoroughly reflect the shape quality. they often capture occupancy or point-wise distance rather than surface properties, such as continuity, smoothness, high-order details, for which a standard evaluation metric is barely missing in literature. thus, we recommend to pay attention on qualitative results for better understanding of these aspects. subsubsection: baselines. we compare the presented approach to the most recent single image reconstruction approaches. specifically, we compare with two state-of-the-art methods-choy et. al. (3d-r2n2) producing 3d volume, and fan et. al. (psg) producing point cloud. since the metrics are defined on point cloud, we can evaluate psg directly on its output, our method by uniformly sampling point on surface, and 3d-r2n2 by uniformly sampling point from mesh created using the marching cube method. we also compare to neural 3d mesh renderer (n3mr) which is so far the only deep learning based mesh generation model with code public available. for fair comparison, the models are trained with the same data using the same amount of time. subsubsection: training and runtime. our network receives input images of size, and initial ellipsoid with 156 vertices and 462 edges. the network is implemented in tensorflow and optimized using adam with weight decay 1e-5. the batch size is 1; the total number of training epoch is 50; the learning rate is initialized as 3e-5 and drops to 1e-5 after 40 epochs. the total training time is 72 hours on a nvidia titan x. during testing, our model takes 15.58ms to generate a mesh with 2466 vertices. subsection: comparison to state of the art tab. [reference] shows the f-score with different thresholds of different methods. our approach outperforms the other methods in all categories except watercraft. notably, our results are significantly better than the others in all categories under a smaller threshold, showing at least 10% f-score improvement. n3mr does not perform well, and its result is about 50% worse than ours, probably because their model only learns from limited silhouette signal in images and lacks of explicit handling of the 3d mesh. we also show the cd and emd for all categories in tab. [reference]. our approach outperforms the other methods in most categories and achieves the best mean score. the major competitor is psg, which produces a point cloud and has the most freedom; this freedom leads to smaller cd and emd, however does not necessarily leads to a better mesh model without proper regularization. to demonstrate this, we show the qualitative results to analyze why our approach outperforms the others. fig. [reference] shows the visual results. to compare the quality of mesh model, we convert volumetric and point cloud to mesh using standard approaches. as we can see, the 3d volume results produced by 3d-r2n2 lack of details due to the low resolution, e.g., the legs are missing in the chair example as shown in the 4-th row of fig. [reference]. we tried octree based solution to increase the volume resolution, but found it still hard to recover surface level details as much as our model. psg produces sparse 3d point clouds, and it is non-trivial to recover meshes from them. this is due to the applied chamfer loss acting like a regression loss which gives too much degree of freedom to the point cloud. n3mr produces very rough shape, which might be sufficient for some rendering tasks, however can not recover complicated objects such as chairs and tables. in contrast, our model does not suffer from these issues by leveraging a mesh representation, integration of perceptual feature, and carefully defined losses during the training. our result is not restricted by the resolution due to the limited memory budget and contains both smooth continuous surface and local details. subsection: ablation study now we conduct controlled experiments to analyse the importance of each component in our model. tab. [reference] reports the performance of each model by removing one component from the full model. again, we argue that these commonly used evaluation metrics does not necessarily reflect the quality of the recovered 3d geometry. for example, the model with no edge length regularization achieves the best performance across all, however, in fact produces the worst mesh (fig. [reference], the last 2nd column). as such, we use qualitative result fig. [reference] to show the contribution of each component in our system. subsubsection: graph unpooling we first remove the graph unpooling layers, and thus each block has the same number of vertices as in the last block of our full model. it is observed that the deformation makes mistake easier at beginning, which can not be fixed later on. consequently, there are some obvious artifacts in some parts of the objects. subsubsection: g-resnet we then remove the shortcut connections in g-resnet, and make it regular gcn. as can be seen from tab. [reference], there is a huge performance gap in all four measurement metrics, which means the failure of optimizing chamfer distance. the main reason is the degradation problem observed in the very deep 2d convolutional neural network. such problem leads to a higher training error (and thus higher testing error) when adding more layers to a suitably deep model. essetially, our network has 42 graph convolutional layers. thus, this phenomenon has also been observed in our very deep graph neural network experiment. subsubsection: loss terms we evaluate the function of each additional terms besides the chamfer loss. as can be seen in fig. [reference], removing normal loss severely impairs the surface smoothness and local details, e.g. seat back; removing laplacian term causes intersecting geometry because the local topology changes, e.g. the hand held of the chair; removing edge length term causes flying vertices and surfaces, which completely ruins the surface characteristics. these results demonstrate that all the components presented in this work contribute to the final performance. subsubsection: number of deformation blocks we now analyze the effects of the number of blocks. figure fig. [reference] (left) shows the mean f-score () and cd with regard to the number of blocks. the results indicate that increasing the number of blocks helps, but the benefit is getting saturated with more blocks, e.g. from 3 to 4. in our experiment, we found that 4 blocks results in too many vertices and edges, which slow down our approach dramatically even though it provides better accuracy on evaluation metrics. therefore, we use 3 blocks in all our experiment for the best balance of performance and efficiency. fig. [reference] (right) shows the output of our model after each deformation block. notice how mesh is densified with more vertices and new details are added. subsection: reconstructing real-world images following choy et. al., we test our network on the online products dataset and internet images for qualitative evaluation on real images. we use the model trained from shapenet dataset and directly run on real images without finetuning, and show results in fig. [reference]. as can be seen, our model trained on synthetic data generalizes well to the real-world images across various categories. section: conclusion we have presented an approach to extract 3d triangular meshes from singe images. we exploit the key advantages the mesh presentation can bring to us, and the key issues required to solve for success. the former includes surface normal constraints and information propagation along edges; the latter includes perceptual features extracted from images as a guidance. we carefully design our network structure and propose a very deep cascaded graph convolutional neural network with\" shortcut\" connections. meshes are progressively refined by our network trained end-to-end with the chamfer loss and normal loss. our results are significantly better than the previous state-of-the-art using other shape representations such as 3d volume or 3d point cloud. thus, we believe mesh representation is the next big thing in this direction, and we hope that the key components discovered in our work can support follow-up works that will further advance direct 3d mesh reconstruction from single images. subsubsection: future work our method only produces meshes with the same topology as the initial mesh. in the future, we will extend our approach to more general cases, such as scene level reconstruction, and learn from multiple images for multi-view reconstruction. subsubsection: acknowledgements this work was supported by two projects from nsfc (# 61622204 and# 61572134), two projects from stcsm (# 16jc1420401 and# 16qa1400500), eastern scholar (tp2017006), and the thousand talents plan of china (for young professionals, d1410009). bibliography: references",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "pixel2mesh"
                    ],
                    [
                        "cascaded mesh deformation network"
                    ],
                    [
                        "cascaded mesh deformation network"
                    ],
                    [
                        "graph based convolution network"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "direct 3d mesh reconstruction"
                    ],
                    [
                        "scene level reconstruction"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "shapenet dataset"
                    ]
                ],
                "Method": [
                    [
                        "pixel2mesh"
                    ]
                ],
                "Metric": [
                    [
                        "f-score",
                        "f-score improvement",
                        "mean f-score"
                    ]
                ],
                "Task": [
                    [
                        "3d reconstruction"
                    ]
                ]
            }
        ]
    },
    "3acc07f7f8951617276cf99483ed02aeb0a6eeac-56": {
        "doctext": "document: curriculum domain adaptation for semantic segmentation of urban scenes during the last half decade, convolutional neural networks (cnns) have triumphed over semantic segmentation, which is a core task of various emerging industrial applications such as autonomous driving and medical imaging. however, to train cnns requires a huge amount of data, which is difficult to collect and laborious to annotate. recent advances in computer graphics make it possible to train cnn models on photo-realistic synthetic data with computer-generated annotations. despite this, the domain mismatch between the real images and the synthetic data significantly decreases the models' performance. hence we propose a curriculum-style learning approach to minimize the domain gap in semantic segmentation. the curriculum domain adaptation solves easy tasks first in order to infer some necessary properties about the target domain; in particular, the first task is to learn global label distributions over images and local distributions over landmark superpixels. these are easy to estimate because images of urban traffic scenes have strong idiosyncrasies (e.g., the size and spatial relations of buildings, streets, cars, etc.). we then train the segmentation network in such a way that the network predictions in the target domain follow those inferred properties. in experiments, our method significantly outperforms the baselines as well as the only known existing approach to the same problem. 1] yang zhang 2] philip david 1] boqing gong [1] center for research in computer vision, university of central florida [2] computational and information sciences directorate, u.s. army research laboratory yangzhang@knights.ucf.edu,, bgong@crcv.ucf.edu section: introduction this paper is concerned with domain adaptation for semantic image segmentation of urban scenes, i.e., assigning a category label to every pixel of an image or video frame. our interest in this problem is partially due to the exciting vision of autonomous driving, where understanding complex inner-city traffic scenes is an essential module and semantic segmentation is one of its key constituents. machine learning methods for automatic semantic segmentation require massive amounts of high-quality annotated imagery in order to produce effective classifiers that generalize well to novel scenes. however, annotating training imagery for semantic segmentation is a very cumbersome task for humans. cordts et al. report that the annotation and quality control take more than 1.5 hours on a single image of the cityscapes dataset. besides, it is very difficult and time-consuming to collect imagery that depicts the large number of variabilities possible of urban scenes in different countries, seasons, and lighting conditions, etc. to overcome both shortcomings, simulated urban environments may be used to automatically generate large amounts of annotated training imagery. this, however, introduces a new problem, that of domain mismatch between the source (simulated) domain and the target (real) domain. figure [reference] illustrates some examples drawn from the synthetic synthia dataset and the real cityscapes dataset. it is readily apparent that there are significant visual differences between the two datasets. domain adaptation techniques may be used by machine learning methods to bridge this gap between the two domains. in computer vision, learning domain-invariant features has been a prevalent and successful strategy to tackle the discrepancy between two domains, mainly for classification and regression problems. the core idea is to infer a new feature space such that the marginal distributions of the source domain (s) and the target domain (t) are about the same, i.e.,. furthermore, the prediction function from that space is assumed to be the same across the domains so that one can leverage the rich labeled data in the source domain to train classifiers that generalize well to the target. it is hard to verify the assumption, but the work along this line is rich and has led to impressive practical results regardless, such as the algorithms using linear transformation, kernel methods, and the recent deep learning methods that directly extract domain-invariant features from raw input images. in contrast to prior arts, the semantic segmentation we study in this paper is a highly structured prediction problem, for which domain adaptation is only sparsely explored in the literature. under structured prediction, can we still achieve good domain adaptation results by following the above principles? our intuition and experimental studies (cf. section [reference]) tell us no. learning a decision function for structured prediction is more involved than classification because it has to resolve the predictions in an exponentially large label space. as a result, the assumption that the source and target domains share the same prediction function becomes less likely to hold. besides, some discriminative cues in the data would be suppressed if one matches the feature representations of the two domains without taking careful account of the structured labels. finally, data instances are the proxy to measure the domain difference. however, it is not immediately clear what comprises the instances in semantic segmentation, especially given that the top-performing segmentation methods are built upon deep neural networks. hoffman et al. take each spatial unit in the fully convolutional network (fcn) as an instance. we contend that such instances are actually non-i.i.d. in either individual domain, as their receptive fields overlap with each other. how can we avoid the assumption that the source and target domains share the same prediction function in a transformed domain-invariant feature space? our proposed solution draws on two key observations. one is that the urban traffic scene images have strong idiosyncrasies (e.g., the size and spatial relations of buildings, streets, cars, etc.). therefore, some tasks are\" easy\" and, more importantly, suffer less because of the domain discrepancy. second, the structured output in semantic segmentation enables convenient posterior regularization, as opposed to the popular (e.g.,) regularization over model parameters. accordingly, we propose a curriculum-style domain adaptation approach. recall that, in domain adaptation, only the source domain supplies many labeled data while there are no or only scarce labels from the target. the curriculum domain adaptation begins with the easy tasks, in order to gain some high-level properties about the unknown pixel-level labels for each target image. it then learns a semantic segmentation network\u2014 the hard task, whose predictions over the target images are forced to follow those necessary properties as much as possible. to develop the easy tasks in the curriculum, we consider label distributions over both holistic images and some landmark superpixels of the target domain. take the former for instance. the label distribution of an image indicates the percentage of pixels that belong to each category, respectively. we argue that such tasks are easier, despite the domain mismatch, than assigning pixel-wise labels. indeed, we may directly estimate the label distributions without inferring the pixel-wise labels. moreover, the relative sizes of road, vehicle, pedestrian, etc. constrain the shape of the distributions, effectively reducing the search space. finally, models to estimate the label distributions over superpixels may benefit from the urban scenes' canonical layout that transcends domains, e.g., buildings stand beside streets. why and when are the seemingly simple label distributions useful for the domain adaptation of semantic segmentation? in our experiments, we find that the segmentation networks trained on the source domain perform poorly on many target images, giving rise to disproportionate label assignments (e.g., many more pixels are classified to sidewalks than to streets). to rectify this, the image-level label distribution informs the segmentation network how to update the predictions while the label distributions of the landmark superpixels tell the network where to update. jointly, they guide the adaptation of the networks to the target domain to, at least, generate proportional label predictions. note that additional\" easy tasks\" can be conveniently incorporated into our framework in the future. our main contribution is on the proposed curriculum-style domain adaptation for the semantic segmentation of urban scenes. we select into the curriculum the easy and useful tasks of inferring label distributions for the target images and landmark superpixels, in order to gain some necessary properties about the target domain. built upon these, we learn a pixel-wise discriminative segmentation network from the labeled source data and, meanwhile, conduct a\" sanity check\" to ensure the network behavior is consistent with the previously learned knowledge about the target domain. our approach effectively eludes the assumption about the existence of a common prediction function for both domains in a transformed feature space. it readily applies to different segmentation networks, as it does not change the network architecture or tax any intermediate layers. section: related work we discuss some related work on domain adaptation and semantic segmentation, with special focus on that transferring knowledge from virtual images to real photos. paragraph: domain adaptation. conventional machine learning algorithms rely on the assumption that the training and test data are drawn i.i.d. from the same underlying distribution. however, it is often the case that there exists some discrepancy from the training to the test stage. domain adaptation aims to rectify this mismatch and tune the models toward better generalization at testing. the existing work on domain adaptation mostly focuses on classification and regression problems, e.g., learning from online commercial images to classify real-world objects, and, more recently, aims to improve the adaptability of deep neural networks. among them, the most relevant work to ours is that exploring simulated data. sun and saenko train generic object detectors from the synthetic images, while vazquez et al. use the virtual images to improve pedestrian detections in real environment. the other way around, i.e., how to improve the quality of the simulated images using the real ones, is studied in. paragraph: semantic segmentation. semantic segmentation is the task of assigning an object label to each pixel of an image. traditional methods rely on local image features manually designed by domain experts. after the pioneering work that introduced the convolutional neural network (cnn) to semantic segmentation, most recent top-performing methods are built on cnns. an enormous amount of labor-intensive work is required to annotate the many images that are needed to obtain accurate segmentation models. the pascal voc2012 challenge contains nearly 10, 000 annotated images for the segmentation competition, and the ms coco challenge includes over 200, 000 annotated images. according to, it took about 60 minutes to manually segment each image in and about 90 minutes for each in. a plausible approach to reducing the human workload is to utilize weakly supervised information such as image labels and bounding boxes. we instead explore the use of almost effortlessly labeled virtual images for training high-quality segmentation networks. in, annotating a synthetic image took only 7 seconds on average through a computer game. for the urban scenes, we use the synthia dataset which contains images of a virtual city. paragraph: domain adaptation for semantic segmentation. upon observing the obvious mismatch between virtual and real data, we expect domain adaptation to enhance the segmentation performance on real images by networks trained on virtual ones. to the best of our knowledge, the only attempt to algorithmically address this problem is. while it regularizes the intermediate layers and constrains the output of the network, we propose a different curriculum domain adaptation strategy. we solve the easy task first and then use the learned knowledge about the target domain to regularize the network predictions. section: approach in this section, we present the details of the proposed curriculum domain adaptation for semantic segmentation of urban scene images. unlike previous work that aligns the domains via an intermediate feature space and thereby implicitly assumes the existence of the same decision function for the two domains, it is our intuition that, for structured prediction (i.e., semantic segmentation here), the cross-domain generalization of machine learning models can be more efficiently improved if we avoid this assumption and instead train them subject to necessary properties they should retain in the target domain. paragraph: preliminaries. in particular, the properties are about the pixel-wise category labels of an arbitrary image from the target domain, where and are the width and height of the image, respectively, and is the number of categories. we use one-hot vector encoding for the groundtruth labels, i.e., takes the value of 0 or 1 and the latter means that the-th label is assigned by a human annotator to the pixel at. correspondingly, the prediction by a segmentation network is realized by a softmax function per pixel. we express each target property in the form of a distribution over the categories, where represents the occupancy proportion of the category over the-th target image or a superpixel of the image. therefore, one can immediately calculate the distribution given the human annotations to the image. for instance, the image level label distribution is expressed by similarly, we can compute the target property/ distribution from the network predictions and denote it by. subsection: domain adaptation using the target properties ideally, we would like to have a segmentation network to imitate human annotators on the target domain. therefore, necessarily, the properties of their annotation results should be the same too. we capture this notion by minimizing the cross entropy at training, where the first term of the right-hand side is the entropy and the second is the kl-divergence. given a mini-batch consisting of both source images () and target images (), the overall objective function for training the cross-domain generalizing segmentation network is, where is the pixel-wise cross-entropy loss defined over the sufficiently labeled source domain images, enforcing the network to have the pixel level discriminative capabilities, and the second term is over the unlabeled target domain images, hinting the network what necessary properties its predictions should have in the target domain. we use to balance the two strengths in training and superscript to index different types of label distributions. note that in the domain adaptation context, we actually can not directly compute the label distribution from the groundtruth annotations of the target domain. nonetheless, estimating them using the labeled source data is easier than assigning labels to every single pixel of the target images. we present the details in the next section. paragraph: remarks. mathematically, the objective function has a similar form as in model compression. we thus borrow some concepts to gain more intuitive understanding about our domain adaptation procedure. the\" student\" network follows a curriculum to learn simple knowledge about the target domain before it addresses the hard one of semantically segmenting images. the models inferring the target properties act like\" teachers\", as they hint what label distributions the final solution (image annotation) may have in the target domain at the image and superpixel levels. another perspective is to understand the target properties as a posterior regularization for the network. the posterior regularization can conveniently encode a priori knowledge into the objective function. some applications include weakly supervised segmentation and detection, and rule-regularized training of neural networks. in addition to the domain adaptation setting and novel target properties, another key distinction of our work is that we decouple the label distributions from the network predictions and thus avoid the em type of optimizations. our approach learns the segmentation network with almost effortless changes to the popular deep learning tools. subsection: inferring the target properties thus far we have presented the\" hard\" task in the curriculum domain adaptation. in this section, we describe the\" easy\" ones, i.e., how to infer the target properties without accessing the image annotations of the target domain. our contributions also include selecting the particular property of label distributions to constitute the simple tasks. subsubsection: global label distributions of images due to the domain disparity, a baseline segmentation network trained on the source domain (i.e., using the first term of eq. ([reference])) could be easily crippled given the target images. in our experiments, we find that our baseline network constantly mistakes streets for sidewalks and/ or cars (cf. figure [reference]). consequently, the predicted labels for the pixels are highly disproportionate. to rectify this, we employ the label distribution over the global image as our first property (cf. eq. ([reference])). without access to the target labels, we have to train machine learning models from the labeled source images to estimate the label distribution for the target image. nonetheless, we argue that this is less challenging than generating the per-pixel predictions despite that both tasks are influenced by the domain mismatch. in our experiments, we examine different approaches to this task. we extract image features using the inception-resnet-v2 as the input to the following models. although multinomial logistic regression (lr) is mainly used for classification, its output is actually a valid distribution over the categories. for our purpose, we thus train it by replacing the one-hot vectors in the cross-entropy loss with the groundtruth label distribution, which is calculated using eq. ([reference]) and the available human labels of the source domain. given a target image, we directly take the lr's output as the predicted label distribution. we also test a nonparametric method by simply retrieving the nearest neighbors (nns) for a target image and then transferring the mean of the nns' label distributions to the target image. we use the distance for the nn retrieval. finally, we include two dumb predictions as the control experiment. one is, for any target image, to output the mean of all the label distributions in the source domain (source mean), and the other is to output a uniform distribution. subsubsection: local label distributions of landmark superpixels the image level label distribution globally penalizes potentially disproportional segmentation output on the target domain, and yet is inadequate in providing spatial constraints. in this section, we consider the use of label distributions over some superpixels as the anchors to drive the network towards spatially desired target properties. note that it is not necessary, and is even harmful, to use all of the superpixels in a target image to regularize the segmentation network, because that would be too strong a force and may overrule the pixel-wise discriminativeness revealed by the labeled source images, especially when the label distributions are not inferred accurately enough. in order to have the dual effect of both estimating the label distributions of superpixels and filtering the superpixels, we simplify the problem and employ a linear svm in this work. in particular, we segment each image into 100 superpixels using linear spectral clustering. for the superpixels of the source domain, we are able to assign a single dominant label to each of them, and then use the labels and the corresponding features extracted from the superpixels to train a multi-class svm. given a test superpixel of a target image, the multi-class svm returns a class label as well as a decision value, which is interpreted as the confidence score about classifying this superpixel. we keep the top 60% superpixels, called landmark superpixels, in the target domain and calculate their label distributions as the second type of\" easy\" tasks. in particular, the class label of a landmark superpixel is encoded into a one-hot vector, which serves as a valid distribution about the categories in the landmark superpixel. albeit simple, we find this method works very well in our experiments. we encode both visual and contextual information to represent a superpixel. first, we use the fcn-8s pre-trained on the pascal context dataset, which has 59 distinct classes, to obtain 59 detection scores for each pixel. we then average them within each superpixel. finally, we represent a superpixel by the concatenation of the 59d vectors of itself, its left and right superpixels, as well as the two respectively above and below it. subsection: curriculum domain adaptation: recapitulation we recap the proposed curriculum domain adaptation using figure [reference] before presenting the experiments in the next section. our main idea is to execute the domain adaptation step by step, starting from the easy tasks that are less sensitive to the domain discrepancy than the semantic segmentation. we choose the labels distributions over global images and local landmark superpixels in this work; more tasks will be explored in the future. the solutions to them provide useful gradients originating from the target domain (cf. the arrows with brown color in figure [reference]), while the source domain feeds the network with well-labeled images and segmentation masks (cf. the dark blue arrows in figure [reference]). section: experiments in this section, we describe the experimental setup and compare the results of our approach, its variations, and some existing baseline methods. subsection: segmentation network and optimization in our experiments, we use fcn-8s as our semantic segmentation network. we initialize its convolutional layers with vgg-19, and then train it using the adadelta optimizer with default parameters. each mini-batch is comprised of five source images and five randomly chosen target images. when we train the baseline network with no adaptation, however, we try to use the largest possible mini-batch that includes 15 source images. the network is implemented in keras and theano. we train different versions of the network on a single tesla k40 gpu. unlike the existing deep domain adaptation methods which introduce regularization to the intermediate layers, we only revise the loss function over the output. hence, our curriculum domain adaptation can be readily applied to other segmentation networks (e.g.,). subsection: datasets and evaluation we use the publicly available cityscpaes and synthia datasets in our experiments. cityscapes is a real-world, vehicle-egocentric image dataset collected in 50 cities in germany and nearby countries. it provides four disjoint subsets: 2, 993 training images, 503 validation image, 1, 531 test images, and 20, 021 auxiliary images. all the training, validation, and test images are accurately annotated with per pixel category labels, while the auxiliary set is coarsely labeled. there are 34 distinct categories in the dataset. synthia is a large dataset of synthetic images and provides a particular subset, called synthia-rand-cityscapes, to pair with cityscapes. this subset contains 9, 400 images that are automatically annotated with 12 object categories, one void class, and some unnamed classes. note that the virtual city used to generate the synthetic images does not correspond to any of the real cities covered by cityscapes. we abbreviate synthia-rand-cityscapes to synthia hereon. paragraph: domain idiosyncrasies. although both datasets depict urban scenes, and synthia is created to be as photo-realistic as possible, they are mismatched domains in several ways. the most noticeable difference is probably the coarse-grained textures in synthia; very similar texture patterns repeat in a regular manner across different images. in contrast, the cityscapes images are captured by high-quality dash-cameras. another major distinction is the variability in view angles. since cityscapes images are recorded by the dash cameras mounted on a moving car, they are viewed from almost a constant angle that is about parallel to the ground. more diverse view angles are employed by synthia\u2014 it seems like some cameras are placed on the buildings that are significantly higher than a bus. finally, some of the synthia images are severely shadowed by extreme lighting conditions, while we find no such conditions in the cityscapes images. these combined factors, among others, make domain adaptation from synthia to cityscapes a very challenging problem. figure [reference] shows some example images from both datasets. we pair each cityscpaes image with its nearest neighbor in synthia, retrieved by the inception-resnet-v2 features. however, the cross-dataset nearest neighbors are visually very different from the query images, verifying the dramatic disparity between the two domains. paragraph: experiment setup. since our ultimate goal is to solve the semantic segmentation problem for real images of urban scenes, we take cityscapes as the target domain and synthia as the source domain. the cityscapes validation set is used as our test set. we split 500 images out of the cityscpaes training set for the validation purpose (e.g., to monitor the convergence of the networks). in training, we randomly sample mini-batches from both the images (and their labels) of synthia and the remaining images of cityscapes yet with no labels. as in, we manually find 16 common classes between the two datasets: sky, building, road, sidewalk, fence, vegetation, pole, car, traffic sign, person, bicycle, motorcycle, traffic light, bus, wall, and rider. the last four are unnamed and yet labeled in synthia. paragraph: evaluation. we use the evaluation code released along with the cityscapes dataset to evaluate our results. it calculates the pascal voc intersection-over-union, i.e.,, where tp, fp, and fn are the numbers of true positive, false positive, and false negative pixels, respectively, determined over the whole test set. since we have to resize the images before feeding them to the segmentation network, we resize the output segmentation mask back to the original image size before running the evaluation against the groundtruth annotations. subsection: results of inferring global label distributions before presenting the final semantic segmentation results, we first compare the different approaches to inferring the global label distributions of the target images (cf. section [reference]). we report the results on the held-out validation images of cityscapes in this experiment, and then select the best method for the remaining experiments. in table [reference], we compare the estimated label distributions with the groundtruth ones using the distance, the smaller the better. we see that the baseline network (noadapt), which is directly learned from the source domain without any adaptation methods, outperforms the dumb uniform distribution (uniform) and yet no other methods. this confirms that the baseline network gives rise to severely disproportionate predictions over the target domain. another dumb prediction (src mean), i.e., using the mean of all label distributions over the source domain as the prediction for the target images, however, performs reasonably well. to some extent, this indicates the value of the simulated source domain for the semantic segmentation task of urban scenes. finally, the nearest neighbors (nn) based method and the multinomial logistic regression (lr) (cf. section [reference]) perform the best. we use the output of lr on the target domain in our remaining experiments. subsection: comparison results bike fence wall t-sign pole mbike t-light sky bus rider veg bldg car person sidewalk road we report the final semantic segmentation results on the test data of the target domain in this section. we compare our approach to the following competing methods. we directly train the fcn-8s model on synthia without applying any domain adaptation methods. this is the most basic baseline for our experiments. recall that we have trained a multi-class svm using the dominant labels of the superpixels in the source domain. we then use them to classify the target superpixels. since we keep the top 60% most confidently classified superpixels as the landmarks to regularize our segmentation network during training (cf. section [reference]), it is also interesting to examine the classification results of these superpixels. we run the evaluation after assigning the void class label to the other pixels of the images. in addition to the iou, we have also evaluated the classification results of the superpixels by accuracy. we find that the classification accuracy is 71% for all the superpixels of the target domain, while for the selected 60% landmark superpixels, the classification accuracy is more than 88%. hoffman et al.'s work is the only existing one addressing the same problem as ours, to the best of our knowledge. they introduce a pixel-level adversarial loss to the intermediate layers of the network and impose constraints to the network output. their experimental setup is about identical to ours except that they do not specify which part of cityscapes is considered as the test set. nonetheless, we include their results for comparison to put our work in a better perspective. the comparison results are shown in table [reference]. immediately, we note that all our domain adaptation results are significantly better than those without adaptation (noadapt). we denote by (ours (i)) the network trained using the global label distributions over the target images (and the labeled source images). although one may wonder that the image-wise label distributions are too high-level to supervise the pixel-wise discriminative network, the gain is actually significant. they are able to correct some obvious errors of the baseline network, such as the disproportional predictions about road and sidewalk (cf. the results of ours (i) vs. noadapt in the last two columns). it is interesting to see that both superpixel classification-based segmentation results (sp and sp lndmk) are also better than the baseline network (noadapt). the label distributions obtained over the landmark superpixels boost the segmentation network (ours (sp)) to the mean iou of 28.1%, which is better than those by either superpixel classification or the baseline network individually. we have also tried to use the label distributions over all the superpixels to train the network, and observe little improvement over noadapt. this is probably because it is too forceful to regularize the network output at every single superpixel especially when the estimated label distributions are not accurate enough. the superpixel-based methods, including ours (sp), miss small objects such as fences, traffic lights (t-light), and traffic signs (t-sign), and instead are very accurate for categories like the sky, road, and building, that typically occupy larger image regions. on the contrary, the label distributions on the images give rise to a network (ours (i)) that performs better on the small objects than ours (sp). in other words, they mutually complement to some extent. re-training the network by using the label distributions over both global images and local landmark superpixels (ours (i+ sp)), we achieve the best semantic segmentation results on the target domain. in the future work, it is worth exploring other target properties, perhaps still in the form of label distributions, that handle the small objects well, in order to further complement the superpixel-level label distributions. paragraph: comparison with fcns in the wild. although we use the same segmentation network (fcn-8s) as, our baseline results (noadapt) are better than those reported in. this may be due to subtle differences in terms of implementation or experimental setup. although our own baseline results are superior, we gain larger improvements (7%) over them than the performance gain of (3%) over the seemingly underperforming baseline network there. paragraph: comparison with learning domain-invariant features. at our first attempt to solve the domain adaptation problem for the semantic segmentation of urban scenes, we tried to learn domain invariant features following the deep domain adaptation methods for classification. in particular, we impose the maximum mean discrepancy over the layer before the output. we name such network layer the feature layer. since there are virtually three output layers in fcn-8s, we experiment with all the three feature layers correspondingly. we have also tested the domain adaptation by reversing the gradients of a domain classifier. however, none of these efforts lead to any noticeable gain over the baseline network so the results are omitted. section: conclusion in this paper, we address domain adaptation for the semantic segmentation of urban scenes. we propose a curriculum style approach to this problem. we learn to estimate the global label distributions of the images and local label distributions of the landmark superpixels of the target domain. such tasks are easier to solve than the pixel-wise label assignment. therefore, we use their results to effectively regularize our training of the semantic segmentation network such that its predictions meet the inferred label distributions over the target domain. our method outperforms several competing methods that do domain adaptation from simulated images to real photos of urban traffic scenes. in future work, we will explore more target properties that can be conveniently inferred to enrich our curriculum domain adaptation framework. paragraph: acknowledgements. this work is supported by the nsf award iis# 1566511, a gift from adobe systems inc., and a gpu from nvidia. we thank the anonymous reviewers and area chairs for their insightful comments. bibliography: references bike fence wall t-sign pole mbike t-light sky bus rider veg terrain train bldg car person truck sidewalk road appendix: gta cityscapes the main text above has been accepted to ieee international conference on computer vision (iccv) 2017. after the paper submission, we have been continuously working on the project and have got more results. we include them below to complement the experiments in the main text. the new experiment is basically the same as the one in the main text except that we replace synthia with the gta dataset. gta is a synthetic, vehicle-egocentric image dataset collected from the open world in the realistically rendered computer game grand theft auto v (gta, or gta5). it contains 24, 996 images, whose semantic segmentation annotations are fully compatible with the classes used in cityscapes. hence we use all the 19 official training classes in our experiment. the results are shown in table [reference]. as in the main text, the same observations about our approach apply here. additionally, we note that the results are overall better than those adapting from synthia to cityscapes. this is not surprising, because the gta images are more photo-realistic than synthia's.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "synthia"
                    ],
                    [
                        "cityscpaes"
                    ],
                    [
                        "synthia"
                    ],
                    [
                        "synthia datasets"
                    ],
                    [
                        "cityscapes validation set"
                    ]
                ],
                "Method": [
                    [
                        "domain adaptation"
                    ],
                    [
                        "pixel wise discriminative segmentation network"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "segmentation"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "gta cityscapes"
                    ]
                ],
                "Method": [
                    [
                        "curriculum domain adaptation",
                        "curriculum-style domain adaptation approach",
                        "curriculum-style domain adaptation",
                        "curriculum domain adaptation strategy",
                        "cross-domain generalization of machine learning models",
                        "cross-domain generalizing segmentation network",
                        "curriculum domain adaptation framework"
                    ]
                ],
                "Metric": [
                    [
                        "mean iou"
                    ]
                ],
                "Task": []
            }
        ]
    },
    "3ca3993b1f3536b15112f759067f62e999c5d38f-57": {
        "doctext": "bb8: a scalable, accurate, robust to partial occlusion method for predicting the 3d poses of challenging objects without using depth section: abstract we introduce a novel method for 3d object detection and pose estimation from color images only. we first use segmentation to detect the objects of interest in 2d even in presence of partial occlusions and cluttered background. by contrast with recent patch-based methods, we rely on a\" holistic\" approach: we apply to the detected objects a convolutional neural network (cnn) trained to predict their 3d poses in the form of 2d projections of the corners of their 3d bounding boxes. this, however, is not sufficient for handling objects from the recent t-less dataset: these objects exhibit an axis of rotational symmetry, and the similarity of two images of such an object under two different poses makes training the cnn challenging. we solve this problem by restricting the range of poses used for training, and by introducing a classifier to identify the range of a pose at run-time before estimating it. we also use an optional additional step that refines the predicted poses. we improve the state-of-the-art on the linemod dataset from 73.7% [2] to 89.3% of correctly registered rgb frames. we are also the first to report results on the occlusion dataset [1] using color images only. we obtain 54% of frames passing the pose 6d criterion on average on several sequences of the t-less dataset, compared to the 67% of the state-of-the-art [10] on the same sequences which uses both color and depth. the full approach is also scalable, as a single network can be trained for multiple objects simultaneously. section: introduction 3d pose estimation of object instances has recently become a popular problem again, because of its application in robotics, virtual and augmented reality. many recent approaches rely on depth maps, sometimes in conjunction with color images [reference][reference][reference][reference][reference][reference][reference][reference][reference][reference]. however, it is not always possible to use depth cameras, as they fail (c) (d) figure 1. zooms on estimated poses for (a) the ape of the linemod dataset [reference], (b) the driller of the occlusion dataset [reference], (c) and (d) three objects of the t-less [reference] dataset. the green bounding boxes correspond to the ground truth poses, and the blue bounding boxes to the poses estimated with our method. the two boxes often overlap almost perfectly, showing the accuracy of our estimated poses. the parts of the bounding boxes occluded by the object were removed using the object mask rendered from our estimated pose. in (b), we can still obtain a good pose despite the large occlusion by the bench vise. in (c) and (d), we also obtain very good estimates despite large occlusions, the similarities between the objects, and the fact that the symmetries challenge the learning algorithms. outdoor or on specular objects. in addition, they drain the batteries of mobile devices, being an active sensor. it is therefore desirable to rely only on color images for 3d pose estimation, even if it is more challenging. recent methods [reference][reference][reference] work by identifying the' object coordinates' of the pixels, which are the pixels' 3d coordinates in a coordinate system related to the object [reference]. the object 3d pose can then be estimated using a pnp algorithm from these 2d-3d correspondences. [reference] obtain similar correspondences by associating some pixels in selected parts of the object with virtual 3d points. however, obtaining these 2d-3d correspondences from local patches is difficult and the output is typically very noisy for these methods. a robust optimization is then needed to estimate the pose. in this paper, we argue for a\" holistic\" approach, in the sense that we predict the pose of an object directly from its appearance, instead of identifying its individual surface points. as we will show, this approach provides significantly better results. we first detect the target objects in 2d. we show that using object segmentation performs better for this task compared to a standard sliding window detector, in particular in presence of partial occlusion. we then apply a cnn to predict the 3d pose of the detected objects. while the predicted 3d pose can be represented directly by a translation and a rotation, we achieve better accuracy by using a representation similar to the one used in [reference] for object parts: we predict the 2d projections of the corners of the object's bounding box, and compute the 3d pose from these 2d-3d correspondences with a pnp algorithm. compared to the object coordinate approaches the predictions are typically outlier-free, and no robust estimation is thus needed. compared to the direct prediction of the pose, this also avoids the need for a meta-parameter to balance the translation and rotation terms. unfortunately, this simple approach performs badly on the recent and challenging t-less dataset. this dataset is made of manufactured objects that are not only similar to each other, but also have one axis of rotational symmetry. for example, the squared box of fig. 1 (c) has an angle of symmetry of 90\u2022 and the other object has an angle of symmetry of 0\u2022 since it is an object of revolution; object# 5 in fig. 1 (d) is not perfectly symmetrical but only because of the small screw on the top face. the approach described above fails on these objects because it tries to learn a mapping from the image space to the pose space. since two images of a symmetrical object under two different poses look identical, the image-pose correspondence is in fact a one-to-many relationship. this issue is actually not restricted to our approach. for example, [reference], which relies on object coordinates, does not provide results on the bowl object of the linemod dataset, an object with an axis of symmetry: it is not clear which coordinates should be assigned to the 3d points of this object, as all the points on a circle orthogonal to the axis of symmetry have the same appearance. to solve this problem, we train the method described above using images of the object under rotation in a restricted range, such that the training set does not contain ambiguous images. in order to recover the object pose under a larger range of rotation, we train a classifer to tell under which range the object rotation is. again, this is easy to do with a\" holistic\" approach, and this classifier takes an image of the entire object as input. as we will explain in more details, we can then always use the cnn trained on the restricted range to estimate any pose. in addition, we will show how to adapt this idea to handle\" approximatively symmetrical\" objects like object# 5. this approach allows us to obtain good performance on the t-less dataset. finally, we show that we can add an optional last step to refine the pose estimates by using the\" feedback loop\" proposed in [reference] for hand detection in depth images: we train a network to improve the prediction of the 2d projections by comparing the input image and a rendering of the object for the initial pose estimate. this allows us to improve even more our results on the linemod and occlusion datasets. our full approach, which we call bb8, for the 8 corners of the bounding box, is also very fast, as it only requires to apply deep networks to the input image a few times. in the remainder of the paper, we first discuss related work, describe our approach, and compare it against the state-ofthe-art on the three available datasets. section: related work the literature on 3d object detection is very large, thus we will focus only on recent works. keypoint-based methods [reference][reference] were popular for a long time and perform well but only on very textured objects. the apparition of inexpensive 3d cameras favored the development of methods suitable for untextured objects: [reference][reference] rely on depth data only and use votes from pairs of 3d points and their normals to detect 3d objects. [reference] uses a decision tree applied to rgb-d images to simultaneously recognize the objects and predict their poses. [reference][reference] consider a template-based representation computed from rgb-d or rgb data, which allows for large scale detection [reference]. however, this template approach is sensitive to partial occlusions. to tackle clutter and partial occlusions, [reference] and [reference] rely on local patches recognition performed with random forests. in particular, [reference] considers' 3d object coordinates': a random forest is trained to predict the 3d location in the object coordinate system of each image location. the prediction of this forest is integrated in an energy function together with a term that compares the depth map with a rendering of the object and a term that penalizes pixels that lie on the object rendering but predicted by the forest to not be an object point. this energy function is optimized by a ransac procedure. [reference] replaces this energy function by an energy computed from the output of a cnn trained to compare observed image features and features computed from a 3d rendering of the potentially detected object. this makes the approach very robust to partial occlusions. these works, however, are designed for rgb-d data. [reference] extends this work and relies on rgb data only, as we do. they use auto-context [reference] to obtain better predictions from the random forests, estimate a distribute over the object coordinates to handle the prediction uncertainties better, and propose a more sophisticated ransac-like method that scales with the number of objects. this results in an efficient and accurate method, however, robustness to partial occlusions are not demonstrated. [3] is related to [reference][reference][reference] but focuses on providing sparse 2d-3d correspondences from reliable object parts. unfortunately, it provides results on its own dataset only, not on more broadly available datasets. like us, [reference] relies on a cnn to directly predict a 3d pose, but in the form of a translation and a rotation. it considers camera relocalisation in urban environment rather than 3d object detection, and uses the full image as input to the cnn. by predicting the 2d projections of the corners of the bounding box, we avoid the need for a meta-parameter to balance the position and orientation errors. as shown in our experiments, the pose appears to be more accurate when predicted in this form. intuitively, this should not be surprising, as predicting 2d locations from a color images seems easier than predicting a 3d translation and a quaternion, for example. [6] also uses a cnn to predict the 3d pose of generic objects but from rgb-d data. it first segments the objects of interest to avoid the influence of clutter. we tried segmenting the objects before predicting the pose as well, however, this performed poorly on the linemod dataset, because the segmented silhouttes were not very accurate, even with state-of-the-art segmentation methods. in summary, our method appears to be one of the first to deal with rgb data only to detect 3d objects and estimate their poses on recent datasets. as we will show in the experiments, it outperforms the accuracy of the state-of-theart [reference] by a large margin. section: proposed approach in our approach, we first find the objects in 2d, we obtain a first estimate of the 3d poses, including objects with a rotational symmetry, and we finally refine the initial pose estimates. we describe each step in this section. section: localizing the objects in 2d we first identify the 2d centers of the objects of interest in the input images. we could use a standard 2d object detector, but we developed an approach based on segmentation that resulted in better performance as it can provide accurate locations even under partial occlusions. compared to our initial tests using a sliding window, this ap-proach improved our 2d detection results from about 75% to 98.8% correct detection rate based on a iou of 0.5. we only need a low resolution segmentation and thus do not need a hourglass-shaped architecture [reference], which makes our segmentation more efficient. as shown in fig. 2, our approach performs a two-level coarse-to-fine object segmentation. for each level, we train a single network for all the objects. the first network is obtained by replacing the last layer of vgg [reference] by a fully connected layer with the required number of output required by each step, and fine-tune it. the second network has a simple, ad hoc architecture. more exactly, the first network is trained to provide a very low resolution binary segmentation of the objects given an image region j of size 128\u00d7 128 by minimizing the following objective function: where t s is a training set made of image regions j, and the corresponding segmentations s for object o, (f is the output of network f 1\u03c6 for region j and object o.\u03c6 denotes the network's parameters, optimized during training. for the linemod and occlusion datasets, there is at most one object for a given region j, but more objects can be present for the t-less dataset. at run-time, to get the segmentations, we compute: where s 1, o is a 8\u00d7 8 binary segmentation of j for object o, and\u03c4 1 is a threshold used to binarize the network's output. to obtain a binary segmentation for the full input image, we split this image into regions and compute the s 1, o for each region. this gives us one binary segmentation s 1, o for the full input image, and each possible object. this usually results in a single connected component per visible object; if several components are present, we keep only the largest one for each object. if the largest component in a segmentation s 1, o is small, object o is likely not visible. for the remaining object (s), we refine the shape of the largest component by applying a second network to each 16\u00d7 16 image patch p that corresponds to an active location in s 1: using notations similar to the ones in eq. [reference]. since the input to f 2\u03c8 (p) has a low resolution, we do not need a complex network such as vgg [reference], and we use a much simpler architecture with 2 convolutional layers and 2 pooling layers. we finally obtain a segmentation s 2, o with resolution 64\u00d7 48 for the full input image and each visible object o. we therefore get the identities o of the visible object (s), and for these objects, we use the segmentation centroids as their 2d centers, to compute the 3d poses of the objects as described below. section: predicting the 3d pose we predict the 3d pose of an object by applying a deep network to an image window w centered on the 2d object center estimated as described in the previous section. as for the segmentation, we use vgg [reference] as a basis for this network. this allows us to handle all the objects of the target dataset with a single network. it is possible to directly predict the pose in the form of a 3-vector and an exponential map for example, as in [reference]. however, a more accurate approach was proposed in [reference] for predicting the poses of object parts. to apply it here, we minimize the following cost function over the parameters\u03b8 of network g\u03b8: where t is a training set made of image windows w containing object o under a pose defined by an exponential map e and a 3-vector t. the m o i are the 3d coordinates of the corners of the bounding box of object o in the object coordinate system. proj e, t (m) projects the 3d point m on the image from the pose defined by e and t. returns the two components of the output of g\u03b8 corresponding to the predicted 2d coordinates of the i-th corner for object o.\u2022 modulo 180\u2022 (c). our solution is to restrict the range during training to be between 0\u2022 and 90\u2022. we use a classifier to detect if the pose in an input image is between 90\u2022 and 180\u2022. if this is the case (d), we mirror the input image (e), and mirror back the predicted projections for the corners (f). at run-time, the segmentation gives the identity and the 2d locations of the visible object (s) o. the 3d pose can then be estimated for the correspondences between the 3d points m o i and the predicted m i ((g\u03b8 (w)) [o]) using a pnp algorithm. other 3d points could be used here, however, the corners of the bounding box are a natural choice as they frame the object and are well spread in space 1. section: handling objects with an axis of symmetry if we apply the method described so far to the t-less dataset, the performances are significantly lower than the performances on the linemod dataset. as mentioned in the introduction, this is because training images w in eq. (4) for the objects of this dataset can be identical while having very different expected predictions proj e, t (m o i), because of the rotational symmetry of the objects. we first remark that for an object with an angle of symmetry\u03b1, its 3d rotation around its axis of symmetry can be defined only modulo\u03b1, not 2\u03c0. for an object with an angle of symmetry\u03b1, we can therefore restrict the poses used for training to the poses where the angle of rotation around the symmetry axis is within the range [0;\u03b1 [, to avoid the ambiguity between images. however, this solves our problem only partially: images at one extremity of this range of poses and the images at the other extremity, while not identical, still look very similar. as a result, for input images with an angle of rotation close to 0 modulo\u03b1, the pose prediction can still be very bad, as illustrated in fig. 3. to explain our solution, let us first denote by\u03b2 the rotation angle, and introduce the intervals r 1= [0;\u03b1/ 2 [and r 2= [\u03b1/ 2;\u03b1 [. to avoid ambiguity, we restrict\u03b2 to be in r 1 for the training images used in the optimization problem of eq. (4). the drawback is of course that, without doing anything else, we would not be able to estimate the poses when\u03b2 is in r 2. we therefore introduce a cnn classifier k (\u00b7) to predict at run-time if\u03b2 is in r 1 or r 2: if\u03b2 is in r 1, we can estimate the pose as before; if\u03b2 is in r 2, one option would be to apply another g\u03b8 (\u00b7) network trained for this range. however, it is actually possible to use the same network g\u03b8 (\u00b7) for both r 1 and r 2, as follows. if the classifier predicts that\u03b2 in in r 2, we mirror the input image w: as illustrated in fig. 3 (e), the object appears in the mirror image with a rotation angle equal to\u03b1\u2212\u03b2, which is in r 1. therefore we can apply g\u03b8 (\u00b7) to the mirrored w. to obtain the correct pose, we finally mirror back the projections of the corners predicted by g\u03b8 (\u00b7). we currently consider the case where the axis of symmetry is more or less vertical in the image, and mirror the image from left to right. when the axis is closer to be horizontal, we should mirror the image from top to bottom. objects of revolution are a special and simpler case: since their angle of symmetry is 0\u2022, we predict their poses under the same angle of rotation. for training the pose predictor g\u03b8 (\u00b7), we use the original training images with angles of rotation in r 1, and mirror the training images with angles of rotation in r 2. handling objects that are' not exactly symmetrical' as mentioned in the introduction, some objects of the t-less dataset are only approximately symmetrical, such as object# 5 in fig. 1 (d). the small details that make the object not perfectly symmetrical, however, do not help the optimization problem of eq. (4), but we would still like to predict the pose of this object. in the case of object# 5, we consider 4 regions instead of 2: r 1= [0;\u03c0/ 2 [, r 1= [\u03c0/ 2;\u03c0 [, r 3= [\u03c0; 3\u03c0/ 2 [, and r 4= [3\u03c0/ 2; 2\u03c0 [, and we train the classifier k (\u00b7) to predict in which of these four regions the angle of rotation\u03b2 is. if\u03b2\u2208 r 2 or\u03b2\u2208 r 4, we mirror the image before computing the pose as before. then, if\u03b2\u2208 r 3 or\u03b2\u2208 r 4, we still have to add\u03c0 to the angle of rotation of the recovered pose to get an angle between 0 and 2\u03c0. section: refining the pose we also introduce an optional additional stage to improve the accuracy of the pose estimates inspired by [reference]. as illustrated in fig. 4, we train another cnn that predicts an update to improve the pose. because this cnn takes 4 or 6 channels as input, it is not clear how we can use vgg, as we did for the previously introduced networks, and we use here one cnn per object. however, this stage is optional, and without it, we already outperform the-state-of-the-art. the first image is the image window w as for g\u03b8 (\u00b7). the second image depends on the current estimate of the pose: while [reference] generates a depth map with a deep network, we render (using opengl) either a binary mask or a color rendering of the target object as seen from this current estimate. more formally we train this cnn by minimizing: where h\u00b5 denotes the cnn,\u00b5 its parameters; n (e, t) is a set of poses sampled around pose (e, t), and render (e, t) a function that returns a binary mask, or a color rendering, of the target object seen from pose (e, t). at run-time, given a current estimate of the object pose represented by the projections of the cornersv= [...m i...], and the corresponding parameterisation (\u00ea, t), we can update this estimate by invoking h\u00b5 (\u00b7): section: generating training images in section 4, we will compare our method to the stateof-the art for 3d object detection in color images [reference], and like them, for each of 15 objects of the linemod dataset, we use 15% of the images for training and use the rest for testing. the training images are selected as in [reference], such that relative orientation between them should be larger than a threshold. we also tried a random selection, and there was only a slight drop in performance, for some objects only. the selection method thus does not seem critical. the t-less dataset provides regularly sampled training images. as shown in fig. 5, we also use a similar method as [reference] to augment the training set: we extract the objects' silhouettes from these images, which can be done as the ground figure 5. two generated training images for different objects from the linemod dataset [reference]. the object is shifted from the center to handle the inaccuracy of the detection method, and the background is random to make sure that the network g\u03b8 can not exploit the context specific to the dataset. truth poses and the objects' 3d models are available. note that this means the results are not influenced by the scene context, which makes the pose estimation more difficult. to be robust to clutter and scale changes, we scale the segmented objects by a factor of s\u2208 [0.8, 1.2], and change the background by a patch extracted from a randomly picked image from the imagenet dataset [reference]. moreover, the object is shifted by some pixels from the center of the image window in both x and y directions. this helps us to handle small object localization errors made during detection. section: experiments in this section, we present and discuss the results of our evaluation. we first describe the three evaluation metrics used in the literature and in this paper. we evaluate our method on all the possible datasets with color images for instance 3d detection and pose estimation we are aware of: the linemod [reference], occlusion [reference], and t-less [reference] datasets. section: evaluation metrics as in [reference], we use the percentage of correctly predicted poses for each sequence and each object, where a pose is considered correct if it passes the tests presented below. section: 2d projections [2] this is a metric suited for applications such as augmented reality. a pose is considered correct if the average of the 2d distances between the projections of the object's vertices from the estimated pose and the ground truth pose is less than 5 pixels. 6d pose [reference] with this metric, a pose is considered correct if the average of the 3d distances between the transformed of the object's vertices table 1. evaluation using the 2d projections metric of using the 2d projections of the bounding box (' bb'), compared to the direct prediction of the pose (' direct'), and of the refinement methods. for this evaluation, we used the ground truth 2d object center to avoid the influence of the detection. for the objects marked with a (*), we optimize the value of the weight balancing the rotation and translation terms on the test set, giving an advantage to the' direct' pose method. for the other objects, we used the value that is optimal for both the ape and the driller. is less than 10% of the object's diameter. v is the set of the object's vertices, (\u00ea, t) the estimated pose and (\u0113, t) the ground truth pose, and tr e, t (\u00b7) a rigid transformation by rotation e, translation t. for the objects with ambigious poses due to symmetries, [reference] replaces this measure by: 5 cm 5\u2022 metric [reference] with this metric, a pose is considered correct if the translation and rotation errors are below 5 cm and 5\u2022 respectively. section: contributions of the different steps the columns' bb',' mask ref. [reference], and' rgb ref.' of table 1 compare the results of our method before and after two iterations of refinement, using either a binary mask or a color rendering. for this evaluation, we used the ground truth 2d object center to avoid the influence of the detection. using refinement improves the results on average by 4.5% and 6.3% for the mask and color rendering respectively. using a color rendering systematically yields the best results, but using the binary mask yields already a significant improvement, showing that an untextured model can be used. [reference] and our method without and with rgb refinement using our segmentation-based method to obtain the 2d object centers on the linemod dataset. [reference] does not provide results for the bowl and the cup, hence for the sake of comparison the average is taken over the first 13 objects. section: the linemod dataset: comparison with [2] table 2 compares our bb8 method with and without rgb refinement against the one presented in [reference] on the linemod dataset. because of lack of space, we provide the results without refinement only for the 2d projection metric, however, the results for the other metrics are comparable. for this evaluation, we used the results of our detection method presented in section 3.1, not the ground truth 2d object center. our method outperforms [reference] by a large margin: 15.6% for 2d projection, 12.6% for 6d pose and 28.4% for the 5 cm 5\u2022 metric. fig. 7 shows qualitative results for our method on this dataset. for most of the images, the two bounding boxes, for the ground truth pose and for the pose we estimate, overlap almost perfectly. section: the occlusion dataset: robustness to partial occlusions the occlusion dataset was created by [reference] from the linemod dataset. the partial occlusions make it significantly more difficult, and to the best of our knowledge, the only published results use both color and depth data. [reference] provide results using only color images, but limited to 2d detection, not 3d pose estimation. we only use images from the linemod dataset to generate our training images by using the approach explained in section 3.5, except that we also randomly superimpose objects extracted from the other sequences to the target ob-ject to be robust to occlusions. we do not use any image of the test sequence to avoid having occlusions similar to the ones presented in the test sequence. although all the poses in the test sets are not visible in the training sequences, we can estimate accurate poses with a 2d projection error lower than 15px for about 80% of the frames for these seven objects. we do not report the performance of our method for the eggbox, as more than 70% of close poses are not seen in the training sequence. some qualitative results are shown in the second row of fig. 7. to the best of our knowledge, we are the first to present results on this dataset using color images only. section: the t-less dataset: handling objects with an axis of symmetry the test sequences of the t-less dataset are very challenging, with sometimes multiple instances of the same objects and a high amount of clutter and occlusion. we considered only scenes# 1,# 2,# 4,# 5, and# 7 in our experiments. it is also difficult to compare against the only published work on t-less [reference], as it provides the 6d pose metric averaged per object or per scene, computed using rgb-d data, while, to the best of our knowledge, we are the first to report results on the t-less dataset using rgb images figure 7. some qualitative results. first row: linemod dataset; second row: occlusion dataset; third row: t-less dataset (for objects of revolution, we represent the pose with a cylinder rather than a box); last row: some failure cases. from left to right: an example of a pose rejected by the 2d projections metric, a failure due to the lack of corresponding poses in the training set, two examples from t-less rejected by the 6d pose metric, and one failure due to the fact that some objects are made of several instances of another object. table 3. our quantitative results on t-less [reference]. most of the errors are along the z axis of the camera, as we rely on color images. only. similarly to [reference], we evaluate the poses with more than 10% of the object surface visible in the ground truth poses. as shown in table 3, the 6d pose average per scene with our method is 54%. the object 3d orientation and translation along the x and y axes of the camera are typically very well estimated, and most of the error is along the z axis, which should not be surprising for a method using color images only. section: computation times our implementation takes 140 ms for the segmentation, 130 ms for the pose prediction, and 21 ms for each refinement iteration, on an intel core i7-5820 k 3.30 ghz desktop with a geforce titan x. if there is only one object of interest, we can replace vgg by a specific network with a simpler architecture, the computation times then become 20 ms for the segmentation and 12 ms for the pose prediction, with similar accuracy. section: conclusion our\" holistic\" approach, made possible by the remarkable abilities of deep networks for regression, allowed us to significantly advance the state-of-the-art on 3d pose estimation from color images, even on challenging objects from the t-less dataset. section: section: acknowledgment: this work was funded by the christian doppler laboratory for semantic 3d computer vision. section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "t less"
                    ],
                    [
                        "t less dataset"
                    ],
                    [
                        "t less dataset"
                    ],
                    [
                        "t less dataset"
                    ],
                    [
                        "t less dataset"
                    ],
                    [
                        "t less dataset"
                    ],
                    [
                        "t less dataset"
                    ],
                    [
                        "t less dataset"
                    ]
                ],
                "Method": [
                    [
                        "bb8"
                    ],
                    [
                        "bb8"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "3d object detection"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "linemod dataset",
                        "linemod"
                    ]
                ],
                "Method": [
                    [
                        "bb8"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ]
                ],
                "Task": []
            }
        ]
    },
    "3cf31ecb2724b5088783d7c96a5fc0d5604cbf41-58": {
        "doctext": "document: simple and accurate dependency parsing using bidirectional lstm feature representations we present a simple and effective scheme for dependency parsing which is based on bidirectional-lstms (bilstms). each sentence token is associated with a bilstm vector representing the token in its sentential context, and feature vectors are constructed by concatenating a few bilstm vectors. the bilstm is trained jointly with the parser objective, resulting in very effective feature extractors for parsing. we demonstrate the effectiveness of the approach by applying it to a greedy transition-based parser as well as to a globally optimized graph-based parser. the resulting parsers have very simple architectures, and match or surpass the state-of-the-art accuracies on english and chinese. noitemsep, topsep=0pt, parsep=0pt, partopsep=0pt 1.0em section: introduction the focus of this paper is on feature representation for dependency parsing, using recent techniques from the neural-networks (''deep learning'') literature. modern approaches to dependency parsing can be broadly categorized into graph-based and transition-based parsers. graph-based parsers treat parsing as a search-based structured prediction problem in which the goal is learning a scoring function over dependency trees such that the correct tree is scored above all other trees. transition-based parsers treat parsing as a sequence of actions that produce a parse tree, and a classifier is trained to score the possible actions at each stage of the process and guide the parsing process. perhaps the simplest graph-based parsers are arc-factored (first order) models, in which the scoring function for a tree decomposes over the individual arcs of the tree. more elaborate models look at larger (overlapping) parts, requiring more sophisticated inference and training algorithms. the basic transition-based parsers work in a greedy manner, performing a series of locally-optimal decisions, and boast very fast parsing speeds. more advanced transition-based parsers introduce some search into the process using a beam or dynamic programming. regardless of the details of the parsing framework being used, a crucial step in parser design is choosing the right feature function for the underlying statistical model. recent work (see section [reference] for an overview) attempt to alleviate parts of the feature function design problem by moving from linear to non-linear models, enabling the modeler to focus on a small set of ''core'' features and leaving it up to the machine-learning machinery to come up with good feature combinations. however, the need to carefully define a set of core features remains. for example, the work of chen2014fast uses 18 different elements in its feature function, while the work of pei2015effective uses 21 different elements. other works, notably dyer2015transitionbased and le2014insideoutside, propose more sophisticated feature representations, in which the feature engineering is replaced with architecture engineering. in this work, we suggest an approach which is much simpler in terms of both feature engineering and architecture engineering. our proposal (section [reference]) is centered around birnns, and more specifically bilstms, which are strong and trainable sequence models (see section [reference]). the bilstm excels at representing elements in a sequence (i.e., words) together with their contexts, capturing the element and an ''infinite'' window around it. we represent each word by its bilstm encoding, and use a concatenation of a minimal set of such bilstm encodings as our feature function, which is then passed to a non-linear scoring function (multi-layer perceptron). crucially, the bilstm is trained with the rest of the parser in order to learn a good feature representation for the parsing problem. if we set aside the inherent complexity of the bilstm itself and treat it as a black box, our proposal results in a pleasingly simple feature extractor. we demonstrate the effectiveness of the approach by using the bilstm feature extractor in two parsing architectures, transition-based (section [reference]) as well as a graph-based (section [reference]). in the graph-based parser, we jointly train a structured-prediction model on top of a bilstm, propagating errors from the structured objective all the way back to the bilstm feature-encoder. to the best of our knowledge, we are the first to perform such end-to-end training of a structured prediction model and a recurrent feature extractor for non-sequential outputs. aside from the novelty of the bilstm feature extractor and the end-to-end structured training, we rely on existing models and techniques from the parsing and structured prediction literature. we stick to the simplest parsers in each category- greedy inference for the transition-based architecture, and a first-order, arc-factored model for the graph-based architecture. despite the simplicity of the parsing architectures and the feature functions, we achieve near state-of-the-art parsing accuracies in both english (93.1 uas) and chinese (86.6 uas), using a first-order parser with two features and while training solely on treebank data, without relying on semi-supervised signals such as pre-trained word embeddings, word-clusters, or techniques such as tri-training. when also including pre-trained word embeddings, we obtain further improvements, with accuracies of 93.9 uas (english) and 87.6 uas (chinese) for a greedy transition-based parser with 11 features, and 93.6 uas (en)/ 87.4 (ch) for a greedy transition-based parser with 4 features. section: background and notation paragraph: notation we use to denote a sequence of vectors. is a function parameterized with parameters. we write as shorthand for- an instantiation of with a specific set of parameters. we use to denote a vector concatenation operation, and to denote an indexing operation taking the th element of a vector. subsection: feature functions in dependency parsing traditionally, state-of-the-art parsers rely on linear models over hand-crafted feature functions. the feature functions look at core components (e.g. ''word on top of stack'', ''leftmost child of the second-to-top word on the stack'', ''distance between the head and the modifier words''), and are comprised of several templates, where each template instantiates a binary indicator function over a conjunction of core elements (resulting in features of the form ''word on top of stack is x and leftmost child is y and\u2026''). the design of the feature function- which components to consider and which combinations of components to include- is a major challenge in parser design. once a good feature function is proposed in a paper it is usually adopted in later works, and sometimes tweaked to improve performance. examples of good feature functions are the feature-set proposed by zhang11acl for transition-based parsing (including roughly 20 core components and 72 feature templates), and the feature-set proposed by mst for graph-based parsing, with the paper listing 18 templates for a first-order parser, while the first order feature-extractor in the actual implementation's code (mstparser) includes roughly a hundred feature templates. the core features in a transition-based parser usually look at information such as the word-identity and part-of-speech (pos) tags of a fixed number of words on top of the stack, a fixed number of words on the top of the buffer, the modifiers (usually left-most and right-most) of items on the stack and on the buffer, the number of modifiers of these elements, parents of words on the stack, and the length of the spans spanned by the words on the stack. the core features of a first-order graph-based parser usually take into account the word and pos of the head and modifier items, as well as pos-tags of the items around the head and modifier, pos tags of items between the head and modifier, and the distance and direction between the head and modifier. subsection: related research efforts coming up with a good feature-set for a parser is a hard and time consuming task, and many researchers attempt to reduce the required manual effort. the work of lei-etal:2014:p14-1 suggests a low-rank tensor representation to automatically find good feature combinations. taubtabib2015template suggest a kernel-based approach to implicitly consider all possible feature combinations over sets of core-features. the recent popularity of neural networks prompted a move from templates of sparse, binary indicator features to dense core feature encodings fed into non-linear classifiers. chen2014fast encode each core feature of a greedy transition-based parser as a dense low-dimensional vector, and the vectors are then concatenated and fed into a non-linear classifier (multi-layer perceptron) which can potentially capture arbitrary feature combinations. weiss2015structured showed further gains using the same approach coupled with a somewhat improved set of core features, a more involved network architecture with skip-layers, beam search-decoding, and careful hyper-parameter tuning. pei2015effective apply a similar methodology to graph-based parsing. while the move to neural-network classifiers alleviates the need for hand-crafting feature-combinations, the need to carefully define a set of core features remain. for example, the feature representation in chen2014fast is a concatenation of 18 word vectors, 18 pos vectors and 12 dependency-label vectors. the above works tackle the effort in hand-crafting effective feature combinations. a different line of work attacks the feature-engineering problem by suggesting novel neural-network architectures for encoding the parser state, including intermediately-built subtrees, as vectors which are then fed to non-linear classifiers. titov and henderson encode the parser state using incremental sigmoid-belief networks titov-henderson:2007:iwpt2007. in the work of dyer2015transitionbased, the entire stack and buffer of a transition-based parser are encoded as a stack-lstms, where each stack element is itself based on a compositional representation of parse trees. le2014insideoutside encode each tree node as two compositional representations capturing the inside and outside structures around the node, and feed the representations into a reranker. a similar reranking approach, this time based on convolutional neural networks, is taken by zhu2015reranking. finally, in kiperwasser2016ef we present an easy-first parser based on a novel hierarchical-lstm tree encoding. in contrast to these, the approach we present in this work results in much simpler feature functions, without resorting to elaborate network architectures or compositional tree representations. work by vinlays2014grammar employs a sequence-to-sequence with attention architecture for constituency parsing. each token in the input sentence is encoded in a deep-bilstm representation, and then the tokens are fed as input to a deep-lstm that predicts a sequence of bracketing actions based on the already predicted bracketing as well as the encoded bilstm vectors. a trainable attention mechanism is used to guide the parser to relevant bilstm vectors at each stage. this architecture shares with ours the use of bilstm encoding and end-to-end training. the sequence of bracketing actions can be interpreted as a sequence of shift and reduce operations of a transition-based parser. however, while the parser of vinyals et al. relies on a trainable attention mechanism for focusing on specific bilstm vectors, parsers in the transition-based family we use in section [reference] use a human designed stack and buffer mechanism to manually direct the parser's attention. while the effectiveness of the trainable attention approach is impressive, the stack-and-buffer guidance of transition-based parsers results in more robust learning. indeed, work by cross2016incremental, published while working on the camera-ready version of this paper, show that the same methodology as ours is highly effective also for greedy, transition-based constituency parsing, surpassing the beam-based architecture of vinyals et al. (88.3f vs. 89.8f points) when trained on the penn treebank dataset and without using orthogonal methods such as ensembling and up-training. subsection: bidirectional recurrent neural networks recurrent neural networks (rnns) are statistical learners for modeling sequential data. an rnn allows one to model the th element in the sequence based on the past- the elements up to and including it. the rnn model provides a framework for conditioning on the entire history without resorting to the markov assumption which is traditionally used for modeling sequences. rnns were shown to be capable of learning to count, as well as to model line lengths and complex phenomena such as bracketing and code indentation. our proposed feature extractors are based on a bidirectional recurrent neural network (birnn), an extension of rnns that take into account both the past and the future. we use a specific flavor of rnn called a long short-term memory network (lstm). for brevity, we treat rnn as an abstraction, without getting into the mathematical details of the implementation of the rnns and lstms. for further details on rnns and lstms, the reader is referred to goldberg-primer and cho-primer. the recurrent neural network (rnn) abstraction is a parameterized function mapping a sequence of input vectors, to a sequence of output vectors. each output vector is conditioned on all the input vectors, and can be thought of as a summary of the prefix of. in our notation, we ignore the intermediate vectors and take the output of to be the vector. a bidirectional rnn is composed of two rnns, and, one reading the sequence in its regular order, and the other reading it in reverse. concretely, given a sequence of vectors and a desired index, the function is defined as: the vector is then a representation of the th item in, taking into account both the entire history and the entire future by concatenating the matching rnn s. we can view the birnn encoding of an item as representing the item together with a context of an infinite window around it. paragraph: computational complexity computing the birnn vectors encoding of the th element of a sequence requires time for computing the two rnns and concatenating their outputs. a naive approach of computing the bidirectional representation of all elements result in computation. however, it is trivial to compute the birnn encoding of all sequence items in linear time by pre-computing and, keeping the intermediate representations, and concatenating the required elements as needed. paragraph: birnn training initially, the birnn encodings do not capture any particular information. during training, the encoded vectors are fed into further network layers, until at some point a prediction is made, and a loss is incurred. the back-propagation algorithm is used to compute the gradients of all the parameters in the network (including the birnn parameters) with respect to the loss, and an optimizer is used to update the parameters according to the gradients. the training procedure causes the birnn function to extract from the input sequence the relevant information for the task task at hand. paragraph: going deeper we use a variant of deep bidirectional rnn (or-layer birnn) which is composed of birnn functions that feed into each other: the output of becomes the input of. stacking birnns in this way has been empirically shown to be effective. in this work, we use birnns and deep-birnns interchangeably, specifying the number of layers when needed. paragraph: historical notes rnns were introduced by elman1990finding, and extended to birnns by schuster1997bidirectional. the lstm variant of rnns is due to hochreiter1997long. bilstms were recently popularized by graves2008supervised, and deep birnns were introduced to nlp by irsoy2014opinion, who used them for sequence tagging. in the context of parsing, lewis2016lstm and vaswani:2016:naacl use a bilstm sequence tagging model to assign a ccg supertag for each token in the sentence. lewis2016lstm feeds the resulting supertags sequence into an a* ccg parser. vaswani:2016:naacl adds an additional layer of lstm which receives the bilstm representation together with the k-best supertags for each word and outputs the most likely supertag given previous tags, and then feeds the predicted supertags to a discriminitively trained parser. in both works, the bilstm is trained to produce accurate ccg supertags, and is not aware of the global parsing objective. section: our approach we propose to replace the hand-crafted feature functions in favor of minimally-defined feature functions which make use of automatically learned bidirectional lstm representations. given-words input sentence with words together with the corresponding pos tags, we associate each word and pos with embedding vectors and, and create a sequence of input vectors in which each is a concatenation of the corresponding word and pos vectors: the embeddings are trained together with the model. this encodes each word in isolation, disregarding its context. we introduce context by representing each input element as its (deep) bilstm vector,: our feature function is then a concatenation of a small number of bilstm vectors. the exact feature function is parser dependent and will be discussed when discussing the corresponding parsers. the resulting feature vectors are then scored using a non-linear function, namely a multi-layer perceptron with one hidden layer (mlp): where are the model parameters. beside using the bilstm-based feature functions, we make use of standard parsing techniques. crucially, the bilstm is trained jointly with the rest of the parsing objective. this allows it to learn representations which are suitable for the parsing task. consider a concatenation of two bilstm vectors () scored using an mlp. the scoring function has access to the words and pos-tags of and, as well as the words and pos-tags of the words in an infinite window surrounding them. as lstms are known to capture length and sequence position information, it is very plausible that the scoring function can be sensitive also to the distance between and, their ordering, and the sequential material between them. paragraph: parsing-time complexity once the bilstm is trained, parsing is performed by first computing the bilstm encoding for each word in the sentence (a linear time operation). then, parsing proceeds as usual, where the feature extraction involves a concatenation of a small number of the pre-computed vectors. section: transition-based parser we begin by integrating the feature extractor in a transition-based parser. we follow the notation in tacl2013dynamic. the transition-based parsing framework assumes a transition system, an abstract machine that processes sentences and produces parse trees. the transition system has a set of configurations and a set of transitions which are applied to configurations. when parsing a sentence, the system is initialized to an initial configuration based on the input sentence, and transitions are repeatedly applied to this configuration. after a finite number of transitions, the system arrives at a terminal configuration, and a parse tree is read off the terminal configuration. in a greedy parser, a classifier is used to choose the transition to take in each configuration, based on features extracted from the configuration itself. the parsing algorithm is presented in algorithm [reference] below. [h] greedy transition-based parsing [1] input: sentence, parameterized function with parameters. not given a sentence, the parser is initialized with the configuration (line [reference]). then, a feature function represents the configuration as a vector, which is fed to a scoring function score assigning scores to (configuration, transition) pairs. score scores the possible transitions, and the highest scoring transition is chosen (line [reference]). the transition is applied to the configuration, resulting in a new parser configuration. the process ends when reaching a final configuration, from which the resulting parse tree is read and returned (line [reference]). transition systems differ by the way they define configurations, and by the particular set of transitions available to them. a parser is determined by the choice of a transition system, a feature function and a scoring function score. our choices are detailed below. paragraph: the arc-hybrid system many transition systems exist in the literature. in this work, we use the arc-hybrid transition system, which is similar to the more popular arc-standard system, but for which an efficient dynamic oracle is available. in the arc-hybrid system, a configuration consists of a stack, a buffer, and a set of dependency arcs. both the stack and the buffer hold integer indices pointing to sentence elements. given a sentence, the system is initialized with an empty stack, an empty arc set, and, where is the special root index. any configuration with an empty stack and a buffer containing only is terminal, and the parse tree is given by the arc set of. the arc-hybrid system allows 3 possible transitions, shift, and, defined as: the shift transition moves the first item of the buffer () to the stack. the left\u2113 transition removes the first item on top of the stack () and attaches it as a modifier to with label, adding the arc. the right\u2113 transition removes from the stack and attaches it as a modifier to the next item on the stack (), adding the arc. paragraph: scoring function traditionally, the scoring function is a discriminative linear model of the form. the linearity of score required the feature function to encode non-linearities in the form of combination features. we follow chen and manning chen2014fast and replace the linear scoring model with an mlp. paragraph: simple feature function the feature function is typically complex (see section [reference]). our feature function is the concatenated bilstm vectors of the top 3 items on the stack and the first item on the buffer. i.e., for a configuration the feature extractor is defined as: this feature function is rather minimal: it takes into account the bilstm representations of and, which are the items affected by the possible transitions being scored, as well as one extra stack context. figure 1 depicts transition scoring with our architecture and this feature function. note that, unlike previous work, this feature function does not take into account, the already built structure. the high parsing accuracies in the experimental sections suggest that the bilstm encoding is capable of estimating a lot of the missing information based on the provided stack and buffer elements and the sequential content between them. while not explored in this work, relying on only four word indices for scoring an action results in very compact state signatures, making our proposed feature representation very appealing for use in transition-based parsers that employ dynamic-programming search. paragraph: extended feature function one of the benefits of the greedy transition-based parsing framework is precisely its ability to look at arbitrary features from the already built tree. if we allow somewhat less minimal feature function, we could add the bilstm vectors corresponding to the right-most and left-most modifiers of, and, as well as the left-most modifier of, reaching a total of 11 bilstm vectors. we refer to this as the extended feature set. as we'll see in section [reference], using the extended set does indeed improve parsing accuracies when using pre-trained word embeddings, but has a minimal effect in the fully-supervised case. subsection: details of the training algorithm the training objective is to set the score of correct transitions above the scores of incorrect transitions. we use a margin-based objective, aiming to maximize the margin between the highest scoring correct action and the highest scoring incorrect action. the hinge loss at each parsing configuration is defined as: where is the set of possible transitions and is the set of correct (gold) transitions at the current stage. at each stage of the training process the parser scores the possible transitions, incurs a loss, selects a transition to follow, and moves to the next configuration based on it. the local losses are summed throughout the parsing process of a sentence, and the parameters are updated with respect to the sum of the losses at sentence boundaries. the gradients of the entire network (including the mlp and the bilstm) with respect to the sum of the losses are calculated using the backpropagation algorithm. as usual, we perform several training iterations over the training corpus, shuffling the order of sentences in each iteration. paragraph: error-exploration and dynamic oracle training we follow tacl2013dynamic; coling2012dynamic in using error exploration training with a dynamic-oracle, which we briefly describe below. at each stage in the training process, the parser assigns scores to all the possible transitions. it then selects a transition, applies it, and moves to the next step. which transition should be followed? a common approach follows the highest scoring transition that can lead to the gold tree. however, when training in this way the parser sees only configurations that result from following correct actions, and as a result tends to suffer from error propagation at test time. instead, in error-exploration training the parser follows the highest scoring action in during training even if this action is incorrect, exposing it to configurations that result from erroneous decisions. this strategy requires defining the set such that the correct actions to take are well-defined also for states that can not lead to the gold tree. such a set is called a dynamic oracle. we perform error-exploration training using the dynamic-oracle defined by tacl2013dynamic. paragraph: aggressive exploration we found that even when using error-exploration, after one iteration the model remembers the training set quite well, and does not make enough errors to make error-exploration effective. in order to expose the parser to more errors, we follow an aggressive-exploration scheme: we sometimes follow incorrect transitions also if they score below correct transitions. specifically, when the score of the correct transition is greater than that of the wrong transition but the difference is smaller than a margin constant, we chose to follow the incorrect action with probability (we use in our experiments). paragraph: summary the greedy transition-based parser follows standard techniques from the literature (margin-based objective, dynamic oracle training, error exploration, mlp-based non-linear scoring function). we depart from the literature by replacing the hand-crafted feature function over carefully selected components of the configuration with a concatenation of bilstm representations of a few prominent items on the stack and the buffer, and training the bilstm encoder jointly with the rest of the network. section: graph-based parser graph-based parsing follows the common structured prediction paradigm: given an input sentence (and the corresponding sequence of vectors) we look for the highest-scoring parse tree in the space of valid dependency trees over. in order to make the search tractable, the scoring function is decomposed to the sum of local scores for each part independently. in this work, we focus on arc-factored graph based approach presented in mst. arc-factored parsing decomposes the score of a tree to the sum of the score of its head-modifier arcs: given the scores of the arcs the highest scoring projective tree can be efficiently found using eisner's decoding algorithm eisner1996dep. mcdonald et al. and most subsequent work estimate the local score of an arc by a linear model parameterized by a weight vector, and a feature function assigning a sparse feature vector for an arc linking modifier to head. we follow pei2015effective and replace the linear scoring function with an mlp. the feature extractor is usually complex, involving many elements (see section [reference]). in contrast, our feature extractor uses merely the bilstm encoding of the head word and the modifier word: the final model is: the architecture is illustrated in figure [reference]. paragraph: training the training objective is to set the score function such that correct tree is scored above incorrect ones. we use a margin-based objective, aiming to maximize the margin between the score of the gold tree and the highest scoring incorrect tree. we define a hinge loss with respect to a gold tree as: each of the tree scores is then calculated by activating the mlp on the arc representations. the entire loss can viewed as the sum of multiple neural networks, which is sub-differentiable. we calculate the gradients of the entire network (including to the bilstm encoder and word embeddings). paragraph: labeled parsing up to now, we described unlabeled parsing. a possible approach for adding labels is to score the combination of an unlabeled arc and its label by considering the label as part of the arc. this results in parts that need to be scored, leading to slow parsing speeds and arguably a harder learning problem. instead, we chose to first predict the unlabeled structure using the model given above, and then predict the label of each resulting arc. using this approach, the number of parts stays small, enabling fast parsing. the labeling of an arc is performed using the same feature representation fed into a different mlp predictor: as before we use a margin based hinge loss. the labeler is trained on the gold trees. the bilstm encoder responsible for producing and is shared with the arc-factored parser: the same bilstm encoder is used in the parer and the labeler. this sharing of parameters can be seen as an instance of multi-task learning. as we show in section [reference], the sharing is effective: training the bilstm feature encoder to be good at predicting arc-labels significantly improves the parser's unlabeled accuracy. paragraph: loss augmented inference in initial experiments, the network learned quickly and overfit the data. in order to remedy this, we found it useful to use loss augmented inference. the intuition behind loss augmented inference is to update against trees which have high model scores and are also very wrong. this is done by augmenting the score of each part not belonging to the gold tree by adding a constant to its score. formally, the loss transforms as follows: paragraph: speed improvements the arc-factored model requires the scoring of arcs. scoring is performed using an mlp with one hidden layer, resulting in matrix-vector multiplications from the input to the hidden layer, and multiplications from the hidden to the output layer. the first multiplications involve larger dimensional input and output vectors, and are the most time consuming. fortunately, these can be reduced to multiplications and vector additions, by observing that the multiplication can be written as where and are are the first and second half of the matrix and reusing the products across different pairs. summary the graph-based parser is straight-forward first-order parser, trained with a margin-based hinge-loss and loss-augmented inference. we depart from the literature by replacing the hand-crafted feature function with a concatenation of bilstm representations of the head and modifier words, and training the bilstm encoder jointly with the structured objective. we also introduce a novel multi-task learning approach for labeled parsing by training a second-stage arc-labeler sharing the same bilstm encoder with the unlabeled parser. section: experiments and results we evaluated our parsing model on english and chinese data. for comparison purposes we follow the setup of dyer2015transitionbased. paragraph: data for english, we used the stanford dependency (sd) conversion of the penn treebank, using the standard train/ dev/ test splits with the same predicted pos-tags as used in dyer2015transitionbased; chen2014fast. this dataset contains a few non-projective trees. punctuation symbols are excluded from the evaluation. for chinese, we use the penn chinese treebank 5.1 (ctb5), using the train/ test/ dev splits of with gold part-of-speech tags, also following. when using external word embeddings, we also use the same data as dyer2015transitionbased. paragraph: implementation details the parsers are implemented in python, using the pycnn toolkit for neural network training. the code is available at the github repository. we use the lstm variant implemented in pycnn, and optimize using the adam optimizer. unless otherwise noted, we use the default values provided by pycnn (e.g. for random initialization, learning rates etc). the word and pos embeddings and are initialized to random values and trained together with the rest of the parsers' networks. in some experiments, we introduce also pre-trained word embeddings. in those cases, the vector representation of a word is a concatenation of its randomly-initialized vector embedding with its pre-trained word vector. both are tuned during training. we use the same word vectors as in dyer2015transitionbased during training, we employ a variant of word dropout, and replace a word with the unknown-word symbol with probability that is inversely proportional to the frequency of the word. a word appearing times in the training corpus is replaced with the unknown symbol with probability. if a word was dropped the external embedding of the word is also dropped with probability. we train the parsers for up to 30 iterations, and choose the best model according to the uas accuracy on the development set. paragraph: hyperparameter tuning we performed a very minimal hyper-parameter search with the graph-based parser, and use the same hyper-parameters for both parsers. the hyper-parameters of the final networks used for all the reported experiments are detailed in table [reference]. main results table [reference] lists the test-set accuracies of our best parsing models, compared to other state-of-the-art parsers from the literature. it is clear that our parsers are very competitive, despite using very simple parsing architectures and minimal feature extractors. when not using external embeddings, the first-order graph-based parser with 2 features outperforms all other systems that are not using external resources, including the third-order turboparser. the greedy transition based parser with 4 features also matches or outperforms most other parsers, including the beam-based transition parser with heavily engineered features of zhang and nivre (2011) and the stack-lstm parser of dyer2015transitionbased, as well as the same parser when trained using a dynamic oracle. moving from the simple (4 features) to the extended (11 features) feature set leads to some gains in accuracy for both english and chinese. interestingly, when adding external word embeddings the accuracy of the graph-based parser degrades. we are not sure why this happens, and leave the exploration of effective semi-supervised parsing with the graph-based model for future work. the greedy parser does manage to benefit from the external embeddings, and using them we also see gains from moving from the simple to the extended feature set. both feature sets result in very competitive results, with the extended feature set yielding the best reported results for chinese, and ranked second for english, after the heavily-tuned beam-based parser of weiss2015structured. paragraph: additional results we perform some ablation experiments in order to quantify the effect of the different components on our best models (table [reference]). loss augmented inference is crucial for the success of the graph-based parser, and the multi-task learning scheme for the arc-labeler contributes nicely to the unlabeled scores. dynamic oracle training yields nice gains for both english and chinese. section: conclusion we presented a pleasingly effective approach for feature extraction for dependency parsing based on a bilstm encoder that is trained jointly with the parser, and demonstrated its effectiveness by integrating it into two simple parsing models: a greedy transition-based parser and a globally optimized first-order graph-based parser, yielding very competitive parsing accuracies in both cases. paragraph: acknowledgements this research is supported by the intel collaborative research institute for computational intelligence (icri-ci) and the israeli science foundation (grant number 1555/ 15). we thank lillian lee for her important feedback and efforts invested in editing this paper. we also thank the reviewers for their valuable comments. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "uas english"
                    ]
                ],
                "Method": [
                    [
                        "bidirectional lstm"
                    ],
                    [
                        "bidirectional recurrent neural network"
                    ],
                    [
                        "recurrent neural network"
                    ],
                    [
                        "birnn"
                    ]
                ],
                "Metric": [
                    [
                        "accuracies"
                    ],
                    [
                        "parsing accuracies"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing"
                    ],
                    [
                        "parsing"
                    ],
                    [
                        "dependency parsing"
                    ],
                    [
                        "parsing"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "treebank data",
                        "penn treebank dataset",
                        "penn treebank",
                        "ctb5"
                    ]
                ],
                "Method": [
                    [
                        "globally optimized graph-based parser",
                        "graph-based",
                        "graph-based parsers",
                        "graph-based parser",
                        "graph-based parsing",
                        "beam-based parser"
                    ]
                ],
                "Metric": [
                    [
                        "local score",
                        "loss"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing",
                        "parsing"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "treebank data",
                        "penn treebank dataset",
                        "penn treebank",
                        "ctb5"
                    ]
                ],
                "Method": [
                    [
                        "greedy transition-based parser",
                        "transition-based parsers",
                        "parser",
                        "transition-based",
                        "transition-based architecture",
                        "transition-based parser",
                        "transition-based family",
                        "transition-based parsing framework",
                        "transition system",
                        "greedy transition-based parsing",
                        "transition systems",
                        "shift transition",
                        "greedy transition-based parsing framework",
                        "parer",
                        "greedy transition based parser",
                        "beam-based transition parser"
                    ]
                ],
                "Metric": [
                    [
                        "local score",
                        "loss"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing",
                        "parsing"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "treebank data",
                        "penn treebank dataset",
                        "penn treebank",
                        "ctb5"
                    ]
                ],
                "Method": [
                    [
                        "globally optimized graph-based parser",
                        "graph-based",
                        "graph-based parsers",
                        "graph-based parser",
                        "graph-based parsing",
                        "beam-based parser"
                    ]
                ],
                "Metric": [
                    [
                        "pos",
                        "pos-tags"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing",
                        "parsing"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "treebank data",
                        "penn treebank dataset",
                        "penn treebank",
                        "ctb5"
                    ]
                ],
                "Method": [
                    [
                        "greedy transition-based parser",
                        "transition-based parsers",
                        "parser",
                        "transition-based",
                        "transition-based architecture",
                        "transition-based parser",
                        "transition-based family",
                        "transition-based parsing framework",
                        "transition system",
                        "greedy transition-based parsing",
                        "transition systems",
                        "shift transition",
                        "greedy transition-based parsing framework",
                        "parer",
                        "greedy transition based parser",
                        "beam-based transition parser"
                    ]
                ],
                "Metric": [
                    [
                        "pos",
                        "pos-tags"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing",
                        "parsing"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "treebank data",
                        "penn treebank dataset",
                        "penn treebank",
                        "ctb5"
                    ]
                ],
                "Method": [
                    [
                        "globally optimized graph-based parser",
                        "graph-based",
                        "graph-based parsers",
                        "graph-based parser",
                        "graph-based parsing",
                        "beam-based parser"
                    ]
                ],
                "Metric": [
                    [
                        "parsing accuracies",
                        "uas"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing",
                        "parsing"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "treebank data",
                        "penn treebank dataset",
                        "penn treebank",
                        "ctb5"
                    ]
                ],
                "Method": [
                    [
                        "greedy transition-based parser",
                        "transition-based parsers",
                        "parser",
                        "transition-based",
                        "transition-based architecture",
                        "transition-based parser",
                        "transition-based family",
                        "transition-based parsing framework",
                        "transition system",
                        "greedy transition-based parsing",
                        "transition systems",
                        "shift transition",
                        "greedy transition-based parsing framework",
                        "parer",
                        "greedy transition based parser",
                        "beam-based transition parser"
                    ]
                ],
                "Metric": [
                    [
                        "parsing accuracies",
                        "uas"
                    ]
                ],
                "Task": [
                    [
                        "dependency parsing",
                        "parsing"
                    ]
                ]
            }
        ]
    },
    "3daa086acd367dc971a2dc1382caba2031294233-59": {
        "doctext": "holistic, instance-level human parsing section: abstract object parsing-the task of decomposing an object into its semantic parts-has traditionally been formulated as a category-level segmentation problem. consequently, when there are multiple objects in an image, current methods can not count the number of objects in the scene, nor can they determine which part belongs to which object. we address this problem by segmenting the parts of objects at an instance-level, such that each pixel in the image is assigned a part label, as well as the identity of the object it belongs to. moreover, we show how this approach benefits us in obtaining segmentations at coarser granularities as well. our proposed network is trained end-to-end given detections, and begins with a category-level segmentation module. thereafter, a differentiable conditional random field, defined over a variable number of instances for every input image, reasons about the identity of each part by associating it with a human detection. in contrast to other approaches, our method can handle the varying number of people in each image and our holistic network produces state-of-the-art results in instance-level part and human segmentation, together with competitive results in category-level part segmentation, all achieved by a single forward-pass through our neural network. section: introduction object parsing, the segmentation of an object into semantic parts, is naturally performed by humans to obtain a more detailed understanding of the scene. when performed automatically by computers, it has many practical applications, such as in human-robot interaction, human behaviour analysis and image descriptions for the visually impaired. furthermore, detailed part information has been shown to be beneficial in other visual recognition tasks such as fine-grained recognition [reference], human pose estimation [reference] and object detection [reference]. in this paper, we focus on the application of parsing humans as it is more commonly studied, although our method makes no assumptions on the type of object it is segmenting. in contrast to existing human parsing approaches [reference][reference][reference], we operate at an instance level (to our knowledge, we are the first work to do so). as shown in fig. 1, not only do we segment the various body parts of humans (fig. 1b), but we associate each of these parts to one of the humans in the scene (fig. 1c), which is particularly important for understanding scenes with multiple people. in contrast to existing instance segmentation work [reference] part segmentation human segmentation figure 1: our proposed approach segments human parts at an instance level (c) (which to our knowledge is the first work to do so) from category-level part segmentations produced earlier in the network (b). moreover, we can easily obtain human instance segmentations (d) by taking the union of all pixels associated to a particular person. therefore, our proposed end-to-end trained neural network parses humans into semantic parts at both category and instance level in a single forward-pass. best viewed in colour. [reference], we operate at a more detailed part level, enabling us to extract more comprehensive information of the scene. furthermore, with our part-level instance segmentation of humans, we can easily recover human-level instance segmentation (by taking the union of all parts assigned to a particular instance as shown in fig. 1d), and we show significant improvement over previous state-of-the-art in human instance-segmentation when doing so. our approach is based on a deep convolutional neural network (cnn), which consists of an initial category-level part segmentation module. using the output of a human detector, we are then able to associate segmented parts with detected humans in the image using a differentiable conditional random field (crf), producing a part-level instance segmentation of the image. our formulation is robust to false-positive detections as well as imperfect bounding boxes which do not cover the entire human, in contrast to other instance segmentation methods based on object detectors [reference][reference][reference][reference][reference]. given object detections, our network is trained end-to-end, given detections, with a novel loss function which allows us to handle a variable number of human instances on every image. we evaluate our approach on the pascal person-parts [reference] dataset, which contains humans in a diverse set of poses and occlusions. we achieve state-of-the-art results on instancelevel segmentation of both body parts and humans. moreover, our results on semantic part segmentation (which is not-instance aware) is also competitive with current state-of-theart. all of these results are achieved with a holistic, end-to-end trained model which parses humans at both an instance and category level, and outputs a dynamic number of instances per image, all in a single forward-pass through the network. section: related work the problem of object parsing, which aims to decompose objects into their semantic parts, has been addressed by numerous works [reference][reference][reference][reference][reference], most of which have concentrated on parsing humans. however, none of the aforementioned works have parsed objects at an instance level as shown in fig. 1, but rather category level. in fact, a lot of work on human parsing has focussed on datasets such as fashionista [reference], atr [reference] and deep fashion [reference] where images typically contain only one, centred person. the notion of instance-level segmentation only matters when more than one person is present in an image, motivating us to evaluate our method on the pascal person-parts dataset [reference] where multiple people can appear in unconstrained environments. recent human parsing approaches have typically been similar to semantic segmentation works using fully convolutional networks (fcns) [reference], but trained to label parts [reference][reference][reference] instead of object classes. however, methods using only fcns do not explicitly model the structure of a human body, and typically do not perform as well as methods which do [reference]. structural priors of the human body have been encoded using pictorial structures [reference][reference], conditional random fields (crfs) [reference][reference][reference][reference] and more recently, with lstms [reference][reference]. the hazn approach of [reference] addressed the problem that some parts are often very small compared to other parts and difficult to segment with scale-variant cnns. this scale variation was handled by a cascade of three separatelytrained fcns, each parsing different regions of the image at different scales. an early instance segmentation work by winn et al. [reference] predicted the parts of an object, and then encouraged these parts to maintain a spatial ordering, characteristic of an instance, using asymmetric pairwise potentials in a crf. however, subsequent work has not operated at a part level. zhang et al. [reference][reference] performed instance segmentation of vehicles using an mrf. however, this graphical model was not trained end-to-end as done by [reference][reference][reference] and our approach. furthermore, they assumed a maximum of 9 cars per image. approaches using recurrent neural networks [reference][reference] can handle a variable number of instances per image by segmenting an instance per time-step, but are currently restricted to only one object category. our method, on the other hand, is able to handle both an arbitrary number of objects, and multiple object categories in the image with a single forward-pass through the network. various methods of instance segmentation have also involved modifying object detection systems to output segments instead of bounding boxes [reference][reference][reference][reference]. however, these methods can not produce a segmentation map of the image, as shown in fig. 1, without postprocessing as they consider each detection independently. although our method also uses an object detector, it considers all detections in the image jointly with an initial category-level segmentation, and produces segmentation maps naturally where one pixel can not belong to multiple instances in contrast to the aforementioned approaches. the idea of combining the outputs of a category-level segmentation network and an object detector to reason about different instances was also presented by [reference]. however, that system was not trained end-toend, could not segment instances outside the detector's bounding box, and did not operate at a part level. section: proposed approach our network (fig. 2) consists of two components: a category-level part segmentation module, and an instance segmentation module. as both of these modules are differentiable, they can be integrated into a single network and trained jointly. the instance segmentation module (sec. 3.2) uses the output of the first category-level segmentation module (sec. 3.1) as well as the outputs of an object detector as its input. it associates each pixel in the categorylevel segmentation with an object detection, resulting in an instance-level segmentation of the image. given a h\u00d7w\u00d7 3 input image, i, the category-level part segmentation module produces a h\u00d7w\u00d7 (p+ 1) dimensional output q where p is the number of part classes in the dataset and one background class. there can be a variable number, d, of human detections per image, and the output of the instance segmentation module is an h\u00d7w\u00d7 (pd+ 1) tensor denoting the probabilities, at each pixel in the image, of each of the p part classes belonging to one of the d detections. two challenges of instance segmentation are the variable number of instances in every image, and the fact that permutations of instance labels lead to identical results (in fig. 1, how we order the different people does not matter). zhang et al. [reference][reference] resolve these issues by assuming a maximum number of instances and using the ground-truth depth ordering of instances respectively. others have bypassed both of these issues by predicting each instance independently [reference][reference][reference][reference], but this also allows a pixel to belong to multiple instances. instead, we use a loss function (sec 3.3) that is based on\" matching\" the prediction to the ground-truth, allowing us to handle permutations of the ground truth. furthermore, weight-sharing in our instance segmentation module allows us to segment a variable number of instances per image. as a result, we do not assume a maximum number of instances, consider all instances jointly, and train our network end-to-end, given object detections. section: category-level part segmentation module the part segmentation module is a fully convolutional network [reference] based on resnet-101 [reference]. a common technique, presented in [reference][reference], is to predict the image at three different scales (with network weights shared among all the scales), and combine predictions together with learned, image-dependent weights. we take a different approach of fusing information at multiple scales-we pool the features after res5c [reference] at five different resolutions (by varying the pooling stride), upsample the features to the resolution before pooling, and then concatenate these features before passing them to the final convolutional classifier, as proposed in [reference]. as we show in sec 4.4, this approach achieves better semantic segmentation results than [reference][reference]. we denote the output of this module by the tensor, q, where q i (l) is the probability of pixel i being assigned label l\u2208 {0, 1, 2,..., p}. further details of this module are included in the appendix. section: instance-level segmentation module this module creates an instance-level segmentation of the image by associating each pixel in the input category-level segmentation, q, with one of the d input human-detections or the background label. let there be d input human-detections for the image, where the i-th detection is represented by b i, the set of pixels lying within the four corners of its bounding box, and s i\u2208 [0, 1], the detection score. we assume that the 0-th detection refers to the background label. furthermore, we define a multinomial random variable, v i, at each of the n pixels in the image, and let. this variable can take on a label from the set {1, 2,..., d}\u00d7 {1, 2,..., p}\u222a {(0, 0)} since each of the p part labels can be associated with one of the d human detections, or that pixel could belong to the background label, (0, 0). we formulate a conditional random field over these v variables, where the energy of the assignment v to all of the instance variables v consists of two unary terms, and one pairwise term (whose weighting co-efficients are all learned via backpropagation): (the unary and pairwise potentials are computed within our neural network, differentiable with respect to their input and parameters, and described in sec. 3.2.1 through 3.2.3. the maximum-a-posteriori (map) estimate of our crf (since the energy in eq. 1 characterises a gibbs distribution) is computed as the final labelling produced by our network. we perform the iterative mean-field inference algorithm to approximately compute the map solution by minimising eq. 1. as shown by zheng et al. [reference], this can be formulated as a recurrent neural network (rnn), allowing it to be trained end-to-end as part of a larger network. however, as our network is input a variable number of detections per image, d, the label space of the crf is dynamic. therefore, unlike [reference], the parameters of our crf are not class-specific to allow for this variable number of\" channels\". section: box consistency term we observe that in most cases, a body part belonging to a person is located inside the bounding box of the person. based on this observation, the box consistency term is employed to encourage pixel locations inside a human bounding box b i to be associated with the i-th human detection. the box term potential at spatial location k for body part j of a human i is assigned either 0 for k/\u2208 b i, or the product of the detection score, s i, and the category-level part segmentation confidence, note that this potential may be robust to false-positive detections when the category-level segmentation and human detection do not agree with each other, since q k (l), the probability of a pixel k taking on body-part label l, is low. furthermore, note that we use one humandetection to reason about the identity of all parts which constitute that human. section: global term a possible shortcoming for the box consistency potential is that if some pixels belonging to a human instance fall outside the bounding box and are consequently assigned 0 for the box consistency term potential, they would be lost in the final instance segmentation prediction. visually, the generated instance masks would appear truncated along the bounding box boundaries-a problem suffered by [reference][reference][reference][reference]. to overcome this undesirable effect, we introduce the global potential: it complements the box consistency term by assuming that a pixel is equally likely to belong to any one of the detected humans. it is expressed as prediction, p original ground-truth, y\" matched\" ground-truth, y* figure 3: as different permutations of the ground-truth are equivalent in the case of instance segmentation, we\" match\" the original ground-truth, y, to our network's prediction, p, to obtain the\" matched\" ground-truth which we use to compute our loss during training. section: pairwise term our pairwise term is composed of densely-connected gaussian kernels [reference] which are commonly used in segmentation literature [reference][reference]. this pairwise potential encourages both spatial and appearance consistency, and we find these priors to be suitable in the case of instancelevel segmentation as well. as in [reference], the weighting parameters of these potentials are learned via backpropagation, though in our case, the weights are shared among all classes. section: loss function and network training we first pre-train the category-level segmentation part of our network, as described in the appendix. thereafter, we add the instance segmentation module, and train with a permutationinvariant loss function which is backpropagated through both our instance-and categorylevel segmentation networks. since all permutations of an instance segmentation have the same qualitative result, we\" match\" the original ground-truth to our prediction before computing the loss, as shown in fig. 3. this matching is based on the intersection over union (iou) [reference] of a predicted and ground-truth instance, similar to [reference]. let y= {y 1, y 2,..., y m}, a set of m segments, denote the ground-truth labelling of an image, where each segment is an instance and has a part label assigned to it. similarly, let p= {p 1, p 2,..., p n} denote our n predicted instances, each with an associated part label. note that m and n need not be the same as we may predict greater or fewer instances than there actually are in the image. the\" matched\" ground truth, y* is the permutation of the original ground-truth labelling which maximises the iou between our prediction, p and ground-truth where\u03c0 (y) denotes the set of all permutations of y. note that we define the iou between all segments of different labels to be 0. eq. 4 can be solved efficiently using the hungarian algorithm as it can be formulated as a bipartite graph matching problem, and once we have the\" matched\" ground-truth, y*, we can apply any loss function to it and train our network for segmentation. in our case, we use the standard cross-entropy loss function on the\" matched\" ground truth. in addition, we employ online hard example mining (ohem), and only compute our loss over the top k pixels with the highest loss in the training mini-batch. we found that during training, many pixels already had a high probability of being assigned to the correct class. by only selecting the top k pixels with the highest loss, we are able to encourage our network to improve on the pixels it is currently misclassifying, as opposed to increasing the probability of a pixel it is already classifying correctly. this approach was inspired by\" bootstrapping\" [reference][reference] or\" hard-negative mining\" [reference] commonly used in training object detectors. however, these methods mined hard examples from the entire dataset. our approach is most similar to [reference], who mined hard examples online from each mini-batch in the context of detection. similar to the aforementioned works, we found ohem to improve our overall results, as shown in sec. 4.2. section: obtaining segmentations at other granularities given the part instance prediction produced by our proposed network, we are able to easily obtain human instance segmentation and semantic part segmentation. in order to achieve human instance segmentation, we map the predicted part instance labels (i, j), i.e. part j of person i, to i. whereas to obtain semantic part segmentation, we map predicted part instance labels (i, j) to j instead. section: experiments we describe our dataset and experimental set-up in sec. 4.1, before presenting results on instance-level part segmentation (fig. 1c), instance-level human segmentation (fig. 1d) and semantic part segmentation (fig. 1b). additional quantitative and qualitative results, failure cases and experimental details are included in the appendix. section: experimental set-up we evaluate our proposed method on the pascal person-part dataset [reference] which contains 1716 training images, and 1817 test images. this dataset contains multiple people per image in unconstrained poses and environments, and contains six human body part classes (fig. 1b), as well as the background label. as described in sec. 3.3, we initially pre-train our categorylevel segmentation module before training for instance-level segmentation. this module is first trained on the 21 classes of the pascal voc dataset [reference], and then finetuned on the seven classes of the pascal part training set using category-level annotations. finally, we train for instance segmentation with instance-level ground truth. full details of our training process, including all hyperparameters such as learning rate, are in the appendix. to clarify these details, we will also release our code. we use the standard ap r metric [reference] for evaluating instance-level segmentation: the mean average precision of our predictions is computed where a prediction is considered correct if its iou with a ground-truth instance is above a certain threshold. this is similar to the ap metric used in object detection. however, in detection, the iou between groundtruth and predicted bounding boxes is computed, whereas here, the iou between regions is computed. furthermore, in detection, an overlap threshold of 0.5 is used, whereas we vary this threshold. finally, we define the ap r vol which is the mean of the ap r score for overlap thresholds varying from 0.1 to 0.9 in increments of 0.1. we use the publicly available r-fcn detection framework [reference], and train a new model with data from voc 2012 [reference] that do not overlap with any of our test sets. we train with all object classes of voc, and only use the output for the human class. non-maximal suppression is performed on all detections before being fed into our network. table 1 shows our results on part-level instance segmentation on the pascal person-part dataset. to our knowledge, we are the first work to do this, and hence we study the effects of various design choices on overall performance. we also use the publicly available code for mnc [reference], which won the ms-coco 2016 instance segmentation challenge, and finetune their public model trained on voc 2011 [reference] on person-part instances as a baseline. section: results on instance-level part segmentation we first train our model in a piecewise manner, by first optimising the parameters of the category-level segmentation module, and then\" freezing\" the weights of this module and only training the instance network. initially, we only use the box consistency term (sec. 3.2.1) in the instance crf, resulting in an ap r at 0.5 of 38.0%. note that this model is equivalent to our reimplementation of [reference]. adding in the global potential (sec. 3.2.2) helps us cope with bounding boxes which do not cover the whole human, and we see an improvement at all iou thresholds. training our entire network end-to-end gives further benefits. we then train all variants of our model with ohem, and observe consistent improvements across all iou thresholds with respect to the corresponding baseline. here, we set k= 2 [reference], meaning that we computed our loss over 2 [reference] or approximately 12% of the hardest pixels in each training image (since we train at full resolution). we also employ ohem when pre-training the category-level segmentation module of our network, and observe minimal difference in the final result if we use ohem when training the category-level segmentation module but not the instance segmentation module. training end-to-end with ohem achieves 2.6% higher in ap r at 0.5, and 1.8% higher ap r vol over a piecewise-trained baseline model without ohem and only the box term (second row), which is equivalent to the model of [reference]. furthermore, our ap r vol is 1.7% greater than the strong mnc [reference] baseline. note that although [reference] also performed instance-level segmentation on the same dataset, their evaluation was only done using human instance labels, which is similar to our following experiment on human instance segmentation. section: results on human instance segmentation we can trivially obtain instance-level segmentations of humans (fig 1d), as mentioned in sec. 3.4. table 2 shows our state-of-the-art instance segmentation results for humans on the voc 2012 validation set [reference]. we use the best model from the previous section as there is deeplab* [reference] 53.0 attention [reference] 56.4 hazn [reference] 57.5 lg-lstm [reference] 58.0 graph lstm [reference] 60.2 deeplab v2 [reference] 64.9 refinenet [reference] 68.6 ours, pre-trained 65.9 ours, final network 66.3* result reported in [reference] no overlap between the pascal person-part training set, and the voc 2012 validation set. as tab. 2 shows, our proposed approach outperforms previous state-of-the-art by a significant margin, particularly at high iou thresholds. our model receives extra supervision in its part labels, but the fact that our network can implicitly infer relationships between different parts whilst training may help it handle occluding instances better than other approaches, leading to better instance segmentation performance. the fact that our network is trained with part-level annotations may also help it identify small features of humans better, leading to more precise segmentations and thus improvements at high ap r thresholds. our ap r at each iou threshold for human instance segmentation is higher than that for part instance segmentation (tab. 1). this is because parts are smaller than entire humans, and thus more difficult to localise accurately. an alternate method of performing instance-level part segmentation may be to first obtain an instance-level human segmentation using another method from tab. 2, and then partition it into the various body parts of a human. however, our approach, which groups parts into instances, is validated by the fact that it achieves state-of-the-art instance-level human segmentation performance. section: results on category-level part segmentation finally, our model is also able to produce category-level segmentations (as shown in fig. 1b). this can be obtained from the output of the category-level segmentation module, or from our instance module as described in sec. 3.4. as shown in tab. 3, our semantic segmentation results are competitive with current state-of-the-art. by training our entire network consisting of the category-level and instance-level segmentation modules jointly, and then obtaining the semantic segmentation from the final instance segmentation output by our network, we are able to obtain a small improvement of 0.4% in mean iou over the output of the initial semantic segmentation module. section: conclusion our proposed, end-to-end trained network outputs instance-level body part and human segmentations, as well as category-level part segmentations in a single forward-pass. moreover, section: input semantic segmentation instance segmentation ground truth figure 4: some results of our system. the first column shows the input image and the input detections we obtained from training the r-fcn detector [reference]. the second and third columns show our final semantic segmentation (sec. 3.4) and instance-level part segmentation. first row: our network can deal with poor bounding box localisation, as it manages to segment the third person from the left although the bounding box only partially covers her. second row: our method is robust against false positive detections because of the box term. observe that the bowl of the rightmost person in the bottom row is falsely detected as a person, but rejected in the final prediction. following rows: we are able to handle overlapping bounding boxes by reasoning globally using the instance crf. we have shown how segmenting objects into their constituent parts helps us segment the object as a whole with our state-of-the-art results on instance-level segmentation of both body parts and entire humans. furthermore, our category-level segmentations improve after training for instance-level segmentation. our future work is to train the object detector end-to-end as well. moreover, the improvement that we obtained in instance segmentation of humans as a result of first segmenting parts motivates us to explore weakly-supervised methods which do not require explicit object part annotations. in our main paper, we reported our ap r results averaged over all classes. fig. 5 visualises the perclass results of our best model at different iou thresholds. fig. 6 displays the success cases of our method, while fig. 7 shows examples of failure cases. furthermore, we illustrate the strengths and weaknesses of our part instance segmentation method in comparison to mnc [reference] in fig. 8, and compare our instance-level human segmentation results, which we obtain by the simple mapping described in sec. 3.4 of our main paper, to mnc in fig. 9. finally, we attach an additional video. we run our system offline, on a frame-by-frame basis on the entire music video, and show how our method is able to accurately parse humans at both category and instance level on internet data outside the pascal dataset. instance-level segmentation of videos requires data association. we use a simple, greedy method which operates on a frame-by-frame basis. segments from one frame are associated to segments in the next frame based on the iou, using the same method we use for our loss function as described in sec. 3.3 of the main paper. it shows that our method achieves best instance accuracy for the head category, and finds lower arms and lower legs most challenging to segment correctly. this is likely because of the thin shape of the lower limbs which is known to pose difficulty for semantic segmentation. section: input semantic segmentation instance segmentation ground truth figure 6: success cases of our method. the first column shows the input image and the input detections we obtained from training the r-fcn detector [reference]. the second column shows our final semantic segmentation (as described in sec. 3.4 of the main paper). our proposed method is able to leverage an initial category-level segmentation network and human detections to produce accurate instance-level part segmentation as shown in the third column. first row: unlike mnc which predicts for each part instance independently, our method reasons globally and jointly. as a result, mnc predicts two instances of lower legs for the same lower leg of the second and third person from the left. furthermore, with a dedicated category-level segmentation module, we are less prone to false negatives, whereas mnc misses the legs of the rightmost person, and the lower arm of the second person from the right. second row: while we can handle poor bounding box localisation because of our global potential term, mnc is unable to segment regions outside the bounding boxes it generates. consequently, only one lower arm of the person on the left is segmented as the other one is outside the bounding box. the square corners of the segmented lower arm correspond to the limits imposed by the bounding box which mnc internally uses (box generation is the first stage of the cascade [reference]). third row: by analysing an image globally and employing a differentiable crf, our method can produce more precise boundaries. as mnc does not perform category-level segmentation over the entire image, it has no incentive to produce a coherent and continuous prediction. visually, this is reflected in the gaps of\" background\" between body parts of the same person. fourth row: mnc predicts two instances of lower leg for the second person from the right, and fails to segment any lower arms for all four people due to the aforementioned problems. [reference] using the default parameters and extract only its human instance predictions. in contrast with proposal-driven methods such as mnc, our approach assigns each pixel to only one instance, is robust against non-ideal bounding boxes, and often produces better boundaries due to the instance crf which is trained endto-end. first and second row: since mnc predicts instances independently, it is prone to predicting multiple instances for a single person. third row: due to the global potential term, we can segment regions outside of a detection bounding box which fails to cover the entire person, whereas mnc is unable to recover from such imperfect bounding boxes, leading to its frequent occurrences of truncated instance predictions. fourth row: a case where mnc and our method show different failure modes. mnc predicts three people where there are only two, and our method can only predict one instance due to a missing detection. mnc is unable to recover from a false positive detection and predicts two people. second row: while both mnc and our method start off with poor bounding box localisation that does not cover the whole instance, we are able to segment the entire person, whereas mnc is bounded by its flawed region proposal. third row: mnc performs better in this case as it is able to segment the infant, whereas we miss her completely due to a false negative person detection. section: b additional information we detail our initial category-level segmentation module and compare it to deeplab-v2 [reference] in sec. b.1, present our network training details in sec. b.2, and finally describe how we train the mnc model which serves as our baseline in sec. b.3. section: b.1 details of the category-level segmentation module as shown in fig 10b, the structure of our category-level segmentation module consists of a resnet-101 backbone, and a classifier that extracts multi-scale features from the resnet-101 output by using average pooling with different kernel sizes. while our category-level segmentation module and the deeplab-v2 network (fig. 10a) of chen et al. [reference] both attempt to exploit multi-scale information in the image, the approach of [reference] entails executing three forward passes for each image, whereas we only need a single forward pass. in comparison to deeplab-v2, our network saves both memory and time, and achieves better performance. to carry out a single forward pass, our network uses 4.3 gb of memory while deeplab-v2 [reference] needs 9.5 gb, 120% more than ours. speed-wise, our network runs forward passes at 0.255 seconds per image (3.9 fps), whereas deeplab-v2 takes 55% longer, at 0.396 seconds per image (2.5 fps) on average. when deeplab-v2 adds a crf with 10 mean-field iterations to post-process the network output, it gains a small improvement in mean iou by 0.54% [reference], but it requires 11.2 gb of memory to make a forward pass (140% of the total amount used by our full network including the instance-level segmentation module), and takes 0.960 seconds per image (1.0 fps), almost a quater of our frame rate. tests are done on a single geforce gtx titan x (maxwell) card. overall, we are able to achieve better segmentation accuracy (as shown in tab. 3 of our main paper) and is more memory-and time-efficient than deeplab-v2. section: b.2 training our proposed network b.2.1 training the category-level segmentation module we initialise our semantic segmentation network with the coco pre-trained resnet-101 weights provided by [reference]. training is first performed on the pascal voc 2012 training set using the extra annotations from [reference], which combine to a total of 9012 training images. care is taken to ensure that all images from the pascal person-parts test set is excluded from this training set. a polynomial learning rate policy is adopted such that the effective learning rate at iteration i is given by l i= l 0 (1\u2212 i i max) p, where the base learning rate, l 0, is set to 6.25\u00d7 10\u22124, the total number of iterations, i max, is set to 30k, and the power, p, is set to 0.9. a batch size of 16 is used. however, due to memory constraints, we simulate this batch size by\" accumulating gradients\": we carry out 16 forward and backward passes with one image per iteration, and only perform the weight update after completing all 16 passes. we use a momentum of 0.9 and weight decay of 1\u00d7 10\u22124 for these experiments. after 30k of iterations are completed, we take the best performing model and finetune on the pascal person-parts training set using the same training scheme as described above. note that the parameters of the batch normalisation modules are kept unchanged in the whole learning process. online data-augmentation is performed during training to regularise the model. the training images are randomly mirrored, scaled by a ratio between 0.5 and 2, rotated by an angle between-10 and 10 degrees, translated by a random amount in the hsv colour space, and blurred with a randomly-sized gaussian kernel, all on-the-fly. we observe that these techniques are effective at reducing the accuracy gap between training and testing, leading to overall higher test accuracies. [reference] and our network structure. the numbers following the layer type denote the kernel size and number of filters. for pooling layers, only their kernel sizes are shown as the number of filters is not applicable. the upsampling ratios can be inferred from the context. fig. 10a: in the deeplab-v2 architecture, a 513\u00d7513\u00d73 input image is downsampled by two different ratios (0.75 and 0.5) to produce multi-scale input at three different resolutions. the three resolutions are independently processed by a resnet-101-based network using shared weights (shown by the individually coloured paths). the output feature maps are then upsampled where appropriate, combined by taking the elementwise maximum, and finally upsampled back to 513\u00d7513. fig. 10b: the category-level segmentation module proposed in this paper forwards an input image of size 521\u00d7521\u00d73 through a resnet-101-based cnn, producing a feature map of resolution 66\u00d766\u00d72048. this feature map is average-pooled with four different kernel sizes, giving us four feature maps with spatial resolutions 1\u00d71, 2\u00d72, 3\u00d73, and 6\u00d76 respectively. each feature map undergoes convolution and upsampling, before being concatenated together with each other and the 66\u00d766\u00d72048 resnet-101 output. this is followed by a convolution layer that reduces the dimension of the concatenated features to 512, and a convolutional classifier that maps the 512 channels to the size of label space in the dataset. finally, the prediction is upsampled back to 521\u00d7521. in both fig. 10a and 10b, the resnet-101 backbone uses dilated convolution such that its output at res5c is at 1/ 8 of the input resolution, instead of 1/ 32 for the original resnet-101 [reference]. the convolutional classifiers (coloured in purple) output c channels, corresponding to the number of classes in the dataset including a background class. for the pascal person-parts dataset, c is 7. best viewed in colour. section: b.2.2 training the instance-level segmentation module in our model, the pairwise term of the fully-connected crf takes the following form: where\u00b5 (\u00b7,\u00b7) is a compatibility function, k (\u00b7,\u00b7) is a kernel function, and f i is a feature vector at spatial location i containing the 3-dimensional colour vector i i and the 2-dimensional position vector p i [reference]. we further define the kernel as follows: where w [reference] and w [reference] are the linear combination weights for the bilateral term and the gaussian term respectively. in order to determine the initial values for the parameters in the instance crf to train from, we carry out a random search. according to the search results, the best prediction accuracy is obtained by initialising w (1)= 8, w (2)= 2,\u03b8\u03b1= 2,\u03b8\u03b2= 8,\u03b8\u03b3= 2. furthermore, we use a fixed learning rate of 1\u00d7 10\u22126, momentum of 0.9, and weight decay of 1\u00d7 10\u22124 for training both the instance-level and category-level segmentation modules jointly. although we previously use the polynomial learning rate policy, we find that for training the instance-level segmentation module, a fixed learning rate leads to better results. furthermore, our experiments show that a batch size of one works best at this training stage. using this scheme, we train for 175k iterations, or approximately 100 epochs. section: b.3 training multi-task network cascades (mnc) we use the publicly available multi-task network cascades (mnc) framework [reference], and train a new model for instance-level part segmentation using the pascal person-parts dataset. the weights are initialised with the officially released mnc model 1 which has been trained on pascal voc 2011/ sbd [reference]. the base learning rate is set to 1\u00d7 10\u22123, which is reduced by 10 times after 20k iterations. a total of 25k training iterations are carried out. a batch size of 8, momentum of 0.9 and weight decay of 5\u00d7 10\u22124 are used. these settings are identical to the ones used in training the original mnc and provided in their public source code. using these settings, we are also able to reproduce the experimental results obtained in the original mnc paper [reference], and hence we believe that the mnc model we have trained acts as a strong baseline for our proposed approach. section: section: section: section: appendix in this appendix, we present additional results of our proposed approach in sec. a, and provide additional training and implementation details in sec. b (both for our model, and the strong mnc baseline [reference]). section:",
        "pred_templates": [
            {
                "Material": [
                    [
                        "voc 2012 validation set"
                    ],
                    [
                        "pascal voc 2012 training set"
                    ]
                ],
                "Method": [
                    [
                        "category level part segmentation module"
                    ],
                    [
                        "mnc"
                    ],
                    [
                        "mnc framework"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "holistic instance level human parsing"
                    ],
                    [
                        "instance level human parsing"
                    ],
                    [
                        "human parsing"
                    ],
                    [
                        "parsing"
                    ],
                    [
                        "object parsing"
                    ],
                    [
                        "parsing"
                    ],
                    [
                        "segmentations"
                    ],
                    [
                        "instance level part segmentation"
                    ],
                    [
                        "category level part segmentation"
                    ],
                    [
                        "instance level part segmentation"
                    ],
                    [
                        "category level segmentations"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "pascal person-parts",
                        "pascal person-part dataset",
                        "pascal part training set",
                        "person-part instances",
                        "pascal person-part training set",
                        "pascal dataset"
                    ]
                ],
                "Method": [
                    [
                        "instance-level part",
                        "part-level instance segmentation",
                        "semantic part segmentation",
                        "instance-level segmentation",
                        "instance-level segmentation module",
                        "human instance segmentation",
                        "instance-level part segmentation",
                        "instance-level human segmentation",
                        "instance-level segmentations",
                        "instance module"
                    ]
                ],
                "Metric": [
                    [
                        "ap r metric",
                        "ap metric",
                        "ap r"
                    ]
                ],
                "Task": [
                    [
                        "holistic, instance-level human parsing",
                        "parsing humans",
                        "human parsing"
                    ]
                ]
            }
        ]
    },
    "408e8eecc14c5cc60bbdfc486ba7a7fc97031788-60": {
        "doctext": "discriminative unsupervised feature learning with convolutional neural networks current methods for training convolutional neural networks depend on large amounts of labeled samples for supervised training. in this paper we present an approach for training a convolutional neural network using only unlabeled data. we train the network to discriminate between a set of surrogate classes. each surrogate class is formed by applying a variety of transformations to a randomly sampled' seed' image patch. we find that this simple feature learning algorithm is surprisingly successful when applied to visual object recognition. the feature representation learned by our algorithm achieves classification results matching or outperforming the current state-of-the-art for unsupervised learning on several popular datasets (stl-10, cifar-10, caltech-101). 1 introduction convolutional neural networks (cnns) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories [1, 2]. the feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on caltech-101 [2, 3], caltech-256 [2] and the caltechucsd birds dataset [3]; scene recognition on the sun-397 database [3]; detection on the pascal voc dataset [4]. this capability to generalize to new datasets makes supervised cnn training an attractive approach for generic visual feature learning. the downside of supervised training is the need for expensive labeling, as the amount of required labeled samples grows quickly the larger the model gets. the large performance increase achieved by methods based on the work of krizhevsky et al. [1] was, for example, only possible due to massive efforts on manually annotating millions of images. for this reason, unsupervised learning- although currently underperforming- remains an appealing paradigm, since it can make use of raw unlabeled images and videos. furthermore, on vision tasks outside classification it is not even certain whether training based on object class labels is advantageous. for example, unsupervised feature learning is known to be beneficial for image restoration [5] and recent results show that it outperforms supervised feature learning also on descriptor matching [6]. in this work we combine the power of a discriminative objective with the major advantage of unsupervised feature learning: cheap data acquisition. we introduce a novel training procedure for convolutional neural networks that does not require any labeled data. it rather relies on an automatically generated surrogate task. the task is created by taking the idea of data augmentation- which is commonly used in supervised learning- to the extreme. starting with trivial surrogate classes consisting of one random image patch each, we augment the data by applying a random set of transformations to each patch. then we train a cnn to classify these surrogate classes. we refer to this method as exemplar training of convolutional neural networks (exemplar-cnn). the feature representation learned by exemplar-cnn is, by construction, discriminative and invariant to typical transformations. we confirm this both theoretically and empirically, showing that this approach matches or outperforms all previous unsupervised feature learning methods on the standard image classification benchmarks stl-10, cifar-10, and caltech-101. 1.1 related work our approach is related to a large body of work on unsupervised learning of invariant features and training of convolutional neural networks. convolutional training is commonly used in both supervised and unsupervised methods to utilize the invariance of image statistics to translations (e.g. lecun et al. [7], kavukcuoglu et al. [8], krizhevsky et al. [1]). similar to our approach the current surge of successful methods employing convolutional neural networks for object recognition often rely on data augmentation to generate additional training samples for their classification objective (e.g. krizhevsky et al. [1], zeiler and fergus [2]). while we share the architecture (a convolutional neural network) with these approaches, our method does not rely on any labeled training data. in unsupervised learning, several studies on learning invariant representations exist. denoising autoencoders [9], for example, learn features that are robust to noise by trying to reconstruct data from randomly perturbed input samples. zou et al. [10] learn invariant features from video by enforcing a temporal slowness constraint on the feature representation learned by a linear autoencoder. sohn and lee [11] and hui [12] learn features invariant to local image transformations. in contrast to our discriminative approach, all these methods rely on directly modeling the input distribution and are typically hard to use for jointly training multiple layers of a cnn. the idea of learning features that are invariant to transformations has also been explored for supervised training of neural networks. the research most similar to ours is early work on tangent propagation [13] (and the related double backpropagation [14]) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations. in contrast, our algorithm does not regularize the derivative explicitly. thus it is less sensitive to the magnitude of the applied transformation. this work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training [15] or entropy regularization [16]. in contrast to these semi-supervised methods, exemplar-cnn training does not require any labeled data. finally, the idea of creating an auxiliary task in order to learn a good data representation was used by ahmed et al. [17], collobert et al. [18]. 2 creating surrogate training data the input to the training procedure is a set of unlabeled images, which come from roughly the same distribution as the images to which we later aim to apply the learned features. we randomly sample n\u2208 [50, 32000] patches of size 32\u00d732 pixels from different images at varying positions and scales forming the initial training set x= {x1,...xn}. we are interested in patches containing objects or parts of objects, hence we sample only from regions containing considerable gradients. we define a family of transformations {t\u03b1|\u03b1\u2208 a} parameterized by vectors\u03b1\u2208 a, where a is the set of all possible parameter vectors. each transformation t\u03b1 is a composition of elementary transformations from the following list:\u2022 translation: vertical or horizontal translation by a distance within 0.2 of the patch size;\u2022 scaling: multiplication of the patch scale by a factor between 0.7 and 1.4;\u2022 rotation: rotation of the image by an angle up to 20 degrees;\u2022 contrast 1: multiply the projection of each patch pixel onto the principal components of the set of all pixels by a factor between 0.5 and 2 (factors are independent for each principal component and the same for all pixels within a patch);\u2022 contrast 2: raise saturation and value (s and v components of the hsv color representation) of all pixels to a power between 0.25 and 4 (same for all pixels within a patch), multiply these values by a factor between 0.7 and 1.4, add to them a value between\u22120.1 and 0.1;\u2022 color: add a value between\u22120.1 and 0.1 to the hue (h component of the hsv color representation) of all pixels in the patch (the same value is used for all pixels within a patch). all numerical parameters of elementary transformations, when concatenated together, form a single parameter vector\u03b1. for each initial patch xi\u2208 x we sample k\u2208 [1, 300] random parameter vectors {\u03b11i,...,\u03b1ki} and apply the corresponding transformations ti= {t\u03b11i,..., t\u03b1ki} to the patch xi. this yields the set of its transformed versions sxi= tixi= {txi|t\u2208 ti}. afterwards we subtract the mean of each pixel over the whole resulting dataset. we do not apply any other preprocessing. exemplary patches sampled from the stl-10 unlabeled dataset are shown in fig. 1. examples of transformed versions of one patch are shown in fig. 2. 3 learning algorithm given the sets of transformed image patches, we declare each of these sets to be a class by assigning label i to the class sxi. we next train a cnn to discriminate between these surrogate classes. formally, we minimize the following loss function: l (x)=\u2211 xi\u2208x\u2211 t\u2208ti l (i, txi), (1) where l (i, txi) is the loss on the transformed sample txi with (surrogate) true label i. we use a cnn with a softmax output layer and optimize the multinomial negative log likelihood of the network output, hence in our case l (i, txi)= m (ei, f (txi)), m (y, f)=\u2212\u3008y, log f\u3009=\u2212\u2211 k yk log fk, (2) where f (\u00b7) denotes the function computing the values of the output layer of the cnn given the input data, and ei is the ith standard basis vector. we note that in the limit of an infinite number of transformations per surrogate class, the objective function (1) takes the form l\u0302 (x)=\u2211 xi\u2208x e\u03b1 [l (i, t\u03b1xi)], (3) which we shall analyze in the next section. intuitively, the classification problem described above serves to ensure that different input samples can be distinguished. at the same time, it enforces invariance to the specified transformations. in the following sections we provide a foundation for this intuition. we first present a formal analysis of the objective, separating it into a well defined classification problem and a regularizer that enforces invariance (resembling the analysis in wager et al. [19]). we then discuss the derived properties of this classification problem and compare it to common practices for unsupervised feature learning. 3.1 formal analysis we denote by\u03b1\u2208 a the random vector of transformation parameters, by g (x) the vector of activations of the second-to-last layer of the network when presented the input patch x, by w the matrix of the weights of the last network layer, by h (x)= wg (x) the last layer activations before applying the softmax, and by f (x)= softmax (h (x)) the output of the network. by plugging in the definition of the softmax activation function softmax (z)= exp (z)/\u2016 exp (z)\u20161 (4) the objective function (3) with loss (2) takes the form\u2211 xi\u2208x e\u03b1 [\u2212\u3008ei, h (t\u03b1xi)\u3009+ log\u2016 exp (h (t\u03b1xi))\u20161]. (5) with g\u0302i= e\u03b1 [g (t\u03b1xi)] being the average feature representation of transformed versions of the image patch xi we can rewrite eq. (5) as\u2211 xi\u2208x [\u2212\u3008ei, wg\u0302i\u3009+ log\u2016 exp (wg\u0302i)\u20161]+\u2211 xi\u2208x [e\u03b1 [log\u2016 exp (h (t\u03b1xi))\u20161]\u2212 log\u2016 exp (wg\u0302i)\u20161]. (6) the first sum is the objective function of a multinomial logistic regression problem with input-target pairs (g\u0302i, ei). this objective falls back to the transformation-free instance classification problem l (x)=\u2211 xi\u2208x l (i, xi) if g (xi)= e\u03b1 [g (t\u03b1x)]. in general, this equality does not hold and thus the first sum enforces correct classification of the average representation e\u03b1 [g (t\u03b1xi)] for a given input sample. for a truly invariant representation, however, the equality is achieved. similarly, if we suppose that t\u03b1x= x for\u03b1= 0, that for small values of\u03b1 the feature representation g (t\u03b1xi) is approximately linear with respect to\u03b1 and that the random variable\u03b1 is centered, i.e. e\u03b1 [\u03b1]= 0, then g\u0302i= e\u03b1 [g (t\u03b1xi)]\u2248 e\u03b1 [g (xi)+\u2207\u03b1 (g (t\u03b1xi))|\u03b1=0\u03b1]= g (xi). the second sum in eq. (6) can be seen as a regularizer enforcing all h (t\u03b1xi) to be close to their average value, i.e., the feature representation is sought to be approximately invariant to the transformations t\u03b1. to show this we use the convexity of the function log\u2016 exp (\u00b7)\u20161 and jensen's inequality, which yields (proof in supplementary material) e\u03b1 [log\u2016 exp (h (t\u03b1xi))\u20161]\u2212 log\u2016 exp (wg\u0302i)\u20161\u2265 0. (7) if the feature representation is perfectly invariant, then h (t\u03b1xi)= wg\u0302i and inequality (7) turns to equality, meaning that the regularizer reaches its global minimum. 3.2 conceptual comparison to previous unsupervised learning methods suppose we want to unsupervisedly learn a feature representation useful for a recognition task, for example classification. the mapping from input images x to a feature representation g (x) should then satisfy two requirements: (1) there must be at least one feature that is similar for images of the same category y (invariance); (2) there must be at least one feature that is sufficiently different for images of different categories (ability to discriminate). most unsupervised feature learning methods aim to learn such a representation by modeling the input distribution p (x). this is based on the assumption that a good model of p (x) contains information about the category distribution p (y|x). that is, if a representation is learned, from which a given sample can be reconstructed perfectly, then the representation is expected to also encode information about the category of the sample (ability to discriminate). additionally, the learned representation should be invariant to variations in the samples that are irrelevant for the classification task, i.e., it should adhere to the manifold hypothesis (see e.g. rifai et al. [20] for a recent discussion). invariance is classically achieved by regularization of the latent representation, e.g., by enforcing sparsity [8] or robustness to noise [9]. in contrast, the discriminative objective in eq. (1) does not directly model the input distribution p (x) but learns a representation that discriminates between input samples. the representation is not required to reconstruct the input, which is unnecessary in a recognition or matching task. this leaves more degrees of freedom to model the desired variability of a sample. as shown in our analysis (see eq. (7)), we achieve partial invariance to transformations applied during surrogate data creation by forcing the representation g (t\u03b1xi) of the transformed image patch to be predictive of the surrogate label assigned to the original image patch xi. it should be noted that this approach assumes that the transformations t\u03b1 do not change the identity of the image content. if we, for example, use a color transformation we will force the network to be invariant to this change and can not expect the extracted features to perform well in a task relying on color information (such as differentiating black panthers from pumas) 1. 4 experiments to compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the stl-10 [21], cifar-10 [22] and caltech-101 [23] datasets. moreover, we assess the influence of the augmentation parameters on the classification performance and study the invariance properties of the network. 4.1 experimental setup the datasets we test on differ in the number of classes (10 for cifar and stl, 101 for caltech) and the number of samples per class. stl is especially well suited for unsupervised learning as it contains a large set of 100, 000 unlabeled samples. in all experiments (except for the dataset transfer experiment in the supplementary material) we extracted surrogate training data from the unlabeled subset of stl-10. when testing on cifar-10, we resized the images from 32\u00d732 pixels to 64\u00d764 pixels so that the scale of depicted objects roughly matches the two other datasets. we worked with two network architectures. a\" small\" network was used to evaluate the influence of different components of the augmentation procedure on classification performance. it consists of two convolutional layers with 64 filters each followed by a fully connected layer with 128 neurons. this last layer is succeeded by a softmax layer, which serves as the network output. a\" large\" network, consisting of three convolutional layers with 64, 128 and 256 filters respectively followed by a fully connected layer with 512 neurons, was trained to compare our method to the state-of-theart. in both models all convolutional filters are connected to a 5\u00d75 region of their input. 2\u00d72 maxpooling was performed after the first and second convolutional layers. dropout [24] was applied to the fully connected layers. we trained the networks using an implementation based on caffe [25]. details on the training, the hyperparameter settings, and an analysis of the performance depending on the network architecture is provided in the supplementary material. our code and training data are available at http:// lmb.informatik.uni-freiburg.de/ resources. we applied the feature representation to images of arbitrary size by convolutionally computing the responses of all the network layers except the top softmax. to each feature map, we applied the pooling method that is commonly used for the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure for stl-10 and cifar-10 [26, 10, 27, 12]; 2) 3-layer spatial pyramid, i.e. max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4\u00d7 4 grid, resulting in 1+ 4+ 16= 21 values per feature map, which is the standard for caltech-101 [28, 10, 29]. finally, we trained a linear support vector machine (svm) on the pooled features. on all datasets we used the standard training and test protocols. on stl-10 the svm was trained on 10 pre-defined folds of the training data. we report the mean and standard deviation achieved on the fixed test set. for cifar-10 we report two results: (1) training the svm on the whole cifar-10 training set (' cifar-10'); (2) the average over 10 random selections of 400 training samples per class (' cifar-10 (400)'). for caltech-101 we followed the usual protocol of selecting 30 random samples per class for training and not more than 50 samples per class for testing. this was repeated 10 times. 4.2 classification results in table 1 we compare exemplar-cnn to several unsupervised feature learning methods, including the current state-of-the-art on each dataset. we also list the state-of-the-art for supervised learning (which is not directly comparable). additionally we show the dimensionality of the feature vectors 1such cases could be covered either by careful selection of applied transformations or by combining features from multiple networks trained with different sets of transformations and letting the final classifier choose which features to use. produced by each method before final pooling. the small network was trained on 8000 surrogate classes containing 150 samples each and the large one on 16000 classes with 100 samples each. the features extracted from the larger network match or outperform the best prior result on all datasets. this is despite the fact that the dimensionality of the feature vector is smaller than that of most other approaches and that the networks are trained on the stl-10 unlabeled dataset (i.e. they are used in a transfer learning manner when applied to cifar-10 and caltech 101). the increase in performance is especially pronounced when only few labeled samples are available for training the svm (as is the case for all the datasets except full cifar-10). this is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an svm becomes less dependent on the quality of the features [26, 12]. remarkably, on stl-10 we achieve an accuracy of 72.8%, which is a large improvement over all previously reported results. 4.3 detailed analysis we performed additional experiments (using the\" small\" network) to study the effect of three design choices in exemplar-cnn training and validate the invariance properties of the learned features. experiments on sampling' seed' patches from different datasets can be found in the supplementary. 4.3.1 number of surrogate classes we varied the number n of surrogate classes between 50 and 32000. as a sanity check, we also tried classification with random filters. the results are shown in fig. 3. clearly, the classification accuracy increases with the number of surrogate classes until it reaches an optimum at about 8000 surrogate classes after which it did not change or even decreased. this is to be expected: the larger the number of surrogate classes, the more likely it is to draw very similar or even identical samples, which are hard or impossible to discriminate. few such cases are not detrimental to the classification performance, but as soon as such collisions dominate the set of surrogate labels, the discriminative loss is no longer reasonable and training the network to the surrogate task no longer succeeds. to check the validity of this explanation we also plot in fig. 3 the classification error on the validation set (taken from the surrogate data) computed after training the network. it rapidly grows as the number of surrogate classes increases. we also observed that the optimal number of surrogate classes increases with the size of the network (not shown in the figure), but eventually saturates. this demonstrates the main limitation of our approach to randomly sample' seed' patches: it does not scale to arbitrarily large amounts of unlabeled data. however, we do not see this as a fundamental restriction and discuss possible solutions in section 5. 4.3.2 number of samples per surrogate class fig. 4 shows the classification accuracy when the number k of training samples per surrogate class varies between 1 and 300. the performance improves with more samples per surrogate class and 2 on caltech-101 one can either measure average accuracy over all samples (average overall accuracy) or calculate the accuracy for each class and then average these values (average per-class accuracy). these differ, as some classes contain fewer than 50 test samples. most researchers in ml use average overall accuracy. saturates at around 100 samples. this indicates that this amount is sufficient to approximate the formal objective from eq. (3), hence further increasing the number of samples does not significantly change the optimization problem. on the other hand, if the number of samples is too small, there is insufficient data to learn the desired invariance properties. 4.3.3 types of transformations we varied the transformations used for creating the surrogate data to analyze their influence on the final classification performance. the set of' seed' patches was fixed. the result is shown in fig. 5. the value' 0' corresponds to applying random compositions of all elementary transformations: scaling, rotation, translation, color variation, and contrast variation. different columns of the plot show the difference in classification accuracy as we discarded some types of elementary transformations. several tendencies can be observed. first, rotation and scaling have only a minor impact on the performance, while translations, color variations and contrast variations are significantly more important. secondly, the results on stl-10 and cifar-10 consistently show that spatial invariance and color-contrast invariance are approximately of equal importance for the classification performance. this indicates that variations in color and contrast, though often neglected, may also improve performance in a supervised learning scenario. thirdly, on caltech-101 color and contrast transformations are much more important compared to spatial transformations than on the two other datasets. this is not surprising, since caltech-101 images are often well aligned, and this dataset bias makes spatial invariance less useful. 4.3.4 invariance properties of the learned representation in a final experiment, we analyzed to which extent the representation learned by the network is invariant to the transformations applied during training. we randomly sampled 500 images from the stl-10 test set and applied a range of transformations (translation, rotation, contrast, color) to each image. to avoid empty regions beyond the image boundaries when applying spatial transformations, we cropped the central 64\u00d764 pixel sub-patch from each 96\u00d796 pixel image. we then applied two measures of invariance to these patches. first, as an explicit measure of invariance, we calculated the normalized euclidean distance between normalized feature vectors of the original image patch and the transformed one [10] (see the supplementary material for details). the downside of this approach is that the distance between extracted features does not take into account how informative and discriminative they are. we there-fore evaluated a second measure- classification performance depending on the magnitude of the transformation applied to the classified patches- which does not come with this problem. to compute the classification accuracy, we trained an svm on the central 64\u00d7 64 pixel patches from one fold of the stl-10 training set and measured classification performance on all transformed versions of 500 samples from the test set. the results of both experiments are shown in fig. 6. due to space restrictions we show only few representative plots. overall the experiment empirically confirms that the exemplar-cnn objective leads to learning invariant features. features in the third layer and the final pooled feature representation compare favorably to a hog baseline (fig. 6 (a)). furthermore, adding stronger transformations in the surrogate training data leads to more invariant classification with respect to these transformations (fig. 6 (b)-(d)). however, adding too much contrast variation may deteriorate classification performance (fig. 6 (d)). one possible reason is that level of contrast can be a useful feature: for example, strong edges in an image are usually more important than weak ones. 5 discussion we have proposed a discriminative objective for unsupervised feature learning by training a cnn without class labels. the core idea is to generate a set of surrogate labels via data augmentation. the features learned by the network yield a large improvement in classification accuracy compared to features obtained with previous unsupervised methods. these results strongly indicate that a discriminative objective is superior to objectives previously used for unsupervised feature learning. one potential shortcoming of the proposed method is that in its current state it does not scale to arbitrarily large datasets. two probable reasons for this are that (1) as the number of surrogate classes grows larger, many of them become similar, which contradicts the discriminative objective, and (2) the surrogate task we use is relatively simple and does not allow the network to learn invariance to complex variations, such as 3d viewpoint changes or inter-instance variation. we hypothesize that the presented approach could learn more powerful higher-level features, if the surrogate data were more diverse. this could be achieved by using additional weak supervision, for example, by means of video or a small number of labeled samples. another possible way of obtaining richer surrogate training data and at the same time avoiding similar surrogate classes would be (unsupervised) merging of similar surrogate classes. we see these as interesting directions for future work. acknowledgements we acknowledge funding by the erc starting grant videolearn (279401); the work was also partly supported by the brainlinks-braintools cluster of excellence funded by the german research foundation (dfg, grant number exc 1086).",
        "pred_templates": [
            {
                "Material": [
                    [
                        "cifar-10"
                    ],
                    [
                        "stl-10"
                    ],
                    [
                        "cifar-10"
                    ],
                    [
                        "caltech-101"
                    ]
                ],
                "Method": [],
                "Metric": [],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "cifar-10",
                        "cifar"
                    ]
                ],
                "Method": [
                    [
                        "discriminative unsupervised feature learning with convolutional neural networks",
                        "convolutional neural networks",
                        "cnns",
                        "cnn"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "classification",
                        "image classification tasks",
                        "classification task",
                        "classification problem",
                        "ml"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "stl-10",
                        "stl"
                    ]
                ],
                "Method": [
                    [
                        "discriminative unsupervised feature learning with convolutional neural networks",
                        "convolutional neural networks",
                        "cnns",
                        "cnn"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "classification",
                        "image classification tasks",
                        "classification task",
                        "classification problem",
                        "ml"
                    ]
                ]
            }
        ]
    },
    "4365eb43a635bc6431dfaf3af1f7bf7bf55522cc-61": {
        "doctext": "document: couplenet: coupling global structure with local parts for object detection the region-based convolutional neural network (cnn) detectors such as faster r-cnn or r-fcn have already shown promising results for object detection by combining the region proposal subnetwork and the classification subnetwork together. although r-fcn has achieved higher detection speed while keeping the detection performance, the global structure information is ignored by the position-sensitive score maps. to fully explore the local and global properties, in this paper, we propose a novel fully convolutional network, named as couplenet, to couple the global structure with local parts for object detection. specifically, the object proposals obtained by the region proposal network (rpn) are fed into the the coupling module which consists of two branches. one branch adopts the position-sensitive roi (psroi) pooling to capture the local part information of the object, while the other employs the roi pooling to encode the global and context information. next, we design different coupling strategies and normalization ways to make full use of the complementary advantages between the global and local branches. extensive experiments demonstrate the effectiveness of our approach. we achieve state-of-the-art results on all three challenging datasets, a map of on voc07, on voc12, and on coco. codes will be made publicly available. section: introduction general object detection requires to accurately locate and classify all targets in the image or video. compared to specific object detection, such as face, pedestrian and vehicle detection, general object detection often faces more challenges due to the large inter-class appearance differences. the variations arise not only from changes in a variety of non-rigid deformations, but also due to the truncations, occlusions and inter-class interference. however, no matter how complicated the objects are, when humans identify a target, the recognition of object categories is subserved by both a global process that retrieves structural information and a local process that is sensitive to individual parts. this motivates us to build a detection model that fused both global and local information. with the revival of convolutional neural networks (cnn), cnn-based object detection pipelines have been proposed consecutively and made impressive improvements in generic benchmarks, pascal voc and ms coco. as two representative region-based cnn approaches, fast/ faster r-cnn uses a certain subnetwork to predict the category of each region proposal while r-fcn conducts the inference with the position-sensitive score maps. through removing the roi-wise subnetwork, r-fcn has achieved higher detection speed while keeping the detection performance. however, the global structure information is ignored by the psroi pooling. as shown in figure [reference], using psroi pooling to extract local part information for final object category prediction, r-fcn leads to a low confidence score of 0.08 for the sofa detection since the local responses of sofa are disturbed by a women and a dog (they are also the categories that need to be detected). conversely, the global structure of sofa could be extracted by the roi pooling, but the confidence score is 0.45, which is also very low for the incomplete structure of sofa. by coupling the global confidence with the local part confidence together, we can obtain a more reliable prediction with the confidence score of 0.78. in fact, the idea of fusing global and local information together is widely used in lots of visual tasks. in fingerprint recognition, gu combined the global orientation field and local minutiae cue to largely improve the performance. in clique-graph matching, nie proposed a clique-graph matching method by preserving global clique-to-clique correspondence and local unary and pairwise correspondences. in scene parsing, zhao designed a pyramid pooling module to effectively extract hierarchical global contextual prior, and then concatenated it with the local fcn feature to improve the performance. in traditional object detection, felzenszwalb incorporated a global root model and several finer local part models to represent highly variable objects. all of which show that effective combination of the global structural properties and local fine-grained details can achieve complementary advantages. therefore, to fully explore the global and local clues, in this paper, we propose a novel full convolutional network named as couplenet, to couple the global structure and local parts to boost the detection accuracy. specifically, the object proposals obtained by the rpn are fed into the coupling module which consists of two branches. one branch adopts the psroi pooling to capture the local part information of the object, while the other employs the roi pooling to encode the global and context information. moreover, we design different coupling strategies and normalization ways to make full use of the complementary advantages between the global and local branches. with the coupling structure, our network can jointly learn the local, global and context expression of the objects, which makes the model have a more powerful representation capacity and generalization ability. extensive experiments demonstrate that couplenet can significantly improve the detection performance. our detector shows competitive results on pascal voc 07/ 12 and ms coco compared to other state-of-the-art detectors, even with model ensemble approaches. in summary, our main contributions are as follows: 1. we propose a unified fully convolutional network to jointly learn the local, global and context information for object detection. 2. we design different normalization methods and coupling strategies to mine the compatibility and complementarity between the global and local branches. 3. we achieve the state-of-the-art results on all three challenging datasets, a map of on voc07, on voc12, and on ms coco. section: related work before the arrival of cnn, visual tasks have been dominated by traditional paradigms. as one of an outstanding framework, dpm described the object system using mixtures of multi-scale deformable part models, including a coarse global root model and several finer local part models. the root model extracts structural information of the objects, while the part models capture local appearance properties of an object. the sum of root response and weighted average response of each part is used as the final confidence of an object. although dpm provides an elegant framework for object detection, the hand-crafted features, improved hog, are not discriminative enough to express the diversity of object categories. this is also the main reason that cnn completely surpassed the traditional methods in a short period time. in order to leverage the great success of deep neural networks for image classification, considerable object detection methods based on deep learning have been proposed. although there are end-to-end detection frameworks, like ssd, yolo and densebox, region-based systems (fast/ faster r-cnn and r-fcn) still dominate the detection accuracy on generic benchmarks. compared to the end-to-end framework, the region-based systems have several advantages. firstly, by exploiting a divide-and-conquer strategy, the two-step framework is more stable and easier to converge. secondly, without the complicated data augmentation and training skills, you can still easily achieve state-of-the-art performance. the main reason for these advantages is that there is a certain structure to encode translation variance features for each proposal, since in deep networks, higher-layers contain more semantic meaning and less location information. as a consequence, a roi-wise subnetwork or a position-sensitive roi pooling layer is used to achieve the translation variance in region-based systems. however, all the existing region-based systems utilize either the region-level or part-level features to learn the variations, where each one alone is not representative enough for a variety of challenging situations. therefore, this motivates us to design a certain structure to take advantages of both the global and local features. in addition, context is known to play an important role in visual recognition. considerable works have been proposed for exploting context in object detection. bell explored the use of recurrent neural networks to model the contextual information. gidaris proposed to utilize multiple contextual regions around the object. cai collected the context by padding the proposals for pedestrian and car detection. similar to these works, we also absorb the context prior to enhance the global feature representation. section: couplenet in this section, we first introduce the architecture of the proposed couplenet for object detection. then we explain in detail how we incorporate local representations, global appearance and contextual information for robust object detection. subsection: network architecture the architecture of our proposed couplenet is illustrated in figure [reference]. our couplenet includes two different branches: a) a local part-sensitive fully convolutional network to learn the object-specific parts, denoted as local fcn; b) a global region-sensitive fully convolutional network to encode the whole appearance structure and context prior of the object, denoted as global fcn. we first use the imagenet pre-trained resnet-101 released in to initialize our network. for our detection task, we remove the last average pooling layer and the fc layer. given an input image, we extract candidate proposals by using the region proposal network (rpn), which also shares convolution features with couplenet following. then each proposal flows to two different branches: the local fcn and the global fcn. finally, the output of global and local fcn are coupled together as the final score of the object. we also perform class-agnostic bounding box regression in a similar way. subsection: local fcn to effectively capture the specific fine-grained parts in local fcn, we construct a set of part-sensitive score maps by appending a 1x1 convolutional layer with channels, where means we divide the object into local parts (here is set to the default value 7) and is the number of object categories plus background. for each category, there are totally channels and each channel is responsible for encoding a specific part of the object. the final score of a category is determined by voting the responses. here we use position-sensitive roi pooling layer in to extract object-specific parts and we simply perform average pooling for voting. then, we obtain a-d vector which indicates the probability that the object belongs to each class. this procedure is equivalent to dividing a strong object category decision into the sum of multiple weak classifiers, which serves as the ensemble of several part models. here we refer this part ensemble as local structure representation. as shown in figure [reference] (a), for the truncated person, one can hardly get a strong response from the global description of the person due to truncation, on the contrary, our local fcn can effectively capture several specific parts, such as human nose, mouth,, which correspond to the regions with large responses in the feature map. we argue that the local fcn is much concerned with the internal structure and components, which can effectively reflect the local properties of visual object, especially when the object is occluded or the whole boundary is incomplete. however, for those having simple spatial structure and encompassing considerable background in the bounding box, dining table, the local fcn alone is difficult to make robust predictions. thus it is necessary to add the global structure information to enhance the discrimination. subsection: global fcn for the global fcn, we aim to describe the object by using the whole region-level features. firstly, we attach a 1024-d 1x1 convolutional layer after the last convolutional block in resnet-101 for reducing the dimension. due to the diverse size of the object, we insert a roi pooling layer in to extract a fixed-length feature vector as the global structure description of the object. secondly, we use two convolutional layers with kernal size and respectively (is set to the default value 7) to further abstract the global representation of roi. finally, the output of 1x1 convolution is fed into the classifier whose output is also a-d vector. in addition, context prior is the most basic and important factor for visual recognition tasks. for example, the boat usually travels in the water while is unlikely to fly in the sky. despite the higher layers in deep neural network can involve the spatial context information around the objects due to the large receptive field, zhou have shown that the practical receptive field is actually much smaller than the theoretical one. therefore, it is necessary to explicitly collect the surrounding information to reduce the chance of misclassification. to enhance the feature representation ability of the global fcn, here we introduce the contextual information as an effective supplement. specifically, we extend the context region by 2 times larger than the size of original proposal. then the features roi pooled from the original region and context region are concatenated together and fed into the latter roi-wise subnetwork. as shown in figure [reference], the context region is embedded into the global branch to extract a more complete appearance structure and discriminative prior representation, which will help the classifier to better identity the object categories. due to the roi pooling operation, the global fcn describes the proposal as a whole with cnn features, which can be seen as a global structure description of the object. therefore, it can easily deal with the objects with intact structure and finer scale. as shown in figure [reference] (b), our global fcn shows a large confidence for the dining table. however, in most cases, natural scenes consist of considerable objects with occlusions or truncations, making the detection more difficult. figure [reference] (a) shows that using the global structure information alone can hardly make a confident prediction for the truncated person. by adding local part structural supports, the detection performance can be significantly boosted. therefore, it is essential to combine both local and global descriptions for a robust detection. subsection: coupling structure to match the same order of magnitude, we apply a normalization operation to the output of local and global fcn before they are combined together. we explored two different methods to perform normalization: an l2 normalization layer or a 1x1 convolutional layer to model the scale. meanwhile, how to couple the local and global output is also a problem that needs to be researched. here, we investigated three different coupling methods: element-wise sum, element-wise product and element-wise maximum. our experiments show that using 1x1 convolution along with element-wise sum achieves the best performance and we will discuss it in section [reference]. with the coupling structure, couplenet simultaneously exploits the local parts, global structure and context prior for object detection. the whole network is fully convolutional and benefits from approximate joint training and multi-task learning. we also note that the global branch can be regarded as a lightweight faster r-cnn, in which all learnable parameters are from convolutional layers and the depth of roi-wise subnetwork is only two. therefore, the computational complexity is far less than the subnetwork in resnet-based faster r-cnn system whose depth is ten. as a consequence, our couplenet can perform the inference efficiently, which runs slightly slower than r-fcn but much more faster than faster r-cnn. section: experiments we train and evaluate our method on three challenging object detection datasets: pascal voc2007, voc2012 and ms coco. since all these three datasets contain a variety of circumstances, which can sufficiently verify the effectiveness of our method. we demonstrate state-of-the-art results on all three datasets without bells and whistles. subsection: ablation studies on voc2007 we first perform experiments on pascal voc 2007 with 20 object categories for detailed analysis of our proposed couplenet detector. we train the models on the union set of voc 2007 trainval and voc 2012 trainval (\" 07+ 12\") following, and evaluate on voc 2007 test set. object detection accuracy is measured by mean average precision (map), all the ablation experiments use single-scale training and testing, and we did not add the context prior. normalization. since features extracted form different layers of cnn show various of scales, it is essential to normalize different features before coupling them together. bell proposed to use l2 normalization to each roi-pooled feature and re-scale back up by a empirical scale, which shows a great gain on voc dataset. in this paper, we also explore two different normalization ways to normalize the output of local and global fcn: an l2 normalization layer or a 1x1 convolutional layer to learn the scale. as shown in table [reference], we find that the use of l2 normalization decreases the performance greatly, even worse than the direct addition (without any normalization ways). to explain such a phenomenon, we measured the outputs of two branches before and after l2 normalization. we further found that l2 normalization reduces the output gap between different categories, which results in a smaller score gap. as we know, a small score gap between different categories always means the classifier can not make a confident prediction. therefore, we assume that this is the reason for the performance degradation. moreover, we also exploit a 1x1 convolution to adaptively learn the scales between the global and local branches. table [reference] shows that using 1x1 convolution increases by points compared to the direct addition and points over r-fcn. therefore, we use 1x1 convolution to replace the l2 normalization in the following experiments. coupling strategy. we explore three different response coupling strategies: element-wise sum, element-wise product and element-wise maximum. table [reference] shows the comparison results for the above three different implementations. we can see that the element-wise sum always achieves the best performance even though in different normalization methods. generally, current advanced residual networks also use element-wise sum as the effective way to integrate information from previous layers, which greatly facilitates the circulation of information and achieves the complementary advantages. for element-wise product, we argue that the system is relatively unstable and is susceptible to the weak side, which results in a large gradient to update the weak branch that makes it difficult to converge. for element-wise maximum, it equals to an ensemble model within the network to some extent, which losts the advantages of mutual support compared to element-wise sum when both two branches are failed to detect the object. moreover, a better coupling strategy can be taken into consideration as the future work to further improve the accuracy, such as designing a more subtle nonlinear structure to learn the coupling relationship. model ensemble. model ensemble is commonly used to improve the final detection performance, since diverse initialization of parameters and the randomness of training samples both lead to different performance for the same model. although the differences and complementarities will be more pronounced for different models, the promotion is often very limited. as shown in table [reference], we also compare our couplenet with the model ensemble. for a fair comparison, we first re-implemented faster r-cnn using resnet-101 and online hard example mining (ohem), which achieves a map of on voc07 (in original paper without ohem). we also re-implemented r-fcn with appropriate joint training using the public available code py-r-fcn, which achieves a slightly lower result compared to (vs.). we use our reimplementation models to conduct the comparisons for consistency. we found that the promotion brought by model ensemble is less than 1 point. as shown in table [reference], it is far less than our method (). on the one hand, we argue that the naive model ensemble just combines the results together and does not essentially guide the learning process of the network, while our couplenet can simultaneously utilize the global and local information to update the network and to infer the final results. on the other hand, our method enjoys end-to-end training and there is no need to train multiple models, thus greatly reducing the training time. amount of parameters. since our couplenet introduces a few more parameters compared with the single branch detectors, to further verify effectiveness of the coupling structure, here we increase the parameters of the prediction head for each single branch implementation to maintain the same amount of parameters with couplenet for comparison. in detail, we add a new residual variant block with three convolution layers, where the kernel size is 1x1x256, 3x3x256 and 1x1x1024 respectively, to the prediction sub-network. we found that the standard r-fcn with one or two extra heads got a map of and respectively in voc07, which is slightly higher than our re-implemented version () in as shown in table [reference]. meanwhile, our global fcn, which performs the roi pooling on top of conv5, got a relative higher gain (a map of for one head, for two heads). the results indicate that simply adding more prediction layers obtains a very limited performance gain, while our coupling structure shows more discriminative power with the same amount of parameters. subsection: results on voc2007 using the public available resnet-101 as the initialization model, we note that our method is easy to follow and the hyper-parameters for training are the same as in. similarly, we use the dilation strategy to reduce the effective stride of resnet-101, just as shows, thus both the global and local branches have a stride of 16. we also use a 1-gpu implementation, and the effective mini-batch size is 2 images by setting the to 2. the whole network is trained for 80k iterations with a learning rate of 0.001 and then for 30k iterations with 0.0001. in addition, the context prior is proposed to further boost the performance while keeping the iterations unchanged. finally, we also perform multi-scale training with the shorter sides of images are randomly resized from 480 to 864. table [reference] shows the detailed comparisons with faster r-cnn and r-fcn. as we can see that our single model achieves a map of, which outperforms the r-fcn by 2.2 points. however, while embedding the context prior to the global branch, our map rises up to, which is the current best single model detector to our knowledge. moreover, we also evaluate the inference time of our network using a nvidia titan x gpu (pascal) along with cuda 8.0 and cudnn-v5.1. as shown in the last column of table [reference], our method is slightly slower than r-fcn, which also reaches a real-time speed (8.2 fps or 9.8 fps without context) and achieves the best trade-off between accuracy and speed. we argue that the sharing process of feature extraction between two branches and the design of lightweight roi-wise subnetwork after roi pooling both greatly reduce the model complexity. as shown in table [reference], we also compared our method with other state-of-the-art single model. we found that our method outperforms the others with a large margin, including the advanced end-to-end ssd method, which requires complicated data augmentation and careful training skills. just as discussed earlier, couplenet shows a large gain over the classes with occlusions, truncations and considerable background information, like sofa, person, table and chair, which verifies our analyses. we also observed a large improvement for airplane, bird, boat and pottedplant, which usually have class-specific backgrounds, the sky for airplane and bird, water for boat and so on. therefore, the context surrounding the objects provides an extra auxiliary discrimination. subsection: results on voc2012 we also evaluate our method on the more challenging voc2012 dataset by submitting results to the public evaluation server. we use voc07 trainval, voc07 test and voc12 trainval as the training set, which consists of 21k images in total. we also follow the similar hyper-parameter settings in voc07 but change the iterations, since there are more training images. we train our models with 4 gpus, and the effective mini-batch size thus becomes 4 (1 per gpu). as a result, the network is trained for 60k iterations with a learning rate of 0.001 and 0.0001 for the following 20k iterations. table [reference] shows the results on the voc2012 test set. our method obtains a top map of, which is 2.8 points higher than r-fcn. we note that without using the extra tricks in the testing phase, our detector is the first one with a map higher than. similar promotions over the specific classes analysed in voc07 are also observed, which once again validates the effectiveness of our method. figure [reference] shows some detection examples on voc 2012 test set. subsection: results on ms coco next we present more results on the microsoft coco object detection dataset. the dataset consists of 80k training set, 40k validation set and 20k test-dev set, which involves 80 object categories. all our models are trained on the union set of 80k training set and 40k validation set, and evaluated on 20k test-dev set. the coco standard metric denotes as ap, which is evaluated at. following the voc2012, a 4-gpu implementation is used to accelerate the training process. we use an initial learning rate of 0.001 for the first 510k iterations and 0.0001 for the next 70k iterations. in addition, we conduct multi-scale training with the scales are randomly sampled from while testing in a single scale. table [reference] shows our results. our single-scale trained detector has already achieved a result of, which outperforms the r-fcn by 3.9 points. in addition, the multi-scale training further improves the performance up to. interestingly, we observed that the more challenging the dataset, the more the promotion (, for voc07, for voc12 and for coco, all in multi-scale training), which directly proves that our approach can effectively cope with a variety of complex situations. section: conclusion in this paper, we present the couplenet, a concise yet effective network that simultaneously couples global, local and context cues for accurate object detection. our system naturally combines the advantages of different region-based approaches with the coupling structure. with the combination of local part representation, global structural information and the contextual assistance, our couplenet achieves state-of-the-art results on the challenging pascal voc and coco datasets without using any extra tricks in the testing phase, which validates the effectiveness of our method. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "voc07"
                    ],
                    [
                        "voc07"
                    ],
                    [
                        "microsoft coco object detection dataset"
                    ]
                ],
                "Method": [
                    [
                        "couplenet"
                    ],
                    [
                        "couplenet"
                    ],
                    [
                        "psroi"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "object detection"
                    ],
                    [
                        "detection"
                    ],
                    [
                        "detection task"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "voc07",
                        "pascal voc 07",
                        "voc2007",
                        "union set of voc 2007 trainval",
                        "voc 2007 test set"
                    ]
                ],
                "Method": [
                    [
                        "couplenet"
                    ]
                ],
                "Metric": [
                    [
                        "map",
                        "computational complexity",
                        "mean average precision"
                    ]
                ],
                "Task": [
                    [
                        "object detection",
                        "detection",
                        "sofa detection",
                        "detection task",
                        "robust detection"
                    ]
                ]
            }
        ]
    },
    "436b07bebaa1d1f05ef85415e10374048d25334d-62": {
        "doctext": "outrageously large neural networks: the sparsely-gated mixture-of-experts layer section: abstract the capacity of a neural network to absorb information is limited by its number of parameters. conditional computation, where parts of the network are active on a per-example basis, has been proposed in theory as a way of dramatically increasing model capacity without a proportional increase in computation. in practice, however, there are significant algorithmic and performance challenges. in this work, we address these challenges and finally realize the promise of conditional computation, achieving greater than 1000x improvements in model capacity with only minor losses in computational efficiency on modern gpu clusters. we introduce a sparsely-gated mixture-of-experts layer (moe), consisting of up to thousands of feed-forward sub-networks. a trainable gating network determines a sparse combination of these experts to use for each example. we apply the moe to the tasks of language modeling and machine translation, where model capacity is critical for absorbing the vast quantities of knowledge available in the training corpora. we present model architectures in which a moe with up to 137 billion parameters is applied convolutionally between stacked lstm layers. on large language modeling and machine translation benchmarks, these models achieve significantly better results than state-of-the-art at lower computational cost. section: introduction and related work section: conditional computation exploiting scale in both training data and model size has been central to the success of deep learning. when datasets are sufficiently large, increasing the capacity (number of parameters) of neural networks can give much better prediction accuracy. this has been shown in domains such as text [reference][reference][reference][reference], images [reference][reference], and audio [reference][reference]. for typical deep learning models, where the entire model is activated for every example, this leads to a roughly quadratic blow-up in training costs, as both the model size and the number of training examples increase. unfortunately, the advances in computing power and distributed computation fall short of meeting such demand. various forms of conditional computation have been proposed as a way to increase model capacity without a proportional increase in computational costs [reference][reference][reference][reference][reference][reference]. in these schemes, large parts of a network are active or inactive on a per-example basis. the gating decisions may be binary or sparse and continuous, stochastic or deterministic. various forms of reinforcement learning and back-propagation are proposed for trarining the gating decisions.\u2022 model capacity is most critical for very large data sets. the existing literature on conditional computation deals with relatively small image recognition data sets consisting of up to 600, 000 images. it is hard to imagine that the labels of these images provide a sufficient signal to adequately train a model with millions, let alone billions of parameters. in this work, we for the first time address all of the above challenges and finally realize the promise of conditional computation. we obtain greater than 1000x improvements in model capacity with only minor losses in computational efficiency and significantly advance the state-of-the-art results on public language modeling and translation data sets. section: our approach: the sparsely-gated mixture-of-experts layer our approach to conditional computation is to introduce a new type of general purpose neural network component: a sparsely-gated mixture-of-experts layer (moe). the moe consists of a number of experts, each a simple feed-forward neural network, and a trainable gating network which selects a sparse combination of the experts to process each input (see figure 1). all parts of the network are trained jointly by back-propagation. while the introduced technique is generic, in this paper we focus on language modeling and machine translation tasks, which are known to benefit from very large models. in particular, we apply a moe convolutionally between stacked lstm layers [reference], as in figure 1. the moe is called once for each position in the text, selecting a potentially different combination of experts at each position. the different experts tend to become highly specialized based on syntax and semantics (see appendix e table 9). on both language modeling and machine translation benchmarks, we improve on best published results at a fraction of the computational cost. section: related work on mixtures of experts since its introduction more than two decades ago [reference][reference], the mixture-of-experts approach has been the subject of much research. different types of expert architectures hae been proposed such as svms [reference], gaussian processes [reference][reference][reference], dirichlet processes [reference], and deep networks. other work has focused on different expert configurations such as a hierarchical structure [reference], infinite numbers of experts [reference], and adding experts sequentially [reference]. [reference] suggest an ensemble model in the format of mixture of experts for machine translation. the gating network is trained on a pre-trained ensemble nmt model. the works above concern top-level mixtures of experts. the mixture of experts is the whole model. [reference] introduce the idea of using multiple moes with their own gating networks as parts of a deep model. it is intuitive that the latter approach is more powerful, since complex problems may contain many sub-problems each requiring different experts. they also allude in their conclusion to the potential to introduce sparsity, turning moes into a vehicle for computational computation. our work builds on this use of moes as a general purpose neural network component. while [reference] uses two stacked moes allowing for two sets of gating decisions, our convolutional application of the moe allows for different gating decisions at each position in the text. we also realize sparse gating and demonstrate its use as a practical way to massively increase model capacity. section: the structure of the mixture-of-experts layer the mixture-of-experts (moe) layer consists of a set of n\" expert networks\" e 1,\u00b7\u00b7\u00b7, e n, and a\" gating network\" g whose output is a sparse n-dimensional vector. figure 1 shows an overview of the moe module. the experts are themselves neural networks, each with their own parameters. although in principle we only require that the experts accept the same sized inputs and produce the same-sized outputs, in our initial investigations in this paper, we restrict ourselves to the case where the models are feed-forward networks with identical architectures, but with separate parameters. let us denote by g (x) and e i (x) the output of the gating network and the output of the i-th expert network for a given input x. the output y of the moe module can be written as follows: we save computation based on the sparsity of the output of g (x). wherever g (x) i= 0, we need not compute e i (x). in our experiments, we have up to thousands of experts, but only need to evaluate a handful of them for every example. if the number of experts is very large, we can reduce the branching factor by using a two-level hierarchical moe. in a hierarchical moe, a primary gating network chooses a sparse weighted combination of\" experts\", each of which is itself a secondary mixture-of-experts with its own gating network. in the following we focus on ordinary moes. we provide more details on hierarchical moes in appendix b. our implementation is related to other models of conditional computation. a moe whose experts are simple weight matrices is similar to the parameterized weight matrix proposed in. a moe whose experts have one hidden layer is similar to the block-wise dropout described in [reference], where the dropped-out layer is sandwiched between fully-activated layers. section: gating network softmax gating: a simple choice of non-sparse gating function [reference] is to multiply the input by a trainable weight matrix w g and then apply the sof tmax function. noisy top-k gating: we add two components to the softmax gating network: sparsity and noise. before taking the softmax function, we add tunable gaussian noise, then keep only the top k values, setting the rest to\u2212\u221e (which causes the corresponding gate values to equal 0). the sparsity serves to save computation, as described above. while this form of sparsity creates some theoretically scary discontinuities in the output of gating function, we have not yet observed this to be a problem in practice. the noise term helps with load balancing, as will be discussed in appendix a. the amount of noise per component is controlled by a second trainable weight matrix w noise. training the gating network we train the gating network by simple back-propagation, along with the rest of the model. if we choose k> 1, the gate values for the top k experts have nonzero derivatives with respect to the weights of the gating network. this type of occasionally-sensitive behavior is described in [reference]) with respect to noisy rectifiers. gradients also backpropagate through the gating network to its inputs. our method differs here from [reference] who use boolean gates and a reinforce-style approach to train the gating network. section: addressing performance challenges section: the shrinking batch problem on modern cpus and gpus, large batch sizes are necessary for computational efficiency, so as to amortize the overhead of parameter loads and updates. if the gating network chooses k out of n experts for each example, then for a batch of b examples, each expert receives a much smaller batch of approximately kb n b examples. this causes a naive moe implementation to become very inefficient as the number of experts increases. the solution to this shrinking batch problem is to make the original batch size as large as possible. however, batch size tends to be limited by the memory necessary to store activations between the forwards and backwards passes. we propose the following techniques for increasing the batch size: mixing data parallelism and model parallelism: in a conventional distributed training setting, multiple copies of the model on different devices asynchronously process distinct batches of data, and parameters are synchronized through a set of parameter servers. in our technique, these different batches run synchronously so that they can be combined for the moe layer. we distribute the standard layers of the model and the gating network according to conventional data-parallel schemes, but keep only one shared copy of each expert. each expert in the moe layer receives a combined batch consisting of the relevant examples from all of the data-parallel input batches. the same set of devices function as data-parallel replicas (for the standard layers and the gating networks) and as model-parallel shards (each hosting a subset of the experts). if the model is distributed over d devices, and each device processes a batch of size b, each expert receives a batch of approximately kbd n examples. thus, we achieve a factor of d improvement in expert batch size. in the case of a hierarchical moe (section b), the primary gating network employs data parallelism, and the secondary moes employ model parallelism. each secondary moe resides on one device. this technique allows us to increase the number of experts (and hence the number of parameters) by proportionally increasing the number of devices in the training cluster. the total batch size increases, keeping the batch size per expert constant. the memory and bandwidth requirements per device also remain constant, as do the step times, as does the amount of time necessary to process a number of training examples equal to the number of parameters in the model. it is our goal to train a trillionparameter model on a trillion-word corpus. we have not scaled our systems this far as of the writing of this paper, but it should be possible by adding more hardware. taking advantage of convolutionality: in our language models, we apply the same moe to each time step of the previous layer. if we wait for the previous layer to finish, we can apply the moe to all the time steps together as one big batch. doing so increases the size of the input batch to the moe layer by a factor of the number of unrolled time steps. increasing batch size for a recurrent moe: we suspect that even more powerful models may involve applying a moe recurrently. for example, the weight matrices of a lstm or other rnn could be replaced by a moe. sadly, such models break the convolutional trick from the last paragraph, since the input to the moe at one timestep depends on the output of the moe at the previous timestep. [reference] describe a technique for drastically reducing the number of stored activations in an unrolled rnn, at the cost of recomputing forward activations. this would allow for a large increase in batch size. section: network bandwidth another major performance concern in distributed computing is network bandwidth. since the experts are stationary (see above) and the number of gating parameters is small, most of the communication involves sending the inputs and outputs of the experts across the network. to maintain computational efficiency, the ratio of an expert's computation to the size of its input and output must exceed the ratio of computational to network capacity of the computing device. for gpus, this may be thousands to one. in our experiments, we use experts with one hidden layer containing thousands of relu-activated units. since the weight matrices in the expert have sizes input_size\u00d7hidden_size and hidden_size\u00d7 output_size, the ratio of computation to input and output is equal to the size of the hidden layer. conveniently, we can increase computational efficiency simply by using a larger hidden layer, or more hidden layers. section: balancing expert utilization we have observed that the gating network tends to converge to a state where it always produces large weights for the same few experts. this imbalance is self-reinforcing, as the favored experts are trained more rapidly and thus are selected even more by the gating network. [reference] describe the same phenomenon, and use a hard constraint at the beginning of training to avoid this local minimum. [reference] include a soft constraint on the batch-wise average of each gate. [reference] we take a soft constraint approach. we define the importance of an expert relative to a batch of training examples to be the batchwise sum of the gate values for that expert. we define an additional loss l importance, which is added to the overall loss function for the model. this loss is equal to the square of the coefficient of variation of the set of importance values, multiplied by a hand-tuned scaling factor w importance. this additional loss encourages all experts to have equal importance. 1 [reference] also include two additional losses. one controls per-example sparsity, which we do not need since it is enforced by the fixed value of k. a third loss encourages diversity of gate values. in our experiments, we find that the gate values naturally diversify as the experts specialize (in a virtuous cycle), and we do not need to enforce diversity of gate values. while this loss function can ensure equal importance, experts may still receive very different numbers of examples. for example, one expert may receive a few examples with large weights, and another may receive many examples with small weights. this can cause memory and performance problems on distributed hardware. to solve this problem, we introduce a second loss function, l load, which ensures balanced loads. appendix a contains the definition of this function, along with experimental results. section: experiments section: 1 billion word language modeling benchmark dataset: this dataset, introduced by [reference] consists of shuffled unique sentences from news articles, totaling approximately 829 million words, with a vocabulary of 793, 471 words. previous state-of-the-art: the best previously published results [reference] use models consisting of one or more stacked long short-term memory (lstm) layers [reference][reference]. the number of parameters in the lstm layers of these models vary from 2 million to 151 million. quality increases greatly with parameter count, as do computational costs. results for these models form the top line of figure 2-right. moe models: our models consist of two stacked lstm layers with a moe layer between them (see figure 1). we vary the sizes of the layers and the number of experts. for full details on model architecture, training regimen, additional baselines and results, see appendix c. low computation, varied capacity: to investigate the effects of adding capacity, we trained a series of moe models all with roughly equal computational costs: about 8 million multiply-andadds per training example per timestep in the forwards pass, excluding the softmax layer. we call this metric (ops/ timestep). we trained models with flat moes containing 4, 32, and 256 experts, and models with hierarchical moes containing 256, 1024, and 4096 experts. each expert had about 1 million parameters. for all the moe layers, 4 experts were active per input. the results of these models are shown in figure 2-left. the model with 4 always-active experts performed (unsurprisingly) similarly to the computationally-matched baseline models, while the largest of the models (4096 experts) achieved an impressive 24% lower perplexity on the test set. varied computation, high capacity: in addition to the largest model from the previous section, we trained two more moe models with similarly high capacity (4 billion parameters), but higher computation budgets. these models had larger lstms, and fewer but larger and experts. details can be found in appendix c.2. results of these three models form the bottom line of figure 2-right. table 1 compares the results of these models to the best previously-published result on this dataset. even the fastest of these models beats the best published result (when controlling for the number of training epochs), despite requiring only 6% of the computation. computational efficiency: we trained our models using tensorflow [reference] on clusters containing 16-32 tesla k40 gpus. for each of our models, we determine computational efficiency in tflops/ gpu by dividing the number of floating point operations required to process one training batch by the observed step time and the number of gpus in the cluster. the operation counts used here are higher than the ones we report in our ops/ timestep numbers in that we include the backwards pass, we include the importance-sampling-based training of the softmax layer, and we count a multiply-and-add as two separate operations. for all of our moe models, the floating point operations involved in the experts represent between 37% and 46% of the total. for our baseline models wtih no moe, observed computational efficiency ranged from 1.07-1.29 tflops/ gpu. for our low-computation moe models, computation efficiency ranged from 0.74-0.90 tflops/ gpu, except for the 4-expert model which did not make full use of the available parallelism. our highest-computation moe model was more efficient at 1.56 tflops/ gpu, likely due to the larger matrices. these numbers represent a significant fraction of the theoretical maximum of 4.29 tflops/ gpu claimed by nvidia. detailed results are in appendix c, table 7. section: 100 billion word google news corpus figure 3: language modeling on a 100 billion word corpus. models have similar computational budgets (8 million ops/ timestep). on the 1-billion-word corpus, adding additional capacity seems to produce diminishing returns as the number of parameters in the moe layer exceeds 1 billion, as can be seen in figure 2-left. we hypothesized that for a larger training set, even higher capacities would produce significant quality improvements. we constructed a similar training set consisting of shuffled unique sentences from google's internal news corpus, totalling roughly 100 billion words. similarly to the previous section, we tested a series of models with similar computational costs of about 8 million ops/ timestep. in addition to a baseline lstm model, we trained models augmented with moe layers containing [reference] experts. this corresponds to up to 137 billion parameters in the moe layer. details on architecture, training, and results are given in appendix d. results: figure 3 shows test perplexity as a function of capacity after training on 10 billion words (top line) and 100 billion words (bottom line). when training over the full 100 billion words, test perplexity improves significantly up to 65536 experts (68 billion parameters), dropping 39% lower than the computationally matched baseline, but degrades at 131072 experts, possibly a result of too much sparsity. the widening gap between the two lines demonstrates (unsurprisingly) that increased model capacity helps more on larger training sets. even at 65536 experts (99.994% layer sparsity), computational efficiency for the model stays at a respectable 0.72 tflops/ gpu. section: machine translation (single language pair) model architecture: our model was a modified version of the gnmt model described in [reference]. to reduce computation, we decreased the number of lstm layers in the encoder and decoder from 9 and 8 to 3 and 2 respectively. we inserted moe layers in both the encoder (between layers 2 and 3) and the decoder (between layers 1 and 2). each moe layer contained up to 2048 experts each with about two million parameters, adding a total of about 8 billion parameters to the models. further details on model architecture, testing procedure and results can be found in appendix e. datasets: we benchmarked our method on the wmt'14 en\u2192fr and en\u2192de corpora, whose training sets have 36 m sentence pairs and 5 m sentence pairs, respectively. the experimental protocols were also similar to those in [reference]: newstest2014 was used as the test set to compare against previous work [reference][reference][reference], while the combination of newstest2012 and newstest2013 was used as the development set. we also tested the same model on a google's production english to french data. [reference] 2.79 39.22 214 m 278 m 6 days/ 96 k80s gnmt+ rl [reference] 2.96 39.92 214 m 278 m 6 days/ 96 k80s pbmt [reference] 37.0 lstm (6-layer) [reference] 31.5 lstm (6-layer+ posunk) [reference] 33.1 deepatt [reference] 37.7 deepatt+ posunk [reference] 39.2 [reference] 5.25 24.91 214 m 278 m 1 day/ 96 k80s gnmt+ rl [reference] 8.08 24.66 214 m 278 m 1 day/ 96 k80s pbmt [reference] 20.7 deepatt [reference] 20.6 results: tables 2, 3, and 4 show the results of our largest models, compared with published results. our approach achieved bleu scores of 40.56 and 26.03 on the wmt'14 en\u2192fr and en\u2192de benchmarks. as our models did not use rl refinement, these results constitute significant gains of 1.34 and 1.12 bleu score on top of the strong baselines in [reference]. the perplexity scores are also better. 2 on the google production dataset, our model achieved 1.01 higher test bleu score even after training for only one sixth of the time. section: multilingual machine translation dataset: (johnson et al., 2016) train a single gnmt [reference]) model on a very large combined dataset of twelve language pairs. results are somewhat worse than those for 12 separately trained single-pair gnmt models. this is not surprising, given that the twelve models have 12 times the capacity and twelve times the aggregate training of the one model. we repeat this experiment with a single moe-augmented model. see appendix e for details on model architecture. we train our model on the same dataset as [reference] and process the same number of training examples (about 3 billion sentence pairs). our training time was shorter due to the lower computational budget of our model. section: results: results for the single-pair gnmt models, the multilingual gnmt model and the multilingual moe model are given in table 5. the moe model achieves 19% lower perplexity on the dev set than the multilingual gnmt model. on bleu score, the moe model significantly beats the multilingual gnmt model on 11 of the 12 language pairs (by as much as 5.84 points), and even beats the monolingual gnmt models on 8 of 12 language pairs. the poor performance on english\u2192 korean seems to be a result of severe overtraining, as for the rarer language pairs a small number of real examples were highly oversampled in the training corpus. section: conclusion this work is the first to demonstrate major wins from conditional computation in deep networks. we carefully identified the design considerations and challenges of conditional computing and addressed them with a combination of algorithmic and engineering solutions. while we focused on text, conditional computation may help in other domains as well, provided sufficiently large training sets. we look forward to seeing many novel implementations and applications of conditional computation in the years to come. section: acknowledgments we would like to thank all of the members of the google brain and google translate teams who helped us with this project, in particular zhifeng chen, yonghui wu, and melvin johnson. thanks also to our anonymous iclr reviewers for the helpful suggestions on making this paper better. section: appendices a load-balancing loss as discussed in section 4, for load-balancing purposes, we want to define an additional loss function to encourage experts to receive roughly equal numbers of training examples. unfortunately, the number of examples received by an expert is a discrete quantity, so it can not be used in backpropagation. instead, we define a smooth estimator load (x) of the number of examples assigned to each expert for a batch x of inputs. the smoothness allows us to back-propagate gradients through the estimator. this is the purpose of the noise term in the gating function. we define p (x, i) as the probability that g (x) i is nonzero, given a new random choice of noise on element i, but keeping the already-sampled choices of noise on the other elements. to compute p (x, i), we note that the g (x) i is nonzero if and only if h (x) i is greater than the k th-greatest element of h (x) excluding itself. the probability works out to be: where kth_excluding (v, k, i) means the kth highest component of v, excluding component i. simplifying, we get: where\u03c6 is the cdf of the standard normal distribution. we can now define the load loss to be the square of the coefficient of variation of the load vector, multiplied by a hand-tuned scaling factor w load. initial load imbalance: to avoid out-of-memory errors, we need to initialize the network in a state of approximately equal expert load (since the soft constraints need some time to work). to accomplish this, we initialize the matrices w g and w noise to all zeros, which yields no signal and some noise. section: experiments: we trained a set of models with identical architecture (the moe-256 model described in appendix c), using different values of w importance and w load. we trained each model for 10 epochs, then measured perplexity on the test set. we also measured the coefficients of variation in importance and load, as well as ratio of the load on the most overloaded expert to the average load. this last value is significant for load balancing purposes on distributed hardware. all of these metrics were averaged over several training batches. results: results are reported in table 6. all the combinations containing at least one the two losses led to very similar model quality, where having no loss was much worse. models with higher values of w load had lower loads on the most overloaded expert. section: b hierachical mixture of experts if the number of experts is very large, we can reduce the branching factor by using a two-level hierarchical moe. in a hierarchical moe, a primary gating network chooses a sparse weighted combination of\" experts\", each of which is itself a secondary mixture-of-experts with its own gating network. 3 if the hierarchical moe consists of a groups of b experts each, we denote the primary gating network by g primary, the secondary gating networks by (g 1, g 2.. g a), and the expert networks by (e 0, 0, e 0, 1.. e a, b). the output of the moe is given by: our metrics of expert utilization change to the following: load primary and load i deonte the load functions for the primary gating network and i th secondary gating network respectively. x (i) denotes the subset of x for which g primary (x) i> 0. it would seem simpler to let load h (x) i, j= load i (x i) j, but this would not have a gradient with respect to the primary gating network, so we use the formulation above. section: c 1 billion word language modeling benchmark-experimental details c.1 8-million-operations-per-timestep models model architecture: our model consists of five layers: a word embedding layer, a recurrent long short-term memory (lstm) layer [reference][reference], a moe layer, a second lstm layer, and a softmax layer. the dimensionality of the embedding layer, the number of units in each lstm layer, and the input and output dimensionality of the moe layer are all equal to 512. for every layer other than the softmax, we apply drouput [reference] to the layer output, dropping each activation with probability dropp rob, otherwise dividing by (1\u2212 dropp rob). after dropout, the output of the previous layer is added to the layer output. this residual connection encourages gradient flow [reference]. for the hierarchical moe layers, the first level branching factor was 16, corresponding to the number of gpus in our cluster. we use noisy-top-k gating (see section 2.1) with k= 4 for the ordinary moe layers and k= 2 at each level of the hierarchical moe layers. thus, each example is processed by exactly 4 experts for a total of 4 m ops/ timestep. the two lstm layers contribute 2 m ops/ timestep each for the desired total of 8m. section: computationally-matched baselines: the moe-4 model does not employ sparsity, since all 4 experts are always used. in addition, we trained four more computationally-matched baseline models with no sparsity:\u2022 moe-1-wide: the moe layer consists of a single\" expert\" containing one relu-activated hidden layer of size 4096.\u2022 moe-1-deep: the moe layer consists of a single\" expert\" containing four relu-activated hidden layers, each with size 1024.\u2022 4xlstm-512: we replace the moe layer with two additional 512-unit lstm layers.\u2022 lstm-2048-512: the model contains one 2048-unit lstm layer (and no moe). the output of the lstm is projected down to 512 dimensions [reference]. the next timestep of the lstm receives the projected output. this is identical to one of the models published in [reference]. we re-ran it to account for differences in training regimen, and obtained results very similar to the published ones. training: the models were trained on a cluster of 16 k40 gpus using the synchronous method described in section 3. each batch consisted of a set of sentences totaling roughly 300, 000 words. in the interest of time, we limited training to 10 epochs, (27, 000 steps). training took 12-16 hours for all models, except for moe-4, which took 18 hours (since all the expert computation was performed on only 4 of 16 gpus). we used the adam optimizer [reference]. the base learning rate was increased linearly for the first 1000 training steps, and decreased after that so as to be proportional to the inverse square root of the step number. the softmax output layer was trained efficiently using importance sampling similarly to the models in [reference]. for each model, we performed a hyper-parmeter search to find the best dropout probability, in increments of 0.1. to ensure balanced expert utilization we set w importance= 0.1 and w load= 0.1, as described in section 4 and appendix a. results: we evaluate our model using perplexity on the holdout dataset, used by [reference][reference]. we follow the standard procedure and sum over all the words including the end of sentence symbol. results are reported in table 7. for each model, we report the test perplexity, the computational budget, the parameter counts, the value of dropp rob, and the computational efficiency. section: c.2 more expensive models we ran two additional models (moe-34 m and moe-143 m) to investigate the effects of adding more computation in the presence of a large moe layer. these models have computation budgets of 34 m and 143 m ops/ timestep. similar to the models above, these models use a moe layer between two lstm layers. the dimensionality of the embedding layer, and the input and output dimensionality of the moe layer are set to 1024 instead of 512. for moe-34 m, the lstm layers have 1024 units. for moe-143 m, the lstm layers have 4096 units and an output projection of size 1024 [reference]. moe-34 m uses a hierarchical moe layer with 1024 experts, each with a hidden layer of size 2048. moe-143 m uses a hierarchical moe layer with 256 experts, each with a hidden layer of size 8192. both models have 4b parameters in the moe layers. we searched for the best dropp rob for each model, and trained each model for 10 epochs. the two models achieved test perplexity of 31.3 and 28.0 respectively, showing that even in the presence of a large moe, more computation is still useful. results are reported at the bottom of table 7. the larger of the two models has a similar computational budget to the best published model from the literature, and training times are similar. comparing after 10 epochs, our model has a lower test perplexity by 18%. section: d 100 billion word google news corpus-experimental details model architecture: the models are similar in structure to the 8-million-operations-per-timestep models described in the previous section. we vary the number of experts between models, using an ordinary moe layer with 32 experts and hierarchical moe layers with 256, 1024, 4096, 16384, 65536 and 131072 experts. for the hierarchical moe layers, the first level branching factors are [reference] training: models are trained on a cluster of 32 tesla k40 gpus, except for the last two models, which are trained on clusters of 64 and 128 gpus so as to have enough memory for all the parameters. for all models, training batch sizes are approximately 2.5 million words. models are trained once-through over about 100 billion words. we implement several memory optimizations in order to fit up to 1 billion parameters per gpu. first, we do not store the activations of the hidden layers of the experts, but instead recompute them on the backwards pass. secondly, we modify the optimizer on the expert parameters to require less auxiliary storage: the adam optimizer [reference] keeps first and second moment estimates of the perparameter gradients. this triples the required memory. to avoid keeping a first-moment estimator, we set\u03b2 1= 0. to reduce the size of the second moment estimator, we replace it with a factored approximation. for a matrix of parameters, instead of maintaining a full matrix of second-moment estimators, we maintain vectors of row-wise and column-wise averages of that matrix. at each step, the matrix of estimators is taken to be the outer product of those two vectors divided by the mean of either one. this technique could similarly be applied to adagrad [reference]. results: we evaluate our model using perplexity on a holdout dataset. results are reported in table 8. perplexity after 100 billion training words is 39% lower for the 68-billion-parameter moe model than for the baseline model. it is notable that the measured computational efficiency of the largest model (0.30 tflops/ gpu) is very low compared to the other models. this is likely a result of the fact that, for purposes of comparison to the other models, we did not increase the training batch size proportionally to the number of gpus. for comparison, we include results for a computationally matched baseline model consisting of 4 lstms, and for an unpruned 5-gram model with kneser-ney smoothing [reference]. section: e machine translation-experimental details model architecture for single language pair moe models: our model is a modified version of the gnmt model described in [reference]. to reduce computation, we decrease the number of lstm layers in the encoder and decoder from 9 and 8 to 3 and 2 respectively. we insert moe layers in both the encoder (between layers 2 and 3) and the decoder (between layers 1 and 2). we use an attention mechanism between the encoder and decoder, with the first decoder lstm receiving output from and providing input for the attention 5. all of the layers in our model have input and output dimensionality of 512. our lstm layers have 2048 hidden units, with a 512-dimensional output projection. we add residual connections around all lstm and moe layers to encourage gradient flow [reference]. similar to gnmt, to effectively deal with rare words, we used subword units (also known as\" wordpieces\") (schuster& nakajima, 2012) for inputs and outputs in our system. we use a shared source and target vocabulary of 32 k wordpieces. we also used the same beam search technique as proposed in [reference]. we train models with different numbers of experts in the moe layers. in addition to a baseline model with no moe layers, we train models with flat moe layers containing 32 experts, and models with hierarchical moe layers containing 512 and 2048 experts. the flat moe layers use k= 4 and the hierarchical moe models use k= 2 at each level of the gating network. thus, each input is processed by exactly 4 experts in each moe layer. each expert in the moe layer is a feed forward network with one hidden layer of size 2048 and relu activation. thus, each expert contains [512* 2048]+ [2048* 512]= 2 m parameters. the output of the moe layer is passed through a sigmoid function. we use the strictly-balanced gating function described in appendix f. section: model architecture for multilingual moe model: we used the same model architecture as for the single-language-pair models, with the following exceptions: we used noisy-top-k gating as described in section 2.1, not the scheme from appendix f. the moe layers in the encoder and decoder are non-hierarchical moes with n= 512 experts, and k= 2. each expert has a larger hidden layer of size 8192. this doubles the amount of computation in the moe layers, raising the computational budget of the entire model from 85 m to 102 m ops/ timestep. training: we trained our networks using the adam optimizer [reference]. the base learning rate was increased linearly for the first 2000 training steps, held constant for an additional 8000 steps, and decreased after that so as to be proportional to the inverse square root of the step number. for the single-language-pair models, similarly to [reference], we applied dropout [reference] to the output of all embedding, lstm and moe layers, using dropp rob= 0.4. training was done synchronously on a cluster of up to 64 gpus as described in section 3. each training batch consisted of a set of sentence pairs containing roughly 16000 words per gpu. to ensure balanced expert utilization we set w importance= 0.01 and w load= 0.01, as described in section 4 and appendix a. section: metrics: we evaluated our models using the perplexity and the standard bleu score metric. we reported tokenized bleu score as computed by the multi-bleu.pl script, downloaded from the public implementation of moses (on github), which was also used in [reference]. tables 2, 3 and 4 in section 5.3 show comparisons of our results to other published methods. figure 4 shows test perplexity as a function of number of words in the (training data's) source sentences processed for models with different numbers of experts. as can be seen from the figure, as we increased the number of experts to approach 2048, the test perplexity of our model continued to improve. figure 4: perplexity on wmt'14 en\u2192 fr (left) and google production en\u2192 fr (right) datasets as a function of number of words processed. the large differences between models at the beginning of training are due to different batch sizes. all models incur the same computational budget (85 m ops/ timestep) except the one with no experts. section: results: we found that the experts indeed become highly specialized by syntax and/ or semantics, as can be seen in table 9. for example, one expert is used when the indefinite article\" a\" introduces the direct object in a verb phrase indicating importance or leadership. section: f strictly balanced gating due to some peculiarities in our infrastructure which have since been fixed, at the time we ran some of the machine translation experiments, our models ran faster if every expert received exactly the same batch size. to accommodate this, we used a different gating function which we describe below. recall that we define the softmax gating function to be: sparse gating (alternate formulation): to obtain a sparse gating vector, we multiply g\u03c3 (x) component-wise with a sparse mask m (g\u03c3 (x)) and normalize the output. the mask itself is a function of g\u03c3 (x) and specifies which experts are assigned to each input example: as our experiments suggest and also observed in [reference], using a batchwise function during training (such as m batchwise) requires modifications to the inference when we may not have a large batch of examples. our solution to this is to train a vector t of per-expert threshold values to approximate the effects of the batchwise mask. we use the following mask at inference time: to learn the threshold values, we apply an additional loss at training time which is minimized when the batchwise mask and the threshold mask are identical. g attention function the attention mechanism described in gnmt [reference]) involves a learned\" attention function\" a (x i, y j) which takes a\" source vector\" x i and a\" target vector\" y j, and must be computed for every source time step i and target time step j. in gnmt, the attention function is implemented as a feed forward neural network with a hidden layer of size n. it can be expressed as: where u and w are trainable weight matrices and v is a trainable weight vector. for performance reasons, in our models, we used a slightly different attention function: with our attention function, we can simultaneously compute the attention function on multiple source time steps and multiple target time steps using optimized matrix multiplications. we found little difference in quality between the two functions. section:",
        "pred_templates": [
            {
                "Material": [],
                "Method": [
                    [
                        "moe"
                    ],
                    [
                        "moe"
                    ],
                    [
                        "moe"
                    ]
                ],
                "Metric": [
                    [
                        "accuracy"
                    ],
                    [
                        "perplexity scores"
                    ],
                    [
                        "tokenized bleu score"
                    ]
                ],
                "Task": []
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "trillion-word corpus",
                        "billion word corpus",
                        "1-billion-word corpus",
                        "100 billion word"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "parameter count"
                    ]
                ],
                "Task": [
                    [
                        "language modeling",
                        "billion word language modeling benchmark",
                        "single-language-pair models"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "trillion-word corpus",
                        "billion word corpus",
                        "1-billion-word corpus",
                        "100 billion word"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "perplexity scores",
                        "test perplexity",
                        "perplexity"
                    ]
                ],
                "Task": [
                    [
                        "language modeling",
                        "billion word language modeling benchmark",
                        "single-language-pair models"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "wmt'14 en\u2192fr",
                        "google's production english to french data"
                    ]
                ],
                "Method": [
                    [
                        "sparsely-gated mixture-of-experts layer",
                        "mixture-of-experts layer",
                        "moe",
                        "model architectures",
                        "deep learning models",
                        "model capacity",
                        "mixture-of-experts approach",
                        "ensemble model",
                        "mixture of experts",
                        "ensemble nmt model",
                        "moes",
                        "deep model",
                        "stacked moes",
                        "level hierarchical moe.",
                        "trainable weight matrix w noise",
                        "model-parallel shards",
                        "secondary moes",
                        "model parallelism",
                        "trillionparameter model",
                        "language models",
                        "moe.",
                        "language modeling",
                        "hierachical mixture of experts",
                        "8-million-operations-per-timestep models",
                        "softmax output layer",
                        "importance sampling",
                        "m",
                        "single-language-pair models",
                        "hierarchical moes"
                    ]
                ],
                "Metric": [
                    [
                        "bleu scores",
                        "bleu score"
                    ]
                ],
                "Task": [
                    [
                        "machine translation",
                        "multilingual machine translation"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "en\u2192de corpora",
                        "en\u2192de"
                    ]
                ],
                "Method": [
                    [
                        "sparsely-gated mixture-of-experts layer",
                        "mixture-of-experts layer",
                        "moe",
                        "model architectures",
                        "deep learning models",
                        "model capacity",
                        "mixture-of-experts approach",
                        "ensemble model",
                        "mixture of experts",
                        "ensemble nmt model",
                        "moes",
                        "deep model",
                        "stacked moes",
                        "level hierarchical moe.",
                        "trainable weight matrix w noise",
                        "model-parallel shards",
                        "secondary moes",
                        "model parallelism",
                        "trillionparameter model",
                        "language models",
                        "moe.",
                        "language modeling",
                        "hierachical mixture of experts",
                        "8-million-operations-per-timestep models",
                        "softmax output layer",
                        "importance sampling",
                        "m",
                        "single-language-pair models",
                        "hierarchical moes"
                    ]
                ],
                "Metric": [
                    [
                        "bleu scores",
                        "bleu score"
                    ]
                ],
                "Task": [
                    [
                        "machine translation",
                        "multilingual machine translation"
                    ]
                ]
            }
        ]
    },
    "44078d0daed8b13114cffb15b368acc467f96351-63": {
        "doctext": "document: triplet probabilistic embedding for face verification and clustering despite significant progress made over the past twenty five years, unconstrained face verification remains a challenging problem. this paper proposes an approach that couples a deep cnn-based approach with a low-dimensional discriminative embedding step, learned using triplet probability constraints to address the unconstrained face verification problem. aside from yielding performance improvements, this embedding provides significant advantages in terms of memory and for post-processing operations like subject specific clustering. experiments on the challenging ijb-a dataset show that the proposed algorithm performs close to the state of the art methods in verification and identification metrics, while requiring much less training data and training/ test time. the superior performance of the proposed method on the cfp dataset shows that the representation learned by our deep cnn is robust to large pose variation. furthermore, we demonstrate the robustness of deep features to challenges including age, pose, blur and clutter by performing simple clustering experiments on both ijb-a and lfw datasets. section: introduction recently, with the advent of curated face datasets like labeled faces in the wild (lfw) and advances in learning algorithms like deep neural nets, there is more hope that the unconstrained face verification problem can be solved. a face verification algorithm compares two given templates that are typically not seen during training. research in face verification has progressed well over the past few years, resulting in the saturation of performance on the lfw dataset, yet the problem of unconstrained face verification remains a challenge. this is evident by the performance of traditional algorithms on the publicly available ijb-a dataset (,) that was released recently. moreover, despite the superb performance of cnn-based approaches compared to traditional methods, a drawback of such methods is the long training time needed. in this work, we present a deep cnn (dcnn) architecture that ensures faster training, and investigate how much the performance can be improved if we are provided domain specific data. specifically, our contributions are as follows: we propose a deep network architecture and a training scheme that ensures faster training time. we formulate a triplet probability embedding learning method to improve the performance of deep features for face verification and subject clustering. during training, we use a publicly available face dataset to train our deep architecture. each image is pre-processed and aligned to a canonical view before passing it to the deep network whose features are used to represent the image. in the case of ijb-a dataset, the data is divided into 10 splits, each split containing a training set and a test set. hence, to further improve performance, we learn the proposed triplet probability embedding using the training set provided with each split over the features extracted from our dcnn model. during the deployment phase, given a face template, we extract the deep features using the raw cnn model after implementing automatic pre-processing steps such as face detection and fiducial extraction. the deep features are projected onto a low-dimensional space using the embedding matrix learned during training (note that the projection involves only matrix multiplication). we use the 128-dimensional feature as the final representation of the given face template. this paper is organized as follows: section [reference] places our work among the recently proposed approaches for face verification. section [reference] details the network architecture and the training scheme. the triplet probabilistic embedding learning method is described in section [reference] followed by results on ijb-a and cfp datasets and a brief discussion in section [reference]. in section [reference], we demonstrate the ability of the proposed method to cluster a media collection from lfw and ijb-a datasets. section: related work in the past few years, there have been numerous works in using deep features for tasks related to face verification. the deepface approach uses a carefully crafted 3d alignment procedure to preprocess face images and feeds them to a deep network that is trained using a large training set. more recently, facenet uses a large private dataset to train several deep network models using a triplet distance loss function. the training time for this network is of the order of few weeks. since the release of the ijb-a dataset, there have been several works that have published verification results for this dataset. previous approaches presented in and train deep networks using the casia-webface dataset and the vgg-face dataset respectively, requiring substantial training time. this paper proposes a network architecture and a training scheme that needs shorter training time and a small query time. the idea of learning a compact and discriminative representation has been around for decades. weinberger et al. used a semi definite programming (sdp)- based formulation to learn a metric satisfying pairwise and triplet distance constraints in a large margin framework. more recently, this idea has been successfully applied to face verification by integrating the loss function within the deep network architecture (,). joint bayesian metric learning is also another popular metric used for face verification (,). these methods either require a large dataset for convergence or learn a metric directly and therefore are not amenable to subsequent operations like discriminative clustering or hashing. classic methods like t-sne, t-ste and crowd kernel learning (ckl) perform extremely well when used to visualize or cluster a given data collection. they either operate on the data matrix directly or the distance matrix generated from data by generating a large set of pairwise or triplet constraints. while these methods perform very well on a given set of data points, they do not generalize to out-of-sample data. in the current work, we aim to generalize such formulations, to a more traditional classification setting, where domain specific training and testing data is provided. we formulate an optimization problem based on triplet probabilities that performs dimensionality reduction aside from improving the discriminative ability of the test data. the embedding scheme described in this work is a more general framework that can be applied to any setting where labeled training data is available. section: network architecture this section details the architecture and training algorithm for the deep network used in our work. our architecture consists of 7 convolutional layers with varying kernel sizes. the initial layers have a larger size rapidly subsampling the image and reducing the parameters while subsequent layers consist of small filter sizes, which has proved to be very useful in face recognition tasks (,). furthermore, we use the parametric rectifier linear units (prelus) instead of relus, since they allow a negative value for the output based on a learned threshold and have been shown to improve the convergence rate. tabledeep network architecture details the top three convolutional layers (conv1-conv3) are initialized with the weights from the alexnet model trained on the imagenet challenge dataset. several recent works (,) have empirically shown that this transfer of knowledge across different networks, albeit for a different objective, improves performance and more significantly reduces the need to train over a large number of iterations. the compared methods either learn their deep models from scratch (,) or finetune only the last layer of fully pre-trained models. the former results in large training time and the latter does not generalize well to the task at hand (face verification) and hence resulting in sub optimal performance. in the current work, even though we use a pre-trained model (alexnet) to initialize the proposed deep network, we do so only for the first three convolutional layers, since they retain more generic information (). subsequent layers learn representations which are more specific to the task at hand. thus, to learn more task specific information, we add 4 convolutional layers each consisting of 512 kernels of size. the layers conv4-conv7 do not downsample the input thereby learning more complex higher dimensional representations. this hybrid architecture proves to be extremely effective as our raw cnn representation outperforms some very deep cnn models on the ijb-a dataset (table 2 in results). in addition, we achieve that performance by training the proposed deep network using the relatively smaller casia-webface dataset. the architecture of our network is shown in table [reference]. layers conv4-conv7 and the fully connected layers fc6-fc8 are initialized from scratch using random gaussian distributions. prelu activation functions are added between each layer. since the network is used as a feature extractor, the last layer fc8 is removed during deployment, thus reducing the number of parameters to 29m. the inputs to the network are 227x227x3 rgb images. when the network is deployed, the features are extracted from the fc7 layer resulting in a dimensionality of 512. the network is trained using the softmax loss function for multiclass classification using the caffe deep learning platform. section: learning a discriminative embedding in this section, we describe our algorithm for learning a low-dimensional embedding such that the resulting projections are more discriminative. aside from an improved performance, this embedding provides significant advantages in terms of memory and enables post-processing operations like visualization and clustering. consider a triplet, where (anchor) and (positive) are from the same class, but (negative) belongs to a different class. consider a function that is parameterized by the matrix, that measures the similarity between two vectors. ideally, for all triplets that exist in the training set, we would like the following constraint to be satisfied: thus, the probability of a given triplet satisfying ([reference]) can be written as: the specific form of the similarity function is given as:. in our case, and are deep features normalized to unit length. to learn the embedding from a given set of triplets, we solve the following optimization: ([reference]) can be interpreted as maximizing the likelihood ([reference]) or minimizing the negative log-likelihood (nll) over the triplet set. in practice, the above problem is solved in a large-margin framework using stochastic gradient descent (sgd) and the triplets are sampled online. the gradient update for is given as: where is the estimate at iteration, is the updated estimate, is the triplet sampled at the current iteration and is the learning rate. by choosing the dimension of as with, we achieve dimensionality reduction in addition to improved performance. for our work, we fix based on cross validation and is the dimensionality of our deep features. is initialized with the first principal components of the training data. at each iteration, a random anchor and a random positive data point are chosen. to choose the negative, we perform hard negative mining, ie. we choose the data point that has the least likelihood ([reference]) among the randomly chosen 2000 negative instances at each iteration. since we compute the embedding matrix by optimizing over triplet probabilities, we call this method triplet probability embedding (tpe). the technique closest to the one presented in this section, which is used in recent works (,) computes the embedding based on satisfying a hinge loss constraint: acts a margin parameter for the loss function. to be consistent with the terminology used in this paper, we call it triplet distance embedding (tde). to appreciate the difference between the two approaches, figure [reference] shows the case where the gradient update for the tde method ([reference]) occurs. if the value of is not appropriately chosen, a triplet is considered good even if the positive and negative are very close to one another. but under the proposed formulation, both cases referred to in figure [reference] will update the gradient but their contribution to the gradient will be modulated by the probability with which they violate the constraint in ([reference]). this modulation factor is specified by the term in the gradient update for tpe in ([reference]) implying that if the likelihood of a sampled triplet satisfying ([reference]) is high, then the gradient update is given a lower weight and vice-versa. thus, in our method, the margin parameter () is automatically set based on the likelihood. to compare the relative performances of the raw features before projection, with tde and with tpe (proposed method), we plot the traditional roc curve (tar (vs) far) for split 1 of the ijb-a verify protocol for the three methods in figure [reference]. the equal error rate (eer) metric is specified for each method. the performance improvement due to tpe is significant, especially at regions of far. we observed a similar behaviour for all the ten splits of the ijb-a dataset. section: experimental setup and results in this section we evaluate the proposed method on two challenging datasets: iarpa janus benchmark-a (ijb-a): this dataset contains 500 subjects with a total of 25, 813 images (5, 399 still images and 20, 414 video frames sampled at a rate of 1 in 60). the faces in the ijb-a dataset contain extreme poses and illuminations, more challenging than lfw. some sample images from the ijb-a dataset are shown in figure [reference]. an additional challenge of the ijb-a verification protocol is that the template comparisons include image to image, image to set and set to set comparisons. in this work, for a given test template of the ijb-a data we perform two kinds of pooling to produce its final representation: average pooling (cnn): the deep features of the images and/ or frames present in the template are combined by taking a componentwise average to produce one feature vector. thus each feature equally contributes to the final representation. media pooling (cnn): the deep features are combined keeping in mind the media source they come from. the metadata provided with ijb-a gives us the media i d for each item of the template. thus to get the final feature vector, we first take an intra-media average and then combine these by taking the inter-media average. thus each feature's contribution to the final representation is weighted based on its source. celebrities in frontal-profile (cfp) []: this dataset contains 7000 images of 500 subjects. the dataset is used for evaluating how face verification approaches handle pose variation. hence, it consists of 5000 images in frontal view and 2000 images in extreme profile. the data is organized into 10 splits, each containing equal number of frontal-frontal and frontal-profile comparisons. sample comparison pairs of the cfp dataset are shown in figure [reference]..5.25.25 subsection: pre-processing in the training phase, given an input image, we use the hyperface method for face detection and fiducial point extraction. the hyperface detector automatically extracts many faces from a given image. for the ijb-a dataset, since most images contain more than one face, we use the bounding boxes provided along with the dataset to select the person of interest from the list of automatic detections. we select the detection that has the maximum area overlap with the manually provided bounding box. in the ijb-a dataset, there are few images for which the hyperface detector can not find the relevant face. for the missed cases, we crop the face using the bounding box information provided with the dataset and pass it to hyperface to extract the fiducials. we use six fiducial points (eyes and mouth corners) to align the detected image to a canonical view using the similarity transform. for the cfp dataset, since the six keypoints can not be computed for profile faces we only use three keypoints on one side of the face for aligning them. tableidentification and verification results on the ijb-a dataset. for identification, the scores reported are tpir values at the indicated points. the results are averages over 10 splits and the standard deviation is given in the brackets for methods which have reported them. implies that the result is not reported for that method. the best results are given in bold. tableresults on the cfp dataset. the numbers are averaged over ten test splits and the numbers in brackets indicate standard deviations of those runs. the best results are given in bold. subsection: parameters and training times the training of the proposed deep architecture is done using sgd with momentum, which is set to 0.9 and the learning rate is set to 1e-3 and decreased uniformly by a factor of 10 every 50 k iterations. the weight decay is set to 5e-4 for all layers. the training batch size is set to 256. the training time for our deep network is 24 hours on a single nvidia titanx gpu. for the ijb-a dataset, we use the training data provided with each split to obtain the triplet embedding which takes 3 mins per split. this is the only additional splitwise processing that is done by the proposed approach. during deployment, the average enrollment time per image after pre-processing, including alignment and feature extraction is 8ms. subsection: evaluation pipeline given an image, we pre-process it as described in section 5.1. the deep features are computed as an average of the image and its flip. given two deep features to compare, we compute their cosine similarity score. more specifically, for the ijb-a dataset, given a template containing multiple faces, we flatten the template features by average pooling or media pooling to obtain a vector representation. for each split, we learn the tpe projection using the provided training data. given two templates for comparison, we compute the cosine similarity score using the projected 128-dimensional representations. matrix. subsection: evaluation metrics we report two types of results for the ijb-a dataset: verification and identification. for the verification protocol, we report the false non-match rate (fnmr) values at several false match rates (fmr). for the identification results, we report open set and closed set metrics. for the open set metrics, the true positive identification rate quantifies the fraction of subjects that are classified correctly among the ones that exist in probe but not in gallery. for the closed set metrics, we report the cmc numbers at different values of false positive identification rates (fpirs) and ranks. more details on the evaluation metrics for the ijb-a protocol can be found in. for the cfp dataset, following the protocol set in, we report the area under the curve (auc) and equal error rate (eer) values as averages across splits, in addition to the classification accuracy. to obtain the accuracy for each split, we threshold our cnn similarity scores where the threshold is set to the value that provides the highest classification accuracy over the training data for each split. subsection: discussion subsubsection: performance on ijb-a table [reference] presents the results for the proposed methods compared to existing results for the ijb-a verification and identification protocol. the compared methods are described below: government-of-the-shelf (gots) is the baseline performance provided along with the ijb-a dataset. parkhi et al. train a very deep network (22 layers) over the vgg-face dataset which contains 2.6 m images from 2622 subjects. the neural aggregation network (nan) is trained over large amount of videos from the celeb-1000 dataset starting from the googlenet architecture. masi et al. use a deep cnn based approach that includes a combination of in-plane aligned images, 3d rendered images to augment their performance. the 3d rendered images are also generated during test time per template comparison. it should be noted that many test images of the ijb-a dataset contain extreme poses, harsh illumination conditions and significant blur. crosswhite et al. use template adaptation to tune the performance of their raw features specifically to the ijb-a dataset. compared to these methods, the proposed method trains a single cnn model on the casia-webface dataset which consists of about 500 k images and requires much shorter training time and has a very fast query time (0.08s after face detection per image pair). as shown in table [reference], our raw cnn features after media pooling perform better than most compared methods across both the verification and identification protocols of the ijb-a dataset, with the exception of the template adaptation method by crosswhite et al. which is discussed below. the tpe method provides significant improvement for both identification and verification tasks as shown in table [reference]. the method by crosswhite et al. uses the vgg-face network descriptors (4096-d) as the raw features. they use the concept of template adaptation to improve their performance as follows: when pooling multiple faces of a given template, they train a linear svm with the features of this template as positive and a fixed set of negatives extracted from the training data of the ijb-a splits. let's denote the pooled template feature and classifier pair as. then, at query time when comparing two templates and, the similarity score is computed as:. even when using a carefully engineered fast linear classifier training algorithm, this procedure increases the run time of the pooling procedure. the query time per template comparison is also higher due to the high dimensionality of the input features. in contrast, the proposed approach requires a matrix multiplication and a vector dot product per comparison. by using a simple neural network architecture, a relatively smaller training dataset and a fast embedding method we have realized a faster and more efficient end-to-end system. to improve our performance further, we are currently incorporating the use of video data into our approach. subsubsection: performance on cfp on the cfp dataset, we achieve a new state-of-art on both frontal-frontal and frontal-profile comparisons, the latter by a large margin. more specifically, for the frontal-profile case, we manage to reduce the error rate by 40.8%. it should be noted that for a fair comparison we have used our raw cnn features without performing tpe. this shows that the raw cnn features we learn are effective even at extreme pose variations. section: clustering faces.5.5.5.5 this section illustrates how the proposed tpe method can be used to cluster a given data collection. we perform two clustering experiments: we perform clustering on the entire lfw dataset that consists of 13233 images of 5749 subjects. it should be noted that about 4169 subjects have only one image. we use the ijb-a dataset and cluster the templates corresponding to the query set for each split in the ijb-a verify protocol. for evaluating the clustering results, we use the metrics defined in. these are summarized below: pairwise precision (p\u2062pair): the fraction of pairs of samples within a cluster among all possible pairs which are of the same class, over the total number of same cluster pairs. pairwise recall (r\u2062pair): the fraction of pairs of samples within a class among all possible pairs which are placed in the same cluster, over the total number of same-class pairs. using these metrics, the f-score is computed as: the simplest way we found to demonstrate the effectiveness of our deep features and the proposed tpe method, is to use the standard matlab implementation of the agglomerative clustering algorithm with the average linkage metric. we use the cosine similarity as our basic clustering metric. the simple clustering algorithm that we have used here has computational complexity of. in its current form, this does not scale to large datasets with millions of images. we are currently working on a more efficient and scalable (yet approximate) version of this algorithm. paragraph: clustering lfw:-the images in the lfw dataset are pre-processed as described in section 5.1. for each image and its flip, the deep features are extracted using the proposed architecture, averaged and normalized to unit norm. we run the clustering algorithm over the entire data in a single shot. the clustering algorithm takes as input a cut-off parameter which acts as a distance threshold (below which any two clusters will not be merged). in our experiments, we vary this cut-off parameter over a small range and evaluate the resulting clustering using the-score. we pick the result that yields the best-score. table [reference] shows the result of our approach and compares it to a recently released clustering approach based on approximate rank-order clustering. it should be noted that, in the case of, the clustering result is chosen by varying the number of clusters and picking the one with the best-score. in our approach, we vary the cut-off threshold which is the property of deep features and hence is a more intuitive parameter to tune. we see from table [reference] that aside from better performance, our total cluster estimate is closer to the ground truth value of 5749 than. table-score for comparison of the two clustering schemes on the lfw dataset. the ground truth cluster number is 5749. tableclustering metrics over the ijb-a 1:1 protocol. the standard deviation is indicated in brackets. the ground truth subjects per each split is 167. paragraph: clustering ijb-a:-the ijb-a dataset is processed as described in section 5. in this section, we aim to cluster the query templates provided with each split for the verify protocol. we report the results of two experiments: with the raw cnn features (cnn in table 2) and with the projected cnn features, where the projection matrix is learned through the proposed tpe method (cnn+ tpe in table 2). the cut-off threshold required for our clustering algorithm is learned automatically based on the training data, i.e. we choose the threshold that gives the maximum-score over the training data. the scores reported in table [reference] are average values over ten splits. as expected, the tpe method improves the clustering performance of raw features. the subject estimate is the number of clusters produced as a direct result of our clustering algorithm. the pruned estimate is obtained by ignoring clusters that have fewer than 3 images. for a more complete evaluation of our performance over varying threshold values, we plot the precision-recall (pr) curve for the ijb-a clustering experiment in figure [reference]. as can be observed, the pr curve for clustering the ijb-a data using embedded features exhibits a better performance at all operating points. this is a more transparent evaluation than reporting only the-score since the latter effectively fixes the operating point but the pr curve reveals the performance at all operating points. section: conclusion and future work in this paper, we proposed a deep cnn-based approach coupled with a low-dimensional discriminative embedding learned using triplet probability constraints in a large margin fashion. the proposed pipeline enables a faster training time and improves face verification performance especially at low fmrs. we demonstrated the effectiveness of the proposed method on two challenging datasets: ijb-a and cfp and achieved performance close to the state of the art while using a deep model which is more compact and trained using a moderately sized dataset. we demonstrated the robustness of our features using a simple clustering algorithm on the lfw and ijb-a datasets. for future work, we plan to use videos directly during training and also embed our tpe approach into training the deep network. we intend to scale our clustering algorithm to handle large scale scenarios such as large impostor sets of the order of millions. section: acknowledgement this research is based upon work supported by the office of the director of national intelligence (odni), intelligence advanced research projects activity (iarpa), via iarpa r& d contract no. 2014-14071600012. the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the odni, iarpa, or the u.s. government. the u.s. government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright annotation thereon. bibliography: references",
        "pred_templates": [
            {
                "Material": [
                    [
                        "ijb a dataset"
                    ],
                    [
                        "iarpa janus benchmark"
                    ]
                ],
                "Method": [
                    [
                        "triplet"
                    ],
                    [
                        "triplet probabilistic embedding"
                    ],
                    [
                        "probabilistic embedding"
                    ],
                    [
                        "embedding"
                    ]
                ],
                "Metric": [
                    [
                        "p\u2062pair"
                    ],
                    [
                        "f score"
                    ]
                ],
                "Task": [
                    [
                        "face verification"
                    ],
                    [
                        "verification"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "ijb-a dataset",
                        "ijb-a",
                        "ijb-a datasets",
                        "iarpa janus benchmark-a",
                        "ijb-a:"
                    ]
                ],
                "Method": [
                    [
                        "triplet probabilistic embedding",
                        "triplet probability embedding learning method",
                        "triplet probability embedding",
                        "triplet probabilistic embedding learning method",
                        "tpe",
                        "triplet embedding",
                        "tpe method",
                        "tpe approach"
                    ]
                ],
                "Metric": [
                    [
                        "tar",
                        "far"
                    ]
                ],
                "Task": [
                    [
                        "face verification",
                        "unconstrained face verification",
                        "unconstrained face verification problem",
                        "verification",
                        "identification",
                        "verification protocol",
                        "verification and identification protocols",
                        "identification and verification tasks"
                    ]
                ]
            }
        ]
    },
    "45429c281e30f9e87ebcd1ae42e0656d2ead24d1-64": {
        "doctext": "document: high-resolution image synthesis and semantic manipulation with conditional gans we present a new method for synthesizing high-resolution photo-realistic images from semantic label maps using conditional generative adversarial networks (conditional gans). conditional gans have enabled a variety of applications, but the results are often limited to low-resolution and still far from realistic. in this work, we generate visually appealing results with a novel adversarial loss, as well as new multi-scale generator and discriminator architectures. furthermore, we extend our framework to interactive visual manipulation with two additional features. first, we incorporate object instance segmentation information, which enables object manipulations such as removing/ adding objects and changing the object category. second, we propose a method to generate diverse results given the same input, allowing users to edit the object appearance interactively. human opinion studies demonstrate that our method significantly outperforms existing methods, advancing both the quality and the resolution of deep image synthesis and editing. section: introduction photo-realistic image rendering using standard graphics techniques is involved, since geometry, materials, and light transport must be simulated explicitly. although existing graphics algorithms excel at the task, building and editing virtual environments is expensive and time-consuming. that is because we have to model every aspect of the world explicitly. if we were able to render photo-realistic images using a model learned from data, we could turn the process of graphics rendering into a model learning and inference problem. then, we could simplify the process of creating new virtual worlds by training models on new datasets. we could even make it easier to customize environments by allowing users to simply specify overall semantic structure rather than modeling geometry, materials, or lighting. in this paper, we discuss a new approach that produces high-resolution images from semantic label maps. this method has a wide range of applications. for example, we can use it to create synthetic training data for training visual recognition algorithms, since it is much easier to create semantic labels for desired scenarios than to generate training images. using semantic segmentation methods, we can transform images into a semantic label domain, edit the objects in the label domain, and then transform them back to the image domain. this method also gives us new tools for higher-level image editing, e.g., adding objects to images or changing the appearance of existing objects. to synthesize images from semantic labels, one can use the pix2pix method, an image-to-image translation framework which leverages generative adversarial networks (gans) in a conditional setting. recently, chen and koltun suggest that adversarial training might be unstable and prone to failure for high-resolution image generation tasks. instead, they adopt a modified perceptual loss to synthesize images, which are high-resolution but often lack fine details and realistic textures. here we address two main issues of the above state-of-the-art methods: (1) the difficulty of generating high-resolution images with gans and (2) the lack of details and realistic textures in the previous high-resolution results. we show that through a new, robust adversarial learning objective together with new multi-scale generator and discriminator architectures, we can synthesize photo-realistic images at resolution, which are more visually appealing than those computed by previous methods. we first obtain our results with adversarial training only, without relying on any hand-crafted losses or pre-trained networks (e.g. vggnet) for perceptual losses (figs. [reference] c, [reference] b). then we show that adding perceptual losses from pre-trained networks can slightly improve the results in some circumstances (figs. [reference] d, [reference] c), if a pre-trained network is available. both results outperform previous works substantially in terms of image quality. furthermore, to support interactive semantic manipulation, we extend our method in two directions. first, we use instance-level object segmentation information, which can separate different object instances within the same category. this enables flexible object manipulations, such as adding/ removing objects and changing object types. second, we propose a method to generate diverse results given the same input label map, allowing the user to edit the appearance of the same object interactively. we compare against state-of-the-art visual synthesis systems, and show that our method outperforms these approaches regarding both quantitative evaluations and human perception studies. we also perform an ablation study regarding the training objectives and the importance of instance-level segmentation information. in addition to semantic manipulation, we test our method on edge2photo applications (figs. [reference], [reference]), which shows the generalizability of our approach. code and data are available at our. section: related work paragraph: generative adversarial networks generative adversarial networks (gans) aim to model the natural image distribution by forcing the generated samples to be indistinguishable from natural images. gans enable a wide variety of applications such as image generation, representation learning, image manipulation, object detection, and video applications. various coarse-to-fine schemes have been proposed to synthesize larger images (e.g.) in an unconditional setting. inspired by their successes, we propose a new coarse-to-fine generator and multi-scale discriminator architectures suitable for conditional image generation at a much higher resolution. paragraph: image-to-image translation many researchers have leveraged adversarial learning for image-to-image translation, whose goal is to translate an input image from one domain to another domain given input-output image pairs as training data. compared to loss, which often leads to blurry images, the adversarial loss has become a popular choice for many image-to-image tasks. the reason is that the discriminator can learn a trainable loss function and automatically adapt to the differences between the generated and real images in the target domain. for example, the recent pix2pix framework used image-conditional gans for different applications, such as transforming google maps to satellite views and generating cats from user sketches. various methods have also been proposed to learn an image-to-image translation in the absence of training pairs. recently, chen and koltun suggest that it might be hard for conditional gans to generate high-resolution images due to the training instability and optimization issues. to avoid this difficulty, they use a direct regression objective based on a perceptual loss and produce the first model that can synthesize images. the generated results are high-resolution but often lack fine details and realistic textures. motivated by their success, we show that using our new objective function as well as novel multi-scale generators and discriminators, we not only largely stabilize the training of conditional gans on high-resolution images, but also achieve significantly better results compared to chen and koltun. side-by-side comparisons clearly show our advantage (figs. [reference], [reference], [reference], [reference]). paragraph: deep visual manipulation recently, deep neural networks have obtained promising results in various image processing tasks, such as style transfer, inpainting, colorization, and restoration. however, most of these works lack an interface for users to adjust the current result or explore the output space. to address this issue, zhu developed an optimization method for editing the object appearance based on the priors learned by gans. recent works also provide user interfaces for creating novel imagery from low-level cues such as color and sketch. all of the prior works report results on low-resolution images. our system shares the same spirit as this past work, but we focus on object-level semantic editing, allowing users to interact with the entire scene and manipulate individual objects in the image. as a result, users can quickly create a new scene with minimal effort. our interface is inspired by prior data-driven graphics systems. but our system allows more flexible manipulations and produces high-res results in real-time. section: instance-level image synthesis we propose a conditional adversarial framework for generating high-resolution photo-realistic images from semantic label maps. we first review our baseline model pix2pix (sec. [reference]). we then describe how we increase the photo-realism and resolution of the results with our improved objective function and network design (sec. [reference]). next, we use additional instance-level object semantic information to further improve the image quality (sec. [reference]). finally, we introduce an instance-level feature embedding scheme to better handle the multi-modal nature of image synthesis, which enables interactive object editing (sec. [reference]). subsection: the pix2pix baseline the pix2pix method is a conditional gan framework for image-to-image translation. it consists of a generator and a discriminator. for our task, the objective of the generator is to translate semantic label maps to realistic-looking images, while the discriminator aims to distinguish real images from the translated ones. the framework operates in a supervised setting. in other words, the training dataset is given as a set of pairs of corresponding images, where is a semantic label map and is a corresponding natural photo. conditional gans aim to model the conditional distribution of real images given the input semantic label maps via the following minimax game: where the objective function is given by the pix2pix method adopts u-net as the generator and a patch-based fully convolutional network as the discriminator. the input to the discriminator is a channel-wise concatenation of the semantic label map and the corresponding image. however, the resolution of the generated images on cityscapes is up to. we tested directly applying the pix2pix framework to generate high-resolution images but found the training unstable and the quality of generated images unsatisfactory. therefore, we describe how we improve the pix2pix framework in the next subsection. subsection: improving photorealism and resolution we improve the pix2pix framework by using a coarse-to-fine generator, a multi-scale discriminator architecture, and a robust adversarial learning objective function. coarse-to-fine generator we decompose the generator into two sub-networks: and. we term as the global generator network and as the local enhancer network. the generator is then given by the tuple as visualized in fig. [reference]. the global generator network operates at a resolution of, and the local enhancer network outputs an image with a resolution that is the output size of the previous one (along each image dimension). for synthesizing images at an even higher resolution, additional local enhancer networks could be utilized. for example, the output image resolution of the generator is, and the output image resolution of is. our global generator is built on the architecture proposed by johnson, which has been proven successful for neural style transfer on images up to. it consists of components: a convolutional front-end, a set of residual blocks, and a transposed convolutional back-end. a semantic label map of resolution is passed through the 3 components sequentially to output an image of resolution. the local enhancer network also consists of 3 components: a convolutional front-end, a set of residual blocks, and a transposed convolutional back-end. the resolution of the input label map to is. different from the global generator network, the input to the residual block is the element-wise sum of two feature maps: the output feature map of, and the last feature map of the back-end of the global generator network. this helps integrating the global information from to. during training, we first train the global generator and then train the local enhancer in the order of their resolutions. we then jointly fine-tune all the networks together. we use this generator design to effectively aggregate global and local information for the image synthesis task. we note that such a multi-resolution pipeline is a well-established practice in computer vision and two-scale is often enough. similar ideas but different architectures could be found in recent unconditional gans and conditional image generation. multi-scale discriminators high-resolution image synthesis poses a significant challenge to the gan discriminator design. to differentiate high-resolution real and synthesized images, the discriminator needs to have a large receptive field. this would require either a deeper network or larger convolutional kernels, both of which would increase the network capacity and potentially cause overfitting. also, both choices demand a larger memory footprint for training, which is already a scarce resource for high-resolution image generation. to address the issue, we propose using multi-scale discriminators. we use discriminators that have an identical network structure but operate at different image scales. we will refer to the discriminators as, and. specifically, we downsample the real and synthesized high-resolution images by a factor of and to create an image pyramid of 3 scales. the discriminators, and are then trained to differentiate real and synthesized images at the different scales, respectively. although the discriminators have an identical architecture, the one that operates at the coarsest scale has the largest receptive field. it has a more global view of the image and can guide the generator to generate globally consistent images. on the other hand, the discriminator at the finest scale encourages the generator to produce finer details. this also makes training the coarse-to-fine generator easier, since extending a low-resolution model to a higher resolution only requires adding a discriminator at the finest level, rather than retraining from scratch. without the multi-scale discriminators, we observe that many repeated patterns often appear in the generated images. with the discriminators, the learning problem in eq. ([reference]) then becomes a multi-task learning problem of using multiple gan discriminators at the same image scale has been proposed in unconditional gans. iizuka et al. add a global image classifier to conditional gans to synthesize globally coherent content for inpainting. here we extend the design to multiple discriminators at different image scales for modeling high-resolution images. improved adversarial loss we improve the gan loss in eq. ([reference]) by incorporating a feature matching loss based on the discriminator. this loss stabilizes the training as the generator has to produce natural statistics at multiple scales. specifically, we extract features from multiple layers of the discriminator and learn to match these intermediate representations from the real and the synthesized image. for ease of presentation, we denote the th-layer feature extractor of discriminator as (from input to the th layer of). the feature matching loss is then calculated as: where is the total number of layers and denotes the number of elements in each layer. our gan discriminator feature matching loss is related to the perceptual loss, which has been shown to be useful for image super-resolution and style transfer. in our experiments, we discuss how the discriminator feature matching loss and the perceptual loss can be jointly used for further improving the performance. we note that a similar loss is used in vae-gans. our full objective combines both gan loss and feature matching loss as: where controls the importance of the two terms. note that for the feature matching loss, only serves as a feature extractor and does not maximize the loss. subsection: using instance maps existing image synthesis methods only utilize semantic label maps, an image where each pixel value represents the object class of the pixel. this map does not differentiate objects of the same category. on the other hand, an instance-level semantic label map contains a unique object id for each individual object. to incorporate the instance map, one can directly pass it into the network, or encode it into a one-hot vector. however, both approaches are difficult to implement in practice, since different images may contain different numbers of objects of the same category. alternatively, one can pre-allocate a fixed number of channels (e.g.,) for each class, but this method fails when the number is set too small, and wastes memory when the number is too large. instead, we argue that the most critical information the instance map provides, which is not available in the semantic label map, is the object boundary. for example, when objects of the same class are next to one another, looking at the semantic label map alone can not tell them apart. this is especially true for the street scene since many parked cars or walking pedestrians are often next to one another, as shown in fig. [reference] a. however, with the instance map, separating these objects becomes an easier task. therefore, to extract this information, we first compute the instance boundary map (fig. [reference] b). in our implementation, a pixel in the instance boundary map is if its object id is different from any of its-neighbors, and otherwise. the instance boundary map is then concatenated with the one-hot vector representation of the semantic label map, and fed into the generator network. similarly, the input to the discriminator is the channel-wise concatenation of instance boundary map, semantic label map, and the real/ synthesized image. figure [reference] b shows an example demonstrating the improvement by using object boundaries. our user study in sec. [reference] also shows the model trained with instance boundary maps renders more photo-realistic object boundaries. subsection: learning an instance-level feature embedding image synthesis from semantic label maps is a one-to-many mapping problem. an ideal image synthesis algorithm should be able to generate diverse, realistic images using the same semantic label map. recently, several works learn to produce a fixed number of discrete outputs given the same input or synthesize diverse modes controlled by a latent code that encodes the entire image. although these approaches tackle the multi-modal image synthesis problem, they are unsuitable for our image manipulation task mainly for two reasons. first, the user has no intuitive control over which kinds of images the model would produce. second, these methods focus on global color and texture changes and allow no object-level control on the generated contents. to generate diverse images and allow instance-level control, we propose adding additional low-dimensional feature channels as the input to the generator network. we show that, by manipulating these features, we can have flexible control over the image synthesis process. furthermore, note that since the feature channels are continuous quantities, our model is, in principle, capable of generating infinitely many images. to generate the low-dimensional features, we train an encoder network to find a low-dimensional feature vector that corresponds to the ground truth target for each instance in the image. our feature encoder architecture is a standard encoder-decoder network. to ensure the features are consistent within each instance, we add an instance-wise average pooling layer to the output of the encoder to compute the average feature for the object instance. the average feature is then broadcast to all the pixel locations of the instance. figure [reference] visualizes an example of the encoded features. we replace with in eq. ([reference]) and train the encoder jointly with the generators and discriminators. after the encoder is trained, we run it on all instances in the training images and record the obtained features. then we perform a-means clustering on these features for each semantic category. each cluster thus encodes the features for a specific style, for example, the asphalt or cobblestone texture for a road. at inference time, we randomly pick one of the cluster centers and use it as the encoded features. these features are concatenated with the label map and used as the input to our generator. we tried to enforce the kullback-leibler loss on the feature space for better test-time sampling as used in the recent work but found it quite involved for users to adjust the latent vectors for each object directly. instead, for each object instance, we present modes for users to choose from. section: results we first provide a quantitative comparison against leading methods in sec. [reference]. we then report a subjective human perceptual study in sec. [reference]. finally, we show a few examples of interactive object editing results in sec. [reference]. implementation details we use lsgans for stable training. in all experiments, we set the weight (eq. ([reference])) and for k-means. we use-dimensional vectors to encode features for each object instance. we experimented with adding a perceptual loss to our objective (eq. ([reference])), where and denotes the-th layer with elements of the vgg network. we observe that this loss slightly improves the results. we name these two variants as ours and ours (w/ o vgg loss). please find more training and architecture details in the appendix. datasets we conduct extensive comparisons and ablation studies on cityscapes dataset and nyu indoor rgbd dataset. we report additional qualitative results on ade20 k dataset and helen face dataset. baselines we compare our method with two state-of-the-art algorithms: pix2pix and crn. we train pix2pix models on high-res images with the default setting. we produce the high-res crn images via the authors' publicly available model. subsection: quantitative comparisons we adopt the same evaluation protocol from previous image-to-image translation works. to quantify the quality of our results, we perform semantic segmentation on the synthesized images and compare how well the predicted segments match the input. the intuition is that if we can produce realistic images that correspond to the input label map, an off-the-shelf semantic segmentation model (e.g., pspnet that we use) should be able to predict the ground truth label. table [reference] reports the calculated segmentation accuracy. as can be seen, for both pixel-wise accuracy and mean intersection-over-union (iou), our method outperforms the other methods by a large margin. moreover, our result is very close to the result of the original images, the theoretical\" upper bound\" of the realism we can achieve. this justifies the superiority of our algorithm. subsection: human perceptual study we further evaluate our algorithm via a human subjective study. we perform pairwise a/ b tests deployed on the amazon mechanical turk (mturk) platform on the cityscapes dataset. we follow the same experimental procedure as described in chen and koltun. more specifically, two different kinds of experiments are conducted: unlimited time and limited time, as explained below. unlimited time for this task, workers are given two images at once, each of which is synthesized by a different method for the same label map. we give them unlimited time to select which image looks more natural. the left-right order and the image order are randomized to ensure fair comparisons. all cityscapes test images are compared times, resulting in human judgments for each method. in this experiment, we use the model trained on labels only (without instance maps) to ensure a fair comparison. table [reference] shows that both variants of our method outperform the other methods significantly. limited time next, for the limited time experiment, we compare our result with crn and the original image (ground truth). in each comparison, we show results of two methods for a short period of time. we randomly select a duration between seconds and seconds, as adopted by prior work. this evaluates how quickly the difference between the images can be perceived. fig. [reference] shows the comparison results at different time intervals. as the given time becomes longer and longer, the differences between these three types of images become more apparent and easier to observe. figures [reference] and [reference] show some example results. analysis of the loss function we also study the importance of each term in our objective function using the unlimited time experiment. specifically, our final loss contains three components: gan loss, discriminator-based feature matching loss, and vgg perceptual loss. we compare our final implementation to the results using () only gan loss, and () gan feature matching loss (i.e., without vgg loss). the obtained preference rates are and, respectively. as can be seen, adding the feature matching loss substantially improves the performance, while adding perceptual loss further enhances the results. however, note that using the perceptual loss is not critical, and we are still able to generate visually appealing results even without it (e.g., figs. [reference] c, [reference] b). using instance maps we compare the results using instance maps to results without using them. we highlight the car regions in the images and ask the participants to choose which region looks more realistic. we obtain a preference rate of, which indicates that using instance maps improves the realism of our results, especially around the object boundaries. analysis of the generator we compare results of different generators with all the other components fixed. in particular, we compare our generator with two state-of-the-art generator architectures: u-net and crn. we evaluate the performance regarding both semantic segmentation scores and human perceptual study results. table [reference] and table [reference] show that our coarse-to-fine generator outperforms other networks by a large margin. analysis of the discriminator next, we also compare results using our multi-scale discriminators and results using only one discriminator while we keep the generator and the loss function fixed. the segmentation scores on cityscapes (table [reference]) demonstrate that using multi-scale discriminators helps produce higher quality results as well as stabilize the adversarial training. we also perform pairwise a/ b tests on the amazon mechanical turk platform. of the participants prefer our results with multi-scale discriminators over the results trained with a single-scale discriminator (chance is). additional datasets to further evaluate our method, we perform unlimited time comparisons on the nyu dataset. we obtain and against pix2pix and crn, respectively. fig. [reference] show some example images. finally, we show results on the ade20 k dataset (fig. [reference]). subsection: interactive object editing our feature encoder allows us to perform interactive instance editing on the resulting images. for example, we can change the object labels in the image to quickly create novel scenes, such as replacing trees with buildings (fig. [reference] b). we can also change the colors of individual cars or the textures of the road (fig. [reference] c). please check out our interactive demos on our website. besides, we implement our interactive object editing feature on the helen face dataset where labels for different facial parts are available (fig. [reference]). this makes it easy to edit human portraits, e.g., changing the face color to mimic different make-up effects or adding beard to a face. section: discussion and conclusion the results in this paper suggest that conditional gans can synthesize high-resolution photo-realistic imagery without any hand-crafted losses or pre-trained networks. we have observed that incorporating a perceptual loss can slightly improve the results. our method allows many applications and will be potentially useful for domains where high-resolution results are in demand but pre-trained networks are not available (e.g., medical imaging and biology). this paper also shows that an image-to-image synthesis pipeline can be extended to produce diverse outputs, and enable interactive image manipulation given appropriate training input-output pairs (e.g., instance maps in our case). without ever been told what a\" texture\" is, our model learns to stylize different objects, which may be generalized to other datasets as well (i.e., using textures in one dataset to synthesize images in another dataset). we believe these extensions can be potentially applied to other image synthesis problems. acknowledgements we thank taesung park, phillip isola, tinghui zhou, richard zhang, rafael valle and alexei a. efros for helpful comments. we also thank chen and koltun and isola et al. for sharing their code. jyz is supported by a facebook graduate fellowship. bibliography: references appendix: training details all the networks were trained from scratch, using the adam solver and a learning rate of. we keep the same learning rate for the first epochs and linearly decay the rate to zero over the next epochs. weights were initialized from a gaussian distribution with mean and standard deviation. we train all our models on an nvidia quadro m6000 gpu with gb gpu memory. the inference time is between milliseconds per input image on an nvidia 1080ti gpu with gb gpu memory. this real-time performance allows us to develop interactive image editing applications. below we discuss the details of the datasets we used. cityscapes dataset []: training images from the cityscapes training set with image size. we use the cityscapes validation set for testing, which consists of 500 images. nyu indoor rgbd dataset []: training images and test images, all at resolution of. ade20 k dataset []: training images and test images with varying image sizes. we scale the width of all images to before training and inference. helen face dataset []: training images and test images with varying image sizes. we resize all images to before training and inference. appendix: generator architectures our generator consists of a global generator network and a local enhancer network. we follow the naming convention used in johnson el al. and cyclegan. let c7s1-k denote a convolution-instancenorm-relu layer with filters and stride. dk denotes a convolution-instancenorm-relu layer with filters, and stride. we use reflection padding to reduce boundary artifacts. rk denotes a residual block that contains two convolutional layers with the same number of filters on both layers. uk denotes a fractional-strided-convolution-instancenorm-relu layer with filters, and stride. recall that we have two generators: the global generator and the local enhancer. our global network: c7s1-64, d128, d256, d512, d1024, r1024, r1024, r1024, r1024, r1024, r1024, r1024, r1024, r1024, u512, u256, u128, u64, c7s1-3 our local enhancer: c7s1-32, d64we add the last feature map (u64) in our global network to the output of this layer., r64, r64, r64, u32, c7s1-3 appendix: discriminator architectures for discriminator networks, we use patchgan. let ck denote a convolution-instancenorm-leakyrelu layer with k filters and stride. after the last layer, we apply a convolution to produce a dimensional output. we do not use instancenorm for the first c64 layer. we use leaky relus with slope. all our three discriminators have the identical architecture as follows: c64-c128-c256-c512 appendix: change log paragraph: v1 initial preprint release paragraph: v2 cvpr camera ready, adding more results for edge-to-photo examples.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "cityscapes validation set"
                    ]
                ],
                "Method": [
                    [
                        "conditional gans"
                    ]
                ],
                "Metric": [],
                "Task": [
                    [
                        "semantic manipulation"
                    ],
                    [
                        "object instance segmentation"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "ade20 k dataset",
                        "ade20"
                    ]
                ],
                "Method": [
                    [
                        "pix2pix method"
                    ]
                ],
                "Metric": [
                    [
                        "segmentation accuracy",
                        "pixel-wise accuracy"
                    ]
                ],
                "Task": [
                    [
                        "image-to-image translation"
                    ]
                ]
            },
            {
                "Material": [
                    [
                        "cityscapes",
                        "cityscapes dataset"
                    ]
                ],
                "Method": [
                    [
                        "pix2pix method"
                    ]
                ],
                "Metric": [
                    [
                        "intersection-over-union",
                        "iou"
                    ]
                ],
                "Task": [
                    [
                        "image-to-image translation"
                    ]
                ]
            }
        ]
    },
    "455da02e5048dffb51fb6ab5eb8aeca5926c9d9a-65": {
        "doctext": "document: spatial pyramid pooling in deep convolutional networks for visual recognition existing deep convolutional neural networks (cnns) require a fixed-size (, 224 224) input image. this requirement is\" artificial\" and may reduce the recognition accuracy for the images or sub-images of an arbitrary size/ scale. in this work, we equip the networks with another pooling strategy,\" spatial pyramid pooling\", to eliminate the above requirement. the new network structure, called spp-net, can generate a fixed-length representation regardless of image size/ scale. pyramid pooling is also robust to object deformations. with these advantages, spp-net should in general improve all cnn-based image classification methods. on the imagenet 2012 dataset, we demonstrate that spp-net boosts the accuracy of a variety of cnn architectures despite their different designs. on the pascal voc 2007 and caltech101 datasets, spp-net achieves state-of-the-art classification results using a single full-image representation and no fine-tuning. the power of spp-net is also significant in object detection. using spp-net, we compute the feature maps from the entire image only once, and then pool features in arbitrary regions (sub-images) to generate fixed-length representations for training the detectors. this method avoids repeatedly computing the convolutional features. in processing test images, our method is 24-102 faster than the r-cnn method, while achieving better or comparable accuracy on pascal voc 2007. in imagenet large scale visual recognition challenge (ilsvrc) 2014, our methods rank# 2 in object detection and# 3 in image classification among all 38 teams. this manuscript also introduces the improvement made for this competition. onvolutional neural networks, spatial pyramid pooling, image classification, object detection section: introduction we are witnessing a rapid, revolutionary change in our vision community, mainly caused by deep convolutional neural networks (cnns) and the availability of large scale training data. deep-networks-based approaches have recently been substantially improving upon the state of the art in image classification, object detection, many other recognition tasks, and even non-recognition tasks. however, there is a technical issue in the training and testing of the cnns: the prevalent cnns require a fixed input image size (, 224 224), which limits both the aspect ratio and the scale of the input image. when applied to images of arbitrary sizes, current methods mostly fit the input image to the fixed size, either via cropping or via warping, as shown in figure [reference] (top). but the cropped region may not contain the entire object, while the warped content may result in unwanted geometric distortion. recognition accuracy can be compromised due to the content loss or distortion. besides, a pre-defined scale may not be suitable when object scales vary. fixing input sizes overlooks the issues involving scales. so why do cnns require a fixed input size? a cnn mainly consists of two parts: convolutional layers, and fully-connected layers that follow. the convolutional layers operate in a sliding-window manner and output feature maps which represent the spatial arrangement of the activations (figure [reference]). in fact, convolutional layers do not require a fixed image size and can generate feature maps of any sizes. on the other hand, the fully-connected layers need to have fixed-size/ length input by their definition. hence, the fixed-size constraint comes only from the fully-connected layers, which exist at a deeper stage of the network. in this paper, we introduce a spatial pyramid pooling (spp) layer to remove the fixed-size constraint of the network. specifically, we add an spp layer on top of the last convolutional layer. the spp layer pools the features and generates fixed-length outputs, which are then fed into the fully-connected layers (or other classifiers). in other words, we perform some information\" aggregation\" at a deeper stage of the network hierarchy (between convolutional layers and fully-connected layers) to avoid the need for cropping or warping at the beginning. figure [reference] (bottom) shows the change of the network architecture by introducing the spp layer. we call the new network structure spp-net. spatial pyramid pooling (popularly known as spatial pyramid matching or spm), as an extension of the bag-of-words (bow) model, is one of the most successful methods in computer vision. it partitions the image into divisions from finer to coarser levels, and aggregates local features in them. spp has long been a key component in the leading and competition-winning systems for classification (,) and detection (,) before the recent prevalence of cnns. nevertheless, spp has not been considered in the context of cnns. we note that spp has several remarkable properties for deep cnns: 1) spp is able to generate a fixed-length output regardless of the input size, while the sliding window pooling used in the previous deep networks can not; 2) spp uses multi-level spatial bins, while the sliding window pooling uses only a single window size. multi-level pooling has been shown to be robust to object deformations; 3) spp can pool features extracted at variable scales thanks to the flexibility of input scales. through experiments we show that all these factors elevate the recognition accuracy of deep networks. spp-net not only makes it possible to generate representations from arbitrarily sized images/ windows for testing, but also allows us to feed images with varying sizes or scales during training. training with variable-size images increases scale-invariance and reduces over-fitting. we develop a simple multi-size training method. for a single network to accept variable input sizes, we approximate it by multiple networks that share all parameters, while each of these networks is trained using a fixed input size. in each epoch we train the network with a given input size, and switch to another input size for the next epoch. experiments show that this multi-size training converges just as the traditional single-size training, and leads to better testing accuracy. the advantages of spp are orthogonal to the specific cnn designs. in a series of controlled experiments on the imagenet 2012 dataset, we demonstrate that spp improves four different cnn architectures in existing publications (or their modifications), over the no-spp counterparts. these architectures have various filter numbers/ sizes, strides, depths, or other designs. it is thus reasonable for us to conjecture that spp should improve more sophisticated (deeper and larger) convolutional architectures. spp-net also shows state-of-the-art classification results on caltech101 and pascal voc 2007 using only a single full-image representation and no fine-tuning. spp-net also shows great strength in object detection. in the leading object detection method r-cnn, the features from candidate windows are extracted via deep convolutional networks. this method shows remarkable detection accuracy on both the voc and imagenet datasets. but the feature computation in r-cnn is time-consuming, because it repeatedly applies the deep convolutional networks to the raw pixels of thousands of warped regions per image. in this paper, we show that we can run the convolutional layers only once on the entire image (regardless of the number of windows), and then extract features by spp-net on the feature maps. this method yields a speedup of over one hundred times over r-cnn. note that training/ running a detector on the feature maps (rather than image regions) is actually a more popular idea. but spp-net inherits the power of the deep cnn feature maps and also the flexibility of spp on arbitrary window sizes, which leads to outstanding accuracy and efficiency. in our experiment, the spp-net-based system (built upon the r-cnn pipeline) computes features 24-102 faster than r-cnn, while has better or comparable accuracy. with the recent fast proposal method of edgeboxes, our system takes 0.5 seconds processing an image (including all steps). this makes our method practical for real-world applications. a preliminary version of this manuscript has been published in eccv 2014. based on this work, we attended the competition of ilsvrc 2014, and ranked# 2 in object detection and# 3 in image classification (both are provided-data-only tracks) among all 38 teams. there are a few modifications made for ilsvrc 2014. we show that the spp-nets can boost various networks that are deeper and larger (sec. [reference]-[reference]) over the no-spp counterparts. further, driven by our detection framework, we find that multi-view testing on feature maps with flexibly located/ sized windows (sec. [reference]) can increase the classification accuracy. this manuscript also provides the details of these modifications. we have released the code to facilitate future research (http:// research.microsoft.com/ en-us/ um/ people/ kahe/). section: deep networks with spatial pyramid pooling subsection: convolutional layers and feature maps consider the popular seven-layer architectures. the first five layers are convolutional, some of which are followed by pooling layers. these pooling layers can also be considered as\" convolutional\", in the sense that they are using sliding windows. the last two layers are fully connected, with an n-way softmax as the output, where n is the number of categories. the deep network described above needs a fixed image size. however, we notice that the requirement of fixed sizes is only due to the fully-connected layers that demand fixed-length vectors as inputs. on the other hand, the convolutional layers accept inputs of arbitrary sizes. the convolutional layers use sliding filters, and their outputs have roughly the same aspect ratio as the inputs. these outputs are known as feature maps-they involve not only the strength of the responses, but also their spatial positions. in figure [reference], we visualize some feature maps. they are generated by some filters of the conv layer. figure [reference] (c) shows the strongest activated images of these filters in the imagenet dataset. we see a filter can be activated by some semantic content. for example, the 55-th filter (figure [reference], bottom left) is most activated by a circle shape; the 66-th filter (figure [reference], top right) is most activated by a-shape; and the 118-th filter (figure [reference], bottom right) is most activated by a-shape. these shapes in the input images (figure [reference] (a)) activate the feature maps at the corresponding positions (the arrows in figure [reference]). it is worth noticing that we generate the feature maps in figure [reference] without fixing the input size. these feature maps generated by deep convolutional layers are analogous to the feature maps in traditional methods. in those methods, sift vectors or image patches are densely extracted and then encoded,, by vector quantization, sparse coding, or fisher kernels. these encoded features consist of the feature maps, and are then pooled by bag-of-words (bow) or spatial pyramids. analogously, the deep convolutional features can be pooled in a similar way. subsection: the spatial pyramid pooling layer the convolutional layers accept arbitrary input sizes, but they produce outputs of variable sizes. the classifiers (svm/ softmax) or fully-connected layers require fixed-length vectors. such vectors can be generated by the bag-of-words (bow) approach that pools the features together. spatial pyramid pooling improves bow in that it can maintain spatial information by pooling in local spatial bins. these spatial bins have sizes proportional to the image size, so the number of bins is fixed regardless of the image size. this is in contrast to the sliding window pooling of the previous deep networks, where the number of sliding windows depends on the input size. to adopt the deep network for images of arbitrary sizes, we replace the last pooling layer (, pool, after the last convolutional layer) with a spatial pyramid pooling layer. figure [reference] illustrates our method. in each spatial bin, we pool the responses of each filter (throughout this paper we use max pooling). the outputs of the spatial pyramid pooling are-dimensional vectors with the number of bins denoted as (is the number of filters in the last convolutional layer). the fixed-dimensional vectors are the input to the fully-connected layer. with spatial pyramid pooling, the input image can be of any sizes. this not only allows arbitrary aspect ratios, but also allows arbitrary scales. we can resize the input image to any scale (,= 180, 224,\u2026) and apply the same deep network. when the input image is at different scales, the network (with the same filter sizes) will extract features at different scales. the scales play important roles in traditional methods,, the sift vectors are often extracted at multiple scales (determined by the sizes of the patches and gaussian filters). we will show that the scales are also important for the accuracy of deep networks. interestingly, the coarsest pyramid level has a single bin that covers the entire image. this is in fact a\" global pooling\" operation, which is also investigated in several concurrent works. in a global average pooling is used to reduce the model size and also reduce overfitting; in, a global average pooling is used on the testing stage after all fc layers to improve accuracy; in, a global max pooling is used for weakly supervised object recognition. the global pooling operation corresponds to the traditional bag-of-words method. subsection: training the network theoretically, the above network structure can be trained with standard back-propagation, regardless of the input image size. but in practice the gpu implementations (such as cuda-convnet and caffe) are preferably run on fixed input images. next we describe our training solution that takes advantage of these gpu implementations while still preserving the spatial pyramid pooling behaviors. subsubsection: single-size training as in previous works, we first consider a network taking a fixed-size input (224 224) cropped from images. the cropping is for the purpose of data augmentation. for an image with a given size, we can pre-compute the bin sizes needed for spatial pyramid pooling. consider the feature maps after conv that have a size of (, 13 13). with a pyramid level of bins, we implement this pooling level as a sliding window pooling, where the window size and stride with and denoting ceiling and floor operations. with an-level pyramid, we implement such layers. the next fully-connected layer (fc) will concatenate the outputs. figure [reference] shows an example configuration of 3-level pyramid pooling (3 3, 2 2, 1 1) in the cuda-convnet style. the main purpose of our single-size training is to enable the multi-level pooling behavior. experiments show that this is one reason for the gain of accuracy. subsubsection: multi-size training our network with spp is expected to be applied on images of any sizes. to address the issue of varying image sizes in training, we consider a set of pre-defined sizes. we consider two sizes: 180 180 in addition to 224 224. rather than crop a smaller 180 180 region, we resize the aforementioned 224 224 region to 180 180. so the regions at both scales differ only in resolution but not in content/ layout. for the network to accept 180 180 inputs, we implement another fixed-size-input (180 180) network. the feature map size after conv is 10 in this case. then we still use and to implement each pyramid pooling level. the output of the spatial pyramid pooling layer of this 180-network has the same fixed length as the 224-network. as such, this 180-network has exactly the same parameters as the 224-network in each layer. in other words, during training we implement the varying-input-size spp-net by two fixed-size networks that share parameters. to reduce the overhead to switch from one network (, 224) to the other (, 180), we train each full epoch on one network, and then switch to the other one (keeping all weights) for the next full epoch. this is iterated. in experiments, we find the convergence rate of this multi-size training to be similar to the above single-size training. the main purpose of our multi-size training is to simulate the varying input sizes while still leveraging the existing well-optimized fixed-size implementations. besides the above two-scale implementation, we have also tested a variant using as input where is randomly and uniformly sampled from at each epoch. we report the results of both variants in the experiment section. note that the above single/ multi-size solutions are for training only. at the testing stage, it is straightforward to apply spp-net on images of any sizes. section: spp-net for image classification subsection: experiments on imagenet 2012 classification we train the networks on the 1000-category training set of imagenet 2012. our training algorithm follows the practices of previous work. the images are resized so that the smaller dimension is 256, and a 224 224 crop is picked from the center or the four corners from the entire image. the data are augmented by horizontal flipping and color altering. dropout is used on the two fully-connected layers. the learning rate starts from 0.01, and is divided by 10 (twice) when the error plateaus. our implementation is based on the publicly available code of cuda-convnet and caffe. all networks in this paper can be trained on a single geforce gtx titan gpu (6 gb memory) within two to four weeks. subsubsection: baseline network architectures the advantages of spp are independent of the convolutional network architectures used. we investigate four different network architectures in existing publications (or their modifications), and we show spp improves the accuracy of all these architectures. these baseline architectures are in table [reference] and briefly introduced below: zf-5: this architecture is based on zeiler and fergus's (zf)\" fast\" (smaller) model. the number indicates five convolutional layers. convnet*-5: this is a modification on krizhevsky's network. we put the two pooling layers after conv and conv (instead of after conv and conv). as a result, the feature maps after each layer have the same size as zf-5. overfeat-5/ 7: this architecture is based on the overfeat paper, with some modifications as in. in contrast to zf-5/ convnet*-5, this architecture produces a larger feature map (instead of) before the last pooling layer. a larger filter number (512) is used in conv and the following convolutional layers. we also investigate a deeper architecture with 7 convolutional layers, where conv to conv have the same structures. in the baseline models, the pooling layer after the last convolutional layer generates feature maps, with two 4096-d fc layers and a 1000-way softmax layer following. our replications of these baseline networks are in table [reference] (a). we train 70 epochs for zf-5 and 90 epochs for the others. our replication of zf-5 is better than the one reported in. this gain is because the corner crops are from the entire image, as is also reported in. subsubsection: multi-level pooling improves accuracy in table [reference] (b) we show the results using single-size training. the training and testing sizes are both 224 224. in these networks, the convolutional layers have the same structures as the corresponding baseline models, whereas the pooling layer after the final convolutional layer is replaced with the spp layer. for the results in table [reference], we use a 4-level pyramid. the pyramid is {6 6, 3 3, 2 2, 1 1} (totally 50 bins). for fair comparison, we still use the standard 10-view prediction with each view a 224 224 crop. our results in table [reference] (b) show considerable improvement over the no-spp baselines in table [reference] (a). interestingly, the largest gain of top-1 error (1.65%) is given by the most accurate architecture. since we are still using the same 10 cropped views as in (a), these gains are solely because of multi-level pooling. it is worth noticing that the gain of multi-level pooling is not simply due to more parameters; rather, it is because the multi-level pooling is robust to the variance in object deformations and spatial layout. to show this, we train another zf-5 network with a different 4-level pyramid: {4 4, 3 3, 2 2, 1 1} (totally 30 bins). this network has fewer parameters than its no-spp counterpart, because its fc layer has 30 256-d inputs instead of 36 256-d. the top-1/ top-5 errors of this network are 35.06/ 14.04. this result is similar to the 50-bin pyramid above (34.98/ 14.14), but considerably better than the no-spp counterpart (35.99/ 14.76). subsubsection: multi-size training improves accuracy table [reference] (c) shows our results using multi-size training. the training sizes are 224 and 180, while the testing size is still 224. we still use the standard 10-view prediction. the top-1/ top-5 errors of all architectures further drop. the top-1 error of spp-net (overfeat-7) drops to 29.68%, which is 2.33% better than its no-spp counterpart and 0.68% better than its single-size trained counterpart. besides using the two discrete sizes of 180 and 224, we have also evaluated using a random size uniformly sampled from. the top-1/ 5 error of spp-net (overfeat-7) is 30.06%/ 10.96%. the top-1 error is slightly worse than the two-size version, possibly because the size of 224 (which is used for testing) is visited less. but the results are still better the single-size version. there are previous cnn solutions that deal with various scales/ sizes, but they are mostly based on testing. in overfeat and howard's method, the single network is applied at multiple scales in the testing stage, and the scores are averaged. howard further trains two different networks on low/ high-resolution image regions and averages the scores. to our knowledge, our method is the first one that trains a single network with input images of multiple sizes. subsubsection: full-image representations improve accuracy next we investigate the accuracy of the full-image views. we resize the image so that= 256 while maintaining its aspect ratio. the spp-net is applied on this full image to compute the scores of the full view. for fair comparison, we also evaluate the accuracy of the single view in the center 224 224 crop (which is used in the above evaluations). the comparisons of single-view testing accuracy are in table [reference]. here we evaluate zf-5/ overfeat-7. the top-1 error rates are all reduced by the full-view representation. this shows the importance of maintaining the complete content. even though our network is trained using square images only, it generalizes well to other aspect ratios. comparing table [reference] and table [reference], we find that the combination of multiple views is substantially better than the single full-image view. however, the full-image representations are still of good merits. first, we empirically find that (discussed in the next subsection) even for the combination of dozens of views, the additional two full-image views (with flipping) can still boost the accuracy by about 0.2%. second, the full-image view is methodologically consistent with the traditional methods where the encoded sift vectors of the entire image are pooled together. third, in other applications such as image retrieval, an image representation, rather than a classification score, is required for similarity ranking. a full-image representation can be preferred. subsubsection: multi-view testing on feature maps inspired by our detection algorithm (described in the next section), we further propose a multi-view testing method on the feature maps. thanks to the flexibility of spp, we can easily extract the features from windows (views) of arbitrary sizes from the convolutional feature maps. on the testing stage, we resize an image so where represents a predefined scale (like 256). then we compute the convolutional feature maps from the entire image. for the usage of flipped views, we also compute the feature maps of the flipped image. given any view (window) in the image, we map this window to the feature maps (the way of mapping is in appendix), and then use spp to pool the features from this window (see figure [reference]). the pooled features are then fed into the fc layers to compute the softmax score of this window. these scores are averaged for the final prediction. for the standard 10-view, we use and the views are 224 224 windows on the corners or center. experiments show that the top-5 error of the 10-view prediction on feature maps is within 0.1% around the original 10-view prediction on image crops. we further apply this method to extract multiple views from multiple scales. we resize the image to six scales and compute the feature maps on the entire image for each scale. we use as the view size for any scale, so these views have different relative sizes on the original image for different scales. we use 18 views for each scale: one at the center, four at the corners, and four on the middle of each side, with/ without flipping (when= 224 there are 6 different views). the combination of these 96 views reduces the top-5 error from 10.95% to 9.36%. combining the two full-image views (with flipping) further reduces the top-5 error to 9.14%. in the overfeat paper, the views are also extracted from the convolutional feature maps instead of image crops. however, their views can not have arbitrary sizes; rather, the windows are those where the pooled features match the desired dimensionality. we empirically find that these restricted windows are less beneficial than our flexibly located/ sized windows. subsubsection: summary and results for ilsvrc 2014 in table [reference] we compare with previous state-of-the-art methods. krizhevsky's is the winning method in ilsvrc 2012; overfeat, howard's, and zeiler and fergus's are the leading methods in ilsvrc 2013. we only consider single-network performance for manageable comparisons. our best single network achieves 9.14% top-5 error on the validation set. this is exactly the single-model entry we submitted to ilsvrc 2014. the top-5 error is 9.08% on the testing set (ilsvrc 2014 has the same training/ validation/ testing data as ilsvrc 2012). after combining eleven models, our team's result (8.06%) is ranked# 3 among all 38 teams attending ilsvrc 2014 (table [reference]). since the advantages of spp-net should be in general independent of architectures, we expect that it will further improve the deeper and larger convolutional architectures. subsection: experiments on voc 2007 classification our method can generate a full-view image representation. with the above networks pre-trained on imagenet, we extract these representations from the images in the target datasets and re-train svm classifiers. in the svm training, we intentionally do not use any data augmentation (flip/ multi-view). we l-normalize the features for svm training. the classification task in pascal voc 2007 involves 9, 963 images in 20 categories. 5, 011 images are for training, and the rest are for testing. the performance is evaluated by mean average precision (map). table [reference] summarizes the results. we start from a baseline in table [reference] (a). the model is zf-5 without spp. to apply this model, we resize the image so that its smaller dimension is 224, and crop the center 224 224 region. the svm is trained via the features of a layer. on this dataset, the deeper the layer is, the better the result is. in table [reference] (b), we replace the no-spp net with our spp-net. as a first-step comparison, we still apply the spp-net on the center 224 224 crop. the results of the fc layers improve. this gain is mainly due to multi-level pooling. table [reference] (c) shows our results on full images, where the images are resized so that the shorter side is 224. we find that the results are considerably improved (78.39% 76.45%). this is due to the full-image representation that maintains the complete content. because the usage of our network does not depend on scale, we resize the images so that the smaller dimension is and use the same network to extract features. we find that gives the best results (table [reference] (d)) based on the validation set. this is mainly because the objects occupy smaller regions in voc 2007 but larger regions in imagenet, so the relative object scales are different between the two sets. these results indicate scale matters in the classification tasks, and spp-net can partially address this\" scale mismatch\" issue. in table [reference] (e) the network architecture is replaced with our best model (overfeat-7, multi-size trained), and the map increases to 82.44%. table [reference] summarizes our results and the comparisons with the state-of-the-art methods. among these methods, vq, lcc, and fk are all based on spatial pyramids matching, and are based on deep networks. in these results, oquab's (77.7%) and chatfield's (82.42%) are obtained by network fine-tuning and multi-view testing. our result is comparable with the state of the art, using only a single full-image representation and without fine-tuning. subsection: experiments on caltech101 the caltech101 dataset contains 9, 144 images in 102 categories (one background). we randomly sample 30 images per category for training and up to 50 images per category for testing. we repeat 10 random splits and average the accuracy. table [reference] summarizes our results. there are some common observations in the pascal voc 2007 and caltech101 results: spp-net is better than the no-spp net (table [reference] (b) (a)), and the full-view representation is better than the crop ((c) (b)). but the results in caltech101 have some differences with pascal voc. the fully-connected layers are less accurate, and the spp layers are better. this is possibly because the object categories in caltech101 are less related to those in imagenet, and the deeper layers are more category-specialized. further, we find that the scale 224 has the best performance among the scales we tested on this dataset. this is mainly because the objects in caltech101 also occupy large regions of the images, as is the case of imagenet. besides cropping, we also evaluate warping the image to fit the 224 224 size. this solution maintains the complete content, but introduces distortion. on the spp (zf-5) model, the accuracy is 89.91% using the spp layer as features-lower than 91.44% which uses the same model on the undistorted full image. table [reference] summarizes our results compared with the state-of-the-art methods on caltech101. our result (93.42%) exceeds the previous record (88.54%) by a substantial margin (4.88%). section: spp-net for object detection deep networks have been used for object detection. we briefly review the recent state-of-the-art r-cnn method. r-cnn first extracts about 2, 000 candidate windows from each image via selective search. then the image region in each window is warped to a fixed size (227 227). a pre-trained deep network is used to extract the feature of each window. a binary svm classifier is then trained on these features for detection. r-cnn generates results of compelling quality and substantially outperforms previous methods. however, because r-cnn repeatedly applies the deep convolutional network to about 2, 000 windows per image, it is time-consuming. feature extraction is the major timing bottleneck in testing. our spp-net can also be used for object detection. we extract the feature maps from the entire image only once (possibly at multiple scales). then we apply the spatial pyramid pooling on each candidate window of the feature maps to pool a fixed-length representation of this window (see figure [reference]). because the time-consuming convolutions are only applied once, our method can run orders of magnitude faster. our method extracts window-wise features from regions of the feature maps, while r-cnn extracts directly from image regions. in previous works, the deformable part model (dpm) extracts features from windows in hog feature maps, and the selective search (ss) method extracts from windows in encoded sift feature maps. the overfeat detection method also extracts from windows of deep convolutional feature maps, but needs to pre-define the window size. on the contrary, our method enables feature extraction in arbitrary windows from the deep convolutional feature maps. subsection: detection algorithm we use the\" fast\" mode of selective search to generate about 2, 000 candidate windows per image. then we resize the image such that, and extract the feature maps from the entire image. we use the spp-net model of zf-5 (single-size trained) for the time being. in each candidate window, we use a 4-level spatial pyramid (1 1, 2 2, 3 3, 6 6, totally 50 bins) to pool the features. this generates a 12, 800-d (256 50) representation for each window. these representations are provided to the fully-connected layers of the network. then we train a binary linear svm classifier for each category on these features. our implementation of the svm training follows. we use the ground-truth windows to generate the positive samples. the negative samples are those overlapping a positive window by at most 30% (measured by the intersection-over-union (iou) ratio). any negative sample is removed if it overlaps another negative sample by more than 70%. we apply the standard hard negative mining to train the svm. this step is iterated once. it takes less than 1 hour to train svms for all 20 categories. in testing, the classifier is used to score the candidate windows. then we use non-maximum suppression (threshold of 30%) on the scored windows. our method can be improved by multi-scale feature extraction. we resize the image such that, and compute the feature maps of conv for each scale. one strategy of combining the features from these scales is to pool them channel-by-channel. but we empirically find that another strategy provides better results. for each candidate window, we choose a single scale such that the scaled candidate window has a number of pixels closest to 224 224. then we only use the feature maps extracted from this scale to compute the feature of this window. if the pre-defined scales are dense enough and the window is approximately square, our method is roughly equivalent to resizing the window to 224 224 and then extracting features from it. nevertheless, our method only requires computing the feature maps once (at each scale) from the entire image, regardless of the number of candidate windows. we also fine-tune our pre-trained network, following. since our features are pooled from the conv feature maps from windows of any sizes, for simplicity we only fine-tune the fully-connected layers. in this case, the data layer accepts the fixed-length pooled features after conv, and the fc layers and a new 21-way (one extra negative category) fc layer follow. the fc weights are initialized with a gaussian distribution of= 0.01. we fix all the learning rates to 1e-4 and then adjust to 1e-5 for all three layers. during fine-tuning, the positive samples are those overlapping with a ground-truth window by, and the negative samples by. in each mini-batch, 25% of the samples are positive. we train 250k mini-batches using the learning rate 1e-4, and then 50k mini-batches using 1e-5. because we only fine-tune the fc layers, the training is very fast and takes about 2 hours on the gpu (excluding pre-caching feature maps which takes about 1 hour). also following, we use bounding box regression to post-process the prediction windows. the features used for regression are the pooled features from conv (as a counterpart of the pool features used in). the windows used for the regression training are those overlapping with a ground-truth window by at least 50%. subsection: detection results we evaluate our method on the detection task of the pascal voc 2007 dataset. table [reference] shows our results on various layers, by using 1-scale (= 688) or 5-scale. here the r-cnn results are as reported in using the alexnet with 5 conv layers. using the pool layers (in our case the pooled features), our result (44.9%) is comparable with r-cnn's result (44.2%). but using the non-fine-tuned fc layers, our results are inferior. an explanation is that our fc layers are pre-trained using image regions, while in the detection case they are used on the feature map regions. the feature map regions can have strong activations near the window boundaries, while the image regions may not. this difference of usages can be addressed by fine-tuning. using the fine-tuned fc layers (ftfc), our results are comparable with or slightly better than the fine-tuned results of r-cnn. after bounding box regression, our 5-scale result (59.2%) is 0.7% better than r-cnn (58.5%), and our 1-scale result (58.0%) is 0.5% worse. in table [reference] we further compare with r-cnn using the same pre-trained model of sppnet (zf-5). in this case, our method and r-cnn have comparable averaged scores. the r-cnn result is boosted by this pre-trained model. this is because of the better architecture of zf-5 than alexnet, and also because of the multi-level pooling of sppnet (if using the no-spp zf-5, the r-cnn result drops). table [reference] shows the results for each category. table [reference] also includes additional methods. selective search (ss) applies spatial pyramid matching on sift feature maps. dpm and regionlet are based on hog features. the regionlet method improves to 46.1% by combining various features including conv. detectornet trains a deep network that outputs pixel-wise object masks. this method only needs to apply the deep network once to the entire image, as is the case for our method. but this method has lower map (30.5%). subsection: complexity and running time despite having comparable accuracy, our method is much faster than r-cnn. the complexity of the convolutional feature computation in r-cnn is with the window number (2000). this complexity of our method is at a scale, where is the aspect ratio. assume is about 4/ 3. in the single-scale version when, this complexity is about 1/ 160 of r-cnn's; in the 5-scale version, this complexity is about 1/ 24 of r-cnn's. in table [reference], we provide a fair comparison on the running time of the feature computation using the same spp (zf-5) model. the implementation of r-cnn is from the code published by the authors implemented in caffe. we also implement our feature computation in caffe. in table [reference] we evaluate the average time of 100 random voc images using gpu. r-cnn takes 14.37s per image for convolutions, while our 1-scale version takes only 0.053s per image. so ours is 270 faster than r-cnn. our 5-scale version takes 0.293s per image for convolutions, so is 49 faster than r-cnn. our convolutional feature computation is so fast that the computational time of fc layers takes a considerable portion. table [reference] shows that the gpu time of computing the 4, 096-d fc features is 0.089s per image. considering both convolutional and fully-connected features, our 1-scale version is 102\u00d7 faster than r-cnn and is 1.2% inferior; our 5-scale version is 38\u00d7 faster and has comparable results. we also compares the running time in table [reference] where r-cnn uses alexnet as is in the original paper. our method is 24 to 64 faster. note that the alexnet has the same number of filters as our zf-5 on each conv layer. the alexnet is faster because it uses splitting on some layers, which was designed for two gpus in. we further achieve an efficient full system with the help of the recent window proposal method. the selective search (ss) proposal takes about 1-2 seconds per image on a cpu. the method of edgeboxes only takes 0.2s. note that it is sufficient to use a fast proposal method during testing only. using the same model trained as above (using ss), we test proposals generated by edgeboxes only. the map is 52.8 without bounding box regression. this is reasonable considering that edgeboxes are not used for training. then we use both ss and edgebox as proposals in the training stage, and adopt only edgeboxes in the testing stage. the map is 56.3 without bounding box regression, which is better than 55.2 (table [reference]) due to additional training samples. in this case, the overall testing time is 0.5s per image including all steps (proposal and recognition). this makes our method practical for real-world applications. subsection: model combination for detection model combination is an important strategy for boosting cnn-based classification accuracy. we propose a simple combination method for detection. we pre-train another network in imagenet, using the same structure but different random initializations. then we repeat the above detection algorithm. table [reference] (spp-net (2)) shows the results of this network. its map is comparable with the first network (59.1% 59.2%), and outperforms the first network in 11 categories. given the two models, we first use either model to score all candidate windows on the test image. then we perform non-maximum suppression on the union of the two sets of candidate windows (with their scores). a more confident window given by one method can suppress those less confident given by the other method. after combination, the map is boosted to 60.9% (table [reference]). in 17 out of all 20 categories the combination performs better than either individual model. this indicates that the two models are complementary. we further find that the complementarity is mainly because of the convolutional layers. we have tried to combine two randomly initialized fine-tuned results of the same convolutional model, and found no gain. subsection: ilsvrc 2014 detection the ilsvrc 2014 detection task involves 200 categories. there are 450k/ 20k/ 40k images in the training/ validation/ testing sets. we focus on the task of the provided-data-only track (the 1000-category cls training data is not allowed to use). there are three major differences between the detection (det) and classification (cls) training datasets, which greatly impacts the pre-training quality. first, the det training data is merely 1/ 3 of the cls training data. this seems to be a fundamental challenge of the provided-data-only det task. second, the category number of det is 1/ 5 of cls. to overcome this problem, we harness the provided subcategory labels for pre-training. there are totally 499 non-overlapping subcategories (, the leaf nodes in the provided category hierarchy). so we pre-train a 499-category network on the det training set. third, the distributions of object scales are different between det/ cls training sets. the dominant object scale in cls is about 0.8 of the image length, but in det is about 0.5. to address the scale difference, we resize each training image to (instead of), and randomly crop views for training. a crop is only used when it overlaps with a ground truth object by at least 50%. we verify the effect of pre-training on pascal voc 2007. for a cls-pre-training baseline, we consider the pool features (map 43.0% in table [reference]). replaced with a 200-category network pre-trained on det, the map significantly drops to 32.7%. a 499-category pre-trained network improves the result to 35.9%. interestingly, even if the amount of training data do not increase, training a network of more categories boosts the feature quality. finally, training with instead of further improves the map to 37.8%. even so, we see that there is still a considerable gap to the cls-pre-training result. this indicates the importance of big data to deep learning. for ilsvrc 2014, we train a 499-category overfeat-7 spp-net. the remaining steps are similar to the voc 2007 case. following, we use the validation set to generate the positive/ negative samples, with windows proposed by the selective search fast mode. the training set only contributes positive samples using the ground truth windows. we fine-tune the fc layers and then train the svms using the samples in both validation and training sets. the bounding box regression is trained on the validation set. our single model leads to 31.84% map in the ilsvrc 2014 testing set. we combine six similar models using the strategy introduced in this paper. the map is 35.11% in the testing set. this result ranks# 2 in the provided-data-only track of ilsvrc 2014 (table [reference]). the winning result is 37.21% from nus, which uses contextual information. our system still shows great advantages on speed for this dataset. it takes our single model 0.6 seconds (0.5 for conv, 0.1 for fc, excluding proposals) per testing image on a gpu extracting convolutional features from all 5 scales. using the same model, it takes 32 seconds per image in the way of rcnn. for the 40k testing images, our method requires 8 gpu hours to compute convolutional features, while rcnn would require 15 gpu days. section: conclusion spp is a flexible solution for handling different scales, sizes, and aspect ratios. these issues are important in visual recognition, but received little consideration in the context of deep networks. we have suggested a solution to train a deep network with a spatial pyramid pooling layer. the resulting spp-net shows outstanding accuracy in classification/ detection tasks and greatly accelerates dnn-based detection. our studies also show that many time-proven techniques/ insights in computer vision can still play important roles in deep-networks-based recognition. section: in the appendix, we describe some implementation details: mean subtraction. the 224 224 cropped training/ testing images are often pre-processed by subtracting the per-pixel mean. when input images are in any sizes, the fixed-size mean image is not directly applicable. in the imagenet dataset, we warp the 224 224 mean image to the desired size and then subtract it. in pascal voc 2007 and caltech101, we use the constant mean (128) in all the experiments. implementation of pooling bins. we use the following implementation to handle all bins when applying the network. denote the width and height of the conv feature maps (can be the full image or a window) as and. for a pyramid level with bins, the-th bin is in the range of. intuitively, if rounding is needed, we take the floor operation on the left/ top boundary and ceiling on the right/ bottom boundary. mapping a window to feature maps. in the detection algorithm (and multi-view testing on feature maps), a window is given in the image domain, and we use it to crop the convolutional feature maps (, conv) which have been sub-sampled several times. so we need to align the window on the feature maps. in our implementation, we project the corner point of a window onto a pixel in the feature maps, such that this corner point in the image domain is closest to the center of the receptive field of that feature map pixel. the mapping is complicated by the padding of all convolutional and pooling layers. to simplify the implementation, during deployment we pad pixels for a layer with a filter size of. as such, for a response centered at, its effective receptive field in the image domain is centered at where is the product of all previous strides. in our models, for zf-5 on conv, and for overfeat-5/ 7 on conv. given a window in the image domain, we project the left (top) boundary by: and the right (bottom) boundary. if the padding is not, we need to add a proper offset to. bibliography: references section: changelog arxiv v1. initial technical report for eccv 2014 paper. arxiv v2. submitted version for tpami. includes extra experiments of spp on various architectures. includes details for ilsvrc 2014. arxiv v3. accepted version for tpami. includes comparisons with r-cnn using the same architecture. includes detection experiments using edgeboxes. arxiv v4. revised\" mapping a window to feature maps\" in appendix for easier implementation.",
        "pred_templates": [
            {
                "Material": [
                    [
                        "imagenet"
                    ],
                    [
                        "imagenet 2012"
                    ],
                    [
                        "imagenet 2012 dataset"
                    ],
                    [
                        "pascal voc 2007"
                    ],
                    [
                        "caltech101"
                    ],
                    [
                        "caltech101 datasets"
                    ],
                    [
                        "imagenet 2012 dataset"
                    ],
                    [
                        "caltech101 dataset"
                    ],
                    [
                        "det training set"
                    ]
                ],
                "Method": [
                    [
                        "spatial pyramid pooling"
                    ],
                    [
                        "spatial pyramid pooling"
                    ],
                    [
                        "spp net"
                    ]
                ],
                "Metric": [
                    [
                        "top-1 error"
                    ],
                    [
                        "top-1 error rates"
                    ],
                    [
                        "mean average precision"
                    ]
                ],
                "Task": [
                    [
                        "object detection"
                    ]
                ]
            }
        ],
        "gold_templates": [
            {
                "Material": [
                    [
                        "pascal voc 2007",
                        "voc"
                    ]
                ],
                "Method": [],
                "Metric": [
                    [
                        "mean average precision",
                        "map"
                    ]
                ],
                "Task": [
                    [
                        "object detection",
                        "detection",
                        "detection task",
                        "detection case",
                        "detection (det"
                    ]
                ]
            }
        ]
    }
}